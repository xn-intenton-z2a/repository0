{
  "message": "Enhance --features command to include descriptions and update tests and docs accordingly",
  "updatedFile01Filepath": "sandbox/source/main.js",
  "updatedFile01Contents": "#!/usr/bin/env node\nimport { fileURLToPath } from \"url\";\nimport path from \"path\";\nimport fs from \"fs/promises\";\nimport minimist from \"minimist\";\nimport ejs from \"ejs\";\nimport yaml from \"js-yaml\";\n\n/**\n * Main entrypoint for CLI commands.\n * @param {string[]} argv - Command-line arguments (excluding node and script path).\n */\nexport async function main(argv) {\n  const args = minimist(argv, {\n    boolean: [\"help\", \"mission\", \"version\", \"render\", \"features\"],\n    alias: { h: \"help\", m: \"mission\", f: \"features\" },\n  });\n\n  // Help command\n  if (args.help) {\n    console.log(\n      `Usage: ${path.basename(\n        process.argv[1]\n      )} [--help] [-m|--mission] [--version] [-f|--features] [--render <template> <data>] [echo <message>...]`\n    );\n    console.log(`\\nCommands:`);\n    console.log(`  --help                      Display usage instructions`);\n    console.log(`  -m, --mission               Print mission statement`);\n    console.log(`  --version                   Print version`);\n    console.log(`  -f, --features              List available features`);\n    console.log(`  --render <template> <data>  Render EJS template with data (JSON or YAML)`);\n    console.log(`  echo <message>              Echo message`);\n    return;\n  }\n\n  // Mission statement\n  if (args.mission) {\n    const mission = await fs.readFile(path.resolve(\"MISSION.md\"), \"utf-8\");\n    console.log(mission);\n    return;\n  }\n\n  // Version\n  if (args.version) {\n    const pkg = JSON.parse(\n      await fs.readFile(path.resolve(\"package.json\"), \"utf-8\")\n    );\n    console.log(pkg.version);\n    return;\n  }\n\n  // List features\n  if (args.features) {\n    // Read and display mission statement first\n    const missionText = await fs.readFile(path.resolve(\"MISSION.md\"), \"utf-8\");\n    console.log(missionText);\n    try {\n      const dirPath = path.resolve(\"sandbox/features\");\n      const files = await fs.readdir(dirPath);\n      const mdFiles = files.filter((f) => f.endsWith(\".md\"));\n      const featuresList = [];\n      for (const file of mdFiles) {\n        const content = await fs.readFile(path.join(dirPath, file), \"utf-8\");\n        // Extract title\n        const titleMatch = content.match(/^#\\s+(.*)$/m);\n        const title = titleMatch ? titleMatch[1].trim() : \"\";\n        // Extract description: first non-heading paragraph\n        const afterHeading = content.replace(/^#\\s+.*$/m, \"\").trim();\n        let description = \"\";\n        if (afterHeading) {\n          const lines = afterHeading.split(/\\r?\\n/);\n          const descLines = [];\n          for (const line of lines) {\n            if (line.trim() === \"\") break;\n            descLines.push(line.trim());\n          }\n          description = descLines.join(\" \");\n        }\n        featuresList.push({ title, description });\n      }\n      console.log(JSON.stringify(featuresList, null, 2));\n      process.exit(0);\n    } catch (e) {\n      console.error(`Error: ${e.message}`);\n      process.exit(1);\n    }\n    return;\n  }\n\n  // Render EJS template\n  if (args.render) {\n    const [templatePath, dataPath] = args._;\n    if (!templatePath || !dataPath) {\n      console.error(\"Error: --render requires <templatePath> and <dataPath>\");\n      process.exit(1);\n    }\n    const tpl = await fs.readFile(path.resolve(templatePath), \"utf-8\");\n    const dataRaw = await fs.readFile(path.resolve(dataPath), \"utf-8\");\n    let data;\n    if (dataPath.endsWith(\".json\")) {\n      data = JSON.parse(dataRaw);\n    } else if (dataPath.endsWith(\".yaml\") || dataPath.endsWith(\".yml\")) {\n      data = yaml.load(dataRaw);\n    } else {\n      // Fallback to JSON parse\n      data = JSON.parse(dataRaw);\n    }\n    const output = ejs.render(tpl, data);\n    console.log(output);\n    return;\n  }\n\n  // Echo command\n  if (args._.length > 0 && args._[0] === \"echo\") {\n    console.log(args._.slice(1).join(\" \"));\n    return;\n  }\n\n  // Default to help\n  console.log(\n    `Usage: ${path.basename(\n      process.argv[1]\n    )} [--help] [-m|--mission] [--version] [-f|--features] [--render <template> <data>] [echo <message>...]`\n  );\n}\n\n// If the script is run directly, invoke main with process arguments\nif (process.argv[1] === fileURLToPath(import.meta.url)) {\n  main(process.argv.slice(2));\n}\n",
  "updatedFile02Filepath": "sandbox/tests/features.test.js",
  "updatedFile02Contents": "import { describe, test, expect, vi, beforeEach, afterEach } from \"vitest\";\nimport fs from \"fs/promises\";\nimport path from \"path\";\nimport { main } from \"../source/main.js\";\n\ndescribe(\"--features CLI option\", () => {\n  const featuresDir = path.resolve(\"sandbox/features\");\n  let logSpy;\n  let errorSpy;\n  let exitSpy;\n  let fsReadSpy;\n  let originalReadFile;\n\n  beforeEach(async () => {\n    // ensure features dir exists and is empty\n    await fs.mkdir(featuresDir, { recursive: true });\n    const existing = await fs.readdir(featuresDir);\n    for (const file of existing) {\n      await fs.unlink(path.join(featuresDir, file));\n    }\n    // Spy on console and process.exit\n    logSpy = vi.spyOn(console, \"log\").mockImplementation(() => {});\n    errorSpy = vi.spyOn(console, \"error\").mockImplementation(() => {});\n    exitSpy = vi.spyOn(process, \"exit\").mockImplementation(() => {});\n    // Spy on fs.readFile to return mission text for MISSION.md\n    originalReadFile = fs.readFile;\n    fsReadSpy = vi.spyOn(fs, \"readFile\").mockImplementation(async (filePath, encoding) => {\n      if (filePath.endsWith(\"MISSION.md\")) {\n        return \"Dummy mission statement\";\n      }\n      return originalReadFile(filePath, encoding);\n    });\n  });\n\n  afterEach(() => {\n    logSpy.mockRestore();\n    errorSpy.mockRestore();\n    exitSpy.mockRestore();\n    fsReadSpy.mockRestore();\n  });\n\n  test(\"lists features from markdown files\", async () => {\n    await fs.writeFile(path.join(featuresDir, \"feat1.md\"), \"# First Feature\\nDetails\");\n    await fs.writeFile(path.join(featuresDir, \"feat2.md\"), \"# Second Feature\\nMore details\");\n    await main([\"--features\"]);\n    const calls = logSpy.mock.calls.map((args) => args[0]);\n    expect(calls[0]).toBe(\"Dummy mission statement\");\n    const expected = JSON.stringify([\n      { title: \"First Feature\", description: \"Details\" },\n      { title: \"Second Feature\", description: \"More details\" }\n    ], null, 2);\n    expect(calls[1]).toBe(expected);\n    expect(exitSpy).toHaveBeenCalledWith(0);\n  });\n\n  test(\"alias -f works the same\", async () => {\n    await fs.writeFile(path.join(featuresDir, \"feat.md\"), \"# Only Feature\");\n    await main([\"-f\"]);\n    const calls = logSpy.mock.calls.map((args) => args[0]);\n    expect(calls[0]).toBe(\"Dummy mission statement\");\n    const expected = JSON.stringify([\n      { title: \"Only Feature\", description: \"\" }\n    ], null, 2);\n    expect(calls[1]).toBe(expected);\n    expect(exitSpy).toHaveBeenCalledWith(0);\n  });\n\n  test(\"empty directory yields empty array\", async () => {\n    await main([\"--features\"]);\n    const calls = logSpy.mock.calls.map((args) => args[0]);\n    expect(calls[0]).toBe(\"Dummy mission statement\");\n    expect(calls[1]).toBe(JSON.stringify([], null, 2));\n    expect(exitSpy).toHaveBeenCalledWith(0);\n  });\n\n  test(\"error handling on fs error\", async () => {\n    // mock readdir to throw\n    vi.spyOn(fs, \"readdir\").mockRejectedValue(new Error(\"oops\"));\n    await main([\"--features\"]);\n    expect(errorSpy).toHaveBeenCalledWith(\"Error: oops\");\n    expect(exitSpy).toHaveBeenCalledWith(1);\n    fs.readdir.mockRestore();\n  });\n});\n",
  "updatedFile03Filepath": "sandbox/docs/README.md",
  "updatedFile03Contents": "# CLI Demo of Agentic Workflows\n\nA simple CLI demonstration of agentic workflows integrated with GitHub Actions. This tool provides basic commands to showcase **help**, **mission**, **version**, **features**, **echo**, and **render** functionality.\n\n## Links\n\n- [Mission Statement](../../MISSION.md)\n- [Contributing Guidelines](../../CONTRIBUTING.md)\n- [License](../../LICENSE.md)\n- [intent√Øon agentic-lib](https://github.com/xn-intenton-z2a/agentic-lib)\n\n## Commands\n\n- `--help`  \n  : Displays usage instructions and a summary of available commands.\n\n- `-m, --mission`  \n  : Reads and prints the mission statement from `MISSION.md` (alias -m).\n\n- `--version`  \n  : Reads and prints the version from `package.json`.\n\n- `-f, --features`  \n  : Prints the mission statement from `MISSION.md` then lists available features by reading markdown files in `sandbox/features/` and printing a JSON array of objects containing `title` and `description` for each feature.\n\n- `--render <templatePath> <dataPath>`  \n  : Renders the specified EJS template with data provided in a JSON or YAML file and prints the result to stdout.\n\n- `echo` _<message>..._  \n  : Prints any additional arguments passed after the `echo` command.\n\n## Usage Examples\n\n```bash\n# Display help text\nnpm run start -- --help\n\n# Display mission statement\nnpm run start -- --mission\n\n# Display mission statement using alias\nnpm run start -- -m\n\n# Display current version\nnpm run start -- --version\n\n# List features\nnpm run start -- --features\n# List features using alias\nnpm run start -- -f\n```\n\n### Expected Output for Features\n\nFirst, the mission statement:\n\n```\n<Contents of MISSION.md>\n```\n\nThen, the list of features:\n\n```json\n[\n  {\n    \"title\": \"CLI Tool Enhancements\",\n    \"description\": \"Brief description of CLI enhancements.\"\n  },\n  {\n    \"title\": \"Schema Validation\",\n    \"description\": \"Short description of schema validation feature.\"\n  }\n]\n```",
  "updatedFile04Filepath": "unused",
  "updatedFile04Contents": "unused",
  "updatedFile05Filepath": "unused",
  "updatedFile05Contents": "unused",
  "updatedFile06Filepath": "unused",
  "updatedFile06Contents": "unused",
  "updatedFile07Filepath": "unused",
  "updatedFile07Contents": "unused",
  "updatedFile08Filepath": "unused",
  "updatedFile08Contents": "unused",
  "updatedFile09Filepath": "unused",
  "updatedFile09Contents": "unused",
  "updatedFile10Filepath": "unused",
  "updatedFile10Contents": "unused",
  "updatedFile11Filepath": "unused",
  "updatedFile11Contents": "unused",
  "updatedFile12Filepath": "unused",
  "updatedFile12Contents": "unused",
  "updatedFile13Filepath": "unused",
  "updatedFile13Contents": "unused",
  "updatedFile14Filepath": "unused",
  "updatedFile14Contents": "unused",
  "updatedFile15Filepath": "unused",
  "updatedFile15Contents": "unused",
  "updatedFile16Filepath": "unused",
  "updatedFile16Contents": "unused"
}