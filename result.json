{
  "message": "Support filtering CLI features list by mission tags",
  "updatedFile01Filepath": "sandbox/source/main.js",
  "updatedFile01Contents": "#!/usr/bin/env node\n/* eslint-disable sonarjs/cognitive-complexity */\nimport { fileURLToPath } from \"url\";\nimport path from \"path\";\nimport fs from \"fs/promises\";\nimport minimist from \"minimist\";\nimport ejs from \"ejs\";\nimport yaml from \"js-yaml\";\nimport dotenv from \"dotenv\";\n\n// Load .env file silently\nconst dotenvResult = dotenv.config({ path: path.resolve(\".env\") });\nconst loadedEnv = dotenvResult.parsed || {};\n\n/**\n * Main entrypoint for CLI commands.\n * Dispatches commands to dedicated handlers.\n * @param {string[]} argv - Command-line arguments (excluding node and script path).\n */\nexport async function main(argv) {\n  const args = minimist(argv, {\n    boolean: [\"help\", \"mission\", \"version\", \"render\", \"features\"],\n    alias: { h: \"help\", m: \"mission\", f: \"features\", e: \"env\" },\n    string: [\"env\"],\n  });\n\n  // Handle environment variables option\n  if (args.env !== undefined) {\n    handleEnv(args.env);\n    return;\n  }\n\n  if (args.help) {\n    return printHelp();\n  }\n  if (args.mission) {\n    return printMission();\n  }\n  if (args.version) {\n    return printVersion();\n  }\n  if (args.features) {\n    return listFeatures(args);\n  }\n  if (args.render) {\n    return renderTemplate(args);\n  }\n  if (args._.length > 0 && args._[0] === \"echo\") {\n    return echoMessage(args._);\n  }\n\n  // Default to help when no known command is provided\n  return printHelp();\n}\n\n/**\n * Handle --env and -e option.\n * @param {boolean|string} envArg - The argument passed to --env.\n */\nfunction handleEnv(envArg) {\n  if (envArg === true || envArg === \"\") {\n    console.log(JSON.stringify(loadedEnv, null, 2));\n    process.exit(0);\n  }\n  const varName = envArg;\n  const value = loadedEnv[varName];\n  if (value === undefined) {\n    console.error(`Missing environment variable: ${varName}`);\n    process.exit(1);\n  }\n  console.log(value);\n  process.exit(0);\n}\n\n/**\n * Print usage instructions and summary of commands.\n */\nfunction printHelp() {\n  const cmd = path.basename(process.argv[1]);\n  console.log(\n    `Usage: ${cmd} [--help] [-m|--mission] [--version] [-f|--features <tag>...] [--render <template> <data>] [--env <VAR_NAME>] [echo <message>...]`\n  );\n  console.log(\"\");\n  console.log(\"Commands:\");\n  console.log(\"  --help                      Display usage instructions\");\n  console.log(\"  -m, --mission               Print mission statement\");\n  console.log(\"  --version                   Print version\");\n  console.log(\"  -f, --features [<tag>...]   List available features, optionally filtered by mission tags\");\n  console.log(\"  --render <template> <data>  Render EJS template with data (JSON or YAML)\");\n  console.log(\"  -e, --env <VAR_NAME>        Print a specific environment variable\");\n  console.log(\"  -e, --env                   Print all loaded environment variables as JSON\");\n  console.log(\"  echo <message>              Echo message\");\n}\n\n/**\n * Print the mission statement from MISSION.md.\n */\nasync function printMission() {\n  const mission = await fs.readFile(path.resolve(\"MISSION.md\"), \"utf-8\");\n  console.log(mission);\n}\n\n/**\n * Print the version from package.json.\n */\nasync function printVersion() {\n  const pkg = JSON.parse(\n    await fs.readFile(path.resolve(\"package.json\"), \"utf-8\")\n  );\n  console.log(pkg.version);\n}\n\n/**\n * List available features by reading markdown files and extracting YAML frontmatter,\n * optionally filtering by provided mission tags.\n * @param {object} args - Parsed CLI arguments including positional tags in args._\n */\nasync function listFeatures(args) {\n  const missionText = await fs.readFile(path.resolve(\"MISSION.md\"), \"utf-8\");\n  console.log(missionText);\n\n  try {\n    const dirPath = path.resolve(\"sandbox/features\");\n    const files = await fs.readdir(dirPath);\n    const mdFiles = files.filter((f) => f.endsWith(\".md\"));\n    const featuresList = [];\n\n    for (const file of mdFiles) {\n      const raw = await fs.readFile(path.join(dirPath, file), \"utf-8\");\n      let mission = [];\n      let content = raw;\n      // Parse YAML frontmatter if present\n      if (content.startsWith(\"---\")) {\n        const fmMatch = content.match(/^---\\s*[\\r\\n]+([\\s\\S]*?)\\r?\\n---[\\r\\n]+/);\n        if (fmMatch) {\n          try {\n            const fmData = yaml.load(fmMatch[1]);\n            if (fmData && Array.isArray(fmData.mission)) {\n              mission = fmData.mission;\n            }\n          } catch (e) {\n            // ignore YAML parse errors\n          }\n          content = content.slice(fmMatch[0].length);\n        }\n      }\n\n      // Extract title\n      // eslint-disable-next-line sonarjs/slow-regex\n      const titleMatch = content.match(/^#\\s+(.*)$/m);\n      const title = titleMatch ? titleMatch[1].trim() : \"\";\n      // Extract description: first non-heading paragraph\n      // eslint-disable-next-line sonarjs/slow-regex\n      const afterHeading = content.replace(/^#\\s+.*$/m, \"\").trim();\n      let description = \"\";\n      if (afterHeading) {\n        const lines = afterHeading.split(/\\r?\\n/);\n        const descLines = [];\n        for (const line of lines) {\n          if (line.trim() === \"\") break;\n          descLines.push(line.trim());\n        }\n        description = descLines.join(\" \");\n      }\n      featuresList.push({ title, description, mission });\n    }\n\n    const filterTags = Array.isArray(args._) ? args._ : [];\n    let outputList = featuresList;\n    if (filterTags.length > 0) {\n      outputList = featuresList.filter((f) =>\n        Array.isArray(f.mission) && f.mission.some((tag) => filterTags.includes(tag))\n      );\n    }\n\n    console.log(JSON.stringify(outputList, null, 2));\n    process.exit(0);\n  } catch (e) {\n    console.error(`Error: ${e.message}`);\n    process.exit(1);\n  }\n}\n\n/**\n * Render an EJS template with provided JSON or YAML data.\n */\nasync function renderTemplate(args) {\n  const [templatePath, dataPath] = args._;\n  if (!templatePath || !dataPath) {\n    console.error(\"Error: --render requires <templatePath> and <dataPath>\");\n    process.exit(1);\n  }\n  const tpl = await fs.readFile(path.resolve(templatePath), \"utf-8\");\n  const dataRaw = await fs.readFile(path.resolve(dataPath), \"utf-8\");\n  let data;\n  if (dataPath.endsWith(\".json\")) {\n    data = JSON.parse(dataRaw);\n  } else if (dataPath.endsWith(\".yaml\") || dataPath.endsWith(\".yml\")) {\n    data = yaml.load(dataRaw);\n  } else {\n    data = JSON.parse(dataRaw);\n  }\n  const output = ejs.render(tpl, data);\n  console.log(output);\n}\n\n/**\n * Echo message arguments to stdout.\n */\nfunction echoMessage(args) {\n  console.log(args.slice(1).join(\" \"));\n}\n\n// If the script is run directly, invoke main with process arguments\nif (process.argv[1] === fileURLToPath(import.meta.url)) {\n  main(process.argv.slice(2));\n}\n",
  "updatedFile02Filepath": "sandbox/tests/features.test.js",
  "updatedFile02Contents": "import { describe, test, expect, vi, beforeEach, afterEach } from \"vitest\";\nimport fs from \"fs/promises\";\nimport path from \"path\";\nimport { main } from \"../source/main.js\";\n\ndescribe(\"--features CLI option\", () => {\n  const featuresDir = path.resolve(\"sandbox/features\");\n  let logSpy;\n  let errorSpy;\n  let exitSpy;\n  let fsReadSpy;\n  let originalReadFile;\n\n  beforeEach(async () => {\n    // ensure features dir exists and is empty\n    await fs.mkdir(featuresDir, { recursive: true });\n    const existing = await fs.readdir(featuresDir);\n    for (const file of existing) {\n      await fs.unlink(path.join(featuresDir, file));\n    }\n    // Spy on console and process.exit\n    logSpy = vi.spyOn(console, \"log\").mockImplementation(() => {});\n    errorSpy = vi.spyOn(console, \"error\").mockImplementation(() => {});\n    exitSpy = vi.spyOn(process, \"exit\").mockImplementation(() => {});\n    // Spy on fs.readFile to return mission text for MISSION.md\n    originalReadFile = fs.readFile;\n    fsReadSpy = vi.spyOn(fs, \"readFile\").mockImplementation(async (filePath, encoding) => {\n      if (filePath.endsWith(\"MISSION.md\")) {\n        return \"Dummy mission statement\";\n      }\n      return originalReadFile(filePath, encoding);\n    });\n  });\n\n  afterEach(() => {\n    logSpy.mockRestore();\n    errorSpy.mockRestore();\n    exitSpy.mockRestore();\n    fsReadSpy.mockRestore();\n  });\n\n  test(\"lists features from markdown files\", async () => {\n    await fs.writeFile(path.join(featuresDir, \"feat1.md\"), \"# First Feature\\nDetails\");\n    await fs.writeFile(path.join(featuresDir, \"feat2.md\"), \"# Second Feature\\nMore details\");\n    await main([\"--features\"]);\n    const calls = logSpy.mock.calls.map((args) => args[0]);\n    expect(calls[0]).toBe(\"Dummy mission statement\");\n    const expected = JSON.stringify(\n      [\n        { title: \"First Feature\", description: \"Details\", mission: [] },\n        { title: \"Second Feature\", description: \"More details\", mission: [] }\n      ],\n      null,\n      2\n    );\n    expect(calls[1]).toBe(expected);\n    expect(exitSpy).toHaveBeenCalledWith(0);\n  });\n\n  test(\"alias -f works the same\", async () => {\n    await fs.writeFile(path.join(featuresDir, \"feat.md\"), \"# Only Feature\");\n    await main([\"-f\"]);\n    const calls = logSpy.mock.calls.map((args) => args[0]);\n    expect(calls[0]).toBe(\"Dummy mission statement\");\n    const expected = JSON.stringify(\n      [\n        { title: \"Only Feature\", description: \"\", mission: [] }\n      ],\n      null,\n      2\n    );\n    expect(calls[1]).toBe(expected);\n    expect(exitSpy).toHaveBeenCalledWith(0);\n  });\n\n  test(\"parses YAML frontmatter mission tags\", async () => {\n    await fs.writeFile(\n      path.join(featuresDir, \"fancy.md\"),\n      `---\nmission:\n  - cli\n  - user-experience\n---\n# Fancy Feature\nImplements fancy CLI formatting`\n    );\n    await main([\"--features\"]);\n    const calls = logSpy.mock.calls.map((args) => args[0]);\n    expect(calls[0]).toBe(\"Dummy mission statement\");\n    const expected = JSON.stringify(\n      [\n        { title: \"Fancy Feature\", description: \"Implements fancy CLI formatting\", mission: [\"cli\", \"user-experience\"] }\n      ],\n      null,\n      2\n    );\n    expect(calls[1]).toBe(expected);\n    expect(exitSpy).toHaveBeenCalledWith(0);\n  });\n\n  test(\"filters features by mission tag\", async () => {\n    await fs.writeFile(\n      path.join(featuresDir, 'alpha.md'),\n      `---\nmission: ['cli','user-experience']\n---\n# Alpha\nFirst feature`\n    );\n    await fs.writeFile(\n      path.join(featuresDir, 'beta.md'),\n      `---\nmission: ['render']\n---\n# Beta\nSecond feature`\n    );\n    await main([\"--features\", \"cli\"]);\n    const calls = logSpy.mock.calls.map(args => args[0]);\n    expect(calls[0]).toBe(\"Dummy mission statement\");\n    const result = JSON.parse(calls[1]);\n    expect(result).toEqual([\n      { title: 'Alpha', description: 'First feature', mission: ['cli','user-experience'] }\n    ]);\n    expect(exitSpy).toHaveBeenCalledWith(0);\n  });\n\n  test(\"empty directory yields empty array\", async () => {\n    await main([\"--features\"]);\n    const calls = logSpy.mock.calls.map((args) => args[0]);\n    expect(calls[0]).toBe(\"Dummy mission statement\");\n    expect(calls[1]).toBe(JSON.stringify([], null, 2));\n    expect(exitSpy).toHaveBeenCalledWith(0);\n  });\n\n  test(\"error handling on fs error\", async () => {\n    // mock readdir to throw\n    vi.spyOn(fs, \"readdir\").mockRejectedValue(new Error(\"oops\"));\n    await main([\"--features\"]);\n    expect(errorSpy).toHaveBeenCalledWith(\"Error: oops\");\n    expect(exitSpy).toHaveBeenCalledWith(1);\n    fs.readdir.mockRestore();\n  });\n});\n",
  "updatedFile03Filepath": "sandbox/docs/README.md",
  "updatedFile03Contents": "# CLI Demo of Agentic Workflows\n\nA simple CLI demonstration of agentic workflows integrated with GitHub Actions. This tool provides commands to showcase **help**, **mission**, **version**, **features**, **render**, **echo**, and **env** functionality.\n\n## Links\n\n- [Mission Statement](../../MISSION.md)\n- [Contributing Guidelines](../../CONTRIBUTING.md)\n- [License](../../LICENSE.md)\n- [intentïon agentic-lib](https://github.com/xn-intenton-z2a/agentic-lib)\n\n## Commands\n\nUsage: main.js [--help] [-m|--mission] [--version] [-f|--features [<tag>...]] [--render <template> <data>] [--env <VAR_NAME>] [echo <message>...]\n\nCommands:\n  --help                      Display usage instructions\n  -m, --mission               Print mission statement\n  --version                   Print version\n  -f, --features [<tag>...]   List available features, optionally filtered by mission tags\n  --render <template> <data>  Render EJS template with data (JSON or YAML)\n  -e, --env <VAR_NAME>        Print a specific environment variable\n  -e, --env                   Print all loaded environment variables as JSON\n  echo <message>              Echo message\n\n## Usage Examples\n\n```bash\nnpm run start -- --help\n# Displays help text\n\nnpm run start -- --mission\n# Prints the mission statement\n\nnpm run start -- --version\n# Prints the current version\n\nnpm run start -- --features\n# Prints the mission statement then lists available features as JSON\n\nnpm run start -- --render path/to/template.ejs path/to/data.json\n# Renders EJS template with JSON data and prints the result\n\nnpm run start -- --render path/to/template.ejs path/to/data.yaml\n# Renders EJS template with YAML data and prints the result\n\nnpm run start -- echo Hello World\n# Prints \"Hello World\"\n\nnpm run start -- --env VAR_NAME\n# Prints the value of VAR_NAME loaded from .env\n\nnpm run start -- --env\n# Prints all loaded environment variables as JSON\n\nnpm run start -- --features cli\n# Only show features tagged with 'cli'\n```",
  "updatedFile04Filepath": "unused",
  "updatedFile04Contents": "unused",
  "updatedFile05Filepath": "unused",
  "updatedFile05Contents": "unused",
  "updatedFile06Filepath": "unused",
  "updatedFile06Contents": "unused",
  "updatedFile07Filepath": "unused",
  "updatedFile07Contents": "unused",
  "updatedFile08Filepath": "unused",
  "updatedFile08Contents": "unused",
  "updatedFile09Filepath": "unused",
  "updatedFile09Contents": "unused",
  "updatedFile10Filepath": "unused",
  "updatedFile10Contents": "unused",
  "updatedFile11Filepath": "unused",
  "updatedFile11Contents": "unused",
  "updatedFile12Filepath": "unused",
  "updatedFile12Contents": "unused",
  "updatedFile13Filepath": "unused",
  "updatedFile13Contents": "unused",
  "updatedFile14Filepath": "unused",
  "updatedFile14Contents": "unused",
  "updatedFile15Filepath": "unused",
  "updatedFile15Contents": "unused",
  "updatedFile16Filepath": "unused",
  "updatedFile16Contents": "unused"
}