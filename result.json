{
  "message": "Include mission statement in --features output and update tests and docs accordingly",
  "updatedFile01Filepath": "sandbox/source/main.js",
  "updatedFile01Contents": "#!/usr/bin/env node\nimport { fileURLToPath } from \"url\";\nimport path from \"path\";\nimport fs from \"fs/promises\";\nimport minimist from \"minimist\";\nimport ejs from \"ejs\";\nimport yaml from \"js-yaml\";\n\n/**\n * Main entrypoint for CLI commands.\n * @param {string[]} argv - Command-line arguments (excluding node and script path).\n */\nexport async function main(argv) {\n  const args = minimist(argv, {\n    boolean: [\"help\", \"mission\", \"version\", \"render\", \"features\"],\n    alias: { h: \"help\", m: \"mission\", f: \"features\" },\n  });\n\n  // Help command\n  if (args.help) {\n    console.log(\n      `Usage: ${path.basename(\n        process.argv[1]\n      )} [--help] [-m|--mission] [--version] [-f|--features] [--render <template> <data>] [echo <message>...]`\n    );\n    console.log(`\\nCommands:`);\n    console.log(`  --help                      Display usage instructions`);\n    console.log(`  -m, --mission               Print mission statement`);\n    console.log(`  --version                   Print version`);\n    console.log(`  -f, --features              List available features`);\n    console.log(`  --render <template> <data>  Render EJS template with data (JSON or YAML)`);\n    console.log(`  echo <message>              Echo message`);\n    return;\n  }\n\n  // Mission statement\n  if (args.mission) {\n    const mission = await fs.readFile(path.resolve(\"MISSION.md\"), \"utf-8\");\n    console.log(mission);\n    return;\n  }\n\n  // Version\n  if (args.version) {\n    const pkg = JSON.parse(\n      await fs.readFile(path.resolve(\"package.json\"), \"utf-8\")\n    );\n    console.log(pkg.version);\n    return;\n  }\n\n  // List features\n  if (args.features) {\n    // Read and display mission statement first\n    const missionText = await fs.readFile(path.resolve(\"MISSION.md\"), \"utf-8\");\n    console.log(missionText);\n    try {\n      const dirPath = path.resolve(\"sandbox/features\");\n      const files = await fs.readdir(dirPath);\n      const mdFiles = files.filter((f) => f.endsWith(\".md\"));\n      const titles = [];\n      for (const file of mdFiles) {\n        const content = await fs.readFile(path.join(dirPath, file), \"utf-8\");\n        const match = content.match(/^#\\s+(.*)$/m);\n        if (match) {\n          titles.push(match[1]);\n        }\n      }\n      console.log(JSON.stringify(titles, null, 2));\n      process.exit(0);\n    } catch (e) {\n      console.error(`Error: ${e.message}`);\n      process.exit(1);\n    }\n    return;\n  }\n\n  // Render EJS template\n  if (args.render) {\n    const [templatePath, dataPath] = args._;\n    if (!templatePath || !dataPath) {\n      console.error(\"Error: --render requires <templatePath> and <dataPath>\");\n      process.exit(1);\n    }\n    const tpl = await fs.readFile(path.resolve(templatePath), \"utf-8\");\n    const dataRaw = await fs.readFile(path.resolve(dataPath), \"utf-8\");\n    let data;\n    if (dataPath.endsWith(\".json\")) {\n      data = JSON.parse(dataRaw);\n    } else if (dataPath.endsWith(\".yaml\") || dataPath.endsWith(\".yml\")) {\n      data = yaml.load(dataRaw);\n    } else {\n      // Fallback to JSON parse\n      data = JSON.parse(dataRaw);\n    }\n    const output = ejs.render(tpl, data);\n    console.log(output);\n    return;\n  }\n\n  // Echo command\n  if (args._.length > 0 && args._[0] === \"echo\") {\n    console.log(args._.slice(1).join(\" \"));\n    return;\n  }\n\n  // Default to help\n  console.log(\n    `Usage: ${path.basename(\n      process.argv[1]\n    )} [--help] [-m|--mission] [--version] [-f|--features] [--render <template> <data>] [echo <message>...]`\n  );\n}\n\n// If the script is run directly, invoke main with process arguments\nif (process.argv[1] === fileURLToPath(import.meta.url)) {\n  main(process.argv.slice(2));\n}\n",
  "updatedFile02Filepath": "sandbox/tests/features.test.js",
  "updatedFile02Contents": "import { describe, test, expect, vi, beforeEach, afterEach } from \"vitest\";\nimport fs from \"fs/promises\";\nimport path from \"path\";\nimport { main } from \"../source/main.js\";\n\ndescribe(\"--features CLI option\", () => {\n  const featuresDir = path.resolve(\"sandbox/features\");\n  let logSpy;\n  let errorSpy;\n  let exitSpy;\n  let fsReadSpy;\n  let originalReadFile;\n\n  beforeEach(async () => {\n    // ensure features dir exists and is empty\n    await fs.mkdir(featuresDir, { recursive: true });\n    const existing = await fs.readdir(featuresDir);\n    for (const file of existing) {\n      await fs.unlink(path.join(featuresDir, file));\n    }\n    // Spy on console and process.exit\n    logSpy = vi.spyOn(console, \"log\").mockImplementation(() => {});\n    errorSpy = vi.spyOn(console, \"error\").mockImplementation(() => {});\n    exitSpy = vi.spyOn(process, \"exit\").mockImplementation(() => {});\n    // Spy on fs.readFile to return mission text for MISSION.md\n    originalReadFile = fs.readFile;\n    fsReadSpy = vi.spyOn(fs, \"readFile\").mockImplementation(async (filePath, encoding) => {\n      if (filePath.endsWith(\"MISSION.md\")) {\n        return \"Dummy mission statement\";\n      }\n      return originalReadFile(filePath, encoding);\n    });\n  });\n\n  afterEach(() => {\n    logSpy.mockRestore();\n    errorSpy.mockRestore();\n    exitSpy.mockRestore();\n    fsReadSpy.mockRestore();\n  });\n\n  test(\"lists features from markdown files\", async () => {\n    await fs.writeFile(path.join(featuresDir, \"feat1.md\"), \"# First Feature\\nDetails\");\n    await fs.writeFile(path.join(featuresDir, \"feat2.md\"), \"# Second Feature\\nMore details\");\n    await main([\"--features\"]);\n    const calls = logSpy.mock.calls.map((args) => args[0]);\n    expect(calls[0]).toBe(\"Dummy mission statement\");\n    expect(calls[1]).toBe(JSON.stringify([\"First Feature\", \"Second Feature\"], null, 2));\n    expect(exitSpy).toHaveBeenCalledWith(0);\n  });\n\n  test(\"alias -f works the same\", async () => {\n    await fs.writeFile(path.join(featuresDir, \"feat.md\"), \"# Only Feature\");\n    await main([\"-f\"]);\n    const calls = logSpy.mock.calls.map((args) => args[0]);\n    expect(calls[0]).toBe(\"Dummy mission statement\");\n    expect(calls[1]).toBe(JSON.stringify([\"Only Feature\"], null, 2));\n    expect(exitSpy).toHaveBeenCalledWith(0);\n  });\n\n  test(\"empty directory yields empty array\", async () => {\n    await main([\"--features\"]);\n    const calls = logSpy.mock.calls.map((args) => args[0]);\n    expect(calls[0]).toBe(\"Dummy mission statement\");\n    expect(calls[1]).toBe(JSON.stringify([], null, 2));\n    expect(exitSpy).toHaveBeenCalledWith(0);\n  });\n\n  test(\"error handling on fs error\", async () => {\n    // mock readdir to throw\n    vi.spyOn(fs, \"readdir\").mockRejectedValue(new Error(\"oops\"));\n    await main([\"--features\"]);\n    expect(errorSpy).toHaveBeenCalledWith(\"Error: oops\");\n    expect(exitSpy).toHaveBeenCalledWith(1);\n    fs.readdir.mockRestore();\n  });\n});\n",
  "updatedFile03Filepath": "sandbox/docs/README.md",
  "updatedFile03Contents": "# CLI Demo of Agentic Workflows\n\nA simple CLI demonstration of agentic workflows integrated with GitHub Actions. This tool provides basic commands to showcase **help**, **mission**, **version**, **features**, **echo**, and **render** functionality.\n\n## Links\n\n- [Mission Statement](../../MISSION.md)\n- [Contributing Guidelines](../../CONTRIBUTING.md)\n- [License](../../LICENSE.md)\n- [intent√Øon agentic-lib](https://github.com/xn-intenton-z2a/agentic-lib)\n\n## Commands\n\n- `--help`  \n  : Displays usage instructions and a summary of available commands.\n\n- `-m, --mission`  \n  : Reads and prints the mission statement from `MISSION.md` (alias -m).\n\n- `--version`  \n  : Reads and prints the version from `package.json`.\n\n- `-f, --features`  \n  : Prints the mission statement from `MISSION.md` then lists available features by reading markdown files in `sandbox/features/` and printing a JSON array of their level-1 headings.\n\n- `--render <templatePath> <dataPath>`  \n  : Renders the specified EJS template with data provided in a JSON or YAML file and prints the result to stdout.\n\n- `echo` _<message>..._  \n  : Prints any additional arguments passed after the `echo` command.\n\n## Usage Examples\n\n```bash\n# Display help text\nnpm run start -- --help\n\n# Display mission statement\nnpm run start -- --mission\n\n# Display mission statement using alias\nnpm run start -- -m\n\n# Display current version\nnpm run start -- --version\n\n# List features\nnpm run start -- --features\n# List features using alias\nnpm run start -- -f\n```\n\n### Expected Output for Features\n\nFirst, the mission statement:\n\n```\n<Contents of MISSION.md>\n```\n\nThen, the list of features:\n\n```json\n[\n  \"CLI Tool Enhancements\",\n  \"Schema Validation\"\n]\n```\n\n## Getting Started\n\n1. **Clone the repository**:\n   ```bash\n   git clone <repository_url>\n   cd repository0\n   ```\n2. **Install dependencies**:\n   ```bash\n   npm install\n   ```\n3. **Run tests**:\n   ```bash\n   npm test\n   ```\n4. **Run the CLI**:\n   ```bash\n   npm run start -- --help\n   ```",
  "updatedFile04Filepath": "unused",
  "updatedFile04Contents": "unused",
  "updatedFile05Filepath": "unused",
  "updatedFile05Contents": "unused",
  "updatedFile06Filepath": "unused",
  "updatedFile06Contents": "unused",
  "updatedFile07Filepath": "unused",
  "updatedFile07Contents": "unused",
  "updatedFile08Filepath": "unused",
  "updatedFile08Contents": "unused",
  "updatedFile09Filepath": "unused",
  "updatedFile09Contents": "unused",
  "updatedFile10Filepath": "unused",
  "updatedFile10Contents": "unused",
  "updatedFile11Filepath": "unused",
  "updatedFile11Contents": "unused",
  "updatedFile12Filepath": "unused",
  "updatedFile12Contents": "unused",
  "updatedFile13Filepath": "unused",
  "updatedFile13Contents": "unused",
  "updatedFile14Filepath": "unused",
  "updatedFile14Contents": "unused",
  "updatedFile15Filepath": "unused",
  "updatedFile15Contents": "unused",
  "updatedFile16Filepath": "unused",
  "updatedFile16Contents": "unused"
}