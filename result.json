{
  "message": "Add --validate-mission flag to features command, update docs and tests",
  "updatedFile01Filepath": "sandbox/source/main.js",
  "updatedFile01Contents": "#!/usr/bin/env node\nimport minimist from \"minimist\";\nimport fs from \"fs/promises\";\nimport path from \"path\";\nimport { parse } from \"csv-parse/sync\";\nimport ejs from \"ejs\";\nimport dotenv from \"dotenv\";\nimport jsYaml from \"js-yaml\";\nimport MarkdownIt from \"markdown-it\";\nimport Database from \"better-sqlite3\";\n\nasync function showHelp() {\n  console.log(`Usage: npm run start -- <command> [args]\n\nCommands:\n  help               Display this help message\n  mission            Print the mission statement\n  version            Print the current version\n  echo               Echo the provided arguments\n  features           List available feature documents (use --validate-mission to list those without mission reference)\n  mission-features   Print the mission statement and list available features\n  csv-import         Import a CSV file and output JSON array\n  render             Render an EJS template with optional JSON data and output file\n  replace            Perform search-and-replace on a text file\n  text-replace       Alias for replace\n  convert            Convert between .env, JSON, and YAML formats (use --to-json, --to-env, or --to-yaml)\n  markdown           Convert a Markdown file to HTML\n  import-data        Import structured data files into a SQLite database\n\nExamples:\n  npm run start -- help\n  npm run start -- mission\n  npm run start -- version\n  npm run start -- echo Hello World\n  npm run start -- features\n  npm run start -- features --validate-mission\n  npm run start -- mission-features\n  npm run start -- csv-import data.csv\n  npm run start -- csv-import data.csv --output out.json --delimiter \";\" --header false\n  npm run start -- render template.ejs\n  npm run start -- render template.ejs data.json\n  npm run start -- render template.ejs data.json --output out.html\n  npm run start -- replace file.txt --search foo --replace bar\n  npm run start -- text-replace file.txt --search foo --replace bar --regex --flags \"gi\" --output out.txt\n  npm run start -- convert file.env --to-yaml --output out.yaml\n  npm run start -- convert file.env --to-json\n  npm run start -- convert config.json --to-env\n  npm run start -- markdown file.md --output file.html\n  npm run start -- import-data data.csv --db my.db --table users --delimiter \";\" --header false --overwrite`);\n}\n\nasync function showMission() {\n  try {\n    const cwd = process.cwd();\n    const content = await fs.readFile(path.join(cwd, \"MISSION.md\"), \"utf-8\");\n    console.log(content);\n  } catch (err) {\n    console.error(\"Error reading mission:\", err.message);\n    process.exit(1);\n  }\n}\n\nasync function showVersion() {\n  try {\n    const cwd = process.cwd();\n    const pkg = await fs.readFile(path.join(cwd, \"package.json\"), \"utf-8\");\n    const { version } = JSON.parse(pkg);\n    console.log(version);\n  } catch (err) {\n    console.error(\"Error reading version:\", err.message);\n    process.exit(1);\n  }\n}\n\nasync function doEcho(args) {\n  console.log(args.join(\" \"));\n}\n\nasync function showFeatures(argv) {\n  const validate = argv && argv['validate-mission'];\n  try {\n    const cwd = process.cwd();\n    const featuresDir = path.join(cwd, \"sandbox/features\");\n    const files = await fs.readdir(featuresDir);\n    for (const file of files) {\n      if (path.extname(file).toLowerCase() === \".md\") {\n        const filePath = path.join(featuresDir, file);\n        const content = await fs.readFile(filePath, \"utf-8\");\n        const lines = content.split(\"\\n\");\n        let heading = null;\n        for (const line of lines) {\n          const match = line.match(/^#\\s+(.*)/);\n          if (match) {\n            heading = match[1];\n            break;\n          }\n        }\n        if (!heading) {\n          continue;\n        }\n        if (validate) {\n          if (content.includes(\"MISSION.md\") || content.includes(\"# Mission Statement\")) {\n            continue;\n          }\n        }\n        console.log(heading);\n      }\n    }\n  } catch (err) {\n    console.error(\"Error listing features:\", err.message);\n    process.exit(1);\n  }\n}\n\nasync function doCsvImport(argv) {\n  const inputFile = argv._[1];\n  if (!inputFile) {\n    console.error(\"Error: No input file specified\");\n    process.exit(1);\n  }\n\n  const delimiter = argv.delimiter || \",\";\n  const header = argv.header !== false;\n  const output = argv.output;\n\n  let content;\n  try {\n    const inputPath = path.resolve(inputFile);\n    content = await fs.readFile(inputPath, \"utf-8\");\n  } catch (err) {\n    console.error(\"Error reading input file:\", err.message);\n    process.exit(1);\n  }\n\n  let records;\n  try {\n    records = parse(content, { columns: header, delimiter, skip_empty_lines: true });\n  } catch (err) {\n    console.error(\"Error parsing CSV:\", err.message);\n    process.exit(1);\n  }\n\n  const json = JSON.stringify(records, null, 2);\n\n  if (output) {\n    try {\n      const outputPath = path.resolve(output);\n      await fs.writeFile(outputPath, json, \"utf-8\");\n      process.exit(0);\n    } catch (err) {\n      console.error(\"Error writing output file:\", err.message);\n      process.exit(1);\n    }\n  } else {\n    console.log(json);\n  }\n}\n\nasync function doRender(argv) {\n  const templateFile = argv._[1];\n  const dataFile = argv._[2];\n  const output = argv.output;\n  if (!templateFile) {\n    console.error(\"Error: No template file specified\");\n    process.exit(1);\n  }\n  let template;\n  try {\n    const templatePath = path.resolve(templateFile);\n    template = await fs.readFile(templatePath, \"utf-8\");\n  } catch (err) {\n    console.error(\"Error reading template file:\", err.message);\n    process.exit(1);\n  }\n  let data = {};\n  if (dataFile) {\n    try {\n      const dataPath = path.resolve(dataFile);\n      const raw = await fs.readFile(dataPath, \"utf-8\");\n      data = JSON.parse(raw);\n    } catch (err) {\n      console.error(\"Error parsing data file:\", err.message);\n      process.exit(1);\n    }\n  }\n  let rendered;\n  try {\n    rendered = ejs.render(template, data);\n  } catch (err) {\n    console.error(\"Error rendering template:\", err.message);\n    process.exit(1);\n  }\n  if (output) {\n    try {\n      const outputPath = path.resolve(output);\n      await fs.writeFile(outputPath, rendered, \"utf-8\");\n      console.log(`Wrote rendered output to ${output}`);\n      process.exit(0);\n    } catch (err) {\n      console.error(\"Error writing output file:\", err.message);\n      process.exit(1);\n    }\n  } else {\n    console.log(rendered);\n    process.exit(0);\n  }\n}\n\nasync function doTextReplace(argv) {\n  const inputFile = argv._[1];\n  const search = argv.search;\n  const replacement = argv.replace;\n  const regexFlag = argv.regex;\n  const flags = argv.flags || \"\";\n  const output = argv.output;\n\n  if (!inputFile || search === undefined || replacement === undefined) {\n    console.error(\"Missing --search or --replace flag\");\n    process.exit(1);\n  }\n\n  let content;\n  try {\n    const inputPath = path.resolve(inputFile);\n    content = await fs.readFile(inputPath, \"utf-8\");\n  } catch (err) {\n    console.error(\"Error reading input file:\", err.message);\n    process.exit(1);\n  }\n\n  let result;\n  if (regexFlag) {\n    let re;\n    try {\n      re = new RegExp(search, flags);\n    } catch (err) {\n      console.error(\"Invalid regular expression:\", err.message);\n      process.exit(1);\n    }\n    result = content.replace(re, replacement);\n  } else {\n    result = content.replace(search, replacement);\n  }\n\n  if (output) {\n    try {\n      const outputPath = path.resolve(output);\n      await fs.writeFile(outputPath, result, \"utf-8\");\n      process.exit(0);\n    } catch (err) {\n      console.error(\"Error writing output file:\", err.message);\n      process.exit(1);\n    }\n  } else {\n    console.log(result);\n  }\n}\n\nasync function doConvert(argv) {\n  const inputFile = argv._[1];\n  const toEnv = argv[\"to-env\"];\n  const toYaml = argv[\"to-yaml\"];\n  const toJson = argv[\"to-json\"];\n  const output = argv.output;\n\n  if (!inputFile) {\n    console.error(\"Error: No input file specified\");\n    process.exit(1);\n  }\n\n  const flagCount = [toEnv, toYaml, toJson].filter(Boolean).length;\n  if (flagCount > 1) {\n    console.error(\"Error: Specify exactly one of --to-json, --to-env, or --to-yaml\");\n    process.exit(1);\n  }\n\n  let content;\n  try {\n    const inputPath = path.resolve(inputFile);\n    content = await fs.readFile(inputPath, \"utf-8\");\n  } catch (err) {\n    console.error(\"Error reading input file:\", err.message);\n    process.exit(1);\n  }\n\n  let data;\n  try {\n    const ext = path.extname(inputFile).toLowerCase();\n    if (ext === \".env\") {\n      data = dotenv.parse(content);\n    } else if (ext === \".json\") {\n      data = JSON.parse(content);\n    } else if (ext === \".yaml\" || ext === \".yml\") {\n      data = jsYaml.load(content);\n    } else {\n      console.error(`Unsupported input format: ${ext}`);\n      process.exit(1);\n    }\n  } catch (err) {\n    console.error(`Error parsing input file: ${err.message}`);\n    process.exit(1);\n  }\n\n  let result;\n  try {\n    if (toEnv) {\n      if (typeof data !== \"object\" || data === null) {\n        throw new Error(\"Input JSON must be an object for env conversion\");\n      }\n      result = Object.entries(data)\n        .map(([key, value]) => `${key}=${value}`)\n        .join(\"\\n\");\n    } else if (toYaml) {\n      result = jsYaml.dump(data);\n    } else {\n      result = JSON.stringify(data, null, 2);\n    }\n  } catch (err) {\n    console.error(\"Error serializing output:\", err.message);\n    process.exit(1);\n  }\n\n  if (output) {\n    try {\n      const outputPath = path.resolve(output);\n      await fs.writeFile(outputPath, result, \"utf-8\");\n      process.exit(0);\n    } catch (err) {\n      console.error(\"Error writing output file:\", err.message);\n      process.exit(1);\n    }\n  } else {\n    console.log(result);\n  }\n}\n\nasync function doImportData(argv) {\n  const inputFile = argv._[1];\n  const dbPath = argv.db;\n  const table = argv.table || 'data';\n  const delimiter = argv.delimiter || ',';\n  const header = argv.header !== false;\n  const overwrite = argv.overwrite || false;\n\n  if (!inputFile) {\n    console.error('Error: No input file specified');\n    process.exit(1);\n  }\n  if (!dbPath) {\n    console.error('Error: --db <database path> is required');\n    process.exit(1);\n  }\n\n  let raw;\n  try {\n    raw = await fs.readFile(path.resolve(inputFile), 'utf-8');\n  } catch (err) {\n    console.error('Error reading input file:', err.message);\n    process.exit(1);\n  }\n\n  let records;\n  const ext = path.extname(inputFile).toLowerCase();\n  try {\n    if (ext === '.csv') {\n      records = parse(raw, { columns: header, delimiter, skip_empty_lines: true });\n    } else if (ext === '.json') {\n      const data = JSON.parse(raw);\n      if (!Array.isArray(data)) {\n        console.error('Error: JSON input must be an array of objects');\n        process.exit(1);\n      }\n      records = data;\n    } else if (ext === '.yaml' || ext === '.yml') {\n      const data = jsYaml.load(raw);\n      if (!Array.isArray(data)) {\n        console.error('Error: YAML input must be an array of objects');\n        process.exit(1);\n      }\n      records = data;\n    } else if (ext === '.env') {\n      const envObj = dotenv.parse(raw);\n      records = [envObj];\n    } else {\n      console.error(`Unsupported input format: ${ext}`);\n      process.exit(1);\n    }\n  } catch (err) {\n    console.error(`Error parsing input file: ${err.message}`);\n    process.exit(1);\n  }\n\n  let db;\n  try {\n    db = new Database(dbPath);\n  } catch (err) {\n    console.error('Error opening database:', err.message);\n    process.exit(1);\n  }\n\n  try {\n    const exists = db.prepare(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\").get(table);\n    if (exists) {\n      if (overwrite) {\n        db.prepare(`DROP TABLE \"${table}\"`).run();\n      } else {\n        console.error(`Error: Table '${table}' already exists. Use --overwrite to replace.`);\n        process.exit(1);\n      }\n    }\n  } catch (err) {\n    console.error('Error checking table existence:', err.message);\n    process.exit(1);\n  }\n\n  const keys = Object.keys(records[0] || {});\n  const colsDef = keys.map((k) => `\"${k}\" TEXT`).join(', ');\n  try {\n    db.prepare(`CREATE TABLE \"${table}\" (${colsDef})`).run();\n  } catch (err) {\n    console.error('Error creating table:', err.message);\n    process.exit(1);\n  }\n\n  const placeholders = keys.map(() => '?').join(', ');\n  const insertSQL = `INSERT INTO \"${table}\" (${keys.map((k) => `\"${k}\"`).join(', ')}) VALUES (${placeholders})`;\n  const insertStmt = db.prepare(insertSQL);\n  const insertMany = db.transaction((recs) => {\n    for (const r of recs) {\n      insertStmt.run(...keys.map((k) => r[k]));\n    }\n  });\n  try {\n    insertMany(records);\n  } catch (err) {\n    console.error('Error inserting records:', err.message);\n    process.exit(1);\n  }\n\n  db.close();\n  console.log(`Inserted ${records.length} records into table '${table}' in database ${dbPath}`);\n  process.exit(0);\n}\n\nasync function doMarkdown(argv) {\n  const inputFile = argv._[1];\n  const output = argv.output;\n  if (!inputFile) {\n    console.error(\"Error: No input file specified\");\n    process.exit(1);\n  }\n  let content;\n  try {\n    const inputPath = path.resolve(inputFile);\n    content = await fs.readFile(inputPath, \"utf-8\");\n  } catch (err) {\n    console.error(\"Error reading input file:\", err.message);\n    process.exit(1);\n  }\n  const md = new MarkdownIt();\n  let html;\n  try {\n    html = md.render(content);\n  } catch (err) {\n    console.error(\"Error rendering markdown:\", err.message);\n    process.exit(1);\n  }\n  if (output) {\n    try {\n      const outputPath = path.resolve(output);\n      await fs.writeFile(outputPath, html, \"utf-8\");\n      process.exit(0);\n    } catch (err) {\n      console.error(\"Error writing output file:\", err.message);\n      process.exit(1);\n    }\n  } else {\n    console.log(html);\n  }\n}\n\nasync function main() {\n  const argv = minimist(process.argv.slice(2), {\n    boolean: [\"header\", \"regex\", \"to-env\", \"to-yaml\", \"to-json\", \"overwrite\", \"validate-mission\"],\n    string: [\"output\", \"delimiter\", \"flags\", \"search\", \"replace\", \"db\", \"table\"],\n    default: { header: true, delimiter: \",\" },\n  });\n  const [command, ...rest] = argv._;\n  switch (command) {\n    case \"help\":\n    case undefined:\n      await showHelp();\n      break;\n    case \"mission\":\n      await showMission();\n      break;\n    case \"version\":\n      await showVersion();\n      break;\n    case \"echo\":\n      await doEcho(rest);\n      break;\n    case \"features\":\n      await showFeatures(argv);\n      break;\n    case \"mission-features\":\n      await showMission();\n      console.log(\"\");\n      await showFeatures(argv);\n      break;\n    case \"csv-import\":\n      await doCsvImport(argv);\n      break;\n    case \"render\":\n      await doRender(argv);\n      break;\n    case \"replace\":\n    case \"text-replace\":\n      await doTextReplace(argv);\n      break;\n    case \"convert\":\n      await doConvert(argv);\n      break;\n    case \"markdown\":\n      await doMarkdown(argv);\n      break;\n    case \"import-data\":\n      await doImportData(argv);\n      break;\n    default:\n      console.log(`Unknown command: ${command}` + \"\\n\");\n      await showHelp();\n  }\n}\n\nmain().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n",
  "updatedFile02Filepath": "sandbox/tests/features.test.js",
  "updatedFile02Contents": "import { describe, test, expect } from 'vitest';\nimport { execSync } from 'child_process';\n\ndescribe('CLI sandbox/source/main.js', () => {\n  test('features command lists headings of feature docs', () => {\n    const output = execSync('node sandbox/source/main.js features', { encoding: 'utf-8' });\n    expect(output).toContain('CLI Command Support');\n  });\n\n  test('features command with --validate-mission lists headings without mission references', () => {\n    const output = execSync('node sandbox/source/main.js features --validate-mission', { encoding: 'utf-8' });\n    expect(output).toContain('CLI Command Support');\n  });\n});\n",
  "updatedFile03Filepath": "sandbox/docs/CLI_USAGE.md",
  "updatedFile03Contents": "# CLI Sandbox\n\nProject Overview:\n\n> CLI sandbox showcasing agentic-lib workflows and utility commands.\n\n## Whatâ€™s Inside\n\n- **Entry point:** `sandbox/source/main.js` implements all supported CLI commands.\n- **Tests:** `sandbox/tests/` contains feature-level and unit tests for each command.\n- **Features:** `sandbox/features/` holds Markdown documentation outlining individual features.\n\n## Getting Started\n\n1. Install dependencies:\n   ```bash\n   npm install\n   ```\n2. Run the test suite:\n   ```bash\n   npm test\n   ```\n3. Invoke the CLI:\n   ```bash\n   npm run start -- <command> [options]\n   ```\n\n## Commands Reference\n\n| Command                        | Description                                                                                                                      |\n|--------------------------------|----------------------------------------------------------------------------------------------------------------------------------|\n| help                           | Display help message listing all commands and usage examples                                                                     |\n| mission                        | Print the mission statement from `MISSION.md`                                                                                      |\n| version                        | Show the current version from `package.json`                                                                                      |\n| echo                           | Echo the provided arguments                                                                                                       |\n| features [--validate-mission]  | List headings of Markdown files in `sandbox/features/`. With `--validate-mission`, list only those feature docs that do not reference the mission statement. |\n| mission-features               | Print the mission statement, then list available features                                                                         |\n| csv-import                     | Import a CSV file and output a JSON array                                                                                         |\n| render                         | Render an EJS template with optional JSON data to stdout or file                                                                  |\n| replace / text-replace         | Perform search-and-replace on a text file (literal or regex)                                                                      |\n| convert                        | Convert between .env, JSON, and YAML formats (use --to-json, --to-env, or --to-yaml)                                             |\n| markdown                       | Convert a Markdown file to HTML, optionally writing to an output file                                                             |\n| import-data                    | Import structured data files (.csv, .json, .yaml, .env) into a SQLite database with options --db, --table, --delimiter, --header, --overwrite |\n\n## Examples\n\n- Display help:\n  ```bash\n  npm run start -- help\n  ```\n- Show mission:\n  ```bash\n  npm run start -- mission\n  ```\n- Get version:\n  ```bash\n  npm run start -- version\n  ```\n- Echo arguments:\n  ```bash\n  npm run start -- echo Hello World\n  ```\n- List features:\n  ```bash\n  npm run start -- features\n  ```\n- Validate mission references in feature docs:\n  ```bash\n  npm run start -- features --validate-mission\n  ```\n- Mission and features:\n  ```bash\n  npm run start -- mission-features\n  ```\n- CSV import with header row and custom delimiter:\n  ```bash\n  npm run start -- csv-import data.csv --delimiter \";\" --header false --output out.json\n  ```\n- Render template with data file:\n  ```bash\n  npm run start -- render template.ejs data.json --output report.html\n  ```\n- Replace text using regex:\n  ```bash\n  npm run start -- replace file.txt --search \"foo\" --replace \"bar\" --regex --flags gi\n  ```\n- Convert `.env` to JSON (default):\n  ```bash\n  npm run start -- convert config.env\n  ```\n- Convert JSON to YAML:\n  ```bash\n  npm run start -- convert config.json --to-yaml\n  ```\n- Convert YAML to `.env`:\n  ```bash\n  npm run start -- convert config.yaml --to-env\n  ```\n- Convert Markdown to HTML (stdout):\n  ```bash\n  npm run start -- markdown README.md\n  ```\n- Convert Markdown to HTML and write to file:\n  ```bash\n  npm run start -- markdown README.md --output README.html\n  ```\n- Import data file into SQLite database:\n  ```bash\n  npm run start -- import-data data.csv --db my.db --table users --delimiter \";\" --header false --overwrite\n  ```\n",
  "updatedFile04Filepath": "unused",
  "updatedFile04Contents": "unused",
  "updatedFile05Filepath": "unused",
  "updatedFile05Contents": "unused",
  "updatedFile06Filepath": "unused",
  "updatedFile06Contents": "unused",
  "updatedFile07Filepath": "unused",
  "updatedFile07Contents": "unused",
  "updatedFile08Filepath": "unused",
  "updatedFile08Contents": "unused",
  "updatedFile09Filepath": "unused",
  "updatedFile09Contents": "unused",
  "updatedFile10Filepath": "unused",
  "updatedFile10Contents": "unused",
  "updatedFile11Filepath": "unused",
  "updatedFile11Contents": "unused",
  "updatedFile12Filepath": "unused",
  "updatedFile12Contents": "unused",
  "updatedFile13Filepath": "unused",
  "updatedFile13Contents": "unused",
  "updatedFile14Filepath": "unused",
  "updatedFile14Contents": "unused",
  "updatedFile15Filepath": "unused",
  "updatedFile15Contents": "unused",
  "updatedFile16Filepath": "unused",
  "updatedFile16Contents": "unused"
}