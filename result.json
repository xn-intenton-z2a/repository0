{
  "message": "Enhance features command to fail on mission references and update related tests and docs",
  "updatedFile01Filepath": "sandbox/source/main.js",
  "updatedFile01Contents": "#!/usr/bin/env node\nimport minimist from \"minimist\";\nimport fs from \"fs/promises\";\nimport path from \"path\";\nimport { parse } from \"csv-parse/sync\";\nimport ejs from \"ejs\";\nimport dotenv from \"dotenv\";\nimport jsYaml from \"js-yaml\";\nimport MarkdownIt from \"markdown-it\";\nimport Database from \"better-sqlite3\";\nimport Ajv from \"ajv\";\n\nasync function showHelp() {\n  console.log(`Usage: npm run start -- <command> [args]\n\nCommands:\n  help               Display this help message\n  mission            Print the mission statement\n  version            Print the current version\n  echo               Echo the provided arguments\n  features           List available feature documents (use --validate-mission to list those without mission reference)\n  mission-features   Print the mission statement and list available features\n  csv-import         Import a CSV file and output JSON array\n  render             Render an EJS template with optional JSON data and output file\n  replace            Perform search-and-replace on a text file\n  text-replace       Alias for replace\n  convert            Convert between .env, JSON, and YAML formats (use --to-json, --to-env, or --to-yaml)\n  validate           Validate JSON syntax and optionally JSON Schema\n  markdown           Convert a Markdown file to HTML\n  import-data        Import structured data files into a SQLite database\n\nExamples:\n  npm run start -- help\n  npm run start -- mission\n  npm run start -- version\n  npm run start -- echo Hello World\n  npm run start -- features\n  npm run start -- features --validate-mission\n  npm run start -- mission-features\n  npm run start -- csv-import data.csv\n  npm run start -- csv-import data.csv --output out.json --delimiter \";\" --header false\n  npm run start -- render template.ejs\n  npm run start -- render template.ejs data.json\n  npm run start -- render template.ejs data.json --output out.html\n  npm run start -- replace file.txt --search foo --replace bar\n  npm run start -- text-replace file.txt --search foo --replace bar --regex --flags \"gi\" --output out.txt\n  npm run start -- convert file.env --to-yaml --output out.yaml\n  npm run start -- convert file.env --to-json\n  npm run start -- convert config.json --to-env\n  npm run start -- validate data.json\n  npm run start -- validate data.json --schema schema.json\n  npm run start -- validate data.json --schema schema.json --output report.txt\n  npm run start -- markdown file.md --output file.html\n  npm run start -- import-data data.csv --db my.db --table users --delimiter \";\" --header false --overwrite`);\n}\n\nasync function showMission() {\n  try {\n    const cwd = process.cwd();\n    const content = await fs.readFile(path.join(cwd, \"MISSION.md\"), \"utf-8\");\n    console.log(content);\n  } catch (err) {\n    console.error(\"Error reading mission:\", err.message);\n    process.exit(1);\n  }\n}\n\nasync function showVersion() {\n  try {\n    const cwd = process.cwd();\n    const pkg = await fs.readFile(path.join(cwd, \"package.json\"), \"utf-8\");\n    const { version } = JSON.parse(pkg);\n    console.log(version);\n  } catch (err) {\n    console.error(\"Error reading version:\", err.message);\n    process.exit(1);\n  }\n}\n\nasync function doEcho(args) {\n  console.log(args.join(\" \"));\n}\n\nasync function showFeatures(argv) {\n  const validate = argv && argv[\"validate-mission\"];\n  try {\n    const cwd = process.cwd();\n    const featuresDir = path.join(cwd, \"sandbox/features\");\n    const files = await fs.readdir(featuresDir);\n    const validHeadings = [];\n    const offendingFiles = [];\n    for (const file of files) {\n      if (path.extname(file).toLowerCase() === \".md\") {\n        const filePath = path.join(featuresDir, file);\n        const content = await fs.readFile(filePath, \"utf-8\");\n        if (validate) {\n          if (\n            content.includes(\"MISSION.md\") ||\n            content.includes(\"# Mission Statement\")\n          ) {\n            offendingFiles.push(file);\n            continue;\n          }\n        }\n        const lines = content.split(\"\\n\");\n        let heading = null;\n        for (const line of lines) {\n          const match = line.match(/^#\\s+(.*)/);\n          if (match) {\n            heading = match[1];\n            break;\n          }\n        }\n        if (heading) {\n          if (validate) {\n            validHeadings.push(heading);\n          } else {\n            console.log(heading);\n          }\n        }\n      }\n    }\n    if (validate) {\n      if (offendingFiles.length > 0) {\n        console.error(\n          \"Error: Found mission references in the following feature docs:\"\n        );\n        for (const f of offendingFiles) {\n          console.error(`  ${f}`);\n        }\n        process.exit(1);\n      }\n      for (const h of validHeadings) {\n        console.log(h);\n      }\n      process.exit(0);\n    }\n  } catch (err) {\n    console.error(\"Error listing features:\", err.message);\n    process.exit(1);\n  }\n}\n\nasync function doCsvImport(argv) {\n  const inputFile = argv._[1];\n  if (!inputFile) {\n    console.error(\"Error: No input file specified\");\n    process.exit(1);\n  }\n\n  const delimiter = argv.delimiter || \",\";\n  const header = argv.header !== false;\n  const output = argv.output;\n\n  let content;\n  try {\n    const inputPath = path.resolve(inputFile);\n    content = await fs.readFile(inputPath, \"utf-8\");\n  } catch (err) {\n    console.error(\"Error reading input file:\", err.message);\n    process.exit(1);\n  }\n\n  let records;\n  try {\n    records = parse(content, { columns: header, delimiter, skip_empty_lines: true });\n  } catch (err) {\n    console.error(\"Error parsing CSV:\", err.message);\n    process.exit(1);\n  }\n\n  const json = JSON.stringify(records, null, 2);\n\n  if (output) {\n    try {\n      const outputPath = path.resolve(output);\n      await fs.writeFile(outputPath, json, \"utf-8\");\n      process.exit(0);\n    } catch (err) {\n      console.error(\"Error writing output file:\", err.message);\n      process.exit(1);\n    }\n  } else {\n    console.log(json);\n  }\n}\n\nasync function doRender(argv) {\n  const templateFile = argv._[1];\n  const dataFile = argv._[2];\n  const output = argv.output;\n  if (!templateFile) {\n    console.error(\"Error: No template file specified\");\n    process.exit(1);\n  }\n  let template;\n  try {\n    const templatePath = path.resolve(templateFile);\n    template = await fs.readFile(templatePath, \"utf-8\");\n  } catch (err) {\n    console.error(\"Error reading template file:\", err.message);\n    process.exit(1);\n  }\n  let data = {};\n  if (dataFile) {\n    try {\n      const dataPath = path.resolve(dataFile);\n      const raw = await fs.readFile(dataPath, \"utf-8\");\n      data = JSON.parse(raw);\n    } catch (err) {\n      console.error(\"Error parsing data file:\", err.message);\n      process.exit(1);\n    }\n  }\n  let rendered;\n  try {\n    rendered = ejs.render(template, data);\n  } catch (err) {\n    console.error(\"Error rendering template:\", err.message);\n    process.exit(1);\n  }\n  if (output) {\n    try {\n      const outputPath = path.resolve(output);\n      await fs.writeFile(outputPath, rendered, \"utf-8\");\n      console.log(`Wrote rendered output to ${output}`);\n      process.exit(0);\n    } catch (err) {\n      console.error(\"Error writing output file:\", err.message);\n      process.exit(1);\n    }\n  } else {\n    console.log(rendered);\n    process.exit(0);\n  }\n}\n\nasync function doTextReplace(argv) {\n  const inputFile = argv._[1];\n  const search = argv.search;\n  const replacement = argv.replace;\n  const regexFlag = argv.regex;\n  const allFlag = argv.all;\n  const flagsArg = argv.flags || \"\";\n  const output = argv.output;\n\n  if (!inputFile || search === undefined || replacement === undefined) {\n    console.error(\"Missing --search or --replace flag\");\n    process.exit(1);\n  }\n\n  let content;\n  try {\n    const inputPath = path.resolve(inputFile);\n    content = await fs.readFile(inputPath, \"utf-8\");\n  } catch (err) {\n    console.error(\"Error reading input file:\", err.message);\n    process.exit(1);\n  }\n\n  let result;\n  if (regexFlag) {\n    let flags = flagsArg;\n    if (!flags) {\n      flags = \"g\";\n    }\n    let re;\n    try {\n      re = new RegExp(search, flags);\n    } catch (err) {\n      console.error(\"Invalid regular expression:\", err.message);\n      process.exit(1);\n    }\n    result = content.replace(re, replacement);\n  } else {\n    if (allFlag) {\n      // global literal replacement\n      if (typeof content.replaceAll === \"function\") {\n        result = content.replaceAll(search, replacement);\n      } else {\n        result = content.split(search).join(replacement);\n      }\n    } else {\n      result = content.replace(search, replacement);\n    }\n  }\n\n  if (output) {\n    try {\n      const outputPath = path.resolve(output);\n      await fs.writeFile(outputPath, result, \"utf-8\");\n      process.exit(0);\n    } catch (err) {\n      console.error(\"Error writing output file:\", err.message);\n      process.exit(1);\n    }\n  } else {\n    console.log(result);\n  }\n}\n\nasync function doConvert(argv) {\n  const inputFile = argv._[1];\n  const toEnv = argv[\"to-env\"];\n  const toYaml = argv[\"to-yaml\"];\n  const toJson = argv[\"to-json\"];\n  const output = argv.output;\n\n  if (!inputFile) {\n    console.error(\"Error: No input file specified\");\n    process.exit(1);\n  }\n\n  const flagCount = [toEnv, toYaml, toJson].filter(Boolean).length;\n  if (flagCount > 1) {\n    console.error(\"Error: Specify exactly one of --to-json, --to-env, or --to-yaml\");\n    process.exit(1);\n  }\n\n  let content;\n  try {\n    const inputPath = path.resolve(inputFile);\n    content = await fs.readFile(inputPath, \"utf-8\");\n  } catch (err) {\n    console.error(\"Error reading input file:\", err.message);\n    process.exit(1);\n  }\n\n  let data;\n  try {\n    const ext = path.extname(inputFile).toLowerCase();\n    if (ext === \".env\") {\n      data = dotenv.parse(content);\n    } else if (ext === \".json\") {\n      data = JSON.parse(content);\n    } else if (ext === \".yaml\" || ext === \".yml\") {\n      data = jsYaml.load(content);\n    } else {\n      console.error(`Unsupported input format: ${ext}`);\n      process.exit(1);\n    }\n  } catch (err) {\n    console.error(`Error parsing input file: ${err.message}`);\n    process.exit(1);\n  }\n\n  let result;\n  try {\n    if (toEnv) {\n      if (typeof data !== \"object\" || data === null) {\n        throw new Error(\"Input JSON must be an object for env conversion\");\n      }\n      result = Object.entries(data)\n        .map(([key, value]) => `${key}=${value}`)\n        .join(\"\\n\");\n    } else if (toYaml) {\n      result = jsYaml.dump(data);\n    } else {\n      result = JSON.stringify(data, null, 2);\n    }\n  } catch (err) {\n    console.error(\"Error serializing output:\", err.message);\n    process.exit(1);\n  }\n\n  if (output) {\n    try {\n      const outputPath = path.resolve(output);\n      await fs.writeFile(outputPath, result, \"utf-8\");\n      process.exit(0);\n    } catch (err) {\n      console.error(\"Error writing output file:\", err.message);\n      process.exit(1);\n    }\n  } else {\n    console.log(result);\n  }\n}\n\nasync function doValidateCommand(argv) {\n  const args = argv._;\n  const fileArg = args[1];\n  const schemaArg = argv.schema;\n  const outFile = argv.output;\n  const usage = \"Usage: npm run start -- validate <jsonFile> [--schema <schemaFile>] [--output <file>]\";\n\n  if (!fileArg) {\n    if (outFile) {\n      await fs.writeFile(path.resolve(outFile), usage, \"utf-8\");\n      process.exit(1);\n    }\n    console.error(usage);\n    process.exit(1);\n  }\n\n  let data;\n  try {\n    const content = await fs.readFile(path.resolve(fileArg), \"utf-8\");\n    data = JSON.parse(content);\n  } catch (err) {\n    const msg = err.name === \"SyntaxError\"\n      ? `Error parsing ${fileArg}: ${err.message}`\n      : `Error reading ${fileArg}: ${err.message}`;\n    if (outFile) {\n      await fs.writeFile(path.resolve(outFile), msg, \"utf-8\");\n      process.exit(1);\n    }\n    console.error(msg);\n    process.exit(1);\n  }\n\n  let messages = [];\n  let valid = true;\n  if (schemaArg) {\n    let schema;\n    try {\n      const schemaContent = await fs.readFile(path.resolve(schemaArg), \"utf-8\");\n      schema = JSON.parse(schemaContent);\n    } catch (err) {\n      const msg = `Error reading schema: ${err.message}`;\n      if (outFile) {\n        await fs.writeFile(path.resolve(outFile), msg, \"utf-8\");\n        process.exit(1);\n      }\n      console.error(msg);\n      process.exit(1);\n    }\n    const ajv = new Ajv({ strict: false });\n    const validateFn = ajv.compile(schema);\n    valid = validateFn(data);\n    if (!valid && validateFn.errors) {\n      for (const err of validateFn.errors) {\n        const dataPath = err.instancePath || err.dataPath || \"\";\n        messages.push(`${dataPath}: ${err.message}`);\n      }\n    }\n  }\n\n  if (valid) {\n    messages.push(`Validation passed for ${fileArg}`);\n  }\n\n  if (outFile) {\n    await fs.writeFile(path.resolve(outFile), messages.join(\"\\n\"), \"utf-8\");\n    process.exit(valid ? 0 : 1);\n  } else {\n    if (valid) {\n      console.log(messages[0]);\n      process.exit(0);\n    }\n    for (const msg of messages) {\n      console.error(msg);\n    }\n    process.exit(1);\n  }\n}\n\nasync function doImportData(argv) {\n  const inputFile = argv._[1];\n  const dbPath = argv.db;\n  const table = argv.table || 'data';\n  const delimiter = argv.delimiter || ',';\n  const header = argv.header !== false;\n  const overwrite = argv.overwrite || false;\n\n  if (!inputFile) {\n    console.error('Error: No input file specified');\n    process.exit(1);\n  }\n  if (!dbPath) {\n    console.error('Error: --db <database path> is required');\n    process.exit(1);\n  }\n\n  let raw;\n  try {\n    raw = await fs.readFile(path.resolve(inputFile), 'utf-8');\n  } catch (err) {\n    console.error('Error reading input file:', err.message);\n    process.exit(1);\n  }\n\n  let records;\n  const ext = path.extname(inputFile).toLowerCase();\n  try {\n    if (ext === '.csv') {\n      records = parse(raw, { columns: header, delimiter, skip_empty_lines: true });\n    } else if (ext === '.json') {\n      const data = JSON.parse(raw);\n      if (!Array.isArray(data)) {\n        console.error('Error: JSON input must be an array of objects');\n        process.exit(1);\n      }\n      records = data;\n    } else if (ext === '.yaml' || ext === '.yml') {\n      const data = jsYaml.load(raw);\n      if (!Array.isArray(data)) {\n        console.error('Error: YAML input must be an array of objects');\n        process.exit(1);\n      }\n      records = data;\n    } else if (ext === '.env') {\n      const envObj = dotenv.parse(raw);\n      records = [envObj];\n    } else {\n      console.error(`Unsupported input format: ${ext}`);\n      process.exit(1);\n    }\n  } catch (err) {\n    console.error(`Error parsing input file: ${err.message}`);\n    process.exit(1);\n  }\n\n  let db;\n  try {\n    db = new Database(dbPath);\n  } catch (err) {\n    console.error('Error opening database:', err.message);\n    process.exit(1);\n  }\n\n  try {\n    const exists = db.prepare(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\").get(table);\n    if (exists) {\n      if (overwrite) {\n        db.prepare(`DROP TABLE \\\"${table}\\\"`).run();\n      } else {\n        console.error(`Error: Table '${table}' already exists. Use --overwrite to replace.`);\n        process.exit(1);\n      }\n    }\n  } catch (err) {\n    console.error('Error checking table existence:', err.message);\n    process.exit(1);\n  }\n\n  const keys = Object.keys(records[0] || {});\n  const colsDef = keys.map((k) => `\\\"${k}\\\" TEXT`).join(', ');\n  try {\n    db.prepare(`CREATE TABLE \\\"${table}\\\" (${colsDef})`).run();\n  } catch (err) {\n    console.error('Error creating table:', err.message);\n    process.exit(1);\n  }\n\n  const placeholders = keys.map(() => '?').join(', ');\n  const insertSQL = `INSERT INTO \\\"${table}\\\" (${keys.map((k) => `\\\"${k}\\\"`).join(', ')}) VALUES (${placeholders})`;\n  const insertStmt = db.prepare(insertSQL);\n  const insertMany = db.transaction((recs) => {\n    for (const r of recs) {\n      insertStmt.run(...keys.map((k) => r[k]));\n    }\n  });\n  try {\n    insertMany(records);\n  } catch (err) {\n    console.error('Error inserting records:', err.message);\n    process.exit(1);\n  }\n\n  db.close();\n  console.log(`Inserted ${records.length} records into table '${table}' in database ${dbPath}`);\n  process.exit(0);\n}\n\nasync function doMarkdown(argv) {\n  const inputFile = argv._[1];\n  const output = argv.output;\n  if (!inputFile) {\n    console.error(\"Error: No input file specified\");\n    process.exit(1);\n  }\n  let content;\n  try {\n    const inputPath = path.resolve(inputFile);\n    content = await fs.readFile(inputPath, \"utf-8\");\n  } catch (err) {\n    console.error(\"Error reading input file:\", err.message);\n    process.exit(1);\n  }\n  const md = new MarkdownIt();\n  let html;\n  try {\n    html = md.render(content);\n  } catch (err) {\n    console.error(\"Error rendering markdown:\", err.message);\n    process.exit(1);\n  }\n  if (output) {\n    try {\n      const outputPath = path.resolve(output);\n      await fs.writeFile(outputPath, html, \"utf-8\");\n      process.exit(0);\n    } catch (err) {\n      console.error(\"Error writing output file:\", err.message);\n      process.exit(1);\n    }\n  } else {\n    console.log(html);\n  }\n}\n\nasync function main() {\n  const argv = minimist(process.argv.slice(2), {\n    boolean: [\"header\", \"regex\", \"to-env\", \"to-yaml\", \"to-json\", \"overwrite\", \"validate-мission\", \"all\"],\n    string: [\"output\", \"delimiter\", \"flags\", \"search\", \"replace\", \"db\", \"table\", \"schema\"],\n    default: { header: true, delimiter: \",\" },\n  });\n  const [command, ...rest] = argv._;\n  switch (command) {\n    case \"help\":\n    case undefined:\n      await showHelp();\n      break;\n    case \"mission\":\n      await showMission();\n      break;\n    case \"version\":\n      await showVersion();\n      break;\n    case \"echo\":\n      await doEcho(rest);\n      break;\n    case \"features\":\n      await showFeatures(argv);\n      break;\n    case \"mission-features\":\n      await showMission();\n      console.log(\"\");\n      await showFeatures(argv);\n      break;\n    case \"csv-import\":\n      await doCsvImport(argv);\n      break;\n    case \"render\":\n      await doRender(argv);\n      break;\n    case \"replace\":\n    case \"text-replace\":\n      await doTextReplace(argv);\n      break;\n    case \"convert\":\n      await doConvert(argv);\n      break;\n    case \"validate\":\n      await doValidateCommand(argv);\n      break;\n    case \"markdown\":\n      await doMarkdown(argv);\n      break;\n    case \"import-data\":\n      await doImportData(argv);\n      break;\n    default:\n      console.log(`Unknown command: ${command}` + \"\\n\");\n      await showHelp();\n  }\n}\n\nmain().catch((err) => {\n  console.error(err);\n  process.exit(1);\n});\n",
  "updatedFile02Filepath": "sandbox/tests/features.test.js",
  "updatedFile02Contents": "import { describe, test, expect } from 'vitest';\nimport { execSync } from 'child_process';\nimport fs from 'fs';\nimport path from 'path';\n\ndescribe('CLI sandbox/source/main.js', () => {\n  test('features command lists headings of feature docs', () => {\n    const output = execSync('node sandbox/source/main.js features', { encoding: 'utf-8' });\n    expect(output).toContain('CLI Command Support');\n  });\n\n  test('features command with --validate-mission lists headings without mission references', () => {\n    const output = execSync('node sandbox/source/main.js features --validate-mission', { encoding: 'utf-8' });\n    expect(output).toContain('CLI Command Support');\n  });\n\n  test('features command with --validate-mission fails on mission references', () => {\n    // Create a temporary feature document that references the mission\n    const dummyPath = path.join(process.cwd(), 'sandbox/features/tmp_mission.md');\n    fs.writeFileSync(dummyPath, '# Dummy Feature\\nThis references MISSION.md', 'utf-8');\n    let err;\n    try {\n      execSync('node sandbox/source/main.js features --validate-mission', { encoding: 'utf-8', stdio: 'pipe' });\n    } catch (e) {\n      err = e;\n    } finally {\n      // Clean up the dummy file\n      fs.unlinkSync(dummyPath);\n    }\n    expect(err).toBeDefined();\n    expect(err.status).toBe(1);\n    expect(err.stderr).toContain('tmp_mission.md');\n  });\n});\n",
  "updatedFile03Filepath": "sandbox/docs/CLI_USAGE.md",
  "updatedFile03Contents": "# CLI Sandbox\n\nProject Overview:\n\n> CLI sandbox showcasing agentic-lib workflows and utility commands.\n\n## What’s Inside\n\n- **Entry point:** `sandbox/source/main.js` implements all supported CLI commands.\n- **Tests:** `sandbox/tests/` contains feature-level and unit tests for each command.\n- **Features:** `sandbox/features/` holds Markdown documentation outlining individual features.\n\n## Getting Started\n\n1. Install dependencies:\n   ```bash\n   npm install\n   ```\n2. Run the test suite:\n   ```bash\n   npm test\n   ```\n3. Invoke the CLI:\n   ```bash\n   npm run start -- <command> [options]\n   ```\n\n## Commands Reference\n\n| Command                        | Description                                                                                                                      |\n|--------------------------------|----------------------------------------------------------------------------------------------------------------------------------|\n| help                           | Display help message listing all commands and usage examples                                                                     |\n| mission                        | Print the mission statement from `MISSION.md`                                                                                     |\n| version                        | Show the current version from `package.json`                                                                                      |\n| echo                           | Echo the provided arguments                                                                                                       |\n| features [--validate-mission]  | List headings of Markdown files in `sandbox/features/`. With `--validate-mission`, list only feature docs without mission references; reports and fails (exit code 1) if any docs reference the mission statement. |\n| mission-features               | Print the mission statement, then list available features                                                                         |\n| csv-import                     | Import a CSV file and output a JSON array                                                                                         |\n| render                         | Render an EJS template with optional JSON data to stdout or file                                                                  |\n| replace / text-replace         | Perform search-and-replace on a text file (literal or regex). Supports `--all` for global literal replacements and default global regex when no `--flags` are provided. |\n| convert                        | Convert between `.env`, JSON, and YAML formats (use `--to-json`, `--to-env`, or `--to-yaml`)                                          |\n| validate `<jsonFile>` [--schema `<schemaFile>`] [--output `<file>`] | Validate JSON file syntax and optionally validate against a JSON Schema (Draft-07) using AJV, writing results to stdout or file |\n| markdown                       | Convert a Markdown file to HTML, optionally writing to an output file                                                             |\n| import-data                    | Import structured data files (.csv, .json, .yaml, .env) into a SQLite database with options `--db`, `--table`, `--delimiter`, `--header`, `--overwrite` |\n\n### validate\n\nUsage:\n```bash\nnpm run start -- validate <jsonFile> [--schema <schemaFile>] [--output <file>]\n```\n\nFlags:\n- `--schema <schemaFile>` Validate data against the provided JSON Schema (Draft-07).\n- `--output <file>` Write validation results to the specified file instead of stdout.\n\nBehavior:\n- Syntax-only validation ensures the JSON is well-formed.\n- Schema validation reports each error on its own line as `dataPath: message`.\n- On success, outputs `Validation passed for <jsonFile>`.\n- Exits with code 0 on success, 1 on failure.\n\n## Examples\n\n- Display help:\n  ```bash\n  npm run start -- help\n  ```\n- Show mission:\n  ```bash\n  npm run start -- mission\n  ```\n- Get version:\n  ```bash\n  npm run start -- version\n  ```\n- Echo arguments:\n  ```bash\n  npm run start -- echo Hello World\n  ```\n- List features:\n  ```bash\n  npm run start -- features\n  ```\n- Validate mission references in feature docs:\n  ```bash\n  npm run start -- features --validate-mission\n  ```\n- Mission and features:\n  ```bash\n  npm run start -- mission-features\n  ```\n- CSV import with header row and custom delimiter:\n  ```bash\n  npm run start -- csv-import data.csv --delimiter \";\" --header false --output out.json\n  ```\n- Render template with data file:\n  ```bash\n  npm run start -- render template.ejs data.json --output report.html\n  ```\n- Replace text using regex:\n  ```bash\n  npm run start -- replace file.txt --search \"foo\" --replace \"bar\" --regex --flags gi\n  ```\n- Replace all occurrences literally:\n  ```bash\n  npm run start -- replace file.txt --search \"foo\" --replace \"bar\" --all\n  ```\n- Replace all occurrences using regex by default:\n  ```bash\n  npm run start -- replace file.txt --search \"a\" --replace \"x\" --regex\n  ```\n- Convert `.env` to JSON (default):\n  ```bash\n  npm run start -- convert config.env\n  ```\n- Convert JSON to YAML:\n  ```bash\n  npm run start -- convert config.json --to-yaml\n  ```\n- Convert YAML to `.env`:\n  ```bash\n  npm run start -- convert config.yaml --to-env\n  ```\n- Convert Markdown to HTML (stdout):\n  ```bash\n  npm run start -- markdown README.md\n  ```\n- Convert Markdown to HTML and write to file:\n  ```bash\n  npm run start -- markdown README.md --output README.html\n  ```\n- Import data file into SQLite database:\n  ```bash\n  npm run start -- import-data data.csv --db my.db --table users --delimiter \";\" --header false --overwrite\n  ```\n",
  "updatedFile04Filepath": "sandbox/docs/README.md",
  "updatedFile04Contents": "# CLI Sandbox Tool\n\n[MISSION.md](../../MISSION.md) | [CONTRIBUTING.md](../../CONTRIBUTING.md) | [LICENSE.md](../../LICENSE.md)\n\n## Overview\n\nThis repository provides a CLI sandbox tool implemented in `sandbox/source/main.js` for commands such as `help`, `mission`, `version`, `echo`, and more.\n\n## What’s Inside\n\n- **CLI entrypoint:** `sandbox/source/main.js`\n- **Feature documentation:** files under `sandbox/features/`\n- **Tests:** files under `sandbox/tests/` and `tests/unit/`\n- **Additional docs:** `sandbox/docs/CLI_USAGE.md`\n\n## Getting Started\n\n1. Install dependencies:\n   ```bash\n   npm install\n   ```\n2. Run the test suite:\n   ```bash\n   npm test\n   ```\n3. Invoke the CLI:\n   ```bash\n   npm run start -- <command> [options]\n   ```\n\n## Commands\n\n**help**\n\nDisplay help message.\n\nExample:  \n```bash\nnpm run start -- help\n```\n\n**mission**\n\nPrint the mission statement.\n\nExample:  \n```bash\nnpm run start -- mission\n```\n\n**version**\n\nPrint the current version.\n\nExample:  \n```bash\nnpm run start -- version\n```\n\n**echo**\n\nEcho the provided arguments.\n\nExample:  \n```bash\nnpm run start -- echo Hello World\n```\n\n**features [--validate-mission]**\n\nList feature document headings. With `--validate-mission`, report and fail on any mission references in feature docs (exit code 1).\n\nExample:  \n```bash\nnpm run start -- features --validate-mission\n```\n\n**mission-features**\n\nPrint mission then list features.\n\nExample:  \n```bash\nnpm run start -- mission-features\n```\n\n**csv-import**\n\nImport a CSV file and output a JSON array.\n\nExample:  \n```bash\nnpm run start -- csv-import data.csv\n```\n\n**render**\n\nRender an EJS template with optional JSON data.\n\nExample:  \n```bash\nnpm run start -- render template.ejs data.json\n```\n\n**replace / text-replace**\n\nSearch-and-replace in text files (literal or regex).\n\nExample:  \n```bash\nnpm run start -- replace file.txt --search foo --replace bar --all\n```\n\n**convert**\n\nConvert between `.env`, JSON, and YAML formats.\n\nExample:  \n```bash\nnpm run start -- convert config.env --to-json\n```\n\n**validate**\n\nValidate JSON syntax and optionally against a schema.\n\nExample:  \n```bash\nnpm run start -- validate data.json --schema schema.json\n```\n\n**markdown**\n\nConvert a Markdown file to HTML.\n\nExample:  \n```bash\nnpm run start -- markdown file.md --output file.html\n```\n\n**import-data**\n\nImport structured data into a SQLite database.\n\nExample:  \n```bash\nnpm run start -- import-data data.csv --db my.db --table users\n```\n",
  "updatedFile05Filepath": "unused",
  "updatedFile05Contents": "unused",
  "updatedFile06Filepath": "unused",
  "updatedFile06Contents": "unused",
  "updatedFile07Filepath": "unused",
  "updatedFile07Contents": "unused",
  "updatedFile08Filepath": "unused",
  "updatedFile08Contents": "unused",
  "updatedFile09Filepath": "unused",
  "updatedFile09Contents": "unused",
  "updatedFile10Filepath": "unused",
  "updatedFile10Contents": "unused",
  "updatedFile11Filepath": "unused",
  "updatedFile11Contents": "unused",
  "updatedFile12Filepath": "unused",
  "updatedFile12Contents": "unused",
  "updatedFile13Filepath": "unused",
  "updatedFile13Contents": "unused",
  "updatedFile14Filepath": "unused",
  "updatedFile14Contents": "unused",
  "updatedFile15Filepath": "unused",
  "updatedFile15Contents": "unused",
  "updatedFile16Filepath": "unused",
  "updatedFile16Contents": "unused"
}