sandbox/source/main.js
# sandbox/source/main.js
import minimist from "minimist";
import MarkdownIt from "markdown-it";
import { readFile, writeFile } from "fs/promises";
import { fileURLToPath } from "url";
import { Configuration, OpenAIApi } from "openai";

const __filename = fileURLToPath(import.meta.url);

/**
 * Prints the usage message for the CLI.
 * @returns {string} Usage instructions.
 */
export function usage() {
  return [
    "Usage:",
    "  node main.js convert <input.md> [-o <output.html>]",
    "  node main.js summarize <input.md> [-o <output.txt>]"
  ].join("\n");
}

/**
 * Converts a Markdown file to HTML.
 * @param {string} inputPath - Path to the input Markdown file.
 * @param {string} [outputPath] - Optional path to write the output HTML file.
 * @returns {Promise<string>} The rendered HTML string.
 * @throws {Error} If reading or writing files fails.
 */
export async function convert(inputPath, outputPath) {
  if (!inputPath) {
    throw new Error("No input file specified");
  }
  let data;
  try {
    data = await readFile(inputPath, "utf8");
  } catch (error) {
    throw new Error(`Failed to read input file: ${error.message}`);
  }
  const md = new MarkdownIt();
  const html = md.render(data);
  if (outputPath) {
    try {
      await writeFile(outputPath, html, "utf8");
    } catch (error) {
      throw new Error(`Failed to write output file: ${error.message}`);
    }
  }
  return html;
}

/**
 * Generates a bullet-point summary of a Markdown file using OpenAI API.
 * @param {string} inputPath - Path to the input Markdown file.
 * @param {string} [outputPath] - Optional path to write the summary file.
 * @returns {Promise<string>} The summary text.
 * @throws {Error} For missing API key or file I/O errors.
 */
export async function summarize(inputPath, outputPath) {
  if (!inputPath) {
    throw new Error("No input file specified");
  }
  if (!process.env.OPENAI_API_KEY) {
    throw new Error("Missing OpenAI API key");
  }
  let data;
  try {
    data = await readFile(inputPath, "utf8");
  } catch (error) {
    throw new Error(`Failed to read input file: ${error.message}`);
  }
  const config = new Configuration({ apiKey: process.env.OPENAI_API_KEY });
  const openai = new OpenAIApi(config);
  let summary;
  try {
    const response = await openai.createChatCompletion({
      model: "gpt-3.5-turbo",
      messages: [
        {
          role: "system",
          content:
            "You are a helpful assistant that produces a concise bullet-point summary of the provided Markdown text."
        },
        { role: "user", content: data }
      ]
    });
    summary = response.data.choices[0].message.content.trim();
  } catch (error) {
    throw new Error(`Failed to summarize content: ${error.message}`);
  }
  if (outputPath) {
    try {
      await writeFile(outputPath, summary, "utf8");
    } catch (error) {
      throw new Error(`Failed to write output file: ${error.message}`);
    }
  }
  return summary;
}

/**
 * Main entry point for CLI arguments.
 * @param {string[]} args - Command-line arguments (excluding node and script path).
 * @returns {Promise<string>} The rendered HTML or summary if successful.
 * @throws {Error} For invalid command or missing input.
 */
export async function main(args) {
  const [cmd, ...rest] = args;
  const argv = minimist(rest, { alias: { o: "output" }, string: ["output"] });
  if (cmd === "convert") {
    const input = argv._[0];
    const output = argv.output;
    if (!input) {
      throw new Error(usage());
    }
    return await convert(input, output);
  }
  if (cmd === "summarize") {
    const input = argv._[0];
    const output = argv.output;
    if (!input) {
      throw new Error(usage());
    }
    return await summarize(input, output);
  }
  throw new Error(usage());
}

// CLI wrapper: only run when executed directly
if (process.argv[1] === __filename) {
  const args = process.argv.slice(2);
  main(args)
    .then((result) => {
      const argv = minimist(args, { alias: { o: "output" }, string: ["output"] });
      if (!argv.output) {
        process.stdout.write(result);
      }
      process.exit(0);
    })
    .catch((err) => {
      console.error(err.message);
      process.exit(1);
    });
}
