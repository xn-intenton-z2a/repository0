Bahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSemantic Versioning 2.0.0

Summary

Given a version number MAJOR.MINOR.PATCH, increment the:


  MAJOR version when you make incompatible API changes
  MINOR version when you add functionality in a backward compatible
manner
  PATCH version when you make backward compatible bug fixes


Additional labels for pre-release and build metadata are available as extensions
to the MAJOR.MINOR.PATCH format.

Introduction

In the world of software management there exists a dreaded place called
“dependency hell.” The bigger your system grows and the more packages you
integrate into your software, the more likely you are to find yourself, one
day, in this pit of despair.

In systems with many dependencies, releasing new package versions can quickly
become a nightmare. If the dependency specifications are too tight, you are in
danger of version lock (the inability to upgrade a package without having to
release new versions of every dependent package). If dependencies are
specified too loosely, you will inevitably be bitten by version promiscuity
(assuming compatibility with more future versions than is reasonable).
Dependency hell is where you are when version lock and/or version promiscuity
prevent you from easily and safely moving your project forward.

As a solution to this problem, we propose a simple set of rules and
requirements that dictate how version numbers are assigned and incremented.
These rules are based on but not necessarily limited to pre-existing
widespread common practices in use in both closed and open-source software.
For this system to work, you first need to declare a public API. This may
consist of documentation or be enforced by the code itself. Regardless, it is
important that this API be clear and precise. Once you identify your public
API, you communicate changes to it with specific increments to your version
number. Consider a version format of X.Y.Z (Major.Minor.Patch). Bug fixes not
affecting the API increment the patch version, backward compatible API
additions/changes increment the minor version, and backward incompatible API
changes increment the major version.

We call this system “Semantic Versioning.” Under this scheme, version numbers
and the way they change convey meaning about the underlying code and what has
been modified from one version to the next.

Semantic Versioning Specification (SemVer)

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,
“SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be
interpreted as described in RFC 2119.


  
    Software using Semantic Versioning MUST declare a public API. This API
could be declared in the code itself or exist strictly in documentation.
However it is done, it SHOULD be precise and comprehensive.
  
  
    A normal version number MUST take the form X.Y.Z where X, Y, and Z are
non-negative integers, and MUST NOT contain leading zeroes. X is the
major version, Y is the minor version, and Z is the patch version.
Each element MUST increase numerically. For instance: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Once a versioned package has been released, the contents of that version
MUST NOT be modified. Any modifications MUST be released as a new version.
  
  
    Major version zero (0.y.z) is for initial development. Anything MAY change
at any time. The public API SHOULD NOT be considered stable.
  
  
    Version 1.0.0 defines the public API. The way in which the version number
is incremented after this release is dependent on this public API and how it
changes.
  
  
    Patch version Z (x.y.Z | x > 0) MUST be incremented if only backward
compatible bug fixes are introduced. A bug fix is defined as an internal
change that fixes incorrect behavior.
  
  
    Minor version Y (x.Y.z | x > 0) MUST be incremented if new, backward
compatible functionality is introduced to the public API. It MUST be
incremented if any public API functionality is marked as deprecated. It MAY be
incremented if substantial new functionality or improvements are introduced
within the private code. It MAY include patch level changes. Patch version
MUST be reset to 0 when minor version is incremented.
  
  
    Major version X (X.y.z | X > 0) MUST be incremented if any backward
incompatible changes are introduced to the public API. It MAY also include minor
and patch level changes. Patch and minor versions MUST be reset to 0 when major
version is incremented.
  
  
    A pre-release version MAY be denoted by appending a hyphen and a
series of dot separated identifiers immediately following the patch
version. Identifiers MUST comprise only ASCII alphanumerics and hyphens
[0-9A-Za-z-]. Identifiers MUST NOT be empty. Numeric identifiers MUST
NOT include leading zeroes. Pre-release versions have a lower
precedence than the associated normal version. A pre-release version
indicates that the version is unstable and might not satisfy the
intended compatibility requirements as denoted by its associated
normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.--.
  
  
    Build metadata MAY be denoted by appending a plus sign and a series of dot
separated identifiers immediately following the patch or pre-release version.
Identifiers MUST comprise only ASCII alphanumerics and hyphens [0-9A-Za-z-].
Identifiers MUST NOT be empty. Build metadata MUST be ignored when determining
version precedence. Thus two versions that differ only in the build metadata,
have the same precedence. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3----117B344092BD.
  
  
    Precedence refers to how versions are compared to each other when ordered.

    
      
        Precedence MUST be calculated by separating the version into major,
minor, patch and pre-release identifiers in that order (Build metadata
does not figure into precedence).
      
      
        Precedence is determined by the first difference when comparing each of
these identifiers from left to right as follows: Major, minor, and patch
versions are always compared numerically.

        Example: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        When major, minor, and patch are equal, a pre-release version has lower
precedence than a normal version:

        Example: 1.0.0-alpha < 1.0.0.
      
      
        Precedence for two pre-release versions with the same major, minor, and
patch version MUST be determined by comparing each dot separated identifier
from left to right until a difference is found as follows:

        
          
            Identifiers consisting of only digits are compared numerically.
          
          
            Identifiers with letters or hyphens are compared lexically in ASCII
sort order.
          
          
            Numeric identifiers always have lower precedence than non-numeric
identifiers.
          
          
            A larger set of pre-release fields has a higher precedence than a
smaller set, if all of the preceding identifiers are equal.
          
        

        Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
      
    
  


Backus–Naur Form Grammar for Valid SemVer Versions
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


Why Use Semantic Versioning?

This is not a new or revolutionary idea. In fact, you probably do something
close to this already. The problem is that “close” isn’t good enough. Without
compliance to some sort of formal specification, version numbers are
essentially useless for dependency management. By giving a name and clear
definition to the above ideas, it becomes easy to communicate your intentions
to the users of your software. Once these intentions are clear, flexible (but
not too flexible) dependency specifications can finally be made.

A simple example will demonstrate how Semantic Versioning can make dependency
hell a thing of the past. Consider a library called “Firetruck.” It requires a
Semantically Versioned package named “Ladder.” At the time that Firetruck is
created, Ladder is at version 3.1.0. Since Firetruck uses some functionality
that was first introduced in 3.1.0, you can safely specify the Ladder
dependency as greater than or equal to 3.1.0 but less than 4.0.0. Now, when
Ladder version 3.1.1 and 3.2.0 become available, you can release them to your
package management system and know that they will be compatible with existing
dependent software.

As a responsible developer you will, of course, want to verify that any
package upgrades function as advertised. The real world is a messy place;
there’s nothing we can do about that but be vigilant. What you can do is let
Semantic Versioning provide you with a sane way to release and upgrade
packages without having to roll new versions of dependent packages, saving you
time and hassle.

If all of this sounds desirable, all you need to do to start using Semantic
Versioning is to declare that you are doing so and then follow the rules. Link
to this website from your README so others know the rules and can benefit from
them.

FAQ

How should I deal with revisions in the 0.y.z initial development phase?

The simplest thing to do is start your initial development release at 0.1.0
and then increment the minor version for each subsequent release.

How do I know when to release 1.0.0?

If your software is being used in production, it should probably already be
1.0.0. If you have a stable API on which users have come to depend, you should
be 1.0.0. If you’re worrying a lot about backward compatibility, you should
probably already be 1.0.0.

Doesn’t this discourage rapid development and fast iteration?

Major version zero is all about rapid development. If you’re changing the API
every day you should either still be in version 0.y.z or on a separate
development branch working on the next major version.

If even the tiniest backward incompatible changes to the public API require a major version bump, won’t I end up at version 42.0.0 very rapidly?

This is a question of responsible development and foresight. Incompatible
changes should not be introduced lightly to software that has a lot of
dependent code. The cost that must be incurred to upgrade can be significant.
Having to bump major versions to release incompatible changes means you’ll
think through the impact of your changes, and evaluate the cost/benefit ratio
involved.

Documenting the entire public API is too much work!

It is your responsibility as a professional developer to properly document
software that is intended for use by others. Managing software complexity is a
hugely important part of keeping a project efficient, and that’s hard to do if
nobody knows how to use your software, or what methods are safe to call. In
the long run, Semantic Versioning, and the insistence on a well defined public
API can keep everyone and everything running smoothly.

What do I do if I accidentally release a backward incompatible change as a minor version?

As soon as you realize that you’ve broken the Semantic Versioning spec, fix
the problem and release a new minor version that corrects the problem and
restores backward compatibility. Even under this circumstance, it is
unacceptable to modify versioned releases. If it’s appropriate,
document the offending version and inform your users of the problem so that
they are aware of the offending version.

What should I do if I update my own dependencies without changing the public API?

That would be considered compatible since it does not affect the public API.
Software that explicitly depends on the same dependencies as your package
should have their own dependency specifications and the author will notice any
conflicts. Determining whether the change is a patch level or minor level
modification depends on whether you updated your dependencies in order to fix
a bug or introduce new functionality. We would usually expect additional code
for the latter instance, in which case it’s obviously a minor level increment.

What if I inadvertently alter the public API in a way that is not compliant with the version number change (i.e. the code incorrectly introduces a major breaking change in a patch release)?

Use your best judgment. If you have a huge audience that will be drastically
impacted by changing the behavior back to what the public API intended, then
it may be best to perform a major version release, even though the fix could
strictly be considered a patch release. Remember, Semantic Versioning is all
about conveying meaning by how the version number changes. If these changes
are important to your users, use the version number to inform them.

How should I handle deprecating functionality?

Deprecating existing functionality is a normal part of software development and
is often required to make forward progress. When you deprecate part of your
public API, you should do two things: (1) update your documentation to let
users know about the change, (2) issue a new minor release with the deprecation
in place. Before you completely remove the functionality in a new major release
there should be at least one minor release that contains the deprecation so
that users can smoothly transition to the new API.

Does SemVer have a size limit on the version string?

No, but use good judgment. A 255 character version string is probably overkill,
for example. Also, specific systems may impose their own limits on the size of
the string.

Is “v1.2.3” a semantic version?

No, “v1.2.3” is not a semantic version. However, prefixing a semantic version
with a “v” is a common way (in English) to indicate it is a version number.
Abbreviating “version” as “v” is often seen with version control. Example:
git tag v1.2.3 -m "Release version 1.2.3", in which case “v1.2.3” is a tag
name and the semantic version is “1.2.3”.

Is there a suggested regular expression (RegEx) to check a SemVer string?

There are two. One with named groups for those systems that support them
(PCRE [Perl Compatible Regular Expressions, i.e. Perl, PHP and R], Python
and Go).

See: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


And one with numbered capture groups instead (so cg1 = major, cg2 = minor,
cg3 = patch, cg4 = prerelease and cg5 = buildmetadata) that is compatible
with ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
i.e. Perl, PHP and R), Python and Go.

See: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


About

The Semantic Versioning specification was originally authored by Tom
Preston-Werner, inventor of Gravatar and
cofounder of GitHub.

If you’d like to leave feedback, please open an issue on
GitHub.

License

Creative Commons ― CC BY 3.0\nSemantic Versioning 2.0.0\nGiven a version number MAJOR.MINOR.PATCH, increment the:\nMAJOR version when you make incompatible API changes\nMINOR version when you add functionality in a backward compatible
manner\nPATCH version when you make backward compatible bug fixes\nAdditional labels for pre-release and build metadata are available as extensions
to the MAJOR.MINOR.PATCH format.\nIn the world of software management there exists a dreaded place called
“dependency hell.” The bigger your system grows and the more packages you
integrate into your software, the more likely you are to find yourself, one
day, in this pit of despair.\nIn systems with many dependencies, releasing new package versions can quickly
become a nightmare. If the dependency specifications are too tight, you are in
danger of version lock (the inability to upgrade a package without having to
release new versions of every dependent package). If dependencies are
specified too loosely, you will inevitably be bitten by version promiscuity
(assuming compatibility with more future versions than is reasonable).
Dependency hell is where you are when version lock and/or version promiscuity
prevent you from easily and safely moving your project forward.\nAs a solution to this problem, we propose a simple set of rules and
requirements that dictate how version numbers are assigned and incremented.
These rules are based on but not necessarily limited to pre-existing
widespread common practices in use in both closed and open-source software.
For this system to work, you first need to declare a public API. This may
consist of documentation or be enforced by the code itself. Regardless, it is
important that this API be clear and precise. Once you identify your public
API, you communicate changes to it with specific increments to your version
number. Consider a version format of X.Y.Z (Major.Minor.Patch). Bug fixes not
affecting the API increment the patch version, backward compatible API
additions/changes increment the minor version, and backward incompatible API
changes increment the major version.\nWe call this system “Semantic Versioning.” Under this scheme, version numbers
and the way they change convey meaning about the underlying code and what has
been modified from one version to the next.\nSemantic Versioning Specification (SemVer)\nThe key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,
“SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be
interpreted as described in RFC 2119.\nSoftware using Semantic Versioning MUST declare a public API. This API
could be declared in the code itself or exist strictly in documentation.
However it is done, it SHOULD be precise and comprehensive.\nSoftware using Semantic Versioning MUST declare a public API. This API
could be declared in the code itself or exist strictly in documentation.
However it is done, it SHOULD be precise and comprehensive.\nA normal version number MUST take the form X.Y.Z where X, Y, and Z are
non-negative integers, and MUST NOT contain leading zeroes. X is the
major version, Y is the minor version, and Z is the patch version.
Each element MUST increase numerically. For instance: 1.9.0 -> 1.10.0 -> 1.11.0.\nA normal version number MUST take the form X.Y.Z where X, Y, and Z are
non-negative integers, and MUST NOT contain leading zeroes. X is the
major version, Y is the minor version, and Z is the patch version.
Each element MUST increase numerically. For instance: 1.9.0 -> 1.10.0 -> 1.11.0.\nOnce a versioned package has been released, the contents of that version
MUST NOT be modified. Any modifications MUST be released as a new version.\nOnce a versioned package has been released, the contents of that version
MUST NOT be modified. Any modifications MUST be released as a new version.\nMajor version zero (0.y.z) is for initial development. Anything MAY change
at any time. The public API SHOULD NOT be considered stable.\nMajor version zero (0.y.z) is for initial development. Anything MAY change
at any time. The public API SHOULD NOT be considered stable.\nVersion 1.0.0 defines the public API. The way in which the version number
is incremented after this release is dependent on this public API and how it
changes.\nVersion 1.0.0 defines the public API. The way in which the version number
is incremented after this release is dependent on this public API and how it
changes.\nPatch version Z (x.y.Z | x > 0) MUST be incremented if only backward
compatible bug fixes are introduced. A bug fix is defined as an internal
change that fixes incorrect behavior.\nPatch version Z (x.y.Z | x > 0) MUST be incremented if only backward
compatible bug fixes are introduced. A bug fix is defined as an internal
change that fixes incorrect behavior.\nMinor version Y (x.Y.z | x > 0) MUST be incremented if new, backward
compatible functionality is introduced to the public API. It MUST be
incremented if any public API functionality is marked as deprecated. It MAY be
incremented if substantial new functionality or improvements are introduced
within the private code. It MAY include patch level changes. Patch version
MUST be reset to 0 when minor version is incremented.\nMinor version Y (x.Y.z | x > 0) MUST be incremented if new, backward
compatible functionality is introduced to the public API. It MUST be
incremented if any public API functionality is marked as deprecated. It MAY be
incremented if substantial new functionality or improvements are introduced
within the private code. It MAY include patch level changes. Patch version
MUST be reset to 0 when minor version is incremented.\nMajor version X (X.y.z | X > 0) MUST be incremented if any backward
incompatible changes are introduced to the public API. It MAY also include minor
and patch level changes. Patch and minor versions MUST be reset to 0 when major
version is incremented.\nMajor version X (X.y.z | X > 0) MUST be incremented if any backward
incompatible changes are introduced to the public API. It MAY also include minor
and patch level changes. Patch and minor versions MUST be reset to 0 when major
version is incremented.\nA pre-release version MAY be denoted by appending a hyphen and a
series of dot separated identifiers immediately following the patch
version. Identifiers MUST comprise only ASCII alphanumerics and hyphens
[0-9A-Za-z-]. Identifiers MUST NOT be empty. Numeric identifiers MUST
NOT include leading zeroes. Pre-release versions have a lower
precedence than the associated normal version. A pre-release version
indicates that the version is unstable and might not satisfy the
intended compatibility requirements as denoted by its associated
normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.--.\nA pre-release version MAY be denoted by appending a hyphen and a
series of dot separated identifiers immediately following the patch
version. Identifiers MUST comprise only ASCII alphanumerics and hyphens
[0-9A-Za-z-]. Identifiers MUST NOT be empty. Numeric identifiers MUST
NOT include leading zeroes. Pre-release versions have a lower
precedence than the associated normal version. A pre-release version
indicates that the version is unstable and might not satisfy the
intended compatibility requirements as denoted by its associated
normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.--.\nBuild metadata MAY be denoted by appending a plus sign and a series of dot
separated identifiers immediately following the patch or pre-release version.
Identifiers MUST comprise only ASCII alphanumerics and hyphens [0-9A-Za-z-].
Identifiers MUST NOT be empty. Build metadata MUST be ignored when determining
version precedence. Thus two versions that differ only in the build metadata,
have the same precedence. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3----117B344092BD.\nBuild metadata MAY be denoted by appending a plus sign and a series of dot
separated identifiers immediately following the patch or pre-release version.
Identifiers MUST comprise only ASCII alphanumerics and hyphens [0-9A-Za-z-].
Identifiers MUST NOT be empty. Build metadata MUST be ignored when determining
version precedence. Thus two versions that differ only in the build metadata,
have the same precedence. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3----117B344092BD.\nPrecedence refers to how versions are compared to each other when ordered.

    
      
        Precedence MUST be calculated by separating the version into major,
minor, patch and pre-release identifiers in that order (Build metadata
does not figure into precedence).
      
      
        Precedence is determined by the first difference when comparing each of
these identifiers from left to right as follows: Major, minor, and patch
versions are always compared numerically.

        Example: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        When major, minor, and patch are equal, a pre-release version has lower
precedence than a normal version:

        Example: 1.0.0-alpha < 1.0.0.
      
      
        Precedence for two pre-release versions with the same major, minor, and
patch version MUST be determined by comparing each dot separated identifier
from left to right until a difference is found as follows:

        
          
            Identifiers consisting of only digits are compared numerically.
          
          
            Identifiers with letters or hyphens are compared lexically in ASCII
sort order.
          
          
            Numeric identifiers always have lower precedence than non-numeric
identifiers.
          
          
            A larger set of pre-release fields has a higher precedence than a
smaller set, if all of the preceding identifiers are equal.
          
        

        Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPrecedence refers to how versions are compared to each other when ordered.\nPrecedence MUST be calculated by separating the version into major,
minor, patch and pre-release identifiers in that order (Build metadata
does not figure into precedence).\nPrecedence MUST be calculated by separating the version into major,
minor, patch and pre-release identifiers in that order (Build metadata
does not figure into precedence).\nPrecedence is determined by the first difference when comparing each of
these identifiers from left to right as follows: Major, minor, and patch
versions are always compared numerically.

        Example: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nPrecedence is determined by the first difference when comparing each of
these identifiers from left to right as follows: Major, minor, and patch
versions are always compared numerically.\nExample: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nWhen major, minor, and patch are equal, a pre-release version has lower
precedence than a normal version:

        Example: 1.0.0-alpha < 1.0.0.\nWhen major, minor, and patch are equal, a pre-release version has lower
precedence than a normal version:\nExample: 1.0.0-alpha < 1.0.0.\nPrecedence for two pre-release versions with the same major, minor, and
patch version MUST be determined by comparing each dot separated identifier
from left to right until a difference is found as follows:

        
          
            Identifiers consisting of only digits are compared numerically.
          
          
            Identifiers with letters or hyphens are compared lexically in ASCII
sort order.
          
          
            Numeric identifiers always have lower precedence than non-numeric
identifiers.
          
          
            A larger set of pre-release fields has a higher precedence than a
smaller set, if all of the preceding identifiers are equal.
          
        

        Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPrecedence for two pre-release versions with the same major, minor, and
patch version MUST be determined by comparing each dot separated identifier
from left to right until a difference is found as follows:\nIdentifiers consisting of only digits are compared numerically.\nIdentifiers consisting of only digits are compared numerically.\nIdentifiers with letters or hyphens are compared lexically in ASCII
sort order.\nIdentifiers with letters or hyphens are compared lexically in ASCII
sort order.\nNumeric identifiers always have lower precedence than non-numeric
identifiers.\nNumeric identifiers always have lower precedence than non-numeric
identifiers.\nA larger set of pre-release fields has a higher precedence than a
smaller set, if all of the preceding identifiers are equal.\nA larger set of pre-release fields has a higher precedence than a
smaller set, if all of the preceding identifiers are equal.\nExample: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nBackus–Naur Form Grammar for Valid SemVer Versions\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nWhy Use Semantic Versioning?\nThis is not a new or revolutionary idea. In fact, you probably do something
close to this already. The problem is that “close” isn’t good enough. Without
compliance to some sort of formal specification, version numbers are
essentially useless for dependency management. By giving a name and clear
definition to the above ideas, it becomes easy to communicate your intentions
to the users of your software. Once these intentions are clear, flexible (but
not too flexible) dependency specifications can finally be made.\nA simple example will demonstrate how Semantic Versioning can make dependency
hell a thing of the past. Consider a library called “Firetruck.” It requires a
Semantically Versioned package named “Ladder.” At the time that Firetruck is
created, Ladder is at version 3.1.0. Since Firetruck uses some functionality
that was first introduced in 3.1.0, you can safely specify the Ladder
dependency as greater than or equal to 3.1.0 but less than 4.0.0. Now, when
Ladder version 3.1.1 and 3.2.0 become available, you can release them to your
package management system and know that they will be compatible with existing
dependent software.\nAs a responsible developer you will, of course, want to verify that any
package upgrades function as advertised. The real world is a messy place;
there’s nothing we can do about that but be vigilant. What you can do is let
Semantic Versioning provide you with a sane way to release and upgrade
packages without having to roll new versions of dependent packages, saving you
time and hassle.\nIf all of this sounds desirable, all you need to do to start using Semantic
Versioning is to declare that you are doing so and then follow the rules. Link
to this website from your README so others know the rules and can benefit from
them.\nHow should I deal with revisions in the 0.y.z initial development phase?\nThe simplest thing to do is start your initial development release at 0.1.0
and then increment the minor version for each subsequent release.\nHow do I know when to release 1.0.0?\nIf your software is being used in production, it should probably already be
1.0.0. If you have a stable API on which users have come to depend, you should
be 1.0.0. If you’re worrying a lot about backward compatibility, you should
probably already be 1.0.0.\nDoesn’t this discourage rapid development and fast iteration?\nMajor version zero is all about rapid development. If you’re changing the API
every day you should either still be in version 0.y.z or on a separate
development branch working on the next major version.\nIf even the tiniest backward incompatible changes to the public API require a major version bump, won’t I end up at version 42.0.0 very rapidly?\nThis is a question of responsible development and foresight. Incompatible
changes should not be introduced lightly to software that has a lot of
dependent code. The cost that must be incurred to upgrade can be significant.
Having to bump major versions to release incompatible changes means you’ll
think through the impact of your changes, and evaluate the cost/benefit ratio
involved.\nDocumenting the entire public API is too much work!\nIt is your responsibility as a professional developer to properly document
software that is intended for use by others. Managing software complexity is a
hugely important part of keeping a project efficient, and that’s hard to do if
nobody knows how to use your software, or what methods are safe to call. In
the long run, Semantic Versioning, and the insistence on a well defined public
API can keep everyone and everything running smoothly.\nWhat do I do if I accidentally release a backward incompatible change as a minor version?\nAs soon as you realize that you’ve broken the Semantic Versioning spec, fix
the problem and release a new minor version that corrects the problem and
restores backward compatibility. Even under this circumstance, it is
unacceptable to modify versioned releases. If it’s appropriate,
document the offending version and inform your users of the problem so that
they are aware of the offending version.\nWhat should I do if I update my own dependencies without changing the public API?\nThat would be considered compatible since it does not affect the public API.
Software that explicitly depends on the same dependencies as your package
should have their own dependency specifications and the author will notice any
conflicts. Determining whether the change is a patch level or minor level
modification depends on whether you updated your dependencies in order to fix
a bug or introduce new functionality. We would usually expect additional code
for the latter instance, in which case it’s obviously a minor level increment.\nWhat if I inadvertently alter the public API in a way that is not compliant with the version number change (i.e. the code incorrectly introduces a major breaking change in a patch release)?\nUse your best judgment. If you have a huge audience that will be drastically
impacted by changing the behavior back to what the public API intended, then
it may be best to perform a major version release, even though the fix could
strictly be considered a patch release. Remember, Semantic Versioning is all
about conveying meaning by how the version number changes. If these changes
are important to your users, use the version number to inform them.\nHow should I handle deprecating functionality?\nDeprecating existing functionality is a normal part of software development and
is often required to make forward progress. When you deprecate part of your
public API, you should do two things: (1) update your documentation to let
users know about the change, (2) issue a new minor release with the deprecation
in place. Before you completely remove the functionality in a new major release
there should be at least one minor release that contains the deprecation so
that users can smoothly transition to the new API.\nDoes SemVer have a size limit on the version string?\nNo, but use good judgment. A 255 character version string is probably overkill,
for example. Also, specific systems may impose their own limits on the size of
the string.\nIs “v1.2.3” a semantic version?\nNo, “v1.2.3” is not a semantic version. However, prefixing a semantic version
with a “v” is a common way (in English) to indicate it is a version number.
Abbreviating “version” as “v” is often seen with version control. Example:
git tag v1.2.3 -m "Release version 1.2.3", in which case “v1.2.3” is a tag
name and the semantic version is “1.2.3”.\nIs there a suggested regular expression (RegEx) to check a SemVer string?\nThere are two. One with named groups for those systems that support them
(PCRE [Perl Compatible Regular Expressions, i.e. Perl, PHP and R], Python
and Go).\nSee: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nAnd one with numbered capture groups instead (so cg1 = major, cg2 = minor,
cg3 = patch, cg4 = prerelease and cg5 = buildmetadata) that is compatible
with ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
i.e. Perl, PHP and R), Python and Go.\nSee: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nThe Semantic Versioning specification was originally authored by Tom
Preston-Werner, inventor of Gravatar and
cofounder of GitHub.\nIf you’d like to leave feedback, please open an issue on
GitHub.\nopen an issue on
GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nالإدارة الدلالية لنُسخ البرمجيات 2.0.0

باختصار

بإعطاء الترقيم التالي ترقيع.بسيط.جذري أو كما يُعرف MAJOR.MINOR.PATCH لنُسخ البرمجيات، قم برفع درجة:


  ترقيم MAJOR (جذري) عند القيام بتغيرات جذرية غير متوافقة رجعيا للواجهة البرمجية (API)،
  ترقيم MINOR (بسيط) عند إضافة ميزات ووظائف جديدة لكن مُتوافقة رجعيًا، و
  ترقيم PATCH (ترقيع) عند القيام بإصلاحات للعلل والثغرات مُتوافقة رجعيًا.


الأوسمة الإضافية للنُسخ ما قبل النهائية (مثل: beta ،alpha …) والبيانات الوصفية لعمليات البناء والتجميع (build metadata) متوفرة كلواحق لصيغة MAJOR.MINOR.PATCH.

تمهيد

في عالم إدارة البرمجيات يتواجد هناك مكان مُفزع يُعرف بـ “جحيم الاعتماديات (dependency hell)”. كُلما كبُر نظامك وقمت بإدراج المزيد من الحزم في برمجيتك، كلما زاد احتمال أن تجد نفسك، يوما ما، في هاوية اليأس هذه.

في الأنظمة كثيرة الاعتماديات، إصدار نسخة جديدة من حزمة ما قد يتحول بشكل سريع إلى كابوس مُزعج. إذا كان وصف الاعتماديات في تلك الحزمة مُتشدّدًا جدًا، فإنك ستجد نفسك في مُواجهة خطر “قفل النُسخ” (version lock، أي عدم المقدرة على ترقية حزمة ما، دون الحاجة لإصدار نسخة جديدة من كل حزمة تعتمد عليها تلك الحزمة المُتشدّدة). أما في حال ما كان وصف الاعتماديات في تلك الحزمة مُتساهلا جدًا، فستجد نفسك -لا محالة- وقد تم لسعك بمُشكلة “انحلال النُسخ” (version promiscuity، أي فرط الإدّعاء بالتوافقية مع النسخ المُستقبلية بشكل يتجاوز الحد المعقول). جحيم الاعتماديات يكون عندما يمنعك قفل النُّسخ و/أو انحلال النُّسخ من المُضيّ قُدُما في مشروعك بسهولة وأمان.

كحل لهذه المعضلة، أَقترحُ بضعة قواعد ومتطلبات بسيطة من شأنها إملاء كيفية إسناد ترقيم لنُسخ البرمجيات وكيفية رفع درجة الترقيم.

هذه القواعد تعتمد -لكن ليس بالضرورة بشكل حصري- على الممارسات الشائعة الموجودة مُسبقا في كل من البرمجيات المفتوحة ومغلقة المصدر. وحتى يعمل هذا النظام، عليك أولا أن نُفصِح عن واجهة برمجية (API) للعامة (أي أن تقوم بنشرها ظاهرة)، قد تكون هذه الأخيرة عبارة عن مُجرد توثيق أو معززة بالشفرة المصدرية نفسها. أيًا كان الوضع، فإنه من المُهمّ أن تكون هذه الواجهة البرمجية واضحة ودقيقة. بمُجرد تحديد واجهتك البرمجية المٌُوجّهة للعامة (أي الظاهرة للعيان)، ستُشير إلى التغيّيرات التي تحصل عليها عن طريق رفع درجة ترقيم النسخة الحالية منها بشكل معين. تَبنّى صيغة ترقيم من الشكل X.Y.Z (أي Major.Minor.Patch). إصلاحات العِلل التي لا تؤثر على سير عمل الواجهة البرمجية تستوجب رفع درجة ترقيم “ترقيع” (patch)، التعديلات/الإضافات المُتوافقة رجعيًا على الواجهة البرمجية ترفع درجة ترقيم “بسيط” (minor)، أما التعديلات غير المتوافقة رجعيًا على الواجهة البرمجية تستوجب رفع درجة ترقيم “جذري” (major).

أُسمّي هذا الأمر  بـ”الإدارة الدلالية لنُسخ البرمجيات” (Semantic Versioning واختصارًا SemVer). باتّباع هذا النمط، فإن أرقام نُسخ البرمجيات وطريقة الترقيم ستُضفي معنًى يدُلّ على الشفرة المصدرية ومدى التغيرات الحاصلة من نسخة إلى النسخة التي تليها.

مُواصفات الإدارة الدلالية لنُسخ البرمجيات (SemVer)
الكلمات المفتاحية: يجب (MUST)، يجب أن لا (MUST NOT)، يتطلّب (REQUIRED)، ينبغي (SHALL)، ينبغي أن لا (SHALL NOT)، يجدُر (SHOULD)، يجدر أن لا (SHOULD NOT), مُستحسن (RECOMMENDED)، قد (MAY)، و اختياري (OPTIONAL) في هذه الوثيقة تُحمَل على نفس التأويل المُوَضّح في RFC 2119.


  
    البرمجيات التي تعتمد الإدارة الدلالية للنُّسخ يجب أن تُصرّح بواجهة برمجية (API) عامة. قد تكون هذه الواجهة البرمجية عبارة عن الشفرة المصدرية بحد ذاتها، أو أن وجودها محصورٌ في التوثيق. أيًا كان الأمر، فإنه يجدر بها أن تكون دقيقة ومفهومة.
  
  
    الترقيم الطبيعي للنُّسخ يجب أن يكون من الشكل X.Y.Z حيث X ،Y و Z عبارة عن أعداد صحيحة غير سالبة، و يجب أن لا تحتوي على أصفار بادئة. X يُشير إلى ترقيم جذري (Major)، أما Y إلى ترقيم بسيط (Minor)، و Z إلى ترقيم ترقيع. كل جزء من الترقيم يجب أن يتم رفعه عدديا بدرجة. على سبيل المثال: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    بمُجرّد إصدار نسخة جديدة من حزمة مُعيّنة بترقيم مُعيّن، يجب أن لا يُغيَّر محتوى تلك الحزمة. كل تغيير يتم إجراؤه عليها يجب أن يتم تصديره كنُسخة جديدة بترقيم مُغاير ومُناسب.
  
  
    الترقيم الجذري المُصفّر -(Major version zero (0.y.z- يُمثّل مرحلة التطوير الأوّلية. قد يتغير أي شيء في أي وقت. يجب أن لا تُعتبر الواجهة البرمجية (API) العامة-في هذه المرحلة- مُستقرة.
  
  
    النسخة 1.0.0 تُعرّف الواجهة البرمجية العامة. طريقة رفع درجات الترقيم بعد هذه الإصدارة يعتمد على الواجهة البرمجية العامة نفسها وطريقة إجراء التغييرات عليها.
  
  
    ترقيم الترقيع Z (أي x.y.Z بحيث x > 0) يجب أن تُرفع درجته فقط في حالة إدخال إصلاحات للعِلل مُتوافقة رجعيا، والمتمثلة في الإصلاحات الداخلية التي تُصحّح سُلوكًا غيرَ سويّ للبرمجية.
  
  
    ترقيم “بسيط” Y (أي x.Y.z بحيث x > 0) يجب أن تُرفع درجته إذا تم إدخال وظائف جديدة مُتوافقة رجعيًا للواجهة البرمجية العامة. ويجب أيضا رفع درجته في حال تم التخلي عن وظيفة ما (deprecating functionality) في الواجهة البرمجية العامة. قد يتم رفع درجته في حال تم إضافة وظيفية جوهرية أو تحسينات جديدة على نطاق خاص في الشفرة المصدرية. وقد يحتوي على تغييرات ترقيعية (Patch). ترقيم الترقيع (Patch) يجب أن يتم تصفيره (إرجاع قيمته إلى 0) عند رفع درجة ترقيم “بسيط” (Minor).
  
  
    ترقيم “جذري” X (أي X.y.z بحيث X > 0) يجب أن يتم رفع درجته في حال تم إدخال تغييرات غير متوافقة رجعيًا على الواجهة البرمجية العامة. قد يحتوي على تغييرات “ترقيعية” و “بسيطة”. يجب تصفير كل من ترقيم “بسيط” (Minor) وترقيم “ترقيع” (Patch) (أي إرجاع قيمتهما إلى 0) عند رفع درجة ترقيم “جذري” (Major).
  
  
    النُسخ المُعدّة لما قبل الإصدار قد يتم توسيمها بوصلة ‘-‘ تليها نقاط إضافية يُفصل بينها بمُعرّفات، وذلك مباشرة بعد ترقيم الترقيع (patch). يجب على هذه المُعرّفات أن تكون مكوّنة فقط من هجائيات عددية (alphanumerics) ووصلات ‘-‘ من ترميز ASCII وفقط، أي [0-9 A-Z a-z-]. يجب أن لا تكون هذه المُعرّفات فارغة. يجب أن لا تحتوي المعرفات الرقمية على أصفار بادئة. النُّسخ المُعدّة لما قبل الإصدار لها أولوية أقل من النسخ العادية المُصاحبة لها. النُّسخ المُعدّة لما قبل الإصدار تعني أنها نسخة غير مُستقرة وقد لا تُلبي التوافقية المرجوة منها كما هو مُشار إليه في الترقيم الطبيعي للنسخة المصاحبة لها. أمثلة:
1.0.0-alpha,  1.0.0-alpha.1,   1.0.0-0.3.7,   1.0.0-x.7.z.92
  
  
    البيانات الوصفية لعمليات البناء والتجميع (build metadata) قد يتم تعليمها عن طريق إضافة علامة زائد (+) و سلسلة من المُعرّفات مفصول بينها بنقاط، وذلك مُباشرة بعد ترقيم ترقيع (Patch) أو ترقيم النُسخ ما قبل النهائية (مثل: beta ،alpha …). يجب على البيانات الوصفية هذه أن لا تحتوى سوى على هجائيات عددية من ترميز ASCII ووصلة - وفقط، أي: [0-9A-Za-z-]. يجب أن لا تكون هذه المعرّفات فارغة.  يجدر إهمال ترقيم البيانات الوصفية لعميات البناء والتجميع عند تحديد أفضلية النُسخ. بالتالي، يُعتبر وجود نسختين مُختلفتين فقط في ترقيم البيانات الوصفية أن لهما نفس الأفضلية. أمثلة: 1.0.0-alpha+001,  1.0.0+20130313144700,   1.0.0-beta+exp.sha.5114f85
  
  
    الأفضلية تُشير إلى كيفية المُقارنة بين النُسخ عند ترتيبها. يجب أن يتم حساب الأفضلية عن طريق تقسيم ترقيم النُّسخ إلى ترقيع، بسيط، جذري ثم مُعرفات النسخ ما قبل النهائية (alpha, beta) مع احترام هذا الترتيب (البيانات الوصفية لا تظهر في الأفضلية). يتم تحديد الأفضلية عن طريق أول اختلاف يظهر عند المقارنة بين هذه المعرّفات من اليسار إلى اليمين على النحو التالي: تتم دائما المقارنة بين جذري، بسيط وترقيع عدديا، مثال: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. في حال تساوى ترقيم جذري، بسيط وترقيع، يتم احتساب ترقيم النسخ ما قبل النهائية (alpha, beta) على أن لها أفضلية أقل من النسخ العادية، مثال:  1.0.0 > 1.0.0-alpha . في حال تساوت النُسخ ما قبل النهائية بنفس ترقيم جذري، بسيط، ترقيع، يجب حساب الأفضلية عن طريق المقارنة بين المعرفات المفصول بينها بنقاط من اليسار إلى اليمين إلى غاية العثور على اختلاف، وذلك على النحو التالي: المعرفات المُكونة من أرقام فقط تتم مقارنتها عدديا، والمُعرّفات المُكوّنة من أحرف ووصلة (-) تتم مقارنتها أبجديًا وفق ترتيب ASCII. المُعرّفات الرقمية لها دائما أفضلية أقل من المعرفات غير العددية. كلما امتدت حقول النُّسخ ما قبل النهائية كلما زادت أفضليتها عن النّسخ ذوات حقول أقل إذا تساوت جميع المعرفات السابقة. مثال:
1.0.0 > 1.0.0-rc.1 > 1.0.0-beta.11 > 1.0.0-beta.2 > 1.0.0-beta > 1.0.0-alpha.beta > 1.0.0-alpha.1 > 1.0.0-alpha 
  


لماذا يجب استعمال الإدارة الدلالية لنُسخ البرمجيات ؟
هذه ليست فكرة جديدة أو ثورية. في الحقيقة، ربما تقوم حاليًا بشيء مُشابه لهذا الأمر. المُشكل أن هذا “الشبه” ليس جيدًا بما فيه الكفاية. من دون الامتثال إلى نوع من المُواصفات الرسمية، فإن ترقيم النسخ سيكون أساسًا من دون فائدة لإدارة الاعتماديات. بإعطاء اسم وتعريف واضح للأفكار المُقَدَمة أعلاه، سيُصبح من السهل إخطار مستخدمي برمجيتك بنواياك. بمُجرد أن تصبح هذه النوايا واضحة، سيكون من المُمكن أخيرًا وضع مُواصفات مرنة للاعتماديات (لكنها ليست بالغة المرونة).

مثال بسيط سيُوضّح كيف يُمكن للإدارة الدلالية لنُسخ البرمجيات أن تجعل من “جحيم الاعتماديات” شيئًا من الماضي. لنفرض أن هناك مكتبة برمجية تحمل الاسم “شاحنة الإطفاء”. تتطلّب هذه المكتبة حزمة برمجية تحمل الاسم “سُلّم” يتم إدارة نُسخها دلاليًا. في الوقت الذي تم فيه إنشاء مكتبة شاحنة الإطفاء، كانت حزمة سُلّم في نسختها 3.1.0. بما أن شاحنة الإطفاء تستعمل بعض الوظائف التي تم إدخالها أول مرة في النسخة 3.1.0، فإنه بإمكانك أن تُحدّد اعتمادية سُلّم لتكون أكبر من أو تُساوي 3.1.0 وأقل من 4.0.0 بكل أمان. الآن، عند إصدار النُسَخ 3.1.1 و 3.2.0 من حزمة سُلّم، يُمكنك نشرها في نظام إدارة الحزم خاصتك وأنت تعلم أنها مُتوافقة مع البرمجيات الحالية التي تعتمد عليها.

بصفتك مُطورًا مسؤولا، سيتوجّب عليك أن تتحقّق من أن كل عملية ترقية لحزمة مُعيّنة تعمل كما تم الإشهار لها. العالم الحقيقي مكان فوضوي، لا يوجد ما يمكننا فعله حيال ذلك سوى أن نكون يقظين. ما يمكنك فعله هو أن تنتهج طريقا بواسطة الإدارة الدلالية لنُسخ البرمجيات (Semantic Versioning)  يسمح لك بإصدار وترقية الحزم من دون الحاجة لإصدار نُسخ جديدة من الحزم الأخرى المُعتمد عليها بكل رزانة، حافظًا لوقتك ومُتجنبًا لجميع المتاعب.

إذا بدى لك كل هذا الأمر مُحبّذًا، فإن كل ما تحتاج لفعله للبدء في استعمال الإدارة الدلالية لنُسخ البرمجيات هو أن تعلن أنك ستمتثل وتتّبع قواعدها. أشر إلى هذا الموقع في ملف README الخاص بمشروعك حتى يعلم البقية بهذه القواعد وتُمكّنهم من الاستفادة منها.

الأسئلة الأكثر شيوعًا

كيف يجدر بي التعامل مع مُراجعات O.y.z عند بداية مرحلة التطوير الأوّلية؟

أبسط شيء يُمكن القيام به هو أن تستهلّ مرحلة التطوير الأولية بإصدار النسخة 0.1.0 ثم ترفع درجة ترقيم “بسيط” (Minor) بعد كل إصدارة تليها.

متى أعرف أنه حان وقت إصدار النسخة 1.0.0؟

إذا كان يتم استخدام برمجيتك بشكل فعلي في خدمة زبائن حقيقيين من طرف جهة مُعيّنة، فعلى الأرجح أنه قد حان وقت ترقيمها بالنسخة 1.0.0. إذا كنت تملك واجهة برمجية مُستقرة بحيث يجري الاعتماد عليها من طرف مستخدمين لها، فإنه يجب إذًا أن تكون 1.0.0. إذا كنت من الحريصين جدًا على التوافقية الرجعية، فأغلب الظن أنه قد حان فعلا وقت النسخة 1.0.0.

ألا يُثبّط هذا من عمليات التطوير المُتسارعة والتكرارية؟

الغرض من وجود النسخة الجذرية المصفّرة (Major version zero) هو عمليات التطوير السريعة. إذا كنت تغيّر من الواجهة البرمجية كل يوم، فإنه يجدر بك إما أن تبقى عند الترقيم O.y.z أو أن تكون في فرع تطوير مُنفصل (branch) تعمل فيه على النسخة الجذرية القادمة.

إذا كان حتى أصغر تغيير غير مُتوافق رجعيا للواجهة البرمجية العامة يتطلب رفع ترقيم جذري، ألن يقودَني ذلك إلى النسخة 42.0.0 بسرعة فائقة؟

هذا السؤال له علاقة بمسؤولية التطوير وبُعد النظر، لا يجدر بالتغييرات غير المتوافقة رجعيًا أن يتم إدخالها بهذه السرعة على البرمجيات التي يتم الاعتماد على شفرتها. ستكون التكلفة التي تتكبدها عملية الترقية مُعتبرة. وجوب رفع ترقيم النسخ الجذرية لإصدار تغييرات غير متوافقة يعني أنك ستفكر في عواقب هذه التغييرات، وتوزان بين نسبة المصلحة/التكلفة التي تنجرّ عنها.

عملية التوثيق الكامل للواجهة البرمجية (API) تُعتبر عملا مُنهكا!

من مسؤولياتك كمُطور مُحترف أن توثّق بشكل صحيح البرمجية المُوجّهة للاستعمال من قِبَل مُستخدمين آخرين. إدارة تعقيد البرمجيات هو جزء بالغ الأهمية للحفاظ على كفاءة المشروع، وهذا شيء صعبٌ القيامُ به إن لم يكن هناك أي شخص على علم بكيفية استعمال برمجيتك، أو بالوظائف التي يُمكن استدعاؤها بأمان. على المدى البعيد، ستُمكّن الإدارة الدلالية والإصرار على وجود واجهة برمجية عامة واضحة المعالم من الإبقاء على السير الحسن للأمور عند الجميع.

ماذا يتوجب عليَّ فعله عندما أُصدر عن طريق الخطأ نسخةً بتغييرات غير مُتوافقة رجعيًا كنُسخة ترقيعية (Minor version)؟

بمُجرد إدراكك بأنك قمت بنقض مُواصفات الإدارة الدلالية، قم بإصلاح المُشكل ثم قم بإصدار نسخة بسيطة جديدة (Minor) تُصلح العلة وتقوم بإرجاع التوافقية الرجعية. حتى تحت هذا الظرف، فإنه من غير المقبول أن تُغيّر من النُسخ التي تم إصدارها مُسبقا. قم بتوثيق النُسخة المُخالفة إذا كان ذلك مُلائما، وأخبر المُستخدمين بالمُشكلة حتى يكونوا على علم بالنُسخة المُخالفة.

ما يتوجب علي فعله عندما أحدّث الاعتماديات الخاصة بي دون تغيير الواجهة البرمجية العامة.

سيُعتبر هذا على الأرجح أنه تغيير مُتوافق رجعيًا حيث أنه لا يَمَس الواجهة البرمجية العامة. يجدر بالبرمجيات التي تعتمد صراحة على نفس الاعتماديات التي تعتمد عليها حزمتك أن تتبع مُواصفات اعتماديات خاصة بها وأن ينتبه المُؤلف الأصلي لها لأي تضارب قد يحصل. تحديد ما إذا كانت هذه التغيرات بمثابة ترقيع أو بسيط يعتمد على ما إذا قمت بتحديث اعتمادياتك لتصحيح علة مُعيّنة أو لإدخال وظيفة جديدة. غالبًا ما أتوقع إضافة شفرة برمجية بالنسبة للحالة الثانية (إدخال وظيفة جديدة)، وبالتالي سيكون هذا الأمر بطبيعة الحال بمثابة تغيير يتطلب رفع ترقيم بسيط.

ماذا لو قمت عن غير قصد بتغيير الواجهة البرمجية العامة بطريقة لا تتماشى مع ترقيم النسخة (مثال: الشفرة تُدخِل عن طريق الخطأ تغييرات جذرية تكسر التوافقية الرجعية في إصدارة ترقيعية patch)

اجتهد واحكم بنفسك، إذا كنت تملك جمهورًا غفيرًا سيتأثر بشكل كبير لو قمت بإرجاع الواجهة البرمجية العامة إلى سابق حالها كما كان مقصودًا، فسيكون حينئذ من الأفضل إصدار نسخة جذرية جديدة، حتى ولو تم اعتبار الإصلاح على أنه فقط إصدارة ترقيعية. تذكّر دائما أن هدف الإدارة الدلالية هو إضفاء معنىً حول التغييرات الحاصلة عن طريق كيفية تغيير ترقيم النُّسخ. إذا كانت هذه التغييرات ذات أهمية عند مُستخدمي برمجيتك، فاستعمل ترقيم النُسخ لإعلامهم بذلك.

ماذا عن الوظائف المُتخلى عنها (deprecating functionality) ؟

التخلّي عن وظيفة موجودة مُسبقا شيء طبيعي في تطوير البرمجيات، بل يُعتبر أحيانا خطوة لابد منها للمُضي قُدما. عندما تتخلّى عن إحدى الوظائف في الواجهة البرمجية العامة، فإنه يجب عليك القيام بأمرين: (1) قم بتحديث التوثيق حتى يعلم بقية المُستخدمين بهذا التغيير، (2) أصدر نسخة بسيطة (Minor) جديدةً تحتوي على الوظيفة المُتخلى عنها. قبل حذف الوظيفة نهائيًا في نسخة جذرية (Major). يجب على الأقل أن تكون هناك نسخة بسيطة تحتوي على الوظيفة المُتخلى عنها حتى تُمكّن المستخدمين من الانتقال السلِس إلى الواجهة البرمجية الجديدة.

هل يفرض semver حدًا مُعينًا لطول السلسلة النصية عند ترقيم النُّسخ ؟

لا، لكن اجتهد وأحسن التقدير. استعمال 255 حرفا على سبيل المثال في ترقيم نسخة ما قد يكون أمرًا مُبالغًا فيه. تذكّر أيضًا بأن بعض المنصّات تضع حدًا لطول السلسة النصية.

نُبذة

مُواصفات الإدارة الدلالية لنُسخ البرمجيات من تأليف Tom
Preston-Werner, مُبتكر خدمة Gravatars وأحد مؤسسي GitHub.

لديك اقتراح؟ يُرجى فتح “خطب” على
GitHub.

الرُخصة

المشاع الإبداعي ― CC BY 3.0\nالإدارة الدلالية لنُسخ البرمجيات 2.0.0\nبإعطاء الترقيم التالي ترقيع.بسيط.جذري أو كما يُعرف MAJOR.MINOR.PATCH لنُسخ البرمجيات، قم برفع درجة:\nترقيم MAJOR (جذري) عند القيام بتغيرات جذرية غير متوافقة رجعيا للواجهة البرمجية (API)،\nترقيم MINOR (بسيط) عند إضافة ميزات ووظائف جديدة لكن مُتوافقة رجعيًا، و\nترقيم PATCH (ترقيع) عند القيام بإصلاحات للعلل والثغرات مُتوافقة رجعيًا.\nالأوسمة الإضافية للنُسخ ما قبل النهائية (مثل: beta ،alpha …) والبيانات الوصفية لعمليات البناء والتجميع (build metadata) متوفرة كلواحق لصيغة MAJOR.MINOR.PATCH.\nفي عالم إدارة البرمجيات يتواجد هناك مكان مُفزع يُعرف بـ “جحيم الاعتماديات (dependency hell)”. كُلما كبُر نظامك وقمت بإدراج المزيد من الحزم في برمجيتك، كلما زاد احتمال أن تجد نفسك، يوما ما، في هاوية اليأس هذه.\nفي الأنظمة كثيرة الاعتماديات، إصدار نسخة جديدة من حزمة ما قد يتحول بشكل سريع إلى كابوس مُزعج. إذا كان وصف الاعتماديات في تلك الحزمة مُتشدّدًا جدًا، فإنك ستجد نفسك في مُواجهة خطر “قفل النُسخ” (version lock، أي عدم المقدرة على ترقية حزمة ما، دون الحاجة لإصدار نسخة جديدة من كل حزمة تعتمد عليها تلك الحزمة المُتشدّدة). أما في حال ما كان وصف الاعتماديات في تلك الحزمة مُتساهلا جدًا، فستجد نفسك -لا محالة- وقد تم لسعك بمُشكلة “انحلال النُسخ” (version promiscuity، أي فرط الإدّعاء بالتوافقية مع النسخ المُستقبلية بشكل يتجاوز الحد المعقول). جحيم الاعتماديات يكون عندما يمنعك قفل النُّسخ و/أو انحلال النُّسخ من المُضيّ قُدُما في مشروعك بسهولة وأمان.\nكحل لهذه المعضلة، أَقترحُ بضعة قواعد ومتطلبات بسيطة من شأنها إملاء كيفية إسناد ترقيم لنُسخ البرمجيات وكيفية رفع درجة الترقيم.\nهذه القواعد تعتمد -لكن ليس بالضرورة بشكل حصري- على الممارسات الشائعة الموجودة مُسبقا في كل من البرمجيات المفتوحة ومغلقة المصدر. وحتى يعمل هذا النظام، عليك أولا أن نُفصِح عن واجهة برمجية (API) للعامة (أي أن تقوم بنشرها ظاهرة)، قد تكون هذه الأخيرة عبارة عن مُجرد توثيق أو معززة بالشفرة المصدرية نفسها. أيًا كان الوضع، فإنه من المُهمّ أن تكون هذه الواجهة البرمجية واضحة ودقيقة. بمُجرد تحديد واجهتك البرمجية المٌُوجّهة للعامة (أي الظاهرة للعيان)، ستُشير إلى التغيّيرات التي تحصل عليها عن طريق رفع درجة ترقيم النسخة الحالية منها بشكل معين. تَبنّى صيغة ترقيم من الشكل X.Y.Z (أي Major.Minor.Patch). إصلاحات العِلل التي لا تؤثر على سير عمل الواجهة البرمجية تستوجب رفع درجة ترقيم “ترقيع” (patch)، التعديلات/الإضافات المُتوافقة رجعيًا على الواجهة البرمجية ترفع درجة ترقيم “بسيط” (minor)، أما التعديلات غير المتوافقة رجعيًا على الواجهة البرمجية تستوجب رفع درجة ترقيم “جذري” (major).\nأُسمّي هذا الأمر  بـ”الإدارة الدلالية لنُسخ البرمجيات” (Semantic Versioning واختصارًا SemVer). باتّباع هذا النمط، فإن أرقام نُسخ البرمجيات وطريقة الترقيم ستُضفي معنًى يدُلّ على الشفرة المصدرية ومدى التغيرات الحاصلة من نسخة إلى النسخة التي تليها.\nمُواصفات الإدارة الدلالية لنُسخ البرمجيات (SemVer)\nالكلمات المفتاحية: يجب (MUST)، يجب أن لا (MUST NOT)، يتطلّب (REQUIRED)، ينبغي (SHALL)، ينبغي أن لا (SHALL NOT)، يجدُر (SHOULD)، يجدر أن لا (SHOULD NOT), مُستحسن (RECOMMENDED)، قد (MAY)، و اختياري (OPTIONAL) في هذه الوثيقة تُحمَل على نفس التأويل المُوَضّح في RFC 2119.\nالبرمجيات التي تعتمد الإدارة الدلالية للنُّسخ يجب أن تُصرّح بواجهة برمجية (API) عامة. قد تكون هذه الواجهة البرمجية عبارة عن الشفرة المصدرية بحد ذاتها، أو أن وجودها محصورٌ في التوثيق. أيًا كان الأمر، فإنه يجدر بها أن تكون دقيقة ومفهومة.\nالبرمجيات التي تعتمد الإدارة الدلالية للنُّسخ يجب أن تُصرّح بواجهة برمجية (API) عامة. قد تكون هذه الواجهة البرمجية عبارة عن الشفرة المصدرية بحد ذاتها، أو أن وجودها محصورٌ في التوثيق. أيًا كان الأمر، فإنه يجدر بها أن تكون دقيقة ومفهومة.\nالترقيم الطبيعي للنُّسخ يجب أن يكون من الشكل X.Y.Z حيث X ،Y و Z عبارة عن أعداد صحيحة غير سالبة، و يجب أن لا تحتوي على أصفار بادئة. X يُشير إلى ترقيم جذري (Major)، أما Y إلى ترقيم بسيط (Minor)، و Z إلى ترقيم ترقيع. كل جزء من الترقيم يجب أن يتم رفعه عدديا بدرجة. على سبيل المثال: 1.9.0 -> 1.10.0 -> 1.11.0.\nالترقيم الطبيعي للنُّسخ يجب أن يكون من الشكل X.Y.Z حيث X ،Y و Z عبارة عن أعداد صحيحة غير سالبة، و يجب أن لا تحتوي على أصفار بادئة. X يُشير إلى ترقيم جذري (Major)، أما Y إلى ترقيم بسيط (Minor)، و Z إلى ترقيم ترقيع. كل جزء من الترقيم يجب أن يتم رفعه عدديا بدرجة. على سبيل المثال: 1.9.0 -> 1.10.0 -> 1.11.0.\nبمُجرّد إصدار نسخة جديدة من حزمة مُعيّنة بترقيم مُعيّن، يجب أن لا يُغيَّر محتوى تلك الحزمة. كل تغيير يتم إجراؤه عليها يجب أن يتم تصديره كنُسخة جديدة بترقيم مُغاير ومُناسب.\nبمُجرّد إصدار نسخة جديدة من حزمة مُعيّنة بترقيم مُعيّن، يجب أن لا يُغيَّر محتوى تلك الحزمة. كل تغيير يتم إجراؤه عليها يجب أن يتم تصديره كنُسخة جديدة بترقيم مُغاير ومُناسب.\nالترقيم الجذري المُصفّر -(Major version zero (0.y.z- يُمثّل مرحلة التطوير الأوّلية. قد يتغير أي شيء في أي وقت. يجب أن لا تُعتبر الواجهة البرمجية (API) العامة-في هذه المرحلة- مُستقرة.\nالترقيم الجذري المُصفّر -(Major version zero (0.y.z- يُمثّل مرحلة التطوير الأوّلية. قد يتغير أي شيء في أي وقت. يجب أن لا تُعتبر الواجهة البرمجية (API) العامة-في هذه المرحلة- مُستقرة.\nالنسخة 1.0.0 تُعرّف الواجهة البرمجية العامة. طريقة رفع درجات الترقيم بعد هذه الإصدارة يعتمد على الواجهة البرمجية العامة نفسها وطريقة إجراء التغييرات عليها.\nالنسخة 1.0.0 تُعرّف الواجهة البرمجية العامة. طريقة رفع درجات الترقيم بعد هذه الإصدارة يعتمد على الواجهة البرمجية العامة نفسها وطريقة إجراء التغييرات عليها.\nترقيم الترقيع Z (أي x.y.Z بحيث x > 0) يجب أن تُرفع درجته فقط في حالة إدخال إصلاحات للعِلل مُتوافقة رجعيا، والمتمثلة في الإصلاحات الداخلية التي تُصحّح سُلوكًا غيرَ سويّ للبرمجية.\nترقيم الترقيع Z (أي x.y.Z بحيث x > 0) يجب أن تُرفع درجته فقط في حالة إدخال إصلاحات للعِلل مُتوافقة رجعيا، والمتمثلة في الإصلاحات الداخلية التي تُصحّح سُلوكًا غيرَ سويّ للبرمجية.\nترقيم “بسيط” Y (أي x.Y.z بحيث x > 0) يجب أن تُرفع درجته إذا تم إدخال وظائف جديدة مُتوافقة رجعيًا للواجهة البرمجية العامة. ويجب أيضا رفع درجته في حال تم التخلي عن وظيفة ما (deprecating functionality) في الواجهة البرمجية العامة. قد يتم رفع درجته في حال تم إضافة وظيفية جوهرية أو تحسينات جديدة على نطاق خاص في الشفرة المصدرية. وقد يحتوي على تغييرات ترقيعية (Patch). ترقيم الترقيع (Patch) يجب أن يتم تصفيره (إرجاع قيمته إلى 0) عند رفع درجة ترقيم “بسيط” (Minor).\nترقيم “بسيط” Y (أي x.Y.z بحيث x > 0) يجب أن تُرفع درجته إذا تم إدخال وظائف جديدة مُتوافقة رجعيًا للواجهة البرمجية العامة. ويجب أيضا رفع درجته في حال تم التخلي عن وظيفة ما (deprecating functionality) في الواجهة البرمجية العامة. قد يتم رفع درجته في حال تم إضافة وظيفية جوهرية أو تحسينات جديدة على نطاق خاص في الشفرة المصدرية. وقد يحتوي على تغييرات ترقيعية (Patch). ترقيم الترقيع (Patch) يجب أن يتم تصفيره (إرجاع قيمته إلى 0) عند رفع درجة ترقيم “بسيط” (Minor).\nترقيم “جذري” X (أي X.y.z بحيث X > 0) يجب أن يتم رفع درجته في حال تم إدخال تغييرات غير متوافقة رجعيًا على الواجهة البرمجية العامة. قد يحتوي على تغييرات “ترقيعية” و “بسيطة”. يجب تصفير كل من ترقيم “بسيط” (Minor) وترقيم “ترقيع” (Patch) (أي إرجاع قيمتهما إلى 0) عند رفع درجة ترقيم “جذري” (Major).\nترقيم “جذري” X (أي X.y.z بحيث X > 0) يجب أن يتم رفع درجته في حال تم إدخال تغييرات غير متوافقة رجعيًا على الواجهة البرمجية العامة. قد يحتوي على تغييرات “ترقيعية” و “بسيطة”. يجب تصفير كل من ترقيم “بسيط” (Minor) وترقيم “ترقيع” (Patch) (أي إرجاع قيمتهما إلى 0) عند رفع درجة ترقيم “جذري” (Major).\nالنُسخ المُعدّة لما قبل الإصدار قد يتم توسيمها بوصلة ‘-‘ تليها نقاط إضافية يُفصل بينها بمُعرّفات، وذلك مباشرة بعد ترقيم الترقيع (patch). يجب على هذه المُعرّفات أن تكون مكوّنة فقط من هجائيات عددية (alphanumerics) ووصلات ‘-‘ من ترميز ASCII وفقط، أي [0-9 A-Z a-z-]. يجب أن لا تكون هذه المُعرّفات فارغة. يجب أن لا تحتوي المعرفات الرقمية على أصفار بادئة. النُّسخ المُعدّة لما قبل الإصدار لها أولوية أقل من النسخ العادية المُصاحبة لها. النُّسخ المُعدّة لما قبل الإصدار تعني أنها نسخة غير مُستقرة وقد لا تُلبي التوافقية المرجوة منها كما هو مُشار إليه في الترقيم الطبيعي للنسخة المصاحبة لها. أمثلة:
1.0.0-alpha,  1.0.0-alpha.1,   1.0.0-0.3.7,   1.0.0-x.7.z.92\nالنُسخ المُعدّة لما قبل الإصدار قد يتم توسيمها بوصلة ‘-‘ تليها نقاط إضافية يُفصل بينها بمُعرّفات، وذلك مباشرة بعد ترقيم الترقيع (patch). يجب على هذه المُعرّفات أن تكون مكوّنة فقط من هجائيات عددية (alphanumerics) ووصلات ‘-‘ من ترميز ASCII وفقط، أي [0-9 A-Z a-z-]. يجب أن لا تكون هذه المُعرّفات فارغة. يجب أن لا تحتوي المعرفات الرقمية على أصفار بادئة. النُّسخ المُعدّة لما قبل الإصدار لها أولوية أقل من النسخ العادية المُصاحبة لها. النُّسخ المُعدّة لما قبل الإصدار تعني أنها نسخة غير مُستقرة وقد لا تُلبي التوافقية المرجوة منها كما هو مُشار إليه في الترقيم الطبيعي للنسخة المصاحبة لها. أمثلة:
1.0.0-alpha,  1.0.0-alpha.1,   1.0.0-0.3.7,   1.0.0-x.7.z.92\n1.0.0-alpha,  1.0.0-alpha.1,   1.0.0-0.3.7,   1.0.0-x.7.z.92\nالبيانات الوصفية لعمليات البناء والتجميع (build metadata) قد يتم تعليمها عن طريق إضافة علامة زائد (+) و سلسلة من المُعرّفات مفصول بينها بنقاط، وذلك مُباشرة بعد ترقيم ترقيع (Patch) أو ترقيم النُسخ ما قبل النهائية (مثل: beta ،alpha …). يجب على البيانات الوصفية هذه أن لا تحتوى سوى على هجائيات عددية من ترميز ASCII ووصلة - وفقط، أي: [0-9A-Za-z-]. يجب أن لا تكون هذه المعرّفات فارغة.  يجدر إهمال ترقيم البيانات الوصفية لعميات البناء والتجميع عند تحديد أفضلية النُسخ. بالتالي، يُعتبر وجود نسختين مُختلفتين فقط في ترقيم البيانات الوصفية أن لهما نفس الأفضلية. أمثلة: 1.0.0-alpha+001,  1.0.0+20130313144700,   1.0.0-beta+exp.sha.5114f85\nالبيانات الوصفية لعمليات البناء والتجميع (build metadata) قد يتم تعليمها عن طريق إضافة علامة زائد (+) و سلسلة من المُعرّفات مفصول بينها بنقاط، وذلك مُباشرة بعد ترقيم ترقيع (Patch) أو ترقيم النُسخ ما قبل النهائية (مثل: beta ،alpha …). يجب على البيانات الوصفية هذه أن لا تحتوى سوى على هجائيات عددية من ترميز ASCII ووصلة - وفقط، أي: [0-9A-Za-z-]. يجب أن لا تكون هذه المعرّفات فارغة.  يجدر إهمال ترقيم البيانات الوصفية لعميات البناء والتجميع عند تحديد أفضلية النُسخ. بالتالي، يُعتبر وجود نسختين مُختلفتين فقط في ترقيم البيانات الوصفية أن لهما نفس الأفضلية. أمثلة: 1.0.0-alpha+001,  1.0.0+20130313144700,   1.0.0-beta+exp.sha.5114f85\n1.0.0-alpha+001,  1.0.0+20130313144700,   1.0.0-beta+exp.sha.5114f85\nالأفضلية تُشير إلى كيفية المُقارنة بين النُسخ عند ترتيبها. يجب أن يتم حساب الأفضلية عن طريق تقسيم ترقيم النُّسخ إلى ترقيع، بسيط، جذري ثم مُعرفات النسخ ما قبل النهائية (alpha, beta) مع احترام هذا الترتيب (البيانات الوصفية لا تظهر في الأفضلية). يتم تحديد الأفضلية عن طريق أول اختلاف يظهر عند المقارنة بين هذه المعرّفات من اليسار إلى اليمين على النحو التالي: تتم دائما المقارنة بين جذري، بسيط وترقيع عدديا، مثال: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. في حال تساوى ترقيم جذري، بسيط وترقيع، يتم احتساب ترقيم النسخ ما قبل النهائية (alpha, beta) على أن لها أفضلية أقل من النسخ العادية، مثال:  1.0.0 > 1.0.0-alpha . في حال تساوت النُسخ ما قبل النهائية بنفس ترقيم جذري، بسيط، ترقيع، يجب حساب الأفضلية عن طريق المقارنة بين المعرفات المفصول بينها بنقاط من اليسار إلى اليمين إلى غاية العثور على اختلاف، وذلك على النحو التالي: المعرفات المُكونة من أرقام فقط تتم مقارنتها عدديا، والمُعرّفات المُكوّنة من أحرف ووصلة (-) تتم مقارنتها أبجديًا وفق ترتيب ASCII. المُعرّفات الرقمية لها دائما أفضلية أقل من المعرفات غير العددية. كلما امتدت حقول النُّسخ ما قبل النهائية كلما زادت أفضليتها عن النّسخ ذوات حقول أقل إذا تساوت جميع المعرفات السابقة. مثال:
1.0.0 > 1.0.0-rc.1 > 1.0.0-beta.11 > 1.0.0-beta.2 > 1.0.0-beta > 1.0.0-alpha.beta > 1.0.0-alpha.1 > 1.0.0-alpha\nالأفضلية تُشير إلى كيفية المُقارنة بين النُسخ عند ترتيبها. يجب أن يتم حساب الأفضلية عن طريق تقسيم ترقيم النُّسخ إلى ترقيع، بسيط، جذري ثم مُعرفات النسخ ما قبل النهائية (alpha, beta) مع احترام هذا الترتيب (البيانات الوصفية لا تظهر في الأفضلية). يتم تحديد الأفضلية عن طريق أول اختلاف يظهر عند المقارنة بين هذه المعرّفات من اليسار إلى اليمين على النحو التالي: تتم دائما المقارنة بين جذري، بسيط وترقيع عدديا، مثال: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. في حال تساوى ترقيم جذري، بسيط وترقيع، يتم احتساب ترقيم النسخ ما قبل النهائية (alpha, beta) على أن لها أفضلية أقل من النسخ العادية، مثال:  1.0.0 > 1.0.0-alpha . في حال تساوت النُسخ ما قبل النهائية بنفس ترقيم جذري، بسيط، ترقيع، يجب حساب الأفضلية عن طريق المقارنة بين المعرفات المفصول بينها بنقاط من اليسار إلى اليمين إلى غاية العثور على اختلاف، وذلك على النحو التالي: المعرفات المُكونة من أرقام فقط تتم مقارنتها عدديا، والمُعرّفات المُكوّنة من أحرف ووصلة (-) تتم مقارنتها أبجديًا وفق ترتيب ASCII. المُعرّفات الرقمية لها دائما أفضلية أقل من المعرفات غير العددية. كلما امتدت حقول النُّسخ ما قبل النهائية كلما زادت أفضليتها عن النّسخ ذوات حقول أقل إذا تساوت جميع المعرفات السابقة. مثال:
1.0.0 > 1.0.0-rc.1 > 1.0.0-beta.11 > 1.0.0-beta.2 > 1.0.0-beta > 1.0.0-alpha.beta > 1.0.0-alpha.1 > 1.0.0-alpha\n1.0.0 > 1.0.0-rc.1 > 1.0.0-beta.11 > 1.0.0-beta.2 > 1.0.0-beta > 1.0.0-alpha.beta > 1.0.0-alpha.1 > 1.0.0-alpha\nلماذا يجب استعمال الإدارة الدلالية لنُسخ البرمجيات ؟\nهذه ليست فكرة جديدة أو ثورية. في الحقيقة، ربما تقوم حاليًا بشيء مُشابه لهذا الأمر. المُشكل أن هذا “الشبه” ليس جيدًا بما فيه الكفاية. من دون الامتثال إلى نوع من المُواصفات الرسمية، فإن ترقيم النسخ سيكون أساسًا من دون فائدة لإدارة الاعتماديات. بإعطاء اسم وتعريف واضح للأفكار المُقَدَمة أعلاه، سيُصبح من السهل إخطار مستخدمي برمجيتك بنواياك. بمُجرد أن تصبح هذه النوايا واضحة، سيكون من المُمكن أخيرًا وضع مُواصفات مرنة للاعتماديات (لكنها ليست بالغة المرونة).\nمثال بسيط سيُوضّح كيف يُمكن للإدارة الدلالية لنُسخ البرمجيات أن تجعل من “جحيم الاعتماديات” شيئًا من الماضي. لنفرض أن هناك مكتبة برمجية تحمل الاسم “شاحنة الإطفاء”. تتطلّب هذه المكتبة حزمة برمجية تحمل الاسم “سُلّم” يتم إدارة نُسخها دلاليًا. في الوقت الذي تم فيه إنشاء مكتبة شاحنة الإطفاء، كانت حزمة سُلّم في نسختها 3.1.0. بما أن شاحنة الإطفاء تستعمل بعض الوظائف التي تم إدخالها أول مرة في النسخة 3.1.0، فإنه بإمكانك أن تُحدّد اعتمادية سُلّم لتكون أكبر من أو تُساوي 3.1.0 وأقل من 4.0.0 بكل أمان. الآن، عند إصدار النُسَخ 3.1.1 و 3.2.0 من حزمة سُلّم، يُمكنك نشرها في نظام إدارة الحزم خاصتك وأنت تعلم أنها مُتوافقة مع البرمجيات الحالية التي تعتمد عليها.\nبصفتك مُطورًا مسؤولا، سيتوجّب عليك أن تتحقّق من أن كل عملية ترقية لحزمة مُعيّنة تعمل كما تم الإشهار لها. العالم الحقيقي مكان فوضوي، لا يوجد ما يمكننا فعله حيال ذلك سوى أن نكون يقظين. ما يمكنك فعله هو أن تنتهج طريقا بواسطة الإدارة الدلالية لنُسخ البرمجيات (Semantic Versioning)  يسمح لك بإصدار وترقية الحزم من دون الحاجة لإصدار نُسخ جديدة من الحزم الأخرى المُعتمد عليها بكل رزانة، حافظًا لوقتك ومُتجنبًا لجميع المتاعب.\nإذا بدى لك كل هذا الأمر مُحبّذًا، فإن كل ما تحتاج لفعله للبدء في استعمال الإدارة الدلالية لنُسخ البرمجيات هو أن تعلن أنك ستمتثل وتتّبع قواعدها. أشر إلى هذا الموقع في ملف README الخاص بمشروعك حتى يعلم البقية بهذه القواعد وتُمكّنهم من الاستفادة منها.\nالأسئلة الأكثر شيوعًا\nكيف يجدر بي التعامل مع مُراجعات O.y.z عند بداية مرحلة التطوير الأوّلية؟\nأبسط شيء يُمكن القيام به هو أن تستهلّ مرحلة التطوير الأولية بإصدار النسخة 0.1.0 ثم ترفع درجة ترقيم “بسيط” (Minor) بعد كل إصدارة تليها.\nمتى أعرف أنه حان وقت إصدار النسخة 1.0.0؟\nإذا كان يتم استخدام برمجيتك بشكل فعلي في خدمة زبائن حقيقيين من طرف جهة مُعيّنة، فعلى الأرجح أنه قد حان وقت ترقيمها بالنسخة 1.0.0. إذا كنت تملك واجهة برمجية مُستقرة بحيث يجري الاعتماد عليها من طرف مستخدمين لها، فإنه يجب إذًا أن تكون 1.0.0. إذا كنت من الحريصين جدًا على التوافقية الرجعية، فأغلب الظن أنه قد حان فعلا وقت النسخة 1.0.0.\nألا يُثبّط هذا من عمليات التطوير المُتسارعة والتكرارية؟\nالغرض من وجود النسخة الجذرية المصفّرة (Major version zero) هو عمليات التطوير السريعة. إذا كنت تغيّر من الواجهة البرمجية كل يوم، فإنه يجدر بك إما أن تبقى عند الترقيم O.y.z أو أن تكون في فرع تطوير مُنفصل (branch) تعمل فيه على النسخة الجذرية القادمة.\nإذا كان حتى أصغر تغيير غير مُتوافق رجعيا للواجهة البرمجية العامة يتطلب رفع ترقيم جذري، ألن يقودَني ذلك إلى النسخة 42.0.0 بسرعة فائقة؟\nهذا السؤال له علاقة بمسؤولية التطوير وبُعد النظر، لا يجدر بالتغييرات غير المتوافقة رجعيًا أن يتم إدخالها بهذه السرعة على البرمجيات التي يتم الاعتماد على شفرتها. ستكون التكلفة التي تتكبدها عملية الترقية مُعتبرة. وجوب رفع ترقيم النسخ الجذرية لإصدار تغييرات غير متوافقة يعني أنك ستفكر في عواقب هذه التغييرات، وتوزان بين نسبة المصلحة/التكلفة التي تنجرّ عنها.\nعملية التوثيق الكامل للواجهة البرمجية (API) تُعتبر عملا مُنهكا!\nمن مسؤولياتك كمُطور مُحترف أن توثّق بشكل صحيح البرمجية المُوجّهة للاستعمال من قِبَل مُستخدمين آخرين. إدارة تعقيد البرمجيات هو جزء بالغ الأهمية للحفاظ على كفاءة المشروع، وهذا شيء صعبٌ القيامُ به إن لم يكن هناك أي شخص على علم بكيفية استعمال برمجيتك، أو بالوظائف التي يُمكن استدعاؤها بأمان. على المدى البعيد، ستُمكّن الإدارة الدلالية والإصرار على وجود واجهة برمجية عامة واضحة المعالم من الإبقاء على السير الحسن للأمور عند الجميع.\nماذا يتوجب عليَّ فعله عندما أُصدر عن طريق الخطأ نسخةً بتغييرات غير مُتوافقة رجعيًا كنُسخة ترقيعية (Minor version)؟\nبمُجرد إدراكك بأنك قمت بنقض مُواصفات الإدارة الدلالية، قم بإصلاح المُشكل ثم قم بإصدار نسخة بسيطة جديدة (Minor) تُصلح العلة وتقوم بإرجاع التوافقية الرجعية. حتى تحت هذا الظرف، فإنه من غير المقبول أن تُغيّر من النُسخ التي تم إصدارها مُسبقا. قم بتوثيق النُسخة المُخالفة إذا كان ذلك مُلائما، وأخبر المُستخدمين بالمُشكلة حتى يكونوا على علم بالنُسخة المُخالفة.\nما يتوجب علي فعله عندما أحدّث الاعتماديات الخاصة بي دون تغيير الواجهة البرمجية العامة.\nسيُعتبر هذا على الأرجح أنه تغيير مُتوافق رجعيًا حيث أنه لا يَمَس الواجهة البرمجية العامة. يجدر بالبرمجيات التي تعتمد صراحة على نفس الاعتماديات التي تعتمد عليها حزمتك أن تتبع مُواصفات اعتماديات خاصة بها وأن ينتبه المُؤلف الأصلي لها لأي تضارب قد يحصل. تحديد ما إذا كانت هذه التغيرات بمثابة ترقيع أو بسيط يعتمد على ما إذا قمت بتحديث اعتمادياتك لتصحيح علة مُعيّنة أو لإدخال وظيفة جديدة. غالبًا ما أتوقع إضافة شفرة برمجية بالنسبة للحالة الثانية (إدخال وظيفة جديدة)، وبالتالي سيكون هذا الأمر بطبيعة الحال بمثابة تغيير يتطلب رفع ترقيم بسيط.\nماذا لو قمت عن غير قصد بتغيير الواجهة البرمجية العامة بطريقة لا تتماشى مع ترقيم النسخة (مثال: الشفرة تُدخِل عن طريق الخطأ تغييرات جذرية تكسر التوافقية الرجعية في إصدارة ترقيعية patch)\nاجتهد واحكم بنفسك، إذا كنت تملك جمهورًا غفيرًا سيتأثر بشكل كبير لو قمت بإرجاع الواجهة البرمجية العامة إلى سابق حالها كما كان مقصودًا، فسيكون حينئذ من الأفضل إصدار نسخة جذرية جديدة، حتى ولو تم اعتبار الإصلاح على أنه فقط إصدارة ترقيعية. تذكّر دائما أن هدف الإدارة الدلالية هو إضفاء معنىً حول التغييرات الحاصلة عن طريق كيفية تغيير ترقيم النُّسخ. إذا كانت هذه التغييرات ذات أهمية عند مُستخدمي برمجيتك، فاستعمل ترقيم النُسخ لإعلامهم بذلك.\nماذا عن الوظائف المُتخلى عنها (deprecating functionality) ؟\nالتخلّي عن وظيفة موجودة مُسبقا شيء طبيعي في تطوير البرمجيات، بل يُعتبر أحيانا خطوة لابد منها للمُضي قُدما. عندما تتخلّى عن إحدى الوظائف في الواجهة البرمجية العامة، فإنه يجب عليك القيام بأمرين: (1) قم بتحديث التوثيق حتى يعلم بقية المُستخدمين بهذا التغيير، (2) أصدر نسخة بسيطة (Minor) جديدةً تحتوي على الوظيفة المُتخلى عنها. قبل حذف الوظيفة نهائيًا في نسخة جذرية (Major). يجب على الأقل أن تكون هناك نسخة بسيطة تحتوي على الوظيفة المُتخلى عنها حتى تُمكّن المستخدمين من الانتقال السلِس إلى الواجهة البرمجية الجديدة.\nهل يفرض semver حدًا مُعينًا لطول السلسلة النصية عند ترقيم النُّسخ ؟\nلا، لكن اجتهد وأحسن التقدير. استعمال 255 حرفا على سبيل المثال في ترقيم نسخة ما قد يكون أمرًا مُبالغًا فيه. تذكّر أيضًا بأن بعض المنصّات تضع حدًا لطول السلسة النصية.\nمُواصفات الإدارة الدلالية لنُسخ البرمجيات من تأليف Tom
Preston-Werner, مُبتكر خدمة Gravatars وأحد مؤسسي GitHub.\nلديك اقتراح؟ يُرجى فتح “خطب” على
GitHub.\nالمشاع الإبداعي ― CC BY 3.0\nالمشاع الإبداعي ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nСемантично версиониране 2.0.0

Резюме

Използвайки номериране на версиите като ГЛАВНА.ВТОРОСТЕПЕННА.КРЪПКА, трябва да увеличите:


  
    ГЛАВНАта версия, при направени несъвместими промени в
приложно-програмният интерфейс (API).
  
  
    ВТОРОСТЕПЕННАта версия, когато промените са обратно съвместими.
  
  
    КРЪПКА-номера, когато са направени обратно съвместими поправки.
  


Допускат се допълнителни етикети за предварителни издания и билд-метаданни,
като разширения на формата за версия ГЛАВНА.ВТОРОСТЕПЕННА.КРЪПКА.

Въведение

В света на софтуерния мениджмънт съществува страховито място,
наречено „ад на зависимостите“. Колкото по-голяма става вашата система
и колкото повече библиотеки интегрирате в проекта си, толкова по-голяма
е вероятността един ден да се окажете в тази яма на отчаяние.

В системи с множество зависимости пускането на нови версии на някои от тях
може бързо да се превърне в кошмар. Ако спецификациите за зависимост са
твърде стриктни, рискувате да блокирате версията (невъзможността да обновите пакет,
освен ако не пускате нова версия при всяка промяна в библиотека, от която той
зависи). Ако зависимостите са посочени твърде слабо, неизбежно ще ви застигне
несъвместимостта на версиите (поради заявена съвместимост с повече бъдещи версии,
отколкото е разумно). Адът на зависимостта е мястото, където се намирате, когато
блокирането на версията и/или несъвместимостта на версията ви пречат лесно и
безопасно да движите проекта си напред.

За справяне с този проблем предлагам прост набор от правила и изисквания,
които определят как се присвояват и увеличават номерата на версиите. Тези правила
се основават на (но не непременно са ограничени до) съществуващи широко разпространени
общи практики. Те са приложими както в затворени проекти, така и в такива с
отворен код. За да работи тази система, първо трябва да определите публичен API.
Той може да бъде описан в документация или да се определя от самия код. Важното е
този API да бъде ясен и точен. След като идентифицирате публичния си API, вие
съобщавате промените в него с конкретни увеличения в номера на вашата версия.
Нека разгледаме формат на версия X.Y.Z (ГЛАВНА.ВТОРОСТЕПЕННА.КРЪПКА).
Поправки на грешки, които не засягат версията на API увеличават версията на
кръпката. Oбратно съвместими добавки/промени, увеличават второстепенната версия,
а обратно несъвместими промени в API увеличават главната версия.

Аз наричам това „Семантично версиониране“ (Semantic Versioning).
При тази схема, номерата на версиите и начинът, по който се променят,
предават значение за състоянието на изходния код и какво е променено между две версии.

Спецификация на семантичното версиониране (SemVer)

Ключовите думи „ЗАДЪЛЖИТЕЛНО“ (MUST), „ЗАДЪЛЖИТЕЛНО НЕ“ (MUST NOT),
„ИЗИСКВА“ (REQUIRED), „БИ ТРЯБВАЛО“ (SHELL), „НЕ БИ ТРЯБВАЛО“ (SHELL NOT),
„ТРЯБВА“ (SHOULD), „НЕ ТРЯБВА“ (SHOULD NOT), „ПРЕПОРЪЧИТЕЛНО Е“ (RECOMMENDED),
„МОЖЕ“ (MAY) и „НЕЗАДЪЛЖИТЕЛНО“ (OPTIONAL) в този документ се тълкуват,
както е описано в RFC 2119.


  
    Продуктите, използващи „Семантично версиониране“, ЗАДЪЛЖИТЕЛНО декларират
публичен API. Този API може да бъде деклариран в самия код или да съществува
строго в документацията. Независимо от метода, ТРЯБВА да бъде
прецизен и изчерпателен.
  
  
    Нормалният номер на версията ЗАДЪЛЖИТЕЛНО има вид X.Y.Z, където X, Y и Z са
неотрицателни цели числа и ЗАДЪЛЖИТЕЛНО НЕ съдържат водещи нули. X е главната
версия, Y е второстепенната, а Z е версията на кръпката. Всеки елемент
ЗАДЪЛЖИТЕЛНО се увеличава числено. Например: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    След като бъде пусната дадена версия, съдържанието на тази версия
ЗАДЪЛЖИТЕЛНО НЕ се променя. Всякакви модификации е ЗАДЪЛЖИТЕЛНО да бъдат
пуснати като нова версия.
  
  
    Главна версия нула (0.y.z) е за първоначална разработка. Всичко може
да се промени по всяко време. Публичният API НЕ ТРЯБВА да се счита за стабилен.
  
  
    Версия 1.0.0 определя публичния API. Начинът, по който се увеличава номерът
на версията след това издание, зависи от това, как се променя той.
  
  
    Версия на кръпката Z (x.y.Z | x > 0) ЗАДЪЛЖИТЕЛНО се увеличава, ако се правят
само обратно съвместими корекции на грешки. За такива (bug fix) се считат вътрешни
промени, които коригират неправилно поведение.
  
  
    Второстепенната версия Y (x.Y.z | x > 0) ЗАДЪЛЖИТЕЛНО се увеличава, когато
в публичния API се въвежда нова, обратно съвместима функционалност. ЗАДЪЛЖИТЕЛНО
е тя да се увеличи, ако някоя публична API функция е маркирана като
оттеглена (depricated). МОЖЕ да се увеличи, ако се въведе съществена нова
функционалност или подобрения в рамките на не-публичния програмен код.
МОЖЕ да включва промени характерни за кръпка. Версията на кръпката ЗАДЪЛЖИТЕЛНО
се връща на 0, когато второстепенната версия се увеличава.
  
  
    Главната версия X (X.y.z | X > 0) ЗАДЪЛЖИТЕЛНО се увеличава, когато в публичния
API се въведат каквито и да е обратно несъвместими промени. МОЖЕ да включва и
второстепенни промени или кръпки. Версията на кръпката и второстепенната версия
ЗАДЪЛЖИТЕЛНО се нулират (X.0.0), когато основната версия се увеличава.
  
  
    Предварително издание (pre-release) МОЖЕ да бъде обозначено веднага след
версията на кръпката чрез добавяне на тире, следвано от разделени с точки
идентификатори. Те ЗАДЪЛЖИТЕЛНО съдържат само ASCII буквено-цифрови
последователности и тире [0-9A-Za-z-]. Идентификаторите ЗАДЪЛЖИТЕЛНО НЕ
трябва да са празни. Числовите идентификатори ЗАДЪЛЖИТЕЛНО НЕ включват
водещи нули. Предварителните издания имат по-нисък приоритет от свързаната
основна версия. Предварителното издание показва, че версията е нестабилна
и може да не отговаря на предвидените изисквания за съвместимост, заявени
от свързаната с нея нормална версия. Примери:
1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Билд-метаданни МОЖЕ да бъдат обозначени чрез добавяне
на знак плюс и серия от разделени с точка идентификатори непосредствено след
версията на кръпка или на предварителното издание. Идентификаторите ЗАДЪЛЖИТЕЛНО
съдържат само ASCII буквено-цифрови последователности и тире [0-9A-Za-z-].
Идентификаторите ЗАДЪЛЖИТЕЛНО НЕ трябва да са празни. Билд-метаданните
ЗАДЪЛЖИТЕЛНО се игнорират при определяне на приоритета на версията. По
този начин две версии, които се различават само в билд-метаданните са с
еднакъв приоритет. Примери:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    Приоритетът определя как версиите се нареждате една спрямо друга.
При изчисление на приоритетът, версията ЗАДЪЛЖИТЕЛНО се разделя на ГЛАВНА, ВТОРОСТЕПЕННА,
КРЪПКА и идентификатори за предварително издание в този ред (билд-метаданните
се пренебрегват при определянето му). Подредбата се определя от първата разлика
при сравняване на всеки от тези компоненти отляво надясно, както следва:
Главните, второстепенните и версиите на кръпките винаги се сравняват като числа.
Пример: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Когато всички те са еднакви, версията
с предварително издание има по-нисък приоритет от основната версия.
Пример: 1.0.0-alpha < 1.0.0. Приоритет за две версии с предварително издание
(при еднакви ГЛАВНА, ВТОРОСТЕПЕННА и КРЪПКА) ЗАДЪЛЖИТЕЛНО се определя чрез
сравняване на всеки един идентификатор отляво надясно, докато
не се установи разлика, както следва: идентификаторите, състоящи се само от цифри,
се сравняват цифрово, а идентификаторите с букви или тиретата се сравняват
лексикално в ред на сортиране по ASCII. Цифровите идентификатори винаги имат
по-нисък приоритет от текстовите. По-голям набор от полета на предварителното
издание има по-висок приоритет, ако всички предходни идентификатори са равни.
Пример: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Бакус-Наур форма на граматиката за валидни SemVer версии
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


Защо да използвате „Семантично версиониране“

Това не е нова или революционна идея. Всъщност вероятно вече използвате нещо
подобно. Проблемът е, че „подобно“ не е достатъчно еднозначно. Без
съответствие с някаква официална спецификация, номерата на версиите са
по същество безполезни за управление на зависимости. Като бъдат наречени и ясно
определени, става лесно да заявите вашите намерения пред потребителите
на вашия софтуер. След като тези намерения са ясни и гъвкави (но не твърде),
спецификациите за зависимости най-накрая могат да бъдат направени.

Прост пример ще демонстрира как „Семантично версиониране“ може да изпрати „адът
на зависимостите“ в миналото. Представете си библиотека, наречена „Пожарна кола“.
Тя изисква пакет използващ „Семантично версиониране“, наречен „Стълба“. По времето,
когато „Пожарна кола“ е създадена, „Стълба“ е версия 3.1.0. Тъй като „Пожарна кола“
използва известна функционалност, представена за първи път в 3.1.0, можете
спокойно да заявите зависимост от „Стълба“, версия по-голяма или равна на 3.1.0,
но по-малка от 4.0.0. Сега, кога основни версии 3.1.1 и 3.2.0 стават достъпни,
можете да ги интегрирате с вашата система, знаейки, че те ще бъдат съвместими
със текущата функционалност.

Като отговорен разработчик, разбира се, ще искате да проверите, че обновения пакет
се държи според очакванията. Реалният свят е хаотичен; нищо не може да се направи
по въпроса, освен да сме бдителни. Това, което може да се направи, е да оставите
„Семантично версиониране“ да ви предоставя разумен начин за издаване и надграждане на
пакети, без да се налага да го правите при всяка промяна на зависимости,
спестявайки ви време и нерви.

За да се възползвате от описаното до тук, трябва просто да
заявите, че използвате „Семантично версиониране“ и да следвате правилата.
Поставете връзка към този уеб сайт във вашия README файл, така че значението на
промените във версията да бъде ясно за всички.

Често задавани въпроси

Какво да правя с версиите в началната фаза на разработка 0.y.z

Просто започнете първоначалната си версия от 0.1.0 и след това увеличавайте
второстепенната версия за всяко следващо издание.

Как да разбера кога да издам 1.0.0

Ако вашият софтуер се използва в производствена среда, вероятно вече трябва
да бъде 1.0.0. Ако имате стабилен API, от който потребителите зависят,
трябва да е 1.0.0. Ако се притеснявате много за обратната съвместимост, вероятно
вече трябва да е 1.0.0.

Това не възпрепятства ли бързата разработка и кратките итерации

Главната версия 0 е свързана с бързата разработка. Ако променяте API
всеки ден, трябва или да бъдете във версия 0.y.z, или да използвате отделен
клон за работата върху следващото главно издание.

Ако дори и най-малките обратно несъвместими промени в публичния API изискват промяна в главната версия, няма ли много скоро да стигнем 42.0.0

Това е въпрос на отговорно развитие и предвидливост. Несъвместими
промени не трябва да се въвеждат с лека ръка в софтуер, от който зависят
много проекти. Цената на такова надграждане може да бъде значителна.
Това, че трябва да се увеличи главната версия, за да се издадат несъвместими
промени, означава, че ще обмислите последствията от промените
и ще отчетете съотношението цена/полза.

Документирането на целия публичен API е твърде много работа

Ваша отговорност като професионален разработчик е качественото документиране на
софтуера, предназначен за широко използване. Управлението на сложността
на софтуера е изключително важна част от поддържането на ефективен проект.
Това е трудно да се направи, ако никой не знае как се използва вашия
софтуер или какви методи могат да бъдат извиквани безопасно. В дългосрочен план,
„Семантичното версиониране“ и настойчивостта за качествено документиране на публичния
API помага за безпроблемната работа.

Какво да направя, ако случайно пусна обратно несъвместима промяна като второстепенна версия

Веднага щом разберете, че сте нарушили спецификацията на SemVer, поправете
проблема и пуснете нова вторична версия, която коригира проблема и
възстановява обратната съвместимост. Дори и в такава ситуация е неприемливо
да подменяте вече издадена версия. Ако е подходящо, документирайте некоректната
версия и информирайте потребителите си за проблема с обратната съвместимост в нея.

Какво трябва да направя, ако обновя собствените си зависимости, без да променя публичния API

Това може да се разглежда като съвместимо изменение, тъй като не засяга
публичния API. Софтуер, който има същите зависимости като вашия
пакет трябва да има свои спецификации за зависимост и авторът да забележи
евентуални конфликти. За определяне дали промяната е ниво на кръпка или
второстепенна модификация зависи от това дали сте актуализирали зависимостите си,
за да коригирате грешка или да въведете нова функционалност. Обикновено за второто
е очакван допълнителен код, при което следва да се промени второстепенната версия.

Какво става, ако по невнимание променя публичния API по начин, който не е съвместим с промяната на номера на версията (тоест кодът неправилно въвежда голяма промяна в версията на кръпка)

Използвайте най-добрата си преценка. Ако имате огромна публика, която ще бъде драстично
засегната от промяната на поведението към това, което е планирано в публичният API
може би е най-добре да извършите издание на главна версия, въпреки че поправката може
строго погледнато да се счита за издаване на кръпка. Не забравяйте, че „Семантично
версиониране“ се стреми строго да следва спецификациите. Ако тези промени са важни
за вашите потребители, използвайте номера на версията, за да ги информирате.

Как се оттегля функционалност (deprecating)

Оттеглянето на съществуващата функционалност е нормална част от разработката
на софтуер и често се изисква за постигне на напредък. Когато оттегляте част
от вашия обществен API, трябва да направите две неща: (1) обновете документацията
си информирайки потребителите за промяната, (2) направете ново незначително издание
с оттеглянето. Преди да премахнете напълно функционалността в нова главна версия
трябва да има поне едно второстепенно издание, което съдържа оттеглянето, така че
че потребителите могат плавно да преминат към новия API.

Има ли SemVer ограничение на дължината на версията

Не, но използвайте добра преценка. Например, вероятно е излишно версията да е дълга 255
символа. Също така, специфичните системи могат да налагат свои собствени
ограничения за дължината на низа.

„v1.2.3“ семантично-зададена версия ли е

Не, „v1.2.3“ не е семантично-зададена версия. Префиксиране на семантично-зададена
версия с „v“ е често срещан начин (на английски език) да се посочи, че става дума
за номер на версия. Съкращаването „версия“ като „v“ често се наблюдава при
системи за контрол на версиите. Пример:
git tag v1.2.3 -m "Release version 1.2.3", в случая „v1.2.3“ е маркер,
а семантично-зададената версия е „1.2.3“.

Има ли регулярни изрази (RegEx) за проверка на дали даден низ отговаря на SemVer спецификацията

Съществуват два такива израза. Първият е за системи поддържащи PCRE
(Perl Compatible Regular Expressions, тоест Perl, PHP и R), Python и Go.

Вижте: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Другият използва номерирани групи (при него cg1 = ГЛАВНА, cg2 = ВТОРОСТЕПЕННА,
cg3 = КРЪПКА, cg4 = предварително издание и cg5 = билд-метаданни) и е
съвместим с ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
тоест Perl, PHP и R), Python и Go.

Вижте: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


За автора

Автор на спецификацията „Семантично версиониране“ (SemVer) е
Том Престон-Вернер, основател на Gravatars и
съучредител на GitHub.

За обратна връзка, моля създайте запитване в
GitHub.

Лиценз

Creative Commons — CC BY 3.0\nСемантично версиониране 2.0.0\nИзползвайки номериране на версиите като ГЛАВНА.ВТОРОСТЕПЕННА.КРЪПКА, трябва да увеличите:\nГЛАВНАта версия, при направени несъвместими промени в
приложно-програмният интерфейс (API).\nГЛАВНАта версия, при направени несъвместими промени в
приложно-програмният интерфейс (API).\nВТОРОСТЕПЕННАта версия, когато промените са обратно съвместими.\nВТОРОСТЕПЕННАта версия, когато промените са обратно съвместими.\nКРЪПКА-номера, когато са направени обратно съвместими поправки.\nКРЪПКА-номера, когато са направени обратно съвместими поправки.\nДопускат се допълнителни етикети за предварителни издания и билд-метаданни,
като разширения на формата за версия ГЛАВНА.ВТОРОСТЕПЕННА.КРЪПКА.\nВ света на софтуерния мениджмънт съществува страховито място,
наречено „ад на зависимостите“. Колкото по-голяма става вашата система
и колкото повече библиотеки интегрирате в проекта си, толкова по-голяма
е вероятността един ден да се окажете в тази яма на отчаяние.\nВ системи с множество зависимости пускането на нови версии на някои от тях
може бързо да се превърне в кошмар. Ако спецификациите за зависимост са
твърде стриктни, рискувате да блокирате версията (невъзможността да обновите пакет,
освен ако не пускате нова версия при всяка промяна в библиотека, от която той
зависи). Ако зависимостите са посочени твърде слабо, неизбежно ще ви застигне
несъвместимостта на версиите (поради заявена съвместимост с повече бъдещи версии,
отколкото е разумно). Адът на зависимостта е мястото, където се намирате, когато
блокирането на версията и/или несъвместимостта на версията ви пречат лесно и
безопасно да движите проекта си напред.\nЗа справяне с този проблем предлагам прост набор от правила и изисквания,
които определят как се присвояват и увеличават номерата на версиите. Тези правила
се основават на (но не непременно са ограничени до) съществуващи широко разпространени
общи практики. Те са приложими както в затворени проекти, така и в такива с
отворен код. За да работи тази система, първо трябва да определите публичен API.
Той може да бъде описан в документация или да се определя от самия код. Важното е
този API да бъде ясен и точен. След като идентифицирате публичния си API, вие
съобщавате промените в него с конкретни увеличения в номера на вашата версия.
Нека разгледаме формат на версия X.Y.Z (ГЛАВНА.ВТОРОСТЕПЕННА.КРЪПКА).
Поправки на грешки, които не засягат версията на API увеличават версията на
кръпката. Oбратно съвместими добавки/промени, увеличават второстепенната версия,
а обратно несъвместими промени в API увеличават главната версия.\nАз наричам това „Семантично версиониране“ (Semantic Versioning).
При тази схема, номерата на версиите и начинът, по който се променят,
предават значение за състоянието на изходния код и какво е променено между две версии.\nСпецификация на семантичното версиониране (SemVer)\nКлючовите думи „ЗАДЪЛЖИТЕЛНО“ (MUST), „ЗАДЪЛЖИТЕЛНО НЕ“ (MUST NOT),
„ИЗИСКВА“ (REQUIRED), „БИ ТРЯБВАЛО“ (SHELL), „НЕ БИ ТРЯБВАЛО“ (SHELL NOT),
„ТРЯБВА“ (SHOULD), „НЕ ТРЯБВА“ (SHOULD NOT), „ПРЕПОРЪЧИТЕЛНО Е“ (RECOMMENDED),
„МОЖЕ“ (MAY) и „НЕЗАДЪЛЖИТЕЛНО“ (OPTIONAL) в този документ се тълкуват,
както е описано в RFC 2119.\nПродуктите, използващи „Семантично версиониране“, ЗАДЪЛЖИТЕЛНО декларират
публичен API. Този API може да бъде деклариран в самия код или да съществува
строго в документацията. Независимо от метода, ТРЯБВА да бъде
прецизен и изчерпателен.\nПродуктите, използващи „Семантично версиониране“, ЗАДЪЛЖИТЕЛНО декларират
публичен API. Този API може да бъде деклариран в самия код или да съществува
строго в документацията. Независимо от метода, ТРЯБВА да бъде
прецизен и изчерпателен.\nНормалният номер на версията ЗАДЪЛЖИТЕЛНО има вид X.Y.Z, където X, Y и Z са
неотрицателни цели числа и ЗАДЪЛЖИТЕЛНО НЕ съдържат водещи нули. X е главната
версия, Y е второстепенната, а Z е версията на кръпката. Всеки елемент
ЗАДЪЛЖИТЕЛНО се увеличава числено. Например: 1.9.0 -> 1.10.0 -> 1.11.0.\nНормалният номер на версията ЗАДЪЛЖИТЕЛНО има вид X.Y.Z, където X, Y и Z са
неотрицателни цели числа и ЗАДЪЛЖИТЕЛНО НЕ съдържат водещи нули. X е главната
версия, Y е второстепенната, а Z е версията на кръпката. Всеки елемент
ЗАДЪЛЖИТЕЛНО се увеличава числено. Например: 1.9.0 -> 1.10.0 -> 1.11.0.\nСлед като бъде пусната дадена версия, съдържанието на тази версия
ЗАДЪЛЖИТЕЛНО НЕ се променя. Всякакви модификации е ЗАДЪЛЖИТЕЛНО да бъдат
пуснати като нова версия.\nСлед като бъде пусната дадена версия, съдържанието на тази версия
ЗАДЪЛЖИТЕЛНО НЕ се променя. Всякакви модификации е ЗАДЪЛЖИТЕЛНО да бъдат
пуснати като нова версия.\nГлавна версия нула (0.y.z) е за първоначална разработка. Всичко може
да се промени по всяко време. Публичният API НЕ ТРЯБВА да се счита за стабилен.\nГлавна версия нула (0.y.z) е за първоначална разработка. Всичко може
да се промени по всяко време. Публичният API НЕ ТРЯБВА да се счита за стабилен.\nВерсия 1.0.0 определя публичния API. Начинът, по който се увеличава номерът
на версията след това издание, зависи от това, как се променя той.\nВерсия 1.0.0 определя публичния API. Начинът, по който се увеличава номерът
на версията след това издание, зависи от това, как се променя той.\nВерсия на кръпката Z (x.y.Z | x > 0) ЗАДЪЛЖИТЕЛНО се увеличава, ако се правят
само обратно съвместими корекции на грешки. За такива (bug fix) се считат вътрешни
промени, които коригират неправилно поведение.\nВерсия на кръпката Z (x.y.Z | x > 0) ЗАДЪЛЖИТЕЛНО се увеличава, ако се правят
само обратно съвместими корекции на грешки. За такива (bug fix) се считат вътрешни
промени, които коригират неправилно поведение.\nВторостепенната версия Y (x.Y.z | x > 0) ЗАДЪЛЖИТЕЛНО се увеличава, когато
в публичния API се въвежда нова, обратно съвместима функционалност. ЗАДЪЛЖИТЕЛНО
е тя да се увеличи, ако някоя публична API функция е маркирана като
оттеглена (depricated). МОЖЕ да се увеличи, ако се въведе съществена нова
функционалност или подобрения в рамките на не-публичния програмен код.
МОЖЕ да включва промени характерни за кръпка. Версията на кръпката ЗАДЪЛЖИТЕЛНО
се връща на 0, когато второстепенната версия се увеличава.\nВторостепенната версия Y (x.Y.z | x > 0) ЗАДЪЛЖИТЕЛНО се увеличава, когато
в публичния API се въвежда нова, обратно съвместима функционалност. ЗАДЪЛЖИТЕЛНО
е тя да се увеличи, ако някоя публична API функция е маркирана като
оттеглена (depricated). МОЖЕ да се увеличи, ако се въведе съществена нова
функционалност или подобрения в рамките на не-публичния програмен код.
МОЖЕ да включва промени характерни за кръпка. Версията на кръпката ЗАДЪЛЖИТЕЛНО
се връща на 0, когато второстепенната версия се увеличава.\nГлавната версия X (X.y.z | X > 0) ЗАДЪЛЖИТЕЛНО се увеличава, когато в публичния
API се въведат каквито и да е обратно несъвместими промени. МОЖЕ да включва и
второстепенни промени или кръпки. Версията на кръпката и второстепенната версия
ЗАДЪЛЖИТЕЛНО се нулират (X.0.0), когато основната версия се увеличава.\nГлавната версия X (X.y.z | X > 0) ЗАДЪЛЖИТЕЛНО се увеличава, когато в публичния
API се въведат каквито и да е обратно несъвместими промени. МОЖЕ да включва и
второстепенни промени или кръпки. Версията на кръпката и второстепенната версия
ЗАДЪЛЖИТЕЛНО се нулират (X.0.0), когато основната версия се увеличава.\nПредварително издание (pre-release) МОЖЕ да бъде обозначено веднага след
версията на кръпката чрез добавяне на тире, следвано от разделени с точки
идентификатори. Те ЗАДЪЛЖИТЕЛНО съдържат само ASCII буквено-цифрови
последователности и тире [0-9A-Za-z-]. Идентификаторите ЗАДЪЛЖИТЕЛНО НЕ
трябва да са празни. Числовите идентификатори ЗАДЪЛЖИТЕЛНО НЕ включват
водещи нули. Предварителните издания имат по-нисък приоритет от свързаната
основна версия. Предварителното издание показва, че версията е нестабилна
и може да не отговаря на предвидените изисквания за съвместимост, заявени
от свързаната с нея нормална версия. Примери:
1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nПредварително издание (pre-release) МОЖЕ да бъде обозначено веднага след
версията на кръпката чрез добавяне на тире, следвано от разделени с точки
идентификатори. Те ЗАДЪЛЖИТЕЛНО съдържат само ASCII буквено-цифрови
последователности и тире [0-9A-Za-z-]. Идентификаторите ЗАДЪЛЖИТЕЛНО НЕ
трябва да са празни. Числовите идентификатори ЗАДЪЛЖИТЕЛНО НЕ включват
водещи нули. Предварителните издания имат по-нисък приоритет от свързаната
основна версия. Предварителното издание показва, че версията е нестабилна
и може да не отговаря на предвидените изисквания за съвместимост, заявени
от свързаната с нея нормална версия. Примери:
1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nБилд-метаданни МОЖЕ да бъдат обозначени чрез добавяне
на знак плюс и серия от разделени с точка идентификатори непосредствено след
версията на кръпка или на предварителното издание. Идентификаторите ЗАДЪЛЖИТЕЛНО
съдържат само ASCII буквено-цифрови последователности и тире [0-9A-Za-z-].
Идентификаторите ЗАДЪЛЖИТЕЛНО НЕ трябва да са празни. Билд-метаданните
ЗАДЪЛЖИТЕЛНО се игнорират при определяне на приоритета на версията. По
този начин две версии, които се различават само в билд-метаданните са с
еднакъв приоритет. Примери:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nБилд-метаданни МОЖЕ да бъдат обозначени чрез добавяне
на знак плюс и серия от разделени с точка идентификатори непосредствено след
версията на кръпка или на предварителното издание. Идентификаторите ЗАДЪЛЖИТЕЛНО
съдържат само ASCII буквено-цифрови последователности и тире [0-9A-Za-z-].
Идентификаторите ЗАДЪЛЖИТЕЛНО НЕ трябва да са празни. Билд-метаданните
ЗАДЪЛЖИТЕЛНО се игнорират при определяне на приоритета на версията. По
този начин две версии, които се различават само в билд-метаданните са с
еднакъв приоритет. Примери:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nПриоритетът определя как версиите се нареждате една спрямо друга.
При изчисление на приоритетът, версията ЗАДЪЛЖИТЕЛНО се разделя на ГЛАВНА, ВТОРОСТЕПЕННА,
КРЪПКА и идентификатори за предварително издание в този ред (билд-метаданните
се пренебрегват при определянето му). Подредбата се определя от първата разлика
при сравняване на всеки от тези компоненти отляво надясно, както следва:
Главните, второстепенните и версиите на кръпките винаги се сравняват като числа.
Пример: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Когато всички те са еднакви, версията
с предварително издание има по-нисък приоритет от основната версия.
Пример: 1.0.0-alpha < 1.0.0. Приоритет за две версии с предварително издание
(при еднакви ГЛАВНА, ВТОРОСТЕПЕННА и КРЪПКА) ЗАДЪЛЖИТЕЛНО се определя чрез
сравняване на всеки един идентификатор отляво надясно, докато
не се установи разлика, както следва: идентификаторите, състоящи се само от цифри,
се сравняват цифрово, а идентификаторите с букви или тиретата се сравняват
лексикално в ред на сортиране по ASCII. Цифровите идентификатори винаги имат
по-нисък приоритет от текстовите. По-голям набор от полета на предварителното
издание има по-висок приоритет, ако всички предходни идентификатори са равни.
Пример: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nПриоритетът определя как версиите се нареждате една спрямо друга.
При изчисление на приоритетът, версията ЗАДЪЛЖИТЕЛНО се разделя на ГЛАВНА, ВТОРОСТЕПЕННА,
КРЪПКА и идентификатори за предварително издание в този ред (билд-метаданните
се пренебрегват при определянето му). Подредбата се определя от първата разлика
при сравняване на всеки от тези компоненти отляво надясно, както следва:
Главните, второстепенните и версиите на кръпките винаги се сравняват като числа.
Пример: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Когато всички те са еднакви, версията
с предварително издание има по-нисък приоритет от основната версия.
Пример: 1.0.0-alpha < 1.0.0. Приоритет за две версии с предварително издание
(при еднакви ГЛАВНА, ВТОРОСТЕПЕННА и КРЪПКА) ЗАДЪЛЖИТЕЛНО се определя чрез
сравняване на всеки един идентификатор отляво надясно, докато
не се установи разлика, както следва: идентификаторите, състоящи се само от цифри,
се сравняват цифрово, а идентификаторите с букви или тиретата се сравняват
лексикално в ред на сортиране по ASCII. Цифровите идентификатори винаги имат
по-нисък приоритет от текстовите. По-голям набор от полета на предварителното
издание има по-висок приоритет, ако всички предходни идентификатори са равни.
Пример: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nБакус-Наур форма на граматиката за валидни SemVer версии\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nЗащо да използвате „Семантично версиониране“\nТова не е нова или революционна идея. Всъщност вероятно вече използвате нещо
подобно. Проблемът е, че „подобно“ не е достатъчно еднозначно. Без
съответствие с някаква официална спецификация, номерата на версиите са
по същество безполезни за управление на зависимости. Като бъдат наречени и ясно
определени, става лесно да заявите вашите намерения пред потребителите
на вашия софтуер. След като тези намерения са ясни и гъвкави (но не твърде),
спецификациите за зависимости най-накрая могат да бъдат направени.\nПрост пример ще демонстрира как „Семантично версиониране“ може да изпрати „адът
на зависимостите“ в миналото. Представете си библиотека, наречена „Пожарна кола“.
Тя изисква пакет използващ „Семантично версиониране“, наречен „Стълба“. По времето,
когато „Пожарна кола“ е създадена, „Стълба“ е версия 3.1.0. Тъй като „Пожарна кола“
използва известна функционалност, представена за първи път в 3.1.0, можете
спокойно да заявите зависимост от „Стълба“, версия по-голяма или равна на 3.1.0,
но по-малка от 4.0.0. Сега, кога основни версии 3.1.1 и 3.2.0 стават достъпни,
можете да ги интегрирате с вашата система, знаейки, че те ще бъдат съвместими
със текущата функционалност.\nКато отговорен разработчик, разбира се, ще искате да проверите, че обновения пакет
се държи според очакванията. Реалният свят е хаотичен; нищо не може да се направи
по въпроса, освен да сме бдителни. Това, което може да се направи, е да оставите
„Семантично версиониране“ да ви предоставя разумен начин за издаване и надграждане на
пакети, без да се налага да го правите при всяка промяна на зависимости,
спестявайки ви време и нерви.\nЗа да се възползвате от описаното до тук, трябва просто да
заявите, че използвате „Семантично версиониране“ и да следвате правилата.
Поставете връзка към този уеб сайт във вашия README файл, така че значението на
промените във версията да бъде ясно за всички.\nЧесто задавани въпроси\nКакво да правя с версиите в началната фаза на разработка 0.y.z\nПросто започнете първоначалната си версия от 0.1.0 и след това увеличавайте
второстепенната версия за всяко следващо издание.\nКак да разбера кога да издам 1.0.0\nАко вашият софтуер се използва в производствена среда, вероятно вече трябва
да бъде 1.0.0. Ако имате стабилен API, от който потребителите зависят,
трябва да е 1.0.0. Ако се притеснявате много за обратната съвместимост, вероятно
вече трябва да е 1.0.0.\nТова не възпрепятства ли бързата разработка и кратките итерации\nГлавната версия 0 е свързана с бързата разработка. Ако променяте API
всеки ден, трябва или да бъдете във версия 0.y.z, или да използвате отделен
клон за работата върху следващото главно издание.\nАко дори и най-малките обратно несъвместими промени в публичния API изискват промяна в главната версия, няма ли много скоро да стигнем 42.0.0\nТова е въпрос на отговорно развитие и предвидливост. Несъвместими
промени не трябва да се въвеждат с лека ръка в софтуер, от който зависят
много проекти. Цената на такова надграждане може да бъде значителна.
Това, че трябва да се увеличи главната версия, за да се издадат несъвместими
промени, означава, че ще обмислите последствията от промените
и ще отчетете съотношението цена/полза.\nДокументирането на целия публичен API е твърде много работа\nВаша отговорност като професионален разработчик е качественото документиране на
софтуера, предназначен за широко използване. Управлението на сложността
на софтуера е изключително важна част от поддържането на ефективен проект.
Това е трудно да се направи, ако никой не знае как се използва вашия
софтуер или какви методи могат да бъдат извиквани безопасно. В дългосрочен план,
„Семантичното версиониране“ и настойчивостта за качествено документиране на публичния
API помага за безпроблемната работа.\nКакво да направя, ако случайно пусна обратно несъвместима промяна като второстепенна версия\nВеднага щом разберете, че сте нарушили спецификацията на SemVer, поправете
проблема и пуснете нова вторична версия, която коригира проблема и
възстановява обратната съвместимост. Дори и в такава ситуация е неприемливо
да подменяте вече издадена версия. Ако е подходящо, документирайте некоректната
версия и информирайте потребителите си за проблема с обратната съвместимост в нея.\nКакво трябва да направя, ако обновя собствените си зависимости, без да променя публичния API\nТова може да се разглежда като съвместимо изменение, тъй като не засяга
публичния API. Софтуер, който има същите зависимости като вашия
пакет трябва да има свои спецификации за зависимост и авторът да забележи
евентуални конфликти. За определяне дали промяната е ниво на кръпка или
второстепенна модификация зависи от това дали сте актуализирали зависимостите си,
за да коригирате грешка или да въведете нова функционалност. Обикновено за второто
е очакван допълнителен код, при което следва да се промени второстепенната версия.\nКакво става, ако по невнимание променя публичния API по начин, който не е съвместим с промяната на номера на версията (тоест кодът неправилно въвежда голяма промяна в версията на кръпка)\nИзползвайте най-добрата си преценка. Ако имате огромна публика, която ще бъде драстично
засегната от промяната на поведението към това, което е планирано в публичният API
може би е най-добре да извършите издание на главна версия, въпреки че поправката може
строго погледнато да се счита за издаване на кръпка. Не забравяйте, че „Семантично
версиониране“ се стреми строго да следва спецификациите. Ако тези промени са важни
за вашите потребители, използвайте номера на версията, за да ги информирате.\nКак се оттегля функционалност (deprecating)\nОттеглянето на съществуващата функционалност е нормална част от разработката
на софтуер и често се изисква за постигне на напредък. Когато оттегляте част
от вашия обществен API, трябва да направите две неща: (1) обновете документацията
си информирайки потребителите за промяната, (2) направете ново незначително издание
с оттеглянето. Преди да премахнете напълно функционалността в нова главна версия
трябва да има поне едно второстепенно издание, което съдържа оттеглянето, така че
че потребителите могат плавно да преминат към новия API.\nИма ли SemVer ограничение на дължината на версията\nНе, но използвайте добра преценка. Например, вероятно е излишно версията да е дълга 255
символа. Също така, специфичните системи могат да налагат свои собствени
ограничения за дължината на низа.\n„v1.2.3“ семантично-зададена версия ли е\nНе, „v1.2.3“ не е семантично-зададена версия. Префиксиране на семантично-зададена
версия с „v“ е често срещан начин (на английски език) да се посочи, че става дума
за номер на версия. Съкращаването „версия“ като „v“ често се наблюдава при
системи за контрол на версиите. Пример:
git tag v1.2.3 -m "Release version 1.2.3", в случая „v1.2.3“ е маркер,
а семантично-зададената версия е „1.2.3“.\nИма ли регулярни изрази (RegEx) за проверка на дали даден низ отговаря на SemVer спецификацията\nСъществуват два такива израза. Първият е за системи поддържащи PCRE
(Perl Compatible Regular Expressions, тоест Perl, PHP и R), Python и Go.\nВижте: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nДругият използва номерирани групи (при него cg1 = ГЛАВНА, cg2 = ВТОРОСТЕПЕННА,
cg3 = КРЪПКА, cg4 = предварително издание и cg5 = билд-метаданни) и е
съвместим с ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
тоест Perl, PHP и R), Python и Go.\nВижте: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nАвтор на спецификацията „Семантично версиониране“ (SemVer) е
Том Престон-Вернер, основател на Gravatars и
съучредител на GitHub.\nЗа обратна връзка, моля създайте запитване в
GitHub.\nсъздайте запитване в
GitHub\nCreative Commons — CC BY 3.0\nCreative Commons — CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nGestió semàntica de versions 2.0.0

Sumari

Donat un nombre de versió MAJOR.MINOR.PATCH, heu d’incrementar:


  el nombre de versió MAJOR quan hi hagi canvis incompatibles a l’API,
  el nombre de versió MINOR quan hi hagi canvis compatibles amb versions anteriors, i
  el nombre de versió PATCH quan hi hagi correccions o pedaços compatibles amb versions anteriors.


Es poden afegir etiquetes addicionals per a versions preliminars i metadades de compilació com a extensió del format MAJOR.MINOR.PATCH.

Introducció

Al món de la gestió del programari hi ha un lloc temut anomenat “l’infern de
les dependències” (de l’anglès “dependency hell”). Com més gran creixi el vostre
sistema i més components hi integreu, més probable serà que us trobeu, algun
dia, en aquest abisme de desesperació.

En sistemes amb moltes dependències, publicar la versió d’un nou component pot
esdevenir ràpidament un malson. Si les regles de dependència són massa
estrictes, us podeu trobar en el perill de blocar les vostres versions, (la
incapacitat d’actualitzar un component sense haver de publicar una nova
versió de cada component que en depèn d’ell). En canvi, si les regles de
dependència són massa toves, inevitablement patireu la promiscuïtat de versions
(mantenir una compatibilitat amb més versions futures del que seria raonable).
L’infern de les dependències és quan el bloqueig o la promiscuïtat de versions
us impedeixen avançar el vostre projecte de manera fàcil i sense riscos.

Com a solució a aquest problema, proposo un conjunt de regles i requisits
senzills que dicten com s’assignen i incrementen els nombres de versions.
Aquestes regles es basen, però no es limiten necessàriament, en pràctiques
generalitzades en programari privat i lliure. Perquè aquest sistema funcioni,
primer heu de declarar una API pública. Pot consistir en un document o en les
normes imposades pel propi codi. Tanmateix, és important que aquesta API
sigui clara i precisa. Un cop l’hàgiu enllestida, comuniqueu els canvis que
hi feu amb increments específics en el nombre de versió. Considerant el format
de la versió X.Y.Z (Major.Minor.Patch): quan les correccions o pedaços no
afectin l’API s’ha d’incrementar la versió de correcció (‘patch’), quan s’hi
afegeixin canvis i/o millores que tampoc afectin l’API s’ha d’incrementar la versió
menor (‘minor’), i quan els canvis afectin la compatibilitat de l’API amb versions
anteriors s’ha d’incrementar la versió principal (‘major’).

Jo anomeno aquest sistema “gestió semàntica de versions”. Amb aquest sistema,
els nombres de versió i la manera com canvien donen sentit al codi subjacent
i a tot allò que s’ha modificat d’una versió a una altra.

Especificació de la gestió semàntica de versions (SemVer)

Les paraules clau “HA DE” (“MUST”, “REQUIRED” i “SHALL”), “NO HA DE” (“MUST
NOT” i “SHALL NOT”), “HAURIA DE” (“SHOULD” i “RECOMMENDED”) i “POT” (“MAY i
“OPTIONAL”) d’aquest document han de ser interpretades tal i com es descriuen
en el document RFC 2119.


  
    Tot programari que utilitzi la gestió semàntica de versions HA DE declarar
una API pública. Aquesta API es pot declarar en el mateix codi o en un document.
En qualsevol cas, ha de ser precisa i comprensible.
  
  
    Un nombre de versió normal HA DE tenir la forma X.Y.Z on X, Y i Z representen
nombres enters no negatius, i NO HAN DE ser prefixats amb zeros. X representa
l’identificador de versió principal (‘major’), Y representa l’identificador de
versió menor (‘minor’) i Z l’identificador de versió de correcció (‘patch’). Cada
element HA DE ser augmentat numèricament. Per exemple: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Un cop es publica una nova versió d’un component, el contingut d’aquesta versió
NO HA DE ser modificat. Qualsevol canvi HA DE ser publicat en una nova versió.
  
  
    L’identificador de versió principal (‘major’) a zero (0.y.z) és per al
desenvolupament inicial. Vol dir que qualsevol cosa pot canviar en qualsevol
moment. En aquest punt, l’API pública no hauria de considerar-se estable.
  
  
    La versió 1.0.0 defineix l’API pública. La forma en què el nombre de versió
s’incrementi després d’aquesta publicació dependrà d’aquesta API pública i
de les seves evolucions.
  
  
    L’identificador de versió de correcció (‘patch’) Z (x.y.Z | x > 0) HA DE ser
incrementat si només s’introdueixen correccions compatibles amb les versions
anteriors. Una correcció es defineix com un canvi intern que corregeix un
comportament incorrecte.
  
  
    L’identificador de versió menor (‘minor’) Y (x.Y.z | x > 0) HA DE ser
incrementat si s’introdueixen a l’API pública noves funcionalitats compatibles
amb versions anteriors. També HA DE ser incrementat si es tracta d’una funcionalitat
marcada com a obsoleta a l’API pública. Es POT incrementar si s’introdueixen noves
funcionalitats o millores substancials en el codi privat. POT incloure alhora
petites correccions. L’identificador de versió de correcció (‘patch’)
s’HA DE posar a 0 quan s’incrementi l’identificador de versió menor (‘minor’).
  
  
    L’identificador de versió principal (‘major’) X (X.y.z | X > 0) HA DE ser
incrementat si s’introdueixen canvis no compatibles amb versions anteriors de
l’API pública. POT incloure alhora petits canvis i correccions. Els identificadors
de versió menor (‘minor’) i de correcció (‘patch’) s’HAN DE posar a 0 quan
s’incrementi l’identificador de versió principal (‘major’).
  
  
    Es POT marcar una versió de pre-llançament afegint un guió i una sèrie
d’identificadors separats per punts immediatament després de l’identificador
de versió de correcció (‘patch’). Aquests identificadors HAN DE consistir
únicament en guions i caràcters ASCII alfanumèrics [0-9A-Za-z-]. Aquests
identificadors NO HAN D’estar buits. Els identificadors numèrics NO HAN DE
ser prefixats amb zeros. Les versions de pre-llançament precedeixen la versió
normal associada. Una versió de pre-llançament indica que la versió
no és estable i no necessàriament compleix els requisits de compatibilitat
associat a una versió normal. Exemples: 1.0.0-alpha, 1.0.0-alpha.1,
1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Les metadades de compilació es PODEN marcar afegint un signe més i una sèrie
d’identificadors separats per punts immediatament després de l’identificador
de versió de correcció (‘patch’) o de pre-llançament. Aquests identificadors HAN DE
consistir únicament en guions i caràcters ASCII alfanumèrics [0-9A-Za-z-]. Aquests
identificadors NO HAN D’estar buits. Les metadades de la compilació HAURIEN DE ser
ignorades quan es determini l’ordre de les versions. Per tant, dues versions que
difereixen només per la seva informació de compilació tenen la mateixa prioritat.
Exemples: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    La prioritat o precedència defineix com s’ordenen les versions entre sí. La
prioritat HA DE ser calculada separant els identificadors de la versió entre
principal, menor, correcció i pre-llançament, seguint aquest ordre. (La informació
de compilació no compta durant la comparació). La prioritat es determina per la
primera diferència que apareix a la comparació de cadascun d’aquests identificadors
en l’ordre: principal, menor i correcció. Aquests identificadors sempre es comparen
numèricament. Exemple: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Quan els identificadors
principal, menor i correcció són idèntics, una versió de pre-llançament té menor
prioritat que una versió normal. Exemple: 1.0.0-alpha < 1.0.0. La prioritat de
dues versions de pre-llançament amb els mateixos identificadors principal, menor
i correcció HA DE ser determinada mitjançant la comparació de cadascun dels
identificadors separats per un punt, d’esquerra a dreta fins que es trobi la
diferència, de la següent manera: els identificadors compostos només de nombres
es comparen numèricament, i els identificadors que contenen lletres o guions es
comparen en ordre ASCII. Els identificadors numèrics sempre són menys importants
que els identificadors no numèrics. Un conjunt més llarg d’identificadors de
pre-llançament té major prioritat sobre un conjunt més curt, si tots els identificadors
anteriors són idèntics. Exemple: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta <
1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Per què utilitzar la gestió semàntica de versions?

No és pas una idea nova o revolucionària. De fet, probablement ja esteu fent
alguna cosa semblant. El problema és que això ‘semblant’ no és prou bo. Sense
el compliment d’un mètode els nombres de versió no es poden utilitzar per la
gestió de dependències. Pel sol fet de donar un nom i una definició clares a
les idees que s’han mostrat a dalt, es fa fàcil comunicar les vostres
intencions als usuaris del vostre programari. Un cop aquestes intencions són
clares i flexibles (però no gaire flexibles) es pot dur a terme l’especificació
de dependències.

Un senzill exemple pot mostrar com la gestió semàntica de versions pot fer que
l’infern de les dependències sigui una cosa del passat. Considera una llibreria
anomenada “CamióDeBombers”. Requereix un component anomenat “Escala”, el qual
tracte les versions de forma semàntica. Quan es crea la llibreria CamióDeBombers,
l’Escala és a la versió 3.1.0. Atès que CamióDeBombers utilitza funcions que es
van introduir a la versió 3.1.0, podeu especificar, sense cap risc, una
dependència de l’Escala superior o igual a 3.1.0 però inferior a 4.0.0. Ara,
quan les versions 3.1.1 i 3.2.0 de l’Escala estan disponibles, podeu publicar-les
al vostre sistema de gestió de dependències i sabreu que seran compatibles amb
el programari existent que en depèn d’elles.

Com a desenvolupador responsable, voldreu verificar evidentment que qualsevol
actualització del component funciona tal i com s’anuncia. El món real és un
merder; no hi ha res que puguem fer excepte estar a l’aguait. El que podeu fer,
però, és deixar que la gestió semàntica de versions us proporcioni una manera
saludable de publicar i actualitzar els vostres components, sense haver
d’implementar noves versions de components dependents, estalviant-vos temps i
esforç.

Si tot això us sona bé, tot el que heu de fer per començar a utilitzar la gestió
semàntica de la versions és declarar que ho feu i llavors seguiu les regles.
Afegiu un enllaç a aquest lloc web al vostre fitxer README i així altres podran
conèixer les regles i beneficiar-se’n.

FAQ

Com hauria de gestionar les revisions en la fase inicial de desenvolupament 0.y.z?

El més fàcil de fer és començar els teus desenvolupaments amb la versió 0.1.0 i,
a continuació, incrementar l’identificador de versió menor a cada nova publicació.

Com sé quan he de llançar la versió 1.0.0?

Si el vostre programari s’utilitza en un entorn de producció, ja hauríeu d’estar
a la versió 1.0.0. Si teniu una API estable a partir de la qual els usuaris han
començat a dependre’n, ja hauríeu d’estar a la versió 1.0.0. Si us amoïna molt la
compatibilitat amb versions anteriors, ja hauríeu d’estar a la versió 1.0.0.

No desincentiva tot això el ràpid desenvolupament i les iteracions curtes?

La versió principal (‘major’) a 0 es fa precisament per tenir un desenvolupament
ràpid. Si canvieu l’API cada dia hauríeu de ser a la versió 0.y.z o en una branca
de desenvolupament independent que acabarà sent la nova versió principal.

Si fins i tot el canvi més petit a l’API pública no compatible amb versions anteriors requereix augmentar l’identificador de versió principal, no arribaré a la versió 42.0.0 massa ràpidament?

Es tracta d’un desenvolupament responsable i d’una anticipació. Els canvis
incompatibles no s’han d’introduir a la lleugera en un programari amb un
gran nombre de codi font depenent. El cost d’una actualització a una nova versió
pot ser important. La necessitat d’augmentar la versió principal per publicar
els canvis que no siguin compatibles amb versions anteriors, significa que
haureu mesurat les implicacions dels canvis i avaluada la relació entre el seu
cost i els seus beneficis.

Documentar tota l’API pública demana massa feina!

És la vostra responsabilitat com a desenvolupador professional documentar
correctament el programari que altres usuaris pensen utilitzar. Gestionar la
complexitat d’un programari és una part immensament important per mantenir
un projecte eficient, i es fa difícil de fer quan ningú no sap com utilitzar
el vostre programari, o quins són els mètodes adequats per cridar. A la llarga
la gestió semàntica de versions, i els esforços en la conservació d’una
API pública ben definida permetrà que tots puguem avançar sense problemes.

Què he de fer si accidentalment publico un canvi no compatible amb versions anteriors com una versió menor?

Tan bon punt us adoneu que heu trencat la gestió semàntica de la vostra versió,
corregiu el problema i publiqueu una nova versió menor que restauri la
compatibilitat amb versions anteriors. Fins i tot en aquestes circumstàncies,
és inacceptable modificar una versió ja publicada. Actualitzeu, si cal, la
documentació informant sobre la versió defectuosa i informeu als vostres usuaris
d’aquest problema.

Què he de fer si actualitzo les meves pròpies dependències sense canviar l’API pública?

Això es pot considerar compatible ja que no afecta l’API pública. El programari
que depèn de les mateixes dependències que el vostre component hauria de tenir
la seva pròpia especificació de dependència i l’autor també s’adonarà de
qualsevol conflicte. Per determinar si el canvi és una correcció o un canvi
menor, heu de preguntar-vos si heu actualitzat les vostres dependències per
corregir un error o per introduir una nova característica. En general, esperaria
afegir codi nou en la segona opció, cosa que implica òbviament un increment de
l’identificador de versió menor.

Què passa si canvio l’API pública de forma involuntària de manera que no coincideix amb el canvi de nombre de versió (per exemple: el codi introdueix per error un canvi que trenca la versió major en un llançament de versió de correcció)?

Feu servir el seny. Si teniu un gran públic que es veurà afectat dràsticament pel
canvi de comportament de l’API pública respecte el que hauria de fer, llavors pot
ser preferible llançar una nova versió principal (‘major’), encara que aquesta
versió es pugui considerar una versió de correcció. Recordeu, la gestió semàntica
de versions és bàsicament per transmetre significats en la forma en què canvia el
nombre de versió. Si aquests canvis són importants per als vostres usuaris,
utilitzeu els nombres de versió per informar-los.

Com he de gestionar les funcionalitats obsoletes?

La obsolescència de funcionalitats existents és una part normal del desenvolupament
del programari i molt sovint es fa necessari per avançar. Quan desaproveu
una part de la vostra API pública, heu de fer dues coses: (1) actualitzar la
documentació per informar els usuaris del canvi, (2) publicar una nova versió
menor amb la part desaprovada. Abans d’eliminar completament la funcionalitat
en un nou llançament de versió important (‘major’), hauria d’haver almenys una
versió menor que contingui la desaprovació perquè els usuaris puguin transitar
sense problemes cap a la nova API.

La gestió semàntica de versions especifica un límit màxim per a la cadena del nombre de versió?

No, però feu servir el sentit comú. Per exemple, un nombre de versió de 255 caràcters
probablement sigui excessiu. A més, alguns sistemes poden imposar les seves pròpies
limitacions en aquesta mida.

Quant a

L’especificació de la gestió semàntica de versions està escrita per Tom
Preston-Werner, inventor de Gravatars i
cofundador de GitHub.

Traducció d’aquest document a càrrec de:

  Jordi Sanfeliu


Si voleu deixar comentaris, si us plau obre un tiquet a
GitHub.

Llicència

Creative Commons ― CC BY 3.0\nGestió semàntica de versions 2.0.0\nDonat un nombre de versió MAJOR.MINOR.PATCH, heu d’incrementar:\nel nombre de versió MAJOR quan hi hagi canvis incompatibles a l’API,\nel nombre de versió MINOR quan hi hagi canvis compatibles amb versions anteriors, i\nel nombre de versió PATCH quan hi hagi correccions o pedaços compatibles amb versions anteriors.\nEs poden afegir etiquetes addicionals per a versions preliminars i metadades de compilació com a extensió del format MAJOR.MINOR.PATCH.\nAl món de la gestió del programari hi ha un lloc temut anomenat “l’infern de
les dependències” (de l’anglès “dependency hell”). Com més gran creixi el vostre
sistema i més components hi integreu, més probable serà que us trobeu, algun
dia, en aquest abisme de desesperació.\nEn sistemes amb moltes dependències, publicar la versió d’un nou component pot
esdevenir ràpidament un malson. Si les regles de dependència són massa
estrictes, us podeu trobar en el perill de blocar les vostres versions, (la
incapacitat d’actualitzar un component sense haver de publicar una nova
versió de cada component que en depèn d’ell). En canvi, si les regles de
dependència són massa toves, inevitablement patireu la promiscuïtat de versions
(mantenir una compatibilitat amb més versions futures del que seria raonable).
L’infern de les dependències és quan el bloqueig o la promiscuïtat de versions
us impedeixen avançar el vostre projecte de manera fàcil i sense riscos.\nCom a solució a aquest problema, proposo un conjunt de regles i requisits
senzills que dicten com s’assignen i incrementen els nombres de versions.
Aquestes regles es basen, però no es limiten necessàriament, en pràctiques
generalitzades en programari privat i lliure. Perquè aquest sistema funcioni,
primer heu de declarar una API pública. Pot consistir en un document o en les
normes imposades pel propi codi. Tanmateix, és important que aquesta API
sigui clara i precisa. Un cop l’hàgiu enllestida, comuniqueu els canvis que
hi feu amb increments específics en el nombre de versió. Considerant el format
de la versió X.Y.Z (Major.Minor.Patch): quan les correccions o pedaços no
afectin l’API s’ha d’incrementar la versió de correcció (‘patch’), quan s’hi
afegeixin canvis i/o millores que tampoc afectin l’API s’ha d’incrementar la versió
menor (‘minor’), i quan els canvis afectin la compatibilitat de l’API amb versions
anteriors s’ha d’incrementar la versió principal (‘major’).\nJo anomeno aquest sistema “gestió semàntica de versions”. Amb aquest sistema,
els nombres de versió i la manera com canvien donen sentit al codi subjacent
i a tot allò que s’ha modificat d’una versió a una altra.\nEspecificació de la gestió semàntica de versions (SemVer)\nLes paraules clau “HA DE” (“MUST”, “REQUIRED” i “SHALL”), “NO HA DE” (“MUST
NOT” i “SHALL NOT”), “HAURIA DE” (“SHOULD” i “RECOMMENDED”) i “POT” (“MAY i
“OPTIONAL”) d’aquest document han de ser interpretades tal i com es descriuen
en el document RFC 2119.\nTot programari que utilitzi la gestió semàntica de versions HA DE declarar
una API pública. Aquesta API es pot declarar en el mateix codi o en un document.
En qualsevol cas, ha de ser precisa i comprensible.\nTot programari que utilitzi la gestió semàntica de versions HA DE declarar
una API pública. Aquesta API es pot declarar en el mateix codi o en un document.
En qualsevol cas, ha de ser precisa i comprensible.\nUn nombre de versió normal HA DE tenir la forma X.Y.Z on X, Y i Z representen
nombres enters no negatius, i NO HAN DE ser prefixats amb zeros. X representa
l’identificador de versió principal (‘major’), Y representa l’identificador de
versió menor (‘minor’) i Z l’identificador de versió de correcció (‘patch’). Cada
element HA DE ser augmentat numèricament. Per exemple: 1.9.0 -> 1.10.0 -> 1.11.0.\nUn nombre de versió normal HA DE tenir la forma X.Y.Z on X, Y i Z representen
nombres enters no negatius, i NO HAN DE ser prefixats amb zeros. X representa
l’identificador de versió principal (‘major’), Y representa l’identificador de
versió menor (‘minor’) i Z l’identificador de versió de correcció (‘patch’). Cada
element HA DE ser augmentat numèricament. Per exemple: 1.9.0 -> 1.10.0 -> 1.11.0.\nUn cop es publica una nova versió d’un component, el contingut d’aquesta versió
NO HA DE ser modificat. Qualsevol canvi HA DE ser publicat en una nova versió.\nUn cop es publica una nova versió d’un component, el contingut d’aquesta versió
NO HA DE ser modificat. Qualsevol canvi HA DE ser publicat en una nova versió.\nL’identificador de versió principal (‘major’) a zero (0.y.z) és per al
desenvolupament inicial. Vol dir que qualsevol cosa pot canviar en qualsevol
moment. En aquest punt, l’API pública no hauria de considerar-se estable.\nL’identificador de versió principal (‘major’) a zero (0.y.z) és per al
desenvolupament inicial. Vol dir que qualsevol cosa pot canviar en qualsevol
moment. En aquest punt, l’API pública no hauria de considerar-se estable.\nLa versió 1.0.0 defineix l’API pública. La forma en què el nombre de versió
s’incrementi després d’aquesta publicació dependrà d’aquesta API pública i
de les seves evolucions.\nLa versió 1.0.0 defineix l’API pública. La forma en què el nombre de versió
s’incrementi després d’aquesta publicació dependrà d’aquesta API pública i
de les seves evolucions.\nL’identificador de versió de correcció (‘patch’) Z (x.y.Z | x > 0) HA DE ser
incrementat si només s’introdueixen correccions compatibles amb les versions
anteriors. Una correcció es defineix com un canvi intern que corregeix un
comportament incorrecte.\nL’identificador de versió de correcció (‘patch’) Z (x.y.Z | x > 0) HA DE ser
incrementat si només s’introdueixen correccions compatibles amb les versions
anteriors. Una correcció es defineix com un canvi intern que corregeix un
comportament incorrecte.\nL’identificador de versió menor (‘minor’) Y (x.Y.z | x > 0) HA DE ser
incrementat si s’introdueixen a l’API pública noves funcionalitats compatibles
amb versions anteriors. També HA DE ser incrementat si es tracta d’una funcionalitat
marcada com a obsoleta a l’API pública. Es POT incrementar si s’introdueixen noves
funcionalitats o millores substancials en el codi privat. POT incloure alhora
petites correccions. L’identificador de versió de correcció (‘patch’)
s’HA DE posar a 0 quan s’incrementi l’identificador de versió menor (‘minor’).\nL’identificador de versió menor (‘minor’) Y (x.Y.z | x > 0) HA DE ser
incrementat si s’introdueixen a l’API pública noves funcionalitats compatibles
amb versions anteriors. També HA DE ser incrementat si es tracta d’una funcionalitat
marcada com a obsoleta a l’API pública. Es POT incrementar si s’introdueixen noves
funcionalitats o millores substancials en el codi privat. POT incloure alhora
petites correccions. L’identificador de versió de correcció (‘patch’)
s’HA DE posar a 0 quan s’incrementi l’identificador de versió menor (‘minor’).\nL’identificador de versió principal (‘major’) X (X.y.z | X > 0) HA DE ser
incrementat si s’introdueixen canvis no compatibles amb versions anteriors de
l’API pública. POT incloure alhora petits canvis i correccions. Els identificadors
de versió menor (‘minor’) i de correcció (‘patch’) s’HAN DE posar a 0 quan
s’incrementi l’identificador de versió principal (‘major’).\nL’identificador de versió principal (‘major’) X (X.y.z | X > 0) HA DE ser
incrementat si s’introdueixen canvis no compatibles amb versions anteriors de
l’API pública. POT incloure alhora petits canvis i correccions. Els identificadors
de versió menor (‘minor’) i de correcció (‘patch’) s’HAN DE posar a 0 quan
s’incrementi l’identificador de versió principal (‘major’).\nEs POT marcar una versió de pre-llançament afegint un guió i una sèrie
d’identificadors separats per punts immediatament després de l’identificador
de versió de correcció (‘patch’). Aquests identificadors HAN DE consistir
únicament en guions i caràcters ASCII alfanumèrics [0-9A-Za-z-]. Aquests
identificadors NO HAN D’estar buits. Els identificadors numèrics NO HAN DE
ser prefixats amb zeros. Les versions de pre-llançament precedeixen la versió
normal associada. Una versió de pre-llançament indica que la versió
no és estable i no necessàriament compleix els requisits de compatibilitat
associat a una versió normal. Exemples: 1.0.0-alpha, 1.0.0-alpha.1,
1.0.0-0.3.7, 1.0.0-x.7.z.92.\nEs POT marcar una versió de pre-llançament afegint un guió i una sèrie
d’identificadors separats per punts immediatament després de l’identificador
de versió de correcció (‘patch’). Aquests identificadors HAN DE consistir
únicament en guions i caràcters ASCII alfanumèrics [0-9A-Za-z-]. Aquests
identificadors NO HAN D’estar buits. Els identificadors numèrics NO HAN DE
ser prefixats amb zeros. Les versions de pre-llançament precedeixen la versió
normal associada. Una versió de pre-llançament indica que la versió
no és estable i no necessàriament compleix els requisits de compatibilitat
associat a una versió normal. Exemples: 1.0.0-alpha, 1.0.0-alpha.1,
1.0.0-0.3.7, 1.0.0-x.7.z.92.\nLes metadades de compilació es PODEN marcar afegint un signe més i una sèrie
d’identificadors separats per punts immediatament després de l’identificador
de versió de correcció (‘patch’) o de pre-llançament. Aquests identificadors HAN DE
consistir únicament en guions i caràcters ASCII alfanumèrics [0-9A-Za-z-]. Aquests
identificadors NO HAN D’estar buits. Les metadades de la compilació HAURIEN DE ser
ignorades quan es determini l’ordre de les versions. Per tant, dues versions que
difereixen només per la seva informació de compilació tenen la mateixa prioritat.
Exemples: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nLes metadades de compilació es PODEN marcar afegint un signe més i una sèrie
d’identificadors separats per punts immediatament després de l’identificador
de versió de correcció (‘patch’) o de pre-llançament. Aquests identificadors HAN DE
consistir únicament en guions i caràcters ASCII alfanumèrics [0-9A-Za-z-]. Aquests
identificadors NO HAN D’estar buits. Les metadades de la compilació HAURIEN DE ser
ignorades quan es determini l’ordre de les versions. Per tant, dues versions que
difereixen només per la seva informació de compilació tenen la mateixa prioritat.
Exemples: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nLa prioritat o precedència defineix com s’ordenen les versions entre sí. La
prioritat HA DE ser calculada separant els identificadors de la versió entre
principal, menor, correcció i pre-llançament, seguint aquest ordre. (La informació
de compilació no compta durant la comparació). La prioritat es determina per la
primera diferència que apareix a la comparació de cadascun d’aquests identificadors
en l’ordre: principal, menor i correcció. Aquests identificadors sempre es comparen
numèricament. Exemple: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Quan els identificadors
principal, menor i correcció són idèntics, una versió de pre-llançament té menor
prioritat que una versió normal. Exemple: 1.0.0-alpha < 1.0.0. La prioritat de
dues versions de pre-llançament amb els mateixos identificadors principal, menor
i correcció HA DE ser determinada mitjançant la comparació de cadascun dels
identificadors separats per un punt, d’esquerra a dreta fins que es trobi la
diferència, de la següent manera: els identificadors compostos només de nombres
es comparen numèricament, i els identificadors que contenen lletres o guions es
comparen en ordre ASCII. Els identificadors numèrics sempre són menys importants
que els identificadors no numèrics. Un conjunt més llarg d’identificadors de
pre-llançament té major prioritat sobre un conjunt més curt, si tots els identificadors
anteriors són idèntics. Exemple: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta <
1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nLa prioritat o precedència defineix com s’ordenen les versions entre sí. La
prioritat HA DE ser calculada separant els identificadors de la versió entre
principal, menor, correcció i pre-llançament, seguint aquest ordre. (La informació
de compilació no compta durant la comparació). La prioritat es determina per la
primera diferència que apareix a la comparació de cadascun d’aquests identificadors
en l’ordre: principal, menor i correcció. Aquests identificadors sempre es comparen
numèricament. Exemple: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Quan els identificadors
principal, menor i correcció són idèntics, una versió de pre-llançament té menor
prioritat que una versió normal. Exemple: 1.0.0-alpha < 1.0.0. La prioritat de
dues versions de pre-llançament amb els mateixos identificadors principal, menor
i correcció HA DE ser determinada mitjançant la comparació de cadascun dels
identificadors separats per un punt, d’esquerra a dreta fins que es trobi la
diferència, de la següent manera: els identificadors compostos només de nombres
es comparen numèricament, i els identificadors que contenen lletres o guions es
comparen en ordre ASCII. Els identificadors numèrics sempre són menys importants
que els identificadors no numèrics. Un conjunt més llarg d’identificadors de
pre-llançament té major prioritat sobre un conjunt més curt, si tots els identificadors
anteriors són idèntics. Exemple: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta <
1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPer què utilitzar la gestió semàntica de versions?\nNo és pas una idea nova o revolucionària. De fet, probablement ja esteu fent
alguna cosa semblant. El problema és que això ‘semblant’ no és prou bo. Sense
el compliment d’un mètode els nombres de versió no es poden utilitzar per la
gestió de dependències. Pel sol fet de donar un nom i una definició clares a
les idees que s’han mostrat a dalt, es fa fàcil comunicar les vostres
intencions als usuaris del vostre programari. Un cop aquestes intencions són
clares i flexibles (però no gaire flexibles) es pot dur a terme l’especificació
de dependències.\nUn senzill exemple pot mostrar com la gestió semàntica de versions pot fer que
l’infern de les dependències sigui una cosa del passat. Considera una llibreria
anomenada “CamióDeBombers”. Requereix un component anomenat “Escala”, el qual
tracte les versions de forma semàntica. Quan es crea la llibreria CamióDeBombers,
l’Escala és a la versió 3.1.0. Atès que CamióDeBombers utilitza funcions que es
van introduir a la versió 3.1.0, podeu especificar, sense cap risc, una
dependència de l’Escala superior o igual a 3.1.0 però inferior a 4.0.0. Ara,
quan les versions 3.1.1 i 3.2.0 de l’Escala estan disponibles, podeu publicar-les
al vostre sistema de gestió de dependències i sabreu que seran compatibles amb
el programari existent que en depèn d’elles.\nCom a desenvolupador responsable, voldreu verificar evidentment que qualsevol
actualització del component funciona tal i com s’anuncia. El món real és un
merder; no hi ha res que puguem fer excepte estar a l’aguait. El que podeu fer,
però, és deixar que la gestió semàntica de versions us proporcioni una manera
saludable de publicar i actualitzar els vostres components, sense haver
d’implementar noves versions de components dependents, estalviant-vos temps i
esforç.\nSi tot això us sona bé, tot el que heu de fer per començar a utilitzar la gestió
semàntica de la versions és declarar que ho feu i llavors seguiu les regles.
Afegiu un enllaç a aquest lloc web al vostre fitxer README i així altres podran
conèixer les regles i beneficiar-se’n.\nCom hauria de gestionar les revisions en la fase inicial de desenvolupament 0.y.z?\nEl més fàcil de fer és començar els teus desenvolupaments amb la versió 0.1.0 i,
a continuació, incrementar l’identificador de versió menor a cada nova publicació.\nCom sé quan he de llançar la versió 1.0.0?\nSi el vostre programari s’utilitza en un entorn de producció, ja hauríeu d’estar
a la versió 1.0.0. Si teniu una API estable a partir de la qual els usuaris han
començat a dependre’n, ja hauríeu d’estar a la versió 1.0.0. Si us amoïna molt la
compatibilitat amb versions anteriors, ja hauríeu d’estar a la versió 1.0.0.\nNo desincentiva tot això el ràpid desenvolupament i les iteracions curtes?\nLa versió principal (‘major’) a 0 es fa precisament per tenir un desenvolupament
ràpid. Si canvieu l’API cada dia hauríeu de ser a la versió 0.y.z o en una branca
de desenvolupament independent que acabarà sent la nova versió principal.\nSi fins i tot el canvi més petit a l’API pública no compatible amb versions anteriors requereix augmentar l’identificador de versió principal, no arribaré a la versió 42.0.0 massa ràpidament?\nEs tracta d’un desenvolupament responsable i d’una anticipació. Els canvis
incompatibles no s’han d’introduir a la lleugera en un programari amb un
gran nombre de codi font depenent. El cost d’una actualització a una nova versió
pot ser important. La necessitat d’augmentar la versió principal per publicar
els canvis que no siguin compatibles amb versions anteriors, significa que
haureu mesurat les implicacions dels canvis i avaluada la relació entre el seu
cost i els seus beneficis.\nDocumentar tota l’API pública demana massa feina!\nÉs la vostra responsabilitat com a desenvolupador professional documentar
correctament el programari que altres usuaris pensen utilitzar. Gestionar la
complexitat d’un programari és una part immensament important per mantenir
un projecte eficient, i es fa difícil de fer quan ningú no sap com utilitzar
el vostre programari, o quins són els mètodes adequats per cridar. A la llarga
la gestió semàntica de versions, i els esforços en la conservació d’una
API pública ben definida permetrà que tots puguem avançar sense problemes.\nQuè he de fer si accidentalment publico un canvi no compatible amb versions anteriors com una versió menor?\nTan bon punt us adoneu que heu trencat la gestió semàntica de la vostra versió,
corregiu el problema i publiqueu una nova versió menor que restauri la
compatibilitat amb versions anteriors. Fins i tot en aquestes circumstàncies,
és inacceptable modificar una versió ja publicada. Actualitzeu, si cal, la
documentació informant sobre la versió defectuosa i informeu als vostres usuaris
d’aquest problema.\nQuè he de fer si actualitzo les meves pròpies dependències sense canviar l’API pública?\nAixò es pot considerar compatible ja que no afecta l’API pública. El programari
que depèn de les mateixes dependències que el vostre component hauria de tenir
la seva pròpia especificació de dependència i l’autor també s’adonarà de
qualsevol conflicte. Per determinar si el canvi és una correcció o un canvi
menor, heu de preguntar-vos si heu actualitzat les vostres dependències per
corregir un error o per introduir una nova característica. En general, esperaria
afegir codi nou en la segona opció, cosa que implica òbviament un increment de
l’identificador de versió menor.\nQuè passa si canvio l’API pública de forma involuntària de manera que no coincideix amb el canvi de nombre de versió (per exemple: el codi introdueix per error un canvi que trenca la versió major en un llançament de versió de correcció)?\nFeu servir el seny. Si teniu un gran públic que es veurà afectat dràsticament pel
canvi de comportament de l’API pública respecte el que hauria de fer, llavors pot
ser preferible llançar una nova versió principal (‘major’), encara que aquesta
versió es pugui considerar una versió de correcció. Recordeu, la gestió semàntica
de versions és bàsicament per transmetre significats en la forma en què canvia el
nombre de versió. Si aquests canvis són importants per als vostres usuaris,
utilitzeu els nombres de versió per informar-los.\nCom he de gestionar les funcionalitats obsoletes?\nLa obsolescència de funcionalitats existents és una part normal del desenvolupament
del programari i molt sovint es fa necessari per avançar. Quan desaproveu
una part de la vostra API pública, heu de fer dues coses: (1) actualitzar la
documentació per informar els usuaris del canvi, (2) publicar una nova versió
menor amb la part desaprovada. Abans d’eliminar completament la funcionalitat
en un nou llançament de versió important (‘major’), hauria d’haver almenys una
versió menor que contingui la desaprovació perquè els usuaris puguin transitar
sense problemes cap a la nova API.\nLa gestió semàntica de versions especifica un límit màxim per a la cadena del nombre de versió?\nNo, però feu servir el sentit comú. Per exemple, un nombre de versió de 255 caràcters
probablement sigui excessiu. A més, alguns sistemes poden imposar les seves pròpies
limitacions en aquesta mida.\nL’especificació de la gestió semàntica de versions està escrita per Tom
Preston-Werner, inventor de Gravatars i
cofundador de GitHub.\nTraducció d’aquest document a càrrec de:\nSi voleu deixar comentaris, si us plau obre un tiquet a
GitHub.\nobre un tiquet a
GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSémantické verzování 2.0.0

Shrnutí

Číslo verzí zapisujeme ve formátu MAJOR.MINOR.PATCH
Navyšování jednotlivých čísel verzí probíhá následovně:


  MAJOR ― když nastala změna, která není zpětně kompatibilní s ostatními (API)
  MINOR ― když se přidá funkcionalita se zachováním zpětné kompatibility
  PATCH ― když se opravila chyba a zůstala kompatibilita


Pomocí předběžných verzí a přidáváním metadat je možné upřesnit informace. Např.: 1.0.0-alfa, 1.0.1-beta+2

Úvod

Ve světě softwaru, jeho vývoje a správy existuje děsivé místo, kterému anglicky říkáme „dependency hell“ (v překladu „peklo závislostí“). Čím větší a komplexnější váš projekt je, tím je větší šance, že se na tomto místě jednou ocitnete.

Když mají systémy mnoho závislostí, může se stát, že vydání nové verze je noční můrou pro obě strany. Pokud je specifikovaná závislost příliš striktní, hrozí, že zůstanete na jedné verzi (angl. „version lock“) a nebudete mít možnost přejít na další verzi bez toho, abyste vydali další verze všech balíčků nebo knihoven, na kterých projekt stojí. Na druhou stranu, když je specifikovaná závislost příliš volná, přijdete na to, že váš program je kompatibilní s více verzemi než je nutné a potřebné. V pekle závislostí se nacházíte, jakmile jste vázaný určitou verzí nebo v případně, že není přesně specifikován rozsah verzí, které máte použít. Taková situace brání v bezpečném vývoji kupředu.

Řešením tohoto problému je jednoduchý sled pravidel, které určují, jak budou čísla verzí přiřazována a navyšována. Tato pravidla jsou založena (ale nikoliv omezena) na již ověřené praxi a to ve vývoji otevřeného i uzavřeného softwaru. Pro správné fungování systému, si musíte nejdříve nadefinovat způsob, jakým se bude komunikovat s Vaší aplikací (dále API). Toto API může být nadefinováno pomocí rozsáhlé dokumentace nebo zapsáno přímo ve zdrojovém kódu. Nezáleží na způsobu zápisu, je důležité, aby bylo srozumitelné a snadno čitelné. Je třeba mít kompletní dokumentaci, způsob oznamovaní a čitelné rozdíly v nových verzích. Zápis verzí je ve formátu MAJOR.MINOR.PATCH. Opravy chyb, které nezměnily Vaše API, zvyšují číslo PATCH verze. Zpětně kompatibilní změny v API zvyšují hodnotu MINOR verze a rozdílné verze API, které nejsou zpětně kompatibilní, zvyšují číslo MAJOR verze.

Tímto způsobem je nastavený systém Sémantického verzování.

Specifikace Sémantického verzování (SemVer)

„MUSÍ“ (angl. MUST, REQUIRED, SHALL)
„NESMÍ“ (angl. MUST NOT, SHALL NOT)
„MĚLO BY“ (angl. SHOULD, RECOMMENDED)
„NEMĚLO BY“ (angl. SHOULD NOT)
„MŮŽE“ (angl. MAY, OPTIONAL)
(výrazy jsou interpretované z dokumentu: RFC 2119)


  
    Software používající Sémantické verzování, MUSÍ mít nadefinované API, buďto přímo ve zdrojovém kódu a nebo v externí dokumentaci. V obou případech to musí být hlavně přesné a komplexní.
  
  
    Číslo verzí MUSÍ být ve formátu X, Y, Z. Jedná se o celá nezáporná čísla, přičemž X se NESMÍ rovnat hodnotě nula. Může se rovnat nule jen v případě, kdy se jedná o počáteční vývoj. X je číslo MAJOR verze, Y je číslem MINOR verze a Z je číslem PATCH verze, přičemž každé číslo má svoji hodnotu a navyšují se zvlášť a standardně, např.1.9.0 => 1.10.0 => 1.11.0.
  
  
    Jakmile se vydá očíslovaná verze programu, NESMÍ se měnit a každá další úprava nebo oprava je vydána pod novou verzí.
  
  
    MAJOR verze s hodnotou 0 (0.y.z.) je určena pro počáteční vývoj. Cokoliv se může změnit a API v tomto formátu by NEMĚLO být považováno za stabilní.
  
  
    Verze 1.0.0 definuje veřejně vydané API. Způsob, jakým se dále navyšuje číslo verze je ovlivněné tímto API a jeho změnami.
  
  
    Číslo PATCH (Z) MUSÍ být navýšené jenom pokud byly implentované zpětně kompatibilní opravy chyb. Oprava chyb je definována jako interní změna opravující nežádoucí chování programu.
  
  
    Číslo MINOR (Y) MUSÍ být zvýšené, když byla do API přidána nová, zpětně kompatibilní funkcionalita nebo pokud byla jakákoliv funkcionalita odebrána (jako zastaralá) i pokud neovlivňuje samotný API kód. MŮŽE zahrnout i změnu PATCH verze. Číslo PATCH verze se musí vynulovat vždy, když se změní MINOR verze.
  
  
    Číslo MAJOR (X) MUSÍ být zvýšené, když byly přidané změny, které způsobily zpětnou nekompatibilitu. MŮŽE zahrnout i změny v rámci MINOR a PATCH verze. Číslo MINOR i PATCH se MUSÍ vynulovat vždy, když se změní MAJOR verze.
  
  
    Předběžné verze (angl. pre-release) MOHOU být označeny přidáním pomlčky a sérií identifikátorů oddělených tečkou hned za číslo PATCH verze. Identifikátory MUSÍ obsahovat pouze ASCII alfanumerické znaky a pomlčku [0-9A-Za-z-], NESMÍ být prázdné a číselné identifikátory NESMÍ obsahovat úvodní nulu. Předběžné verze mají nižší prioritu jako související normální verze. Předběžná verze je nestabilní a nemusí splňovat požadavky a závislosti jako normální verze. Např.: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Metadata MOHOU být označené ve verzi přidáním znaku plus (+) a sérií identifikátorů oddělených tečkou hned za číslo PATCH a nebo pomocí předběžné verze. Identifikátory MUSÍ obsahovat pouze ASCII alfanumerické znaky a pomlčku [0-9A-Za-z-], NESMÍ být prázdné a číselné identifikátory NESMÍ obsahovat úvodní nulu. Metadata by NEMĚLA hrát roli při volbě priority verze. Např.: verze 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85 mají všechny stejnou prioritu.
  
  
    Priorita se vztahuje na to, jak se verze vzájemně porovnávají. Priorita MUSÍ být určována rozdělením verze na MAJOR, MINOR, PATCH a identifikátory předběžných verzí ― přesně v tomto pořadí (s metadaty se nepočítá). Priorita je daná prvním rozdílem při porovnání zleva doprava přičemž čísla MAJOR, MINOR a PATCH jsou vždy porovnávána jako čísla. Např.: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Pokud jsou čísla MAJOR, MINOR a PATCH stejná, předběžná verze má menší prioritu, než normální. Např.: 1.0.0-alpha < 1.0.0. Priorita pro dvě předběžné verze, které se shodují v číslech MAJOR, MINOR a PATCH musí být počítána zleva doprava od tečky oddělených identifikátorů a to do doby, dokud se nenajde rozdíl a to následujícím způsobem: (1) Identifikátory obsahující pouze číslice, jsou porovnané číselně a identifikátory s písmeny nebo pomlčkami jsou porovnávané lexikálně, zařazené podle ASCII. (2) Číselné identifikátory mají vždy nižší prioritu jak nečíslené. (3) Jsou-li všechny předchozí identifikátory v předběžné verzi stejné, tak větší množství identifikátorů značí vyšší prioritu, než s menším počtem. Např.: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Proč používat Sémantické verzování?

Sémantické verzování není revoluční myšlenka a když vydáváte software, tak už pravděpodobně děláte něco podobného. Problém je, že „něco podobného“ nestačí. Bez dodržování daných formálních specifikací jsou čísla pro managment závislostí v podstatě na nic. Tím, že výše uvedeným myšlenkám dáváme přesnou a jasnou definici, je lehčí komunikovat záměry Vašeho softwaru jeho uživatelům. Jakmile jsou záměry jasné a flexibilní (ale ne příliš), specifikace závislostí může začít.

Následující příklad ilustruje, jak se díky Sémantickému verzování můžete snadno vyhnout problémům se závislostmi (tzv. „dependency hell“). Mějme knihovnou „Firetruck“ (česky požární vůz). Ta závisí na Sémanticky verzované knihovně „Ladder“ (česky žebřík). Ve době vzniku knihovny Firetruck je aktuální verze knihovny Ladder 3.1.0. Protože Firetruck využívá některé funkce knihovny Ladder, které do ni byly přidány až ve verzi 3.1.0, můžete bez rizika nadefinovat závislost na knihovně Ladder ve verzi vyšší nebo rovno 3.1.0 a menší než 4.0.0. Jakmile bude vydána verze Ladder 3.2.0, můžete se spolehnout na to, že s ní bude knihovna Firetruck kompatibilní.

Jako zodpovědní vývojáři určitě budete chtít kontrolovat, že všechno funguje podle Vašich předpokladů. Sématické verzování vám umožní rozumný způsob, jak vydávat a aktualizovat knihovny tak, abyste nemuseli řešit nové verze závislostí, ušetřili si čas a vyhnuli se zmatkům.

Pokud vám tyto argumenty připadají rozumné, všechno co potřebujete udělat pro začátek používání Sémantického verzování, je dát vědět, že to děláte, a následně dodržovali stanovená pravidla. Odkazem ze souboru README z vaší aplikace/softwaru na tyto stránky dejte ostatním vědět, jaká pravidla používáte. Přinese to užitek vám i uživatelům vašeho software nebo aplikace.

Často kladené otázky (FAQ)

Jak si poradit s verzemi 0.y.z. na začátku vývoje?

Nejjednodušším způsobem je začít vývoj na verzi 0.1.0. a potom zvyšovat MINOR verzi při každém dalším vydání softwaru.

Jak poznat, kdy vydat verzi 1.0.0?

Pokud se váš software již používá v produkci, už by pravděpodobně měl mít verzi 1.0.0. Jestli máte stabilní API, které už uživatelé mají mezi svými závislostmi, měli byste mít už verzi 1.0.0. Taktéž, když se obáváte o zpětnou kompatibilitu.

Neodrazuje to od rychlého vývoje?

MAJOR verze nula je o rychlém vývoji. Když každý den měníte API, stále byste měli být někde ve fázi 0.y.z nebo na separátní vývojové větvi, kde se připravuje následující MAJOR verze.

Pokud ty nejmenší zpětně nekompatibilní změny v API znamenají navýšení MAJOR verze, neskončíme poměrně rychle někde ve verzi 42.0.0?

To je otázka zodpovědného vývoje a prognóz. Nekompatibilní změny by neměly být v softwaru, který má mnoho závislostí, zavedeny jen tak. Náklady vynaložené na aktualizaci mohou být dost vysoké. To, že musíte vydat novou verzi MAJOR znamená, že jste si dobře promysleli dopad všech změn, výhody i následky.

Zdokumentovat celé API je strašně moc práce!

Je Vaší zodpovědností jako profesionálních vývojářů správně dokumentovat software, který je určený i pro ostatní. Spravování složitosti softwaru je velmi důležitá část, pokud chcete váš projekt udržovat efektivní. A to nebude možné, když nikdo nebude vědět, jak váš software používat nebo které metody je bezpečné volat. Z dlouhodobého hlediska se Sématické verzování a důraz na dobře definované API ukázaly jako správná volba, umožňující hladké i dlouhodobé fungování.

Co dělat, když vydám zpětně nekompatibilní verzi MINOR?

Jakmile zjistíte, že jste porušili pravidla Sémantického verzování, opravte problém a vydejte další MINOR verzi, která opět vrátí zpětnou kompatibilitu. I vzhledem na vzniklou situaci je nepřípustné, abyste měnili už vydanou verzi. Pokud je to možné a vhodné, informujte uživatele o špatné verzi, aby věděli, že se jedná o chybu a dané verzi se vyhnuli.

Co dělat, když jsem aktualizoval vlastní závislosti bez toho, aby se změnilo API?

Můžeme to považovat za kompatibilní, když to nijak neovlivnilo API. Software, který přesně závisí na balíčcích jako váš, by měl mít vlastní definici závislostí a jeho autor si všimne jakýchkoliv konfliktů. Rozhodnutí, zda se jedná o MINOR nebo PATCH závisí od toho, jestli jste upravili své závislosti kvůli nějaké chybě nebo proto, že jste přidali novou funkcionalitu. Pokud se jedná o druhý případ, očekává se, že přibude i nějaký kód a tím pádem se jedná o zvýšení MINOR verze.

Co když jsem nechtěně změnil API, způsobem, který není v souladě se změnou čísla verze (například jsem udělal MAJOR změnu v PATCH verzi)

Posuďte, co je nejlepší. Jestli máte velkou skupinu uživatelů, která by byla ovlivněna změnou zpět, tak asi bude nejlepší vydat MAJOR verzi i na úkor toho, že oprava zpět by měla být součástí PATCH verze. Pamatujte, že Sémantické verzování je o tom, jak se verze mění. Jestli jsou změny pro Vaše uživatele důležité, použijte také číslo verze, abyste je informovali.

Jak se vypořádat se zastaralými funkcionalitami?

Označení funkcionality jako zastaralé je standardní část softwarového vývoje a většinou je to potřeba k tomu, aby šel vývoj kupředu. Když zestárne část API, měli by jste udělat dvě věci: (1) upravit dokumentaci, aby uživatelé věděli o změně, (2) vydat další MINOR verzi, která funkcionalitu „zestárne“. Předtím, než funkcionalitu kompletně odstraníte v další MAJOR verzi, měli byste vytvořit alespoň jednu MINOR verzi, která obsahuje „zestárnutí“. To umožní uživatelům hladký a snadný přechod nebo převod na nové API.

Má Sémantické verzování nějaký limit délky označení verzí?

Ne, nemá. Limit je 255 ASCII znaků, ale na to při běžném použití verzování nenarazíte.

O specifikaci

Autorem Specifikace sémantického verzování je
Tom Preston-Werner, autor projektu Gravatar a spolu-zakladatel projektu Github.

Pokud chcete zanechat zpětnou vazbu, prosím
přes GitHub.

Český překlad

Jakub Křižka (autor),
Zuzana Bertová (korektor),
Aleš Pařízek (korektor),
Jan Barášek (korektor),
R3gi (korektor)

Licence

Creative Commons ― CC BY 3.0\nSémantické verzování 2.0.0\nČíslo verzí zapisujeme ve formátu MAJOR.MINOR.PATCH
Navyšování jednotlivých čísel verzí probíhá následovně:\nMAJOR ― když nastala změna, která není zpětně kompatibilní s ostatními (API)\nMINOR ― když se přidá funkcionalita se zachováním zpětné kompatibility\nPATCH ― když se opravila chyba a zůstala kompatibilita\nPomocí předběžných verzí a přidáváním metadat je možné upřesnit informace. Např.: 1.0.0-alfa, 1.0.1-beta+2\nVe světě softwaru, jeho vývoje a správy existuje děsivé místo, kterému anglicky říkáme „dependency hell“ (v překladu „peklo závislostí“). Čím větší a komplexnější váš projekt je, tím je větší šance, že se na tomto místě jednou ocitnete.\nKdyž mají systémy mnoho závislostí, může se stát, že vydání nové verze je noční můrou pro obě strany. Pokud je specifikovaná závislost příliš striktní, hrozí, že zůstanete na jedné verzi (angl. „version lock“) a nebudete mít možnost přejít na další verzi bez toho, abyste vydali další verze všech balíčků nebo knihoven, na kterých projekt stojí. Na druhou stranu, když je specifikovaná závislost příliš volná, přijdete na to, že váš program je kompatibilní s více verzemi než je nutné a potřebné. V pekle závislostí se nacházíte, jakmile jste vázaný určitou verzí nebo v případně, že není přesně specifikován rozsah verzí, které máte použít. Taková situace brání v bezpečném vývoji kupředu.\nŘešením tohoto problému je jednoduchý sled pravidel, které určují, jak budou čísla verzí přiřazována a navyšována. Tato pravidla jsou založena (ale nikoliv omezena) na již ověřené praxi a to ve vývoji otevřeného i uzavřeného softwaru. Pro správné fungování systému, si musíte nejdříve nadefinovat způsob, jakým se bude komunikovat s Vaší aplikací (dále API). Toto API může být nadefinováno pomocí rozsáhlé dokumentace nebo zapsáno přímo ve zdrojovém kódu. Nezáleží na způsobu zápisu, je důležité, aby bylo srozumitelné a snadno čitelné. Je třeba mít kompletní dokumentaci, způsob oznamovaní a čitelné rozdíly v nových verzích. Zápis verzí je ve formátu MAJOR.MINOR.PATCH. Opravy chyb, které nezměnily Vaše API, zvyšují číslo PATCH verze. Zpětně kompatibilní změny v API zvyšují hodnotu MINOR verze a rozdílné verze API, které nejsou zpětně kompatibilní, zvyšují číslo MAJOR verze.\nTímto způsobem je nastavený systém Sémantického verzování.\nSpecifikace Sémantického verzování (SemVer)\n„MUSÍ“ (angl. MUST, REQUIRED, SHALL)
„NESMÍ“ (angl. MUST NOT, SHALL NOT)
„MĚLO BY“ (angl. SHOULD, RECOMMENDED)
„NEMĚLO BY“ (angl. SHOULD NOT)
„MŮŽE“ (angl. MAY, OPTIONAL)
(výrazy jsou interpretované z dokumentu: RFC 2119)\nSoftware používající Sémantické verzování, MUSÍ mít nadefinované API, buďto přímo ve zdrojovém kódu a nebo v externí dokumentaci. V obou případech to musí být hlavně přesné a komplexní.\nSoftware používající Sémantické verzování, MUSÍ mít nadefinované API, buďto přímo ve zdrojovém kódu a nebo v externí dokumentaci. V obou případech to musí být hlavně přesné a komplexní.\nČíslo verzí MUSÍ být ve formátu X, Y, Z. Jedná se o celá nezáporná čísla, přičemž X se NESMÍ rovnat hodnotě nula. Může se rovnat nule jen v případě, kdy se jedná o počáteční vývoj. X je číslo MAJOR verze, Y je číslem MINOR verze a Z je číslem PATCH verze, přičemž každé číslo má svoji hodnotu a navyšují se zvlášť a standardně, např.1.9.0 => 1.10.0 => 1.11.0.\nČíslo verzí MUSÍ být ve formátu X, Y, Z. Jedná se o celá nezáporná čísla, přičemž X se NESMÍ rovnat hodnotě nula. Může se rovnat nule jen v případě, kdy se jedná o počáteční vývoj. X je číslo MAJOR verze, Y je číslem MINOR verze a Z je číslem PATCH verze, přičemž každé číslo má svoji hodnotu a navyšují se zvlášť a standardně, např.1.9.0 => 1.10.0 => 1.11.0.\nJakmile se vydá očíslovaná verze programu, NESMÍ se měnit a každá další úprava nebo oprava je vydána pod novou verzí.\nJakmile se vydá očíslovaná verze programu, NESMÍ se měnit a každá další úprava nebo oprava je vydána pod novou verzí.\nMAJOR verze s hodnotou 0 (0.y.z.) je určena pro počáteční vývoj. Cokoliv se může změnit a API v tomto formátu by NEMĚLO být považováno za stabilní.\nMAJOR verze s hodnotou 0 (0.y.z.) je určena pro počáteční vývoj. Cokoliv se může změnit a API v tomto formátu by NEMĚLO být považováno za stabilní.\nVerze 1.0.0 definuje veřejně vydané API. Způsob, jakým se dále navyšuje číslo verze je ovlivněné tímto API a jeho změnami.\nVerze 1.0.0 definuje veřejně vydané API. Způsob, jakým se dále navyšuje číslo verze je ovlivněné tímto API a jeho změnami.\nČíslo PATCH (Z) MUSÍ být navýšené jenom pokud byly implentované zpětně kompatibilní opravy chyb. Oprava chyb je definována jako interní změna opravující nežádoucí chování programu.\nČíslo PATCH (Z) MUSÍ být navýšené jenom pokud byly implentované zpětně kompatibilní opravy chyb. Oprava chyb je definována jako interní změna opravující nežádoucí chování programu.\nČíslo MINOR (Y) MUSÍ být zvýšené, když byla do API přidána nová, zpětně kompatibilní funkcionalita nebo pokud byla jakákoliv funkcionalita odebrána (jako zastaralá) i pokud neovlivňuje samotný API kód. MŮŽE zahrnout i změnu PATCH verze. Číslo PATCH verze se musí vynulovat vždy, když se změní MINOR verze.\nČíslo MINOR (Y) MUSÍ být zvýšené, když byla do API přidána nová, zpětně kompatibilní funkcionalita nebo pokud byla jakákoliv funkcionalita odebrána (jako zastaralá) i pokud neovlivňuje samotný API kód. MŮŽE zahrnout i změnu PATCH verze. Číslo PATCH verze se musí vynulovat vždy, když se změní MINOR verze.\nČíslo MAJOR (X) MUSÍ být zvýšené, když byly přidané změny, které způsobily zpětnou nekompatibilitu. MŮŽE zahrnout i změny v rámci MINOR a PATCH verze. Číslo MINOR i PATCH se MUSÍ vynulovat vždy, když se změní MAJOR verze.\nČíslo MAJOR (X) MUSÍ být zvýšené, když byly přidané změny, které způsobily zpětnou nekompatibilitu. MŮŽE zahrnout i změny v rámci MINOR a PATCH verze. Číslo MINOR i PATCH se MUSÍ vynulovat vždy, když se změní MAJOR verze.\nPředběžné verze (angl. pre-release) MOHOU být označeny přidáním pomlčky a sérií identifikátorů oddělených tečkou hned za číslo PATCH verze. Identifikátory MUSÍ obsahovat pouze ASCII alfanumerické znaky a pomlčku [0-9A-Za-z-], NESMÍ být prázdné a číselné identifikátory NESMÍ obsahovat úvodní nulu. Předběžné verze mají nižší prioritu jako související normální verze. Předběžná verze je nestabilní a nemusí splňovat požadavky a závislosti jako normální verze. Např.: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nPředběžné verze (angl. pre-release) MOHOU být označeny přidáním pomlčky a sérií identifikátorů oddělených tečkou hned za číslo PATCH verze. Identifikátory MUSÍ obsahovat pouze ASCII alfanumerické znaky a pomlčku [0-9A-Za-z-], NESMÍ být prázdné a číselné identifikátory NESMÍ obsahovat úvodní nulu. Předběžné verze mají nižší prioritu jako související normální verze. Předběžná verze je nestabilní a nemusí splňovat požadavky a závislosti jako normální verze. Např.: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nMetadata MOHOU být označené ve verzi přidáním znaku plus (+) a sérií identifikátorů oddělených tečkou hned za číslo PATCH a nebo pomocí předběžné verze. Identifikátory MUSÍ obsahovat pouze ASCII alfanumerické znaky a pomlčku [0-9A-Za-z-], NESMÍ být prázdné a číselné identifikátory NESMÍ obsahovat úvodní nulu. Metadata by NEMĚLA hrát roli při volbě priority verze. Např.: verze 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85 mají všechny stejnou prioritu.\nMetadata MOHOU být označené ve verzi přidáním znaku plus (+) a sérií identifikátorů oddělených tečkou hned za číslo PATCH a nebo pomocí předběžné verze. Identifikátory MUSÍ obsahovat pouze ASCII alfanumerické znaky a pomlčku [0-9A-Za-z-], NESMÍ být prázdné a číselné identifikátory NESMÍ obsahovat úvodní nulu. Metadata by NEMĚLA hrát roli při volbě priority verze. Např.: verze 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85 mají všechny stejnou prioritu.\nPriorita se vztahuje na to, jak se verze vzájemně porovnávají. Priorita MUSÍ být určována rozdělením verze na MAJOR, MINOR, PATCH a identifikátory předběžných verzí ― přesně v tomto pořadí (s metadaty se nepočítá). Priorita je daná prvním rozdílem při porovnání zleva doprava přičemž čísla MAJOR, MINOR a PATCH jsou vždy porovnávána jako čísla. Např.: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Pokud jsou čísla MAJOR, MINOR a PATCH stejná, předběžná verze má menší prioritu, než normální. Např.: 1.0.0-alpha < 1.0.0. Priorita pro dvě předběžné verze, které se shodují v číslech MAJOR, MINOR a PATCH musí být počítána zleva doprava od tečky oddělených identifikátorů a to do doby, dokud se nenajde rozdíl a to následujícím způsobem: (1) Identifikátory obsahující pouze číslice, jsou porovnané číselně a identifikátory s písmeny nebo pomlčkami jsou porovnávané lexikálně, zařazené podle ASCII. (2) Číselné identifikátory mají vždy nižší prioritu jak nečíslené. (3) Jsou-li všechny předchozí identifikátory v předběžné verzi stejné, tak větší množství identifikátorů značí vyšší prioritu, než s menším počtem. Např.: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPriorita se vztahuje na to, jak se verze vzájemně porovnávají. Priorita MUSÍ být určována rozdělením verze na MAJOR, MINOR, PATCH a identifikátory předběžných verzí ― přesně v tomto pořadí (s metadaty se nepočítá). Priorita je daná prvním rozdílem při porovnání zleva doprava přičemž čísla MAJOR, MINOR a PATCH jsou vždy porovnávána jako čísla. Např.: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Pokud jsou čísla MAJOR, MINOR a PATCH stejná, předběžná verze má menší prioritu, než normální. Např.: 1.0.0-alpha < 1.0.0. Priorita pro dvě předběžné verze, které se shodují v číslech MAJOR, MINOR a PATCH musí být počítána zleva doprava od tečky oddělených identifikátorů a to do doby, dokud se nenajde rozdíl a to následujícím způsobem: (1) Identifikátory obsahující pouze číslice, jsou porovnané číselně a identifikátory s písmeny nebo pomlčkami jsou porovnávané lexikálně, zařazené podle ASCII. (2) Číselné identifikátory mají vždy nižší prioritu jak nečíslené. (3) Jsou-li všechny předchozí identifikátory v předběžné verzi stejné, tak větší množství identifikátorů značí vyšší prioritu, než s menším počtem. Např.: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nProč používat Sémantické verzování?\nSémantické verzování není revoluční myšlenka a když vydáváte software, tak už pravděpodobně děláte něco podobného. Problém je, že „něco podobného“ nestačí. Bez dodržování daných formálních specifikací jsou čísla pro managment závislostí v podstatě na nic. Tím, že výše uvedeným myšlenkám dáváme přesnou a jasnou definici, je lehčí komunikovat záměry Vašeho softwaru jeho uživatelům. Jakmile jsou záměry jasné a flexibilní (ale ne příliš), specifikace závislostí může začít.\nNásledující příklad ilustruje, jak se díky Sémantickému verzování můžete snadno vyhnout problémům se závislostmi (tzv. „dependency hell“). Mějme knihovnou „Firetruck“ (česky požární vůz). Ta závisí na Sémanticky verzované knihovně „Ladder“ (česky žebřík). Ve době vzniku knihovny Firetruck je aktuální verze knihovny Ladder 3.1.0. Protože Firetruck využívá některé funkce knihovny Ladder, které do ni byly přidány až ve verzi 3.1.0, můžete bez rizika nadefinovat závislost na knihovně Ladder ve verzi vyšší nebo rovno 3.1.0 a menší než 4.0.0. Jakmile bude vydána verze Ladder 3.2.0, můžete se spolehnout na to, že s ní bude knihovna Firetruck kompatibilní.\nJako zodpovědní vývojáři určitě budete chtít kontrolovat, že všechno funguje podle Vašich předpokladů. Sématické verzování vám umožní rozumný způsob, jak vydávat a aktualizovat knihovny tak, abyste nemuseli řešit nové verze závislostí, ušetřili si čas a vyhnuli se zmatkům.\nPokud vám tyto argumenty připadají rozumné, všechno co potřebujete udělat pro začátek používání Sémantického verzování, je dát vědět, že to děláte, a následně dodržovali stanovená pravidla. Odkazem ze souboru README z vaší aplikace/softwaru na tyto stránky dejte ostatním vědět, jaká pravidla používáte. Přinese to užitek vám i uživatelům vašeho software nebo aplikace.\nČasto kladené otázky (FAQ)\nJak si poradit s verzemi 0.y.z. na začátku vývoje?\nNejjednodušším způsobem je začít vývoj na verzi 0.1.0. a potom zvyšovat MINOR verzi při každém dalším vydání softwaru.\nJak poznat, kdy vydat verzi 1.0.0?\nPokud se váš software již používá v produkci, už by pravděpodobně měl mít verzi 1.0.0. Jestli máte stabilní API, které už uživatelé mají mezi svými závislostmi, měli byste mít už verzi 1.0.0. Taktéž, když se obáváte o zpětnou kompatibilitu.\nNeodrazuje to od rychlého vývoje?\nMAJOR verze nula je o rychlém vývoji. Když každý den měníte API, stále byste měli být někde ve fázi 0.y.z nebo na separátní vývojové větvi, kde se připravuje následující MAJOR verze.\nPokud ty nejmenší zpětně nekompatibilní změny v API znamenají navýšení MAJOR verze, neskončíme poměrně rychle někde ve verzi 42.0.0?\nTo je otázka zodpovědného vývoje a prognóz. Nekompatibilní změny by neměly být v softwaru, který má mnoho závislostí, zavedeny jen tak. Náklady vynaložené na aktualizaci mohou být dost vysoké. To, že musíte vydat novou verzi MAJOR znamená, že jste si dobře promysleli dopad všech změn, výhody i následky.\nZdokumentovat celé API je strašně moc práce!\nJe Vaší zodpovědností jako profesionálních vývojářů správně dokumentovat software, který je určený i pro ostatní. Spravování složitosti softwaru je velmi důležitá část, pokud chcete váš projekt udržovat efektivní. A to nebude možné, když nikdo nebude vědět, jak váš software používat nebo které metody je bezpečné volat. Z dlouhodobého hlediska se Sématické verzování a důraz na dobře definované API ukázaly jako správná volba, umožňující hladké i dlouhodobé fungování.\nCo dělat, když vydám zpětně nekompatibilní verzi MINOR?\nJakmile zjistíte, že jste porušili pravidla Sémantického verzování, opravte problém a vydejte další MINOR verzi, která opět vrátí zpětnou kompatibilitu. I vzhledem na vzniklou situaci je nepřípustné, abyste měnili už vydanou verzi. Pokud je to možné a vhodné, informujte uživatele o špatné verzi, aby věděli, že se jedná o chybu a dané verzi se vyhnuli.\nCo dělat, když jsem aktualizoval vlastní závislosti bez toho, aby se změnilo API?\nMůžeme to považovat za kompatibilní, když to nijak neovlivnilo API. Software, který přesně závisí na balíčcích jako váš, by měl mít vlastní definici závislostí a jeho autor si všimne jakýchkoliv konfliktů. Rozhodnutí, zda se jedná o MINOR nebo PATCH závisí od toho, jestli jste upravili své závislosti kvůli nějaké chybě nebo proto, že jste přidali novou funkcionalitu. Pokud se jedná o druhý případ, očekává se, že přibude i nějaký kód a tím pádem se jedná o zvýšení MINOR verze.\nCo když jsem nechtěně změnil API, způsobem, který není v souladě se změnou čísla verze (například jsem udělal MAJOR změnu v PATCH verzi)\nPosuďte, co je nejlepší. Jestli máte velkou skupinu uživatelů, která by byla ovlivněna změnou zpět, tak asi bude nejlepší vydat MAJOR verzi i na úkor toho, že oprava zpět by měla být součástí PATCH verze. Pamatujte, že Sémantické verzování je o tom, jak se verze mění. Jestli jsou změny pro Vaše uživatele důležité, použijte také číslo verze, abyste je informovali.\nJak se vypořádat se zastaralými funkcionalitami?\nOznačení funkcionality jako zastaralé je standardní část softwarového vývoje a většinou je to potřeba k tomu, aby šel vývoj kupředu. Když zestárne část API, měli by jste udělat dvě věci: (1) upravit dokumentaci, aby uživatelé věděli o změně, (2) vydat další MINOR verzi, která funkcionalitu „zestárne“. Předtím, než funkcionalitu kompletně odstraníte v další MAJOR verzi, měli byste vytvořit alespoň jednu MINOR verzi, která obsahuje „zestárnutí“. To umožní uživatelům hladký a snadný přechod nebo převod na nové API.\nMá Sémantické verzování nějaký limit délky označení verzí?\nNe, nemá. Limit je 255 ASCII znaků, ale na to při běžném použití verzování nenarazíte.\nAutorem Specifikace sémantického verzování je
Tom Preston-Werner, autor projektu Gravatar a spolu-zakladatel projektu Github.\nPokud chcete zanechat zpětnou vazbu, prosím
přes GitHub.\nJakub Křižka (autor),
Zuzana Bertová (korektor),
Aleš Pařízek (korektor),
Jan Barášek (korektor),
R3gi (korektor)\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSemantisk version 2.0.0

Resumé

Givet et versionsnummer MAJOR.MINOR.PATCH, skal du øge:


  STOR version, når du foretager inkompatible API-ændringer,
  MINOR version, når du tilføjer funktionalitet i en bagudkompatibel
måde, og
  PATCH-version, når du laver bagudkompatible fejlrettelser.


Yderligere etiketter til pre-release og build-metadata er tilgængelige som udvidelser
til MAJOR.MINOR.PATCH-formatet.

Introduktion

I verden af ​​software management findes der et frygtet sted kaldet
“afhængighedshelvede.” Jo større dit system vokser, og jo flere pakker du
integreres i din software, jo større sandsynlighed er der for, at du finder dig selv, en
dag, i denne fortvivlelses hule.

I systemer med mange afhængigheder kan frigivelse af nye pakkeversioner hurtigt
blive et mareridt. Hvis afhængighedsspecifikationerne er for stramme, er du med
fare for versionslås (manglende evne til at opgradere en pakke uden at skulle
frigive nye versioner af hver afhængig pakke). Hvis afhængigheder er
specificeret for løst, vil du uundgåeligt blive bidt af versionspromiskuitet
(forudsat kompatibilitet med flere fremtidige versioner end rimeligt).
Afhængighedshelvede er, når versionslås og/eller versionspromiskuitet
forhindrer dig i nemt og sikkert at komme videre med dit projekt.

Som en løsning på dette problem foreslår vi et simpelt sæt regler og
krav, der dikterer, hvordan versionsnumre tildeles og øges.
Disse regler er baseret på, men ikke nødvendigvis begrænset til, allerede eksisterende
udbredt almindelig praksis i brug i både lukket og open source-software.
For at dette system skal fungere, skal du først erklære en offentlig API. Dette kan evt
bestå af dokumentation eller håndhæves af selve koden. Uanset hvad er det
vigtigt, at dette API er klar og præcis. Når du identificerer dit offentlige
API, kommunikerer du ændringer til det med specifikke ændringer til dit versionsnummer.
Overvej et versionsformat af X.Y.Z (Major.Minor.Patch). Fejlrettelser der ikke
påvirker API’et øger patchversionen (Z), bagudkompatibelt API
med tilføjelser/ændringer øger den mindre version (Y) og bagud inkompatible API
ændringer øger hovedversionen (X).

Vi kalder dette system “Semantisk versionering.” Under denne ordning, formidler versionsnumrene mening om den underliggende kode og hvad der har blevet ændret fra den ene version til den næste.

Semantisk versionsspecifikation (SemVer)

Nøgleordene “MÅ”, “MÅ IKKE”, “PÅKRÆVET”, “SKAL”, “MÅ IKKE”, “BØR”,
“BØR IKKE”, “ANBEFALET”, “KAN” og “VALGFRI” i dette dokument skal være
fortolket som beskrevet i RFC 2119.


  
    Software, der bruger semantisk versionering SKAL erklære et offentlig API. Dette API
kan være erklæret i selve koden eller udelukkende eksistere i dokumentationen.
Uanset hvordan det gøres, SKAL det være præcist og omfattende.
  
  
    Et normalt versionsnummer SKAL have formen X.Y.Z, hvor X, Y og Z er
ikke-negative heltal og MÅ IKKE indeholde indledende nuller. X er
større version, Y er den mindre version, og Z er patch-versionen.
Hvert element SKAL øges numerisk. For eksempel: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Når en versioneret pakke er blevet frigivet, MÅ indholdet IKKE ændres i den version.
Eventuelle ændringer SKAL frigives som en ny version.
  
  
    Større version nul (0.y.z) er til indledende udvikling. Alt KAN ændre sig
når som helst. Det offentlige API BØR IKKE betragtes som stabilt.
  
  
    Version 1.0.0 definerer det offentlige API. Den måde, hvorpå versionsnummeret
øges efter denne udgivelse er afhængig af dette offentlige API og hvordan den
ændrer sig.
  
  
    Patchversion Z (x.y.Z | x > 0) SKAL øges, hvis kun baglæns
kompatible fejlrettelser introduceres. En fejlrettelse er defineret som en intern
ændring, der retter ukorrekt adfærd.
  
  
    Mindre version Y (x.Y.z | x > 0) SKAL øges, hvis ny, baglæns
kompatibel funktionalitet introduceres til det offentlige API. Det må 
øges, hvis noget offentlig API-funktionalitet er markeret som forældet. Det BØR øges,
hvis der indføres væsentlig ny funktionalitet eller forbedringer inden for den private kode. Det KAN omfatte ændringer af patch-niveau. Patch version SKAL nulstilles til 0, når mindre version øges.
  
  
    Større version X (X.y.z | X > 0) SKAL øges, hvis der er nogen baglæns
inkompatible ændringer der introduceres til det offentlige API. Det MÅ også omfatte mindre 
ændringer i patch-niveau. Patch og mindre versioner SKAL nulstilles til 0, når de er større
version er øget.
  
  
    En pre-release version KAN angives ved at tilføje en bindestreg og en
serie af punktseparerede identifikatorer umiddelbart efter patchen
version. Identifikatorer SKAL kun omfatte ASCII alfanumeriske tegn og bindestreger
[0-9A-Za-z-]. Identifikatorer MÅ IKKE være tomme. Numeriske identifikatorer SKAL
Inkluder IKKE foranstillede nuller. Pre-release versioner har en lavere
forrang end den tilhørende normale version. En pre-release version
angiver, at versionen er ustabil og muligvis ikke opfylder
tilsigtede kompatibilitetskrav som angivet af dets tilknyttede
normal version. Eksempler: 1.0.0-alfa, 1.0.0-alfa.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.–.
  
  
    Byggemetadata KAN angives ved at tilføje et plustegn og en række prikker
adskilte identifikatorer umiddelbart efter patchen eller pre-release-versionen.
Identifikatorer SKAL kun omfatte ASCII alfanumeriske tegn og bindestreger [0-9A-Za-z-].
Identifikatorer MÅ IKKE være tomme. Byggemetadata SKAL ignoreres ved bestemmelse
versions forrang. Således to versioner, der kun adskiller sig i byggemetadataene,
har samme forrang. Eksempler: 1.0.0-alfa+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3—-117B344092BD.
  
  
    Forrang henviser til, hvordan versioner sammenlignes med hinanden, når de bestilles.

    
      
        Forrang SKAL beregnes ved at adskille versionen i større,
mindre, patch og pre-release identifikatorer i den rækkefølge (Byggemetadata
har ikke forrang).
      
      
        Forrang bestemmes af den første forskel, når man sammenligner hver af
disse identifikatorer fra venstre mod højre som følger: Større, mindre og patch
versioner sammenlignes altid numerisk.

        Eksempel: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Når større, mindre og patch er ens, har en pre-release version lavere
forrang end en normal version:

        Eksempel: 1.0.0-alfa < 1.0.0.
      
      
        Forrang for to pre-release versioner med samme større, mindre og
patch-version SKAL bestemmes ved at sammenligne hver punktsepareret identifikator
fra venstre mod højre, indtil en forskel er fundet som følger:

        
          
            Identifikatorer, der kun består af cifre, sammenlignes numerisk.
          
          
            Identifikatorer med bogstaver eller bindestreger sammenlignes leksikalsk i ASCII
sorteringsrækkefølge.
          
          
            Numeriske identifikatorer har altid lavere forrang end ikke-numeriske
identifikatorer.
          
          
            Et større sæt præ-udgivelsesfelter har en højere prioritet end en
mindre sæt, hvis alle de foregående identifikatorer er ens.
          
        

        Eksempel: 1.0.0-alfa < 1.0.0-alfa.1 < 1.0.0-alfa.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
      
    
  


Hvorfor bruge semantisk versionering?

Dette er ikke en ny eller revolutionær idé. Faktisk gør du sikkert noget
tæt på dette allerede. Problemet er, at “tæt” ikke er godt nok. Uden
overensstemmelse med en form for formel specifikation, versionsnumre er
i det væsentlige ubrugelig til afhængighedsstyring. Ved at give et navn og klart
definition til ovenstående ideer, bliver det nemt at kommunikere dine hensigter
til brugerne af din software. Når først disse intentioner er klare, fleksible (men
ikke for fleksible) kan der endelig laves afhængighedsspecifikationer.

Et simpelt eksempel vil vise, hvordan semantisk versionering kan gøre afhængighed
helvede hører fortiden til. Overvej et bibliotek kaldet “Brandbil.” Det kræver en
Semantisk versioneret pakke med navnet “Ladder.” På det tidspunkt, hvor Firetruck er
oprettet, er Ladder i version 3.1.0. Da Firetruck bruger nogle funktioner
som først blev introduceret i 3.1.0, kan du roligt angive stigen
afhængighed som større end eller lig med 3.1.0, men mindre end 4.0.0. Nu, hvornår
Ladder version 3.1.1 og 3.2.0 bliver tilgængelige, du kan frigive dem til din
pakkestyringssystem og ved, at de vil være kompatible med eksisterende
afhængig software.

Som ansvarlig udvikler vil du naturligvis gerne verificere, at evt
pakkeopgraderinger fungerer som annonceret. Den virkelige verden er et rodet sted;
der er ikke noget, vi kan gøre ved det, end at være årvågne. Hvad du kan gøre er at lade
Semantisk versionering giver dig en fornuftig måde at frigive og opgradere
pakker uden at skulle rulle nye versioner af afhængige pakker, hvilket sparer dig
tid og bøvl.

Hvis alt dette lyder ønskeligt, er alt hvad du skal gøre for at begynde at bruge Semantic
Versionering er at erklære, at du gør det og derefter følge reglerne. Link
til denne hjemmeside fra din README, så andre kender reglerne og kan drage fordel af
dem.

FAQ

Hvordan skal jeg håndtere revisioner i 0.y.z indledende udviklingsfase?

Den enkleste ting at gøre er at starte din første udviklingsudgivelse på 0.1.0
og øg derefter den mindre version for hver efterfølgende udgivelse.

Hvordan ved jeg, hvornår jeg skal udgive 1.0.0?

Hvis din software bliver brugt i produktionen, burde den sandsynligvis allerede være det
1.0.0. Hvis du har et stabilt API, som brugerne er blevet afhængige af, bør du
være 1.0.0. Hvis du bekymrer dig meget om bagudkompatibilitet, bør du
sandsynligvis allerede være 1.0.0.

Afskrækker dette ikke hurtig udvikling og hurtig iteration?

Større version nul handler om hurtig udvikling. Hvis du ændrer API
hver dag bør du enten stadig være i version 0.y.z eller på en separat
udviklingsgren arbejder på den næste store version.

Hvis selv de mindste bagud-inkompatible ændringer af det offentlige API kræver et større versionsbump, vil jeg så ikke ende med version 42.0.0 meget hurtigt?

Dette er et spørgsmål om ansvarlig udvikling og fremsyn. Uforenelig
ændringer bør ikke introduceres let til software, der har en masse
afhængig kode. De omkostninger, der skal afholdes for at opgradere, kan være betydelige.
At skulle bumpe større versioner for at frigive inkompatible ændringer betyder, at du vil
gennemtænk virkningen af ​​dine ændringer, og evaluer cost/benefit-forholdet
involveret.

Det er for meget arbejde at dokumentere hele det offentlige API!

Det er dit ansvar som professionel udvikler at dokumentere ordentligt
software, der er beregnet til brug af andre. Håndtering af softwarekompleksitet er en
enormt vigtig del af at holde et projekt effektivt, og det er svært at gøre hvis
ingen ved, hvordan man bruger din software, eller hvilke metoder der er sikre at kalde. I
på lang sigt, semantisk versionering og insisteren på en veldefineret offentlighed
API kan holde alle og alt kørende.

Hvad gør jeg, hvis jeg ved et uheld frigiver en bagudinkompatibel ændring som en mindre version?

Så snart du indser, at du har brudt Semantic Versioning-specifikationen, skal du rette det
problemet og frigive en ny mindre version, der retter problemet og
genopretter bagudkompatibilitet. Selv under denne omstændighed er det
uacceptabelt at ændre versionerede udgivelser. Hvis det er passende,
dokumentere den krænkende version og informere dine brugere om problemet, således at
de er opmærksomme på den krænkende version.

Hvad skal jeg gøre, hvis jeg opdaterer mine egne afhængigheder uden at ændre det offentlige API?

Det ville blive betragtet som kompatibelt, da det ikke påvirker der offentlige API.
Software, der eksplicit afhænger af de samme afhængigheder som din pakke
bør have deres egne afhængighedsspecifikationer, og forfatteren vil bemærke evt
konflikter. Afgør, om ændringen er et patch-niveau eller et mindre niveau
ændring afhænger af, om du har opdateret dine afhængigheder for at rette
en fejl eller introducere ny funktionalitet. Vi ville normalt forvente yderligere kode
i sidstnævnte tilfælde, i hvilket tilfælde det åbenbart er en mindre niveaustigning.

Hvad hvis jeg utilsigtet ændrer den offentlige API på en måde, der ikke er i overensstemmelse med ændringen af ​​versionsnummeret (dvs. at koden fejlagtigt introducerer en større brydende ændring i en patch-udgivelse)?

Brug din bedste dømmekraft. Hvis du har et stort publikum, vil det være drastisk
påvirket af at ændre adfærden tilbage til, hvad den offentlige API havde til hensigt
det kan være bedst at udføre en større versionsudgivelse, selvom rettelsen kunne
strengt taget betragtes som en patch-udgivelse. Husk, Semantisk versionering er alt
om at formidle mening ved, hvordan versionsnummeret ændres. Hvis disse ændringer
er vigtige for dine brugere, skal du bruge versionsnummeret til at informere dem.

Hvordan skal jeg håndtere udfasning af funktionalitet?

Forringelse af eksisterende funktionalitet er en normal del af softwareudvikling og
er ofte påkrævet for at gøre fremskridt. Når du fraskriver en del af din
offentlige API, bør du gøre to ting: (1) opdatere din dokumentation for at lade
brugere kender til ændringen, (2) udsteder en ny mindre udgivelse med afskrivningen
på plads. Før du helt fjerner funktionaliteten i en ny større udgivelse
der bør være mindst én mindre udgivelse, der indeholder udfasningen så
at brugerne problemfrit kan skifte til den nye API.

Har SemVer en størrelsesbegrænsning på versionsstrengen?

Nej, men brug god dømmekraft. En version på 255 tegn er sandsynligvis overkill,
for eksempel. Også specifikke systemer kan pålægge deres egne grænser for størrelsen af
strengen.

Er “v1.2.3” en semantisk version?

Nej, “v1.2.3” er ikke en semantisk version. Dog foran en semantisk version
med et “v” er en almindelig måde (på engelsk) at angive, at det er et versionsnummer.
At forkorte “version” som “v” ses ofte med versionskontrol. Eksempel:
git tag v1.2.3 -m "Release version 1.2.3", i hvilket tilfælde “v1.2.3” er et tag
navn og den semantiske version er “1.2.3”.

Er der et foreslået regulært udtryk (RegEx) til at kontrollere en SemVer-streng?

Der er to. En med navngivne grupper for de systemer, der understøtter dem
(PCRE [Perl-kompatible regulære udtryk, dvs. Perl, PHP og R], Python
og gå).

Se: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))$


Og en med nummererede optagelsesgrupper i stedet (så cg1 = større, cg2 = mindre,
cg3 = patch, cg4 = prerelease og cg5 = byggemetadata), der er kompatibel
med ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
dvs. Perl, PHP og R), Python og Go.

Se: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0 |[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d *|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?: \.[0-9a-zA-Z-]+)*))?$


Om

Den semantiske versionsspecifikation blev oprindeligt skrevet af Tom
Preston-Werner, opfinder af Gravatar og
medstifter af GitHub.

Hvis du gerne vil give feedback, bedes du åbn et issue på
GitHub.

Licens

Creative Commons ― CC BY 3.0\nSemantisk version 2.0.0\nGivet et versionsnummer MAJOR.MINOR.PATCH, skal du øge:\nSTOR version, når du foretager inkompatible API-ændringer,\nMINOR version, når du tilføjer funktionalitet i en bagudkompatibel
måde, og\nPATCH-version, når du laver bagudkompatible fejlrettelser.\nYderligere etiketter til pre-release og build-metadata er tilgængelige som udvidelser
til MAJOR.MINOR.PATCH-formatet.\nI verden af ​​software management findes der et frygtet sted kaldet
“afhængighedshelvede.” Jo større dit system vokser, og jo flere pakker du
integreres i din software, jo større sandsynlighed er der for, at du finder dig selv, en
dag, i denne fortvivlelses hule.\nI systemer med mange afhængigheder kan frigivelse af nye pakkeversioner hurtigt
blive et mareridt. Hvis afhængighedsspecifikationerne er for stramme, er du med
fare for versionslås (manglende evne til at opgradere en pakke uden at skulle
frigive nye versioner af hver afhængig pakke). Hvis afhængigheder er
specificeret for løst, vil du uundgåeligt blive bidt af versionspromiskuitet
(forudsat kompatibilitet med flere fremtidige versioner end rimeligt).
Afhængighedshelvede er, når versionslås og/eller versionspromiskuitet
forhindrer dig i nemt og sikkert at komme videre med dit projekt.\nSom en løsning på dette problem foreslår vi et simpelt sæt regler og
krav, der dikterer, hvordan versionsnumre tildeles og øges.
Disse regler er baseret på, men ikke nødvendigvis begrænset til, allerede eksisterende
udbredt almindelig praksis i brug i både lukket og open source-software.
For at dette system skal fungere, skal du først erklære en offentlig API. Dette kan evt
bestå af dokumentation eller håndhæves af selve koden. Uanset hvad er det
vigtigt, at dette API er klar og præcis. Når du identificerer dit offentlige
API, kommunikerer du ændringer til det med specifikke ændringer til dit versionsnummer.
Overvej et versionsformat af X.Y.Z (Major.Minor.Patch). Fejlrettelser der ikke
påvirker API’et øger patchversionen (Z), bagudkompatibelt API
med tilføjelser/ændringer øger den mindre version (Y) og bagud inkompatible API
ændringer øger hovedversionen (X).\nVi kalder dette system “Semantisk versionering.” Under denne ordning, formidler versionsnumrene mening om den underliggende kode og hvad der har blevet ændret fra den ene version til den næste.\nSemantisk versionsspecifikation (SemVer)\nNøgleordene “MÅ”, “MÅ IKKE”, “PÅKRÆVET”, “SKAL”, “MÅ IKKE”, “BØR”,
“BØR IKKE”, “ANBEFALET”, “KAN” og “VALGFRI” i dette dokument skal være
fortolket som beskrevet i RFC 2119.\nSoftware, der bruger semantisk versionering SKAL erklære et offentlig API. Dette API
kan være erklæret i selve koden eller udelukkende eksistere i dokumentationen.
Uanset hvordan det gøres, SKAL det være præcist og omfattende.\nSoftware, der bruger semantisk versionering SKAL erklære et offentlig API. Dette API
kan være erklæret i selve koden eller udelukkende eksistere i dokumentationen.
Uanset hvordan det gøres, SKAL det være præcist og omfattende.\nEt normalt versionsnummer SKAL have formen X.Y.Z, hvor X, Y og Z er
ikke-negative heltal og MÅ IKKE indeholde indledende nuller. X er
større version, Y er den mindre version, og Z er patch-versionen.
Hvert element SKAL øges numerisk. For eksempel: 1.9.0 -> 1.10.0 -> 1.11.0.\nEt normalt versionsnummer SKAL have formen X.Y.Z, hvor X, Y og Z er
ikke-negative heltal og MÅ IKKE indeholde indledende nuller. X er
større version, Y er den mindre version, og Z er patch-versionen.
Hvert element SKAL øges numerisk. For eksempel: 1.9.0 -> 1.10.0 -> 1.11.0.\nNår en versioneret pakke er blevet frigivet, MÅ indholdet IKKE ændres i den version.
Eventuelle ændringer SKAL frigives som en ny version.\nNår en versioneret pakke er blevet frigivet, MÅ indholdet IKKE ændres i den version.
Eventuelle ændringer SKAL frigives som en ny version.\nStørre version nul (0.y.z) er til indledende udvikling. Alt KAN ændre sig
når som helst. Det offentlige API BØR IKKE betragtes som stabilt.\nStørre version nul (0.y.z) er til indledende udvikling. Alt KAN ændre sig
når som helst. Det offentlige API BØR IKKE betragtes som stabilt.\nVersion 1.0.0 definerer det offentlige API. Den måde, hvorpå versionsnummeret
øges efter denne udgivelse er afhængig af dette offentlige API og hvordan den
ændrer sig.\nVersion 1.0.0 definerer det offentlige API. Den måde, hvorpå versionsnummeret
øges efter denne udgivelse er afhængig af dette offentlige API og hvordan den
ændrer sig.\nPatchversion Z (x.y.Z | x > 0) SKAL øges, hvis kun baglæns
kompatible fejlrettelser introduceres. En fejlrettelse er defineret som en intern
ændring, der retter ukorrekt adfærd.\nPatchversion Z (x.y.Z | x > 0) SKAL øges, hvis kun baglæns
kompatible fejlrettelser introduceres. En fejlrettelse er defineret som en intern
ændring, der retter ukorrekt adfærd.\nMindre version Y (x.Y.z | x > 0) SKAL øges, hvis ny, baglæns
kompatibel funktionalitet introduceres til det offentlige API. Det må 
øges, hvis noget offentlig API-funktionalitet er markeret som forældet. Det BØR øges,
hvis der indføres væsentlig ny funktionalitet eller forbedringer inden for den private kode. Det KAN omfatte ændringer af patch-niveau. Patch version SKAL nulstilles til 0, når mindre version øges.\nMindre version Y (x.Y.z | x > 0) SKAL øges, hvis ny, baglæns
kompatibel funktionalitet introduceres til det offentlige API. Det må 
øges, hvis noget offentlig API-funktionalitet er markeret som forældet. Det BØR øges,
hvis der indføres væsentlig ny funktionalitet eller forbedringer inden for den private kode. Det KAN omfatte ændringer af patch-niveau. Patch version SKAL nulstilles til 0, når mindre version øges.\nStørre version X (X.y.z | X > 0) SKAL øges, hvis der er nogen baglæns
inkompatible ændringer der introduceres til det offentlige API. Det MÅ også omfatte mindre 
ændringer i patch-niveau. Patch og mindre versioner SKAL nulstilles til 0, når de er større
version er øget.\nStørre version X (X.y.z | X > 0) SKAL øges, hvis der er nogen baglæns
inkompatible ændringer der introduceres til det offentlige API. Det MÅ også omfatte mindre 
ændringer i patch-niveau. Patch og mindre versioner SKAL nulstilles til 0, når de er større
version er øget.\nEn pre-release version KAN angives ved at tilføje en bindestreg og en
serie af punktseparerede identifikatorer umiddelbart efter patchen
version. Identifikatorer SKAL kun omfatte ASCII alfanumeriske tegn og bindestreger
[0-9A-Za-z-]. Identifikatorer MÅ IKKE være tomme. Numeriske identifikatorer SKAL
Inkluder IKKE foranstillede nuller. Pre-release versioner har en lavere
forrang end den tilhørende normale version. En pre-release version
angiver, at versionen er ustabil og muligvis ikke opfylder
tilsigtede kompatibilitetskrav som angivet af dets tilknyttede
normal version. Eksempler: 1.0.0-alfa, 1.0.0-alfa.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.–.\nEn pre-release version KAN angives ved at tilføje en bindestreg og en
serie af punktseparerede identifikatorer umiddelbart efter patchen
version. Identifikatorer SKAL kun omfatte ASCII alfanumeriske tegn og bindestreger
[0-9A-Za-z-]. Identifikatorer MÅ IKKE være tomme. Numeriske identifikatorer SKAL
Inkluder IKKE foranstillede nuller. Pre-release versioner har en lavere
forrang end den tilhørende normale version. En pre-release version
angiver, at versionen er ustabil og muligvis ikke opfylder
tilsigtede kompatibilitetskrav som angivet af dets tilknyttede
normal version. Eksempler: 1.0.0-alfa, 1.0.0-alfa.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.–.\nByggemetadata KAN angives ved at tilføje et plustegn og en række prikker
adskilte identifikatorer umiddelbart efter patchen eller pre-release-versionen.
Identifikatorer SKAL kun omfatte ASCII alfanumeriske tegn og bindestreger [0-9A-Za-z-].
Identifikatorer MÅ IKKE være tomme. Byggemetadata SKAL ignoreres ved bestemmelse
versions forrang. Således to versioner, der kun adskiller sig i byggemetadataene,
har samme forrang. Eksempler: 1.0.0-alfa+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3—-117B344092BD.\nByggemetadata KAN angives ved at tilføje et plustegn og en række prikker
adskilte identifikatorer umiddelbart efter patchen eller pre-release-versionen.
Identifikatorer SKAL kun omfatte ASCII alfanumeriske tegn og bindestreger [0-9A-Za-z-].
Identifikatorer MÅ IKKE være tomme. Byggemetadata SKAL ignoreres ved bestemmelse
versions forrang. Således to versioner, der kun adskiller sig i byggemetadataene,
har samme forrang. Eksempler: 1.0.0-alfa+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3—-117B344092BD.\nForrang henviser til, hvordan versioner sammenlignes med hinanden, når de bestilles.

    
      
        Forrang SKAL beregnes ved at adskille versionen i større,
mindre, patch og pre-release identifikatorer i den rækkefølge (Byggemetadata
har ikke forrang).
      
      
        Forrang bestemmes af den første forskel, når man sammenligner hver af
disse identifikatorer fra venstre mod højre som følger: Større, mindre og patch
versioner sammenlignes altid numerisk.

        Eksempel: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Når større, mindre og patch er ens, har en pre-release version lavere
forrang end en normal version:

        Eksempel: 1.0.0-alfa < 1.0.0.
      
      
        Forrang for to pre-release versioner med samme større, mindre og
patch-version SKAL bestemmes ved at sammenligne hver punktsepareret identifikator
fra venstre mod højre, indtil en forskel er fundet som følger:

        
          
            Identifikatorer, der kun består af cifre, sammenlignes numerisk.
          
          
            Identifikatorer med bogstaver eller bindestreger sammenlignes leksikalsk i ASCII
sorteringsrækkefølge.
          
          
            Numeriske identifikatorer har altid lavere forrang end ikke-numeriske
identifikatorer.
          
          
            Et større sæt præ-udgivelsesfelter har en højere prioritet end en
mindre sæt, hvis alle de foregående identifikatorer er ens.
          
        

        Eksempel: 1.0.0-alfa < 1.0.0-alfa.1 < 1.0.0-alfa.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nForrang henviser til, hvordan versioner sammenlignes med hinanden, når de bestilles.\nForrang SKAL beregnes ved at adskille versionen i større,
mindre, patch og pre-release identifikatorer i den rækkefølge (Byggemetadata
har ikke forrang).\nForrang SKAL beregnes ved at adskille versionen i større,
mindre, patch og pre-release identifikatorer i den rækkefølge (Byggemetadata
har ikke forrang).\nForrang bestemmes af den første forskel, når man sammenligner hver af
disse identifikatorer fra venstre mod højre som følger: Større, mindre og patch
versioner sammenlignes altid numerisk.

        Eksempel: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nForrang bestemmes af den første forskel, når man sammenligner hver af
disse identifikatorer fra venstre mod højre som følger: Større, mindre og patch
versioner sammenlignes altid numerisk.\nEksempel: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nNår større, mindre og patch er ens, har en pre-release version lavere
forrang end en normal version:

        Eksempel: 1.0.0-alfa < 1.0.0.\nNår større, mindre og patch er ens, har en pre-release version lavere
forrang end en normal version:\nEksempel: 1.0.0-alfa < 1.0.0.\nForrang for to pre-release versioner med samme større, mindre og
patch-version SKAL bestemmes ved at sammenligne hver punktsepareret identifikator
fra venstre mod højre, indtil en forskel er fundet som følger:

        
          
            Identifikatorer, der kun består af cifre, sammenlignes numerisk.
          
          
            Identifikatorer med bogstaver eller bindestreger sammenlignes leksikalsk i ASCII
sorteringsrækkefølge.
          
          
            Numeriske identifikatorer har altid lavere forrang end ikke-numeriske
identifikatorer.
          
          
            Et større sæt præ-udgivelsesfelter har en højere prioritet end en
mindre sæt, hvis alle de foregående identifikatorer er ens.
          
        

        Eksempel: 1.0.0-alfa < 1.0.0-alfa.1 < 1.0.0-alfa.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nForrang for to pre-release versioner med samme større, mindre og
patch-version SKAL bestemmes ved at sammenligne hver punktsepareret identifikator
fra venstre mod højre, indtil en forskel er fundet som følger:\nIdentifikatorer, der kun består af cifre, sammenlignes numerisk.\nIdentifikatorer, der kun består af cifre, sammenlignes numerisk.\nIdentifikatorer med bogstaver eller bindestreger sammenlignes leksikalsk i ASCII
sorteringsrækkefølge.\nIdentifikatorer med bogstaver eller bindestreger sammenlignes leksikalsk i ASCII
sorteringsrækkefølge.\nNumeriske identifikatorer har altid lavere forrang end ikke-numeriske
identifikatorer.\nNumeriske identifikatorer har altid lavere forrang end ikke-numeriske
identifikatorer.\nEt større sæt præ-udgivelsesfelter har en højere prioritet end en
mindre sæt, hvis alle de foregående identifikatorer er ens.\nEt større sæt præ-udgivelsesfelter har en højere prioritet end en
mindre sæt, hvis alle de foregående identifikatorer er ens.\nEksempel: 1.0.0-alfa < 1.0.0-alfa.1 < 1.0.0-alfa.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nHvorfor bruge semantisk versionering?\nDette er ikke en ny eller revolutionær idé. Faktisk gør du sikkert noget
tæt på dette allerede. Problemet er, at “tæt” ikke er godt nok. Uden
overensstemmelse med en form for formel specifikation, versionsnumre er
i det væsentlige ubrugelig til afhængighedsstyring. Ved at give et navn og klart
definition til ovenstående ideer, bliver det nemt at kommunikere dine hensigter
til brugerne af din software. Når først disse intentioner er klare, fleksible (men
ikke for fleksible) kan der endelig laves afhængighedsspecifikationer.\nEt simpelt eksempel vil vise, hvordan semantisk versionering kan gøre afhængighed
helvede hører fortiden til. Overvej et bibliotek kaldet “Brandbil.” Det kræver en
Semantisk versioneret pakke med navnet “Ladder.” På det tidspunkt, hvor Firetruck er
oprettet, er Ladder i version 3.1.0. Da Firetruck bruger nogle funktioner
som først blev introduceret i 3.1.0, kan du roligt angive stigen
afhængighed som større end eller lig med 3.1.0, men mindre end 4.0.0. Nu, hvornår
Ladder version 3.1.1 og 3.2.0 bliver tilgængelige, du kan frigive dem til din
pakkestyringssystem og ved, at de vil være kompatible med eksisterende
afhængig software.\nSom ansvarlig udvikler vil du naturligvis gerne verificere, at evt
pakkeopgraderinger fungerer som annonceret. Den virkelige verden er et rodet sted;
der er ikke noget, vi kan gøre ved det, end at være årvågne. Hvad du kan gøre er at lade
Semantisk versionering giver dig en fornuftig måde at frigive og opgradere
pakker uden at skulle rulle nye versioner af afhængige pakker, hvilket sparer dig
tid og bøvl.\nHvis alt dette lyder ønskeligt, er alt hvad du skal gøre for at begynde at bruge Semantic
Versionering er at erklære, at du gør det og derefter følge reglerne. Link
til denne hjemmeside fra din README, så andre kender reglerne og kan drage fordel af
dem.\nHvordan skal jeg håndtere revisioner i 0.y.z indledende udviklingsfase?\nDen enkleste ting at gøre er at starte din første udviklingsudgivelse på 0.1.0
og øg derefter den mindre version for hver efterfølgende udgivelse.\nHvordan ved jeg, hvornår jeg skal udgive 1.0.0?\nHvis din software bliver brugt i produktionen, burde den sandsynligvis allerede være det
1.0.0. Hvis du har et stabilt API, som brugerne er blevet afhængige af, bør du
være 1.0.0. Hvis du bekymrer dig meget om bagudkompatibilitet, bør du
sandsynligvis allerede være 1.0.0.\nAfskrækker dette ikke hurtig udvikling og hurtig iteration?\nStørre version nul handler om hurtig udvikling. Hvis du ændrer API
hver dag bør du enten stadig være i version 0.y.z eller på en separat
udviklingsgren arbejder på den næste store version.\nHvis selv de mindste bagud-inkompatible ændringer af det offentlige API kræver et større versionsbump, vil jeg så ikke ende med version 42.0.0 meget hurtigt?\nDette er et spørgsmål om ansvarlig udvikling og fremsyn. Uforenelig
ændringer bør ikke introduceres let til software, der har en masse
afhængig kode. De omkostninger, der skal afholdes for at opgradere, kan være betydelige.
At skulle bumpe større versioner for at frigive inkompatible ændringer betyder, at du vil
gennemtænk virkningen af ​​dine ændringer, og evaluer cost/benefit-forholdet
involveret.\nDet er for meget arbejde at dokumentere hele det offentlige API!\nDet er dit ansvar som professionel udvikler at dokumentere ordentligt
software, der er beregnet til brug af andre. Håndtering af softwarekompleksitet er en
enormt vigtig del af at holde et projekt effektivt, og det er svært at gøre hvis
ingen ved, hvordan man bruger din software, eller hvilke metoder der er sikre at kalde. I
på lang sigt, semantisk versionering og insisteren på en veldefineret offentlighed
API kan holde alle og alt kørende.\nHvad gør jeg, hvis jeg ved et uheld frigiver en bagudinkompatibel ændring som en mindre version?\nSå snart du indser, at du har brudt Semantic Versioning-specifikationen, skal du rette det
problemet og frigive en ny mindre version, der retter problemet og
genopretter bagudkompatibilitet. Selv under denne omstændighed er det
uacceptabelt at ændre versionerede udgivelser. Hvis det er passende,
dokumentere den krænkende version og informere dine brugere om problemet, således at
de er opmærksomme på den krænkende version.\nHvad skal jeg gøre, hvis jeg opdaterer mine egne afhængigheder uden at ændre det offentlige API?\nDet ville blive betragtet som kompatibelt, da det ikke påvirker der offentlige API.
Software, der eksplicit afhænger af de samme afhængigheder som din pakke
bør have deres egne afhængighedsspecifikationer, og forfatteren vil bemærke evt
konflikter. Afgør, om ændringen er et patch-niveau eller et mindre niveau
ændring afhænger af, om du har opdateret dine afhængigheder for at rette
en fejl eller introducere ny funktionalitet. Vi ville normalt forvente yderligere kode
i sidstnævnte tilfælde, i hvilket tilfælde det åbenbart er en mindre niveaustigning.\nHvad hvis jeg utilsigtet ændrer den offentlige API på en måde, der ikke er i overensstemmelse med ændringen af ​​versionsnummeret (dvs. at koden fejlagtigt introducerer en større brydende ændring i en patch-udgivelse)?\nBrug din bedste dømmekraft. Hvis du har et stort publikum, vil det være drastisk
påvirket af at ændre adfærden tilbage til, hvad den offentlige API havde til hensigt
det kan være bedst at udføre en større versionsudgivelse, selvom rettelsen kunne
strengt taget betragtes som en patch-udgivelse. Husk, Semantisk versionering er alt
om at formidle mening ved, hvordan versionsnummeret ændres. Hvis disse ændringer
er vigtige for dine brugere, skal du bruge versionsnummeret til at informere dem.\nHvordan skal jeg håndtere udfasning af funktionalitet?\nForringelse af eksisterende funktionalitet er en normal del af softwareudvikling og
er ofte påkrævet for at gøre fremskridt. Når du fraskriver en del af din
offentlige API, bør du gøre to ting: (1) opdatere din dokumentation for at lade
brugere kender til ændringen, (2) udsteder en ny mindre udgivelse med afskrivningen
på plads. Før du helt fjerner funktionaliteten i en ny større udgivelse
der bør være mindst én mindre udgivelse, der indeholder udfasningen så
at brugerne problemfrit kan skifte til den nye API.\nHar SemVer en størrelsesbegrænsning på versionsstrengen?\nNej, men brug god dømmekraft. En version på 255 tegn er sandsynligvis overkill,
for eksempel. Også specifikke systemer kan pålægge deres egne grænser for størrelsen af
strengen.\nEr “v1.2.3” en semantisk version?\nNej, “v1.2.3” er ikke en semantisk version. Dog foran en semantisk version
med et “v” er en almindelig måde (på engelsk) at angive, at det er et versionsnummer.
At forkorte “version” som “v” ses ofte med versionskontrol. Eksempel:
git tag v1.2.3 -m "Release version 1.2.3", i hvilket tilfælde “v1.2.3” er et tag
navn og den semantiske version er “1.2.3”.\nEr der et foreslået regulært udtryk (RegEx) til at kontrollere en SemVer-streng?\nDer er to. En med navngivne grupper for de systemer, der understøtter dem
(PCRE [Perl-kompatible regulære udtryk, dvs. Perl, PHP og R], Python
og gå).\nSe: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))$\nOg en med nummererede optagelsesgrupper i stedet (så cg1 = større, cg2 = mindre,
cg3 = patch, cg4 = prerelease og cg5 = byggemetadata), der er kompatibel
med ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
dvs. Perl, PHP og R), Python og Go.\nSe: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0 |[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d *|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?: \.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0 |[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d *|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?: \.[0-9a-zA-Z-]+)*))?$\nDen semantiske versionsspecifikation blev oprindeligt skrevet af Tom
Preston-Werner, opfinder af Gravatar og
medstifter af GitHub.\nHvis du gerne vil give feedback, bedes du åbn et issue på
GitHub.\nåbn et issue på
GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSemantic Versioning 2.0.0

Zusammenfassung

Auf Grundlage einer Versionsnummer von MAJOR.MINOR.PATCH werden die einzelnen Elemente folgendermaßen erhöht:


  MAJOR wird erhöht, wenn API-inkompatible Änderungen veröffentlicht werden,
  MINOR wird erhöht, wenn neue Funktionalitäten, die kompatibel zur bisherigen API sind, veröffentlicht werden, und
  PATCH wird erhöht, wenn die Änderungen ausschließlich API-kompatible Bugfixes umfassen.


Außerdem sind Bezeichner für Vorveröffentlichungen und Build-Metadaten als Erweiterungen zum MAJOR.MINOR.PATCH-Format verfügbar.

Einführung

In der Welt der Softwareentwicklung existiert ein grauenhafter Ort namens „Dependency Hell“. Um so größer ein Projekt wird und je mehr Pakete in die Software integriert werden, desto wahrscheinlicher ist es, dass dieser fürchterliche Ort eines Tages betreten wird.

In Projekten mit vielen Abhängigkeiten kann das Aktualisieren abhängiger Pakete schnell zum Albtraum werden. Sind die Abhängigkeitsspezifikationen des Pakets zu strikt, besteht die Gefahr des „Version Lock“ (die Unfähigkeit, ein Paket zu aktualisieren, ohne, dass alle abhängigen Pakete dieses Pakets ebenfalls aktualisiert werden müssen). Wenn die Abhängigkeiten des Pakets allerdings zu lasch definiert sind, wird sehr wahrscheinlich ein Problem, das sich „Version Promiscuity“ nennt (das Paket gibt vor, mit mehr zukünftigen Versionen seiner abhängigen Pakete kompatibel zu sein, als angemessen ist), eintreten. Dependency Hell bezeichnet die Situation, in der entweder Version Lock oder Version Promiscuity, oder beides den Entwicklungsprozess des Projekts beeinträchtigt.

Als Lösung für dieses Problem schlage ich ein einfaches Regelwerk vor, das definiert, wie Versionsnummern gewählt und erhöht werden. Diese Regeln basieren auf bereits existierenden und weit verbreiteten Verfahren, die sowohl bei der Entwicklung von Closed- als auch von Open-Source-Software verwendet werden, aber beschränken sich nicht zwingend auf diese. Um dieses System nutzen zu können, muss zuerst eine öffentliche API definiert werden. Diese kann entweder in Form einer Dokumentation existieren oder durch den Code selbst erzwungen werden. Egal auf welche Art und Weise die API umgesetzt wird, es ist wichtig, dass sie übersichtlich und präzise ist. Sobald die öffentliche API erstellt wurde, werden Änderungen an dieser durch bestimmte Veränderungen an der Versionsnummer vermittelt. Nimm ein Versionsnummernformat von X.Y.Z (Major.Minor.Patch) an. Bei Einführung von Bugfixes, die die öffentliche API nicht beeinflussen, wird die Patch-Version erhöht, API-kompatible Ergänzungen oder Änderungen erhöhen die Minor Versionsnummer, und Änderungen, die nicht kompatibel zur aktuellen öffentlichen API sind, erhöhen die Major Version.

Ich nenne dieses System „Semantic Versioning“. Versionsnummern, die nach diesem Schema gewählt und erhöht werden, geben direkten Aufschluss über den entsprechenden Code und was sich von einer zur anderen Version verändert hat.

Semantic-Versioning-Spezifikation (SemVer)

Die Terme „MUST“, „MUST NOT“, „REQUIRED“, „SHALL“, „SHALL NOT“, „SHOULD“, „SHOULD NOT“, „RECOMMENDED“, „MAY“ und „OPTIONAL“ in diesem Dokument sind, wie in RFC 2119 beschrieben, zu interpretieren.


  
    Software, die Semantic Versioning nutzt, muss (MUST) eine öffentliche API definieren. Die API kann entweder im Code selbst deklariert werden oder in einer Dokumentation enthalten sein. Wie auch immer sie umgesetzt wird, es ist wichtig, dass sie präzise und ausführlich ist.
  
  
    Eine gewöhnliche Versionsnummer muss (MUST) dem Format X.Y.Z entsprechen, wobei X, Y und Z Ganzzahlen größer oder gleich Null sind und eine Zahl größer als Null keine führenden Nullen enthalten darf. X ist die Major-Version, Y ist die Minor-Version und Z ist die Patch-Version. Jedes Element muss (MUST) auf numerische Art und Weise erhöht werden. Zum Beispiel: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Sobald eine Version eines Projektes veröffentlicht wurde, darf (MUST NOT) der Inhalt dieser Version nicht mehr verändert werden. Eine Änderung am Inhalt muss (MUST) als eine neue Version veröffentlicht werden.
  
  
    Versionsnummern mit einer Major Version von 0 (0.y.z) sind für die initiale Entwicklungsphase gedacht. Änderungen können in jeder denkbaren Form und zu jeder Zeit auftreten. Die öffentliche API sollte nicht als stable betrachtet werden.
  
  
    Die Version 1.0.0 definiert die öffentliche API. Ab dieser Veröffentlichung hängt die Art und Weise, wie die Versionsnummer erhöht und verändert wird, von der öffentlichen API und den Änderungen, die an ihr vollzogen werden, ab.
  
  
    Die Patch-Version Z (x.y.Z | x > 0) muss (MUST) erhöht werden, wenn ausschließlich API-kompatible Bugfixes eingeführt werden. Ein Bugfix ist als eine interne Änderung, die ein fehlerhaftes Verhalten korrigiert, definiert.
  
  
    Die Minor-Version Y (x.Y.z | x > 0) muss (MUST) erhöht werden, wenn neue Funktionalitäten, die kompatibel zur bisherigen API sind, veröffentlicht werden. Sie muss (MUST) außerdem erhöht werden, wenn eine Funktion der öffentlichen API als deprecated markiert wird. Wenn umfangreiche Änderungen an internem Code eingeführt werden, darf (MAY) die Minor-Version ebenfalls erhöht werden. Wenn diese Versionsnummer erhöht wird, muss (MUST) die Patch-Version auf Null zurückgesetzt werden.
  
  
    Die Major-Version X (X.y.z | X > 0) muss (MUST) immer dann erhöht werden, wenn API-inkompatible Änderungen in die öffentlichen API eingeführt werden. Die Änderungen dürfen (MAY) auch Änderungen umfassen, die ansonsten die Minor-Version oder die Patch-Version erhöht hätten. Wenn diese Versionsnummer erhöht wird, muss (MUST) sowohl die Minor-Version als auch die Patch-Version auf Null zurückgesetzt werden.
  
  
    Eine Vorveröffentlichung kann (MAY) gekennzeichnet werden, indem ein Bindestrich, gefolgt von dem Vorveröffentlichungs-Bezeichner, dessen Elemente durch Punkte voneinander getrennt werden, an die Patch-Version angehängt wird. Die Elemente des Bezeichners dürfen (MUST) nur aus alphanumerischen ASCII-Zeichen und dem Bindestrich ([0-9A-Za-z-]) bestehen. Sie dürfen (MUST NOT) außerdem nicht leer sein. Wenn ein Element ausschließlich aus Ziffern besteht, darf (MUST NOT) es keine führenden Nullen enthalten. Eine Vorveröffentlichungs-Version hat einen niedrigeren Rang als die entsprechende reguläre Version. Ein Vorveröffentlichungs-Bezeichner kennzeichnet, dass die Version als unstable zu betrachten ist und dass sie unter Umständen nicht den Kompatibilitätsanforderungen, die für die entsprechende reguläre Version bestimmt wurden, entspricht. Beispiele: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Build-Metadaten können (MAY) ausgezeichnet werden, indem ein Plus-Symbol, gefolgt von den Metadaten, deren Elemente durch Punkte voneinander getrennt werden, an die Patch-Version oder den Vorveröffentlichungs-Bezeichner angehängt wird. Die Elemente der Metadaten dürfen (MUST) nur aus alphanumerischen ASCII-Zeichen und dem Bindestrich ([0-9A-Za-z-]) bestehen. Sie dürfen (MUST NOT) außerdem nicht leer sein. Die Build-Metadaten haben keinerlei Einfluss auf den Rang einer Version, sodass zwei Versionen, deren Versionsnummern sich nur in den Build-Metadaten unterscheiden, denselben Rang einnehmen. Beispiele: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    Der Rang einer Version bestimmt, welche Versionsnummer einer anderen übergeordnet ist, wenn diese bei einer Sortierung miteinander verglichen werden. Der Rang wird (MUST) aus der Major-, Minor- und Patch-Version sowie dem Vorveröffentlichungs-Bezeichner berechnet (die Build-Metadaten haben keinerlei Einfluss auf den Rang einer Version). Er wird bestimmt, indem der erste Unterschied zwischen den oben aufgeführten Elementen ermittelt wird. Dabei wird von links nach rechts, in der oben genannten Reihenfolge vorgegangen. Die Major-, Minor- und Patch-Versionen werden numerisch miteinander verglichen. Beispiel: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Beim Vergleich von zwei Versionsnummern, deren Major-, Minor- und Patch-Versionen gleich sind, nimmt eine Vorveröffentlichung einen niedrigeren Rang als die reguläre Version ein. Beispiel: 1.0.0-alpha < 1.0.0. Sind beide dieser Versionen Vorveröffentlichungen, wird (MUST) der Rang ermittelt, indem jedes Element eines Vorveröffentlichungs-Bezeichners (durch Punkte voneinander getrennt) mit dem der anderen Version verglichen wird, bis ein Unterschied festgestellt wird. Auch hierbei wird von links nach rechts vorgegangen. Elemente, die ausschließlich aus Ziffern bestehen, werden numerisch miteinander verglichen. Der Vergleich aller anderen Elemente erfolgt auf Basis der ASCII-Stellenwerte ihrer Zeichen. Numerische Elemente haben immer einen niedrigeren Rang als solche, die auch andere Zeichen enthalten. Falls alle Elemente identisch sind, nimmt der Bezeichner mit den meisten Elementen den höheren Rang ein. Beispiel: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Backus–Naur Form Grammatik für valide SemVer Versionen
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


Weshalb sollte man Semantic Versioning nutzen?

Dieses System ist keine neue oder revolutionäre Idee. Tatsächlich hast du wahrscheinlich bereits ein ähnliches System genutzt. Das Problem ist, dass „ähnlich“ nicht ausreichend ist. Ohne Einhaltung irgendeiner Art von offizieller Spezifikation, sind Versionsnummern nicht besonders hilfreich beim Verwalten von Abhängigkeiten. Durch das Benennen und Aufstellen von Regeln für die am Anfang dieses Dokuments angesprochenen Ideen, wird es einfach, Nutzer der Software über die Art und den Umfang der Änderungen zu informieren. Sobald diese Informationen ersichtlich sind, können endlich flexible (aber nicht zu flexible) Abhängigkeitsangaben gemacht werden.

Wie Semantic Versioning die Dependency Hell ein Problem der Vergangenheit werden lassen kann, wird hier an einem einfachen Beispiel veranschaulicht. Geh von einer Library namens „Firetruck“ aus. Sie ist abhängig von einem Semantically versioned Paket namens „Ladder“. Zum Zeitpunkt der Erstellung von Firetruck befindet sich Ladder in Version 3.1.0. Da Firetruck eine Funktion von Ladder verwendet, die erst ab Version 3.1.0 verfügbar ist, kann die Abhängigkeit als größer oder gleich 3.1.0, aber kleiner als 4.0.0 definiert werden. Wenn also jetzt Version 3.1.1 oder 3.2.0 von Ladder veröffentlicht wird, kann diese einfach im Package-Management-System freigeschaltet werden, mit der Gewissheit, dass sie mit der abhängigen Software (Firetruck) kompatibel ist.

Als ein verantwortungsbewusster Programmierer will man natürlich prüfen, ob die aktualisierten Pakete wie beschrieben funktionieren. Die richtige Welt ist ein chaotischer Ort; es gibt nichts, was wir tun können, um dies sicherstellen, aber sei wachsam! Was wir tun können, ist, Semantic Versioning zu nutzen, um auf eine angemessen einfache Art und Weise Pakete zu aktualisieren, ohne auch deren abhängige Pakete aktualisieren zu müssen und damit Zeit und Aufwand zu sparen.

Wenn das alles wünschenswert klingt und von den Vorteilen profitiert werden soll, muss nichts Weiteres getan werden, als anzugeben, dass ein Projekt Semantic Versioning verwendet und anschließend den oben genannten Regeln Folge zu leisten. Verweise in der README auf diese Webseite, sodass auch andere über die Regeln Bescheid wissen und von ihnen profitieren können.

FAQ

Wie soll ich bei der Versionierung in der initialen Entwicklungsphase (0.y.z) verfahren?

Das Einfachste ist, die Versionierung bei 0.1.0 zu beginnen und dann bei jeder folgenden Veröffentlichung die Minor-Version zu erhöhen.

Woher weiß ich, wann es Zeit ist, Version 1.0.0 zu veröffentlichen?

Wenn die Software schon in der Produktion verwendet wird, sollte sie bereits in Version 1.0.0 vorliegen. Falls eine stable API existiert, auf die sich Nutzer bereits verlassen, sollte es ebenfalls die Version 1.0.0 sein. Auch wenn Kompatibilität zu vorherigen Versionen bereits eine wichtige Rolle spielt, ist Version 1.0.0 angebracht.

Hält das nicht von Rapid Development und Fast Iteration ab?

In Versionen mit einer Major-Version von Null dreht sich alles um Rapid Development. Wenn sich die API tagtäglich verändert, sollte sich das Projekt entweder noch in Version 0.y.z befinden oder es sollte auf einem separaten Entwicklungs-Branch an der nächsten Major-Veröffentlichung gearbeitet werden.

Wenn schon die kleinsten API-inkompatiblen Änderungen an der öffentlichen API eine Anhebung der Major-Version erfordern, wird eine Version wie 42.0.0 nicht sehr schnell erreicht werden?

Das ist eine Frage von verantwortungsbewusster Entwicklung und Weitsicht. API-inkompatible Änderungen sollten nicht leichtfertig eingeführt werden, da das Aktualisieren des Pakets in Software von Dritten, die eine große Menge an API-spezifischem Code enthalten, mit drastischem Aufwand verbunden sein kann. Die Tatsache, dass die Major-Version beim Einführen von API-inkompatiblen Änderungen angehoben werden muss, drängt einen dazu, die Auswirkungen der Änderungen noch einmal zu überdenken und das Kosten-Nutzen-Verhältnis abzuwägen.

Die gesamte öffentliche API zu dokumentieren, ist viel zu viel Arbeit!

Es ist die Aufgabe eines professionellen Entwicklers, Software, die für die Verwendung durch andere bestimmt ist, ordentlich zu dokumentieren. Das Verwalten der Komplexität einer Software ist ein enorm wichtiger Teil, wenn es darum geht, ein Projekt erfolgreich zu betreiben, was schwer ist, wenn niemand weiß, wie eine Software zu verwenden ist oder welche Funktionen sie anbietet. Langfristig gesehen, werden Semantic Versioning und eine gut definierte öffentliche API ein System sicherstellen, in dem alles reibungslos ineinandergreift.

Was soll ich tun, wenn ich versehentlich eine API-inkompatible Änderung in einer Minor-Version veröffentlicht habe?

Sobald du feststellst, dass du die Semantic Versioning Spezifikation nicht befolgt hast, korrigiere den Fehler, indem du eine neue Minor-Version veröffentlichst, die das Problem behebt und die Kompatibilität zur API wiederherstellt. Selbst unter diesen Umständen ist es nicht erlaubt, eine bereits veröffentlichte Version zu verändern. Falls es angemessen ist, dokumentiere, welche Version problematisch ist, sodass die Nutzer über diese Version Bescheid wissen.

Was soll ich tun, wenn ich die Abhängigkeitsangaben meines Projekts ändere, aber keine Änderungen an der öffentlichen API einführe?

Dies würde als kompatibel angesehen werden, da es die öffentliche API nicht beeinflusst. Eine Software, die ausdrücklich dieselben Abhängigkeiten wie das Paket hat, sollte seine eigenen Abhängigkeitsangaben haben, und der Autor der Software wird mögliche Konflikte selbstständig feststellen. Ob nun die Minor-Version oder aber die Patch-Version erhöht wird, hängt davon ab, ob die Abhängigkeiten aktualisiert wurden, um einen Bug zu beseitigen oder um eine neue Funktionalität zu ergänzen. Normalerweise geschieht dies aus letzterem Grund, bei dem natürlich die Minor-Version angehoben werden müsste.

Was soll ich tun, wenn ich die öffentliche API versehentlich derartig verändert habe, dass sie nicht mit der Änderung an der Versionsnummer harmoniert (das heißt, der Code zerstört fälschlicherweise in einer Patch-Version die API-Konformität)?

Entscheide nach deinem eigenen Ermessen. Wenn du eine große Nutzergemeinde hast, die von der aktuellen API stark abhängt, dann wäre es wahrscheinlich das Beste, die Veröffentlichung als eine Major-Version zu publizieren, auch wenn die Änderungen eigentlich nur einen Patch darstellen sollten. Denk dran, bei Semantic Versioning dreht sich alles darum, die Art und den Umfang der Änderungen am Code durch die Änderungen an der Versionsnummer zu vermitteln.

Wie soll ich mit deprecated Funktionen verfahren?

Funktionalitäten als deprecated zu markieren, ist ein gewöhnlicher Teil von Softwareentwicklung und ist häufig notwendig, um mit der Entwicklung voranzuschreiten. Wenn etwas in der öffentlichen API als deprecated markiert wird, sollte erstens, die Dokumentation bezüglich der Änderungen angepasst werden, und zweitens, eine neue Minor-Version mit der deprecated Funktionalität veröffentlicht werden. Bevor die Funktionalität in einer Major-Veröffentlichung vollständig entfernt wird, sollte mindestens eine Minor-Version, die die Deprecation enthält, veröffentlicht werden, sodass Nutzer einfach zur neuen API migrieren können.

Ist die Länge eines SemVer-Version-Strings limitiert?

Nein, aber sei vernünftig. Zum Beispiel wäre ein 255 Zeichen langer Version-String wahrscheinlich ein wenig übertrieben. Außerdem könnten bestimmte Systeme ihre eigenen Limits definieren.

Über

Die Semantic-Versioning-Spezifikation wurde von Tom Preston-Werner, Erfinder von Gravatars und Mitbegründer von GitHub, erstellt.

Für Feedback, eröffne bitte ein Issue auf GitHub.

Lizenz

Creative Commons ― CC BY 3.0\nSemantic Versioning 2.0.0\nAuf Grundlage einer Versionsnummer von MAJOR.MINOR.PATCH werden die einzelnen Elemente folgendermaßen erhöht:\nMAJOR wird erhöht, wenn API-inkompatible Änderungen veröffentlicht werden,\nMINOR wird erhöht, wenn neue Funktionalitäten, die kompatibel zur bisherigen API sind, veröffentlicht werden, und\nPATCH wird erhöht, wenn die Änderungen ausschließlich API-kompatible Bugfixes umfassen.\nAußerdem sind Bezeichner für Vorveröffentlichungen und Build-Metadaten als Erweiterungen zum MAJOR.MINOR.PATCH-Format verfügbar.\nIn der Welt der Softwareentwicklung existiert ein grauenhafter Ort namens „Dependency Hell“. Um so größer ein Projekt wird und je mehr Pakete in die Software integriert werden, desto wahrscheinlicher ist es, dass dieser fürchterliche Ort eines Tages betreten wird.\nIn Projekten mit vielen Abhängigkeiten kann das Aktualisieren abhängiger Pakete schnell zum Albtraum werden. Sind die Abhängigkeitsspezifikationen des Pakets zu strikt, besteht die Gefahr des „Version Lock“ (die Unfähigkeit, ein Paket zu aktualisieren, ohne, dass alle abhängigen Pakete dieses Pakets ebenfalls aktualisiert werden müssen). Wenn die Abhängigkeiten des Pakets allerdings zu lasch definiert sind, wird sehr wahrscheinlich ein Problem, das sich „Version Promiscuity“ nennt (das Paket gibt vor, mit mehr zukünftigen Versionen seiner abhängigen Pakete kompatibel zu sein, als angemessen ist), eintreten. Dependency Hell bezeichnet die Situation, in der entweder Version Lock oder Version Promiscuity, oder beides den Entwicklungsprozess des Projekts beeinträchtigt.\nAls Lösung für dieses Problem schlage ich ein einfaches Regelwerk vor, das definiert, wie Versionsnummern gewählt und erhöht werden. Diese Regeln basieren auf bereits existierenden und weit verbreiteten Verfahren, die sowohl bei der Entwicklung von Closed- als auch von Open-Source-Software verwendet werden, aber beschränken sich nicht zwingend auf diese. Um dieses System nutzen zu können, muss zuerst eine öffentliche API definiert werden. Diese kann entweder in Form einer Dokumentation existieren oder durch den Code selbst erzwungen werden. Egal auf welche Art und Weise die API umgesetzt wird, es ist wichtig, dass sie übersichtlich und präzise ist. Sobald die öffentliche API erstellt wurde, werden Änderungen an dieser durch bestimmte Veränderungen an der Versionsnummer vermittelt. Nimm ein Versionsnummernformat von X.Y.Z (Major.Minor.Patch) an. Bei Einführung von Bugfixes, die die öffentliche API nicht beeinflussen, wird die Patch-Version erhöht, API-kompatible Ergänzungen oder Änderungen erhöhen die Minor Versionsnummer, und Änderungen, die nicht kompatibel zur aktuellen öffentlichen API sind, erhöhen die Major Version.\nIch nenne dieses System „Semantic Versioning“. Versionsnummern, die nach diesem Schema gewählt und erhöht werden, geben direkten Aufschluss über den entsprechenden Code und was sich von einer zur anderen Version verändert hat.\nSemantic-Versioning-Spezifikation (SemVer)\nDie Terme „MUST“, „MUST NOT“, „REQUIRED“, „SHALL“, „SHALL NOT“, „SHOULD“, „SHOULD NOT“, „RECOMMENDED“, „MAY“ und „OPTIONAL“ in diesem Dokument sind, wie in RFC 2119 beschrieben, zu interpretieren.\nSoftware, die Semantic Versioning nutzt, muss (MUST) eine öffentliche API definieren. Die API kann entweder im Code selbst deklariert werden oder in einer Dokumentation enthalten sein. Wie auch immer sie umgesetzt wird, es ist wichtig, dass sie präzise und ausführlich ist.\nSoftware, die Semantic Versioning nutzt, muss (MUST) eine öffentliche API definieren. Die API kann entweder im Code selbst deklariert werden oder in einer Dokumentation enthalten sein. Wie auch immer sie umgesetzt wird, es ist wichtig, dass sie präzise und ausführlich ist.\nEine gewöhnliche Versionsnummer muss (MUST) dem Format X.Y.Z entsprechen, wobei X, Y und Z Ganzzahlen größer oder gleich Null sind und eine Zahl größer als Null keine führenden Nullen enthalten darf. X ist die Major-Version, Y ist die Minor-Version und Z ist die Patch-Version. Jedes Element muss (MUST) auf numerische Art und Weise erhöht werden. Zum Beispiel: 1.9.0 -> 1.10.0 -> 1.11.0.\nEine gewöhnliche Versionsnummer muss (MUST) dem Format X.Y.Z entsprechen, wobei X, Y und Z Ganzzahlen größer oder gleich Null sind und eine Zahl größer als Null keine führenden Nullen enthalten darf. X ist die Major-Version, Y ist die Minor-Version und Z ist die Patch-Version. Jedes Element muss (MUST) auf numerische Art und Weise erhöht werden. Zum Beispiel: 1.9.0 -> 1.10.0 -> 1.11.0.\nSobald eine Version eines Projektes veröffentlicht wurde, darf (MUST NOT) der Inhalt dieser Version nicht mehr verändert werden. Eine Änderung am Inhalt muss (MUST) als eine neue Version veröffentlicht werden.\nSobald eine Version eines Projektes veröffentlicht wurde, darf (MUST NOT) der Inhalt dieser Version nicht mehr verändert werden. Eine Änderung am Inhalt muss (MUST) als eine neue Version veröffentlicht werden.\nVersionsnummern mit einer Major Version von 0 (0.y.z) sind für die initiale Entwicklungsphase gedacht. Änderungen können in jeder denkbaren Form und zu jeder Zeit auftreten. Die öffentliche API sollte nicht als stable betrachtet werden.\nVersionsnummern mit einer Major Version von 0 (0.y.z) sind für die initiale Entwicklungsphase gedacht. Änderungen können in jeder denkbaren Form und zu jeder Zeit auftreten. Die öffentliche API sollte nicht als stable betrachtet werden.\nDie Version 1.0.0 definiert die öffentliche API. Ab dieser Veröffentlichung hängt die Art und Weise, wie die Versionsnummer erhöht und verändert wird, von der öffentlichen API und den Änderungen, die an ihr vollzogen werden, ab.\nDie Version 1.0.0 definiert die öffentliche API. Ab dieser Veröffentlichung hängt die Art und Weise, wie die Versionsnummer erhöht und verändert wird, von der öffentlichen API und den Änderungen, die an ihr vollzogen werden, ab.\nDie Patch-Version Z (x.y.Z | x > 0) muss (MUST) erhöht werden, wenn ausschließlich API-kompatible Bugfixes eingeführt werden. Ein Bugfix ist als eine interne Änderung, die ein fehlerhaftes Verhalten korrigiert, definiert.\nDie Patch-Version Z (x.y.Z | x > 0) muss (MUST) erhöht werden, wenn ausschließlich API-kompatible Bugfixes eingeführt werden. Ein Bugfix ist als eine interne Änderung, die ein fehlerhaftes Verhalten korrigiert, definiert.\nDie Minor-Version Y (x.Y.z | x > 0) muss (MUST) erhöht werden, wenn neue Funktionalitäten, die kompatibel zur bisherigen API sind, veröffentlicht werden. Sie muss (MUST) außerdem erhöht werden, wenn eine Funktion der öffentlichen API als deprecated markiert wird. Wenn umfangreiche Änderungen an internem Code eingeführt werden, darf (MAY) die Minor-Version ebenfalls erhöht werden. Wenn diese Versionsnummer erhöht wird, muss (MUST) die Patch-Version auf Null zurückgesetzt werden.\nDie Minor-Version Y (x.Y.z | x > 0) muss (MUST) erhöht werden, wenn neue Funktionalitäten, die kompatibel zur bisherigen API sind, veröffentlicht werden. Sie muss (MUST) außerdem erhöht werden, wenn eine Funktion der öffentlichen API als deprecated markiert wird. Wenn umfangreiche Änderungen an internem Code eingeführt werden, darf (MAY) die Minor-Version ebenfalls erhöht werden. Wenn diese Versionsnummer erhöht wird, muss (MUST) die Patch-Version auf Null zurückgesetzt werden.\nDie Major-Version X (X.y.z | X > 0) muss (MUST) immer dann erhöht werden, wenn API-inkompatible Änderungen in die öffentlichen API eingeführt werden. Die Änderungen dürfen (MAY) auch Änderungen umfassen, die ansonsten die Minor-Version oder die Patch-Version erhöht hätten. Wenn diese Versionsnummer erhöht wird, muss (MUST) sowohl die Minor-Version als auch die Patch-Version auf Null zurückgesetzt werden.\nDie Major-Version X (X.y.z | X > 0) muss (MUST) immer dann erhöht werden, wenn API-inkompatible Änderungen in die öffentlichen API eingeführt werden. Die Änderungen dürfen (MAY) auch Änderungen umfassen, die ansonsten die Minor-Version oder die Patch-Version erhöht hätten. Wenn diese Versionsnummer erhöht wird, muss (MUST) sowohl die Minor-Version als auch die Patch-Version auf Null zurückgesetzt werden.\nEine Vorveröffentlichung kann (MAY) gekennzeichnet werden, indem ein Bindestrich, gefolgt von dem Vorveröffentlichungs-Bezeichner, dessen Elemente durch Punkte voneinander getrennt werden, an die Patch-Version angehängt wird. Die Elemente des Bezeichners dürfen (MUST) nur aus alphanumerischen ASCII-Zeichen und dem Bindestrich ([0-9A-Za-z-]) bestehen. Sie dürfen (MUST NOT) außerdem nicht leer sein. Wenn ein Element ausschließlich aus Ziffern besteht, darf (MUST NOT) es keine führenden Nullen enthalten. Eine Vorveröffentlichungs-Version hat einen niedrigeren Rang als die entsprechende reguläre Version. Ein Vorveröffentlichungs-Bezeichner kennzeichnet, dass die Version als unstable zu betrachten ist und dass sie unter Umständen nicht den Kompatibilitätsanforderungen, die für die entsprechende reguläre Version bestimmt wurden, entspricht. Beispiele: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nEine Vorveröffentlichung kann (MAY) gekennzeichnet werden, indem ein Bindestrich, gefolgt von dem Vorveröffentlichungs-Bezeichner, dessen Elemente durch Punkte voneinander getrennt werden, an die Patch-Version angehängt wird. Die Elemente des Bezeichners dürfen (MUST) nur aus alphanumerischen ASCII-Zeichen und dem Bindestrich ([0-9A-Za-z-]) bestehen. Sie dürfen (MUST NOT) außerdem nicht leer sein. Wenn ein Element ausschließlich aus Ziffern besteht, darf (MUST NOT) es keine führenden Nullen enthalten. Eine Vorveröffentlichungs-Version hat einen niedrigeren Rang als die entsprechende reguläre Version. Ein Vorveröffentlichungs-Bezeichner kennzeichnet, dass die Version als unstable zu betrachten ist und dass sie unter Umständen nicht den Kompatibilitätsanforderungen, die für die entsprechende reguläre Version bestimmt wurden, entspricht. Beispiele: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nBuild-Metadaten können (MAY) ausgezeichnet werden, indem ein Plus-Symbol, gefolgt von den Metadaten, deren Elemente durch Punkte voneinander getrennt werden, an die Patch-Version oder den Vorveröffentlichungs-Bezeichner angehängt wird. Die Elemente der Metadaten dürfen (MUST) nur aus alphanumerischen ASCII-Zeichen und dem Bindestrich ([0-9A-Za-z-]) bestehen. Sie dürfen (MUST NOT) außerdem nicht leer sein. Die Build-Metadaten haben keinerlei Einfluss auf den Rang einer Version, sodass zwei Versionen, deren Versionsnummern sich nur in den Build-Metadaten unterscheiden, denselben Rang einnehmen. Beispiele: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nBuild-Metadaten können (MAY) ausgezeichnet werden, indem ein Plus-Symbol, gefolgt von den Metadaten, deren Elemente durch Punkte voneinander getrennt werden, an die Patch-Version oder den Vorveröffentlichungs-Bezeichner angehängt wird. Die Elemente der Metadaten dürfen (MUST) nur aus alphanumerischen ASCII-Zeichen und dem Bindestrich ([0-9A-Za-z-]) bestehen. Sie dürfen (MUST NOT) außerdem nicht leer sein. Die Build-Metadaten haben keinerlei Einfluss auf den Rang einer Version, sodass zwei Versionen, deren Versionsnummern sich nur in den Build-Metadaten unterscheiden, denselben Rang einnehmen. Beispiele: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nDer Rang einer Version bestimmt, welche Versionsnummer einer anderen übergeordnet ist, wenn diese bei einer Sortierung miteinander verglichen werden. Der Rang wird (MUST) aus der Major-, Minor- und Patch-Version sowie dem Vorveröffentlichungs-Bezeichner berechnet (die Build-Metadaten haben keinerlei Einfluss auf den Rang einer Version). Er wird bestimmt, indem der erste Unterschied zwischen den oben aufgeführten Elementen ermittelt wird. Dabei wird von links nach rechts, in der oben genannten Reihenfolge vorgegangen. Die Major-, Minor- und Patch-Versionen werden numerisch miteinander verglichen. Beispiel: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Beim Vergleich von zwei Versionsnummern, deren Major-, Minor- und Patch-Versionen gleich sind, nimmt eine Vorveröffentlichung einen niedrigeren Rang als die reguläre Version ein. Beispiel: 1.0.0-alpha < 1.0.0. Sind beide dieser Versionen Vorveröffentlichungen, wird (MUST) der Rang ermittelt, indem jedes Element eines Vorveröffentlichungs-Bezeichners (durch Punkte voneinander getrennt) mit dem der anderen Version verglichen wird, bis ein Unterschied festgestellt wird. Auch hierbei wird von links nach rechts vorgegangen. Elemente, die ausschließlich aus Ziffern bestehen, werden numerisch miteinander verglichen. Der Vergleich aller anderen Elemente erfolgt auf Basis der ASCII-Stellenwerte ihrer Zeichen. Numerische Elemente haben immer einen niedrigeren Rang als solche, die auch andere Zeichen enthalten. Falls alle Elemente identisch sind, nimmt der Bezeichner mit den meisten Elementen den höheren Rang ein. Beispiel: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nDer Rang einer Version bestimmt, welche Versionsnummer einer anderen übergeordnet ist, wenn diese bei einer Sortierung miteinander verglichen werden. Der Rang wird (MUST) aus der Major-, Minor- und Patch-Version sowie dem Vorveröffentlichungs-Bezeichner berechnet (die Build-Metadaten haben keinerlei Einfluss auf den Rang einer Version). Er wird bestimmt, indem der erste Unterschied zwischen den oben aufgeführten Elementen ermittelt wird. Dabei wird von links nach rechts, in der oben genannten Reihenfolge vorgegangen. Die Major-, Minor- und Patch-Versionen werden numerisch miteinander verglichen. Beispiel: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Beim Vergleich von zwei Versionsnummern, deren Major-, Minor- und Patch-Versionen gleich sind, nimmt eine Vorveröffentlichung einen niedrigeren Rang als die reguläre Version ein. Beispiel: 1.0.0-alpha < 1.0.0. Sind beide dieser Versionen Vorveröffentlichungen, wird (MUST) der Rang ermittelt, indem jedes Element eines Vorveröffentlichungs-Bezeichners (durch Punkte voneinander getrennt) mit dem der anderen Version verglichen wird, bis ein Unterschied festgestellt wird. Auch hierbei wird von links nach rechts vorgegangen. Elemente, die ausschließlich aus Ziffern bestehen, werden numerisch miteinander verglichen. Der Vergleich aller anderen Elemente erfolgt auf Basis der ASCII-Stellenwerte ihrer Zeichen. Numerische Elemente haben immer einen niedrigeren Rang als solche, die auch andere Zeichen enthalten. Falls alle Elemente identisch sind, nimmt der Bezeichner mit den meisten Elementen den höheren Rang ein. Beispiel: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nBackus–Naur Form Grammatik für valide SemVer Versionen\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nWeshalb sollte man Semantic Versioning nutzen?\nDieses System ist keine neue oder revolutionäre Idee. Tatsächlich hast du wahrscheinlich bereits ein ähnliches System genutzt. Das Problem ist, dass „ähnlich“ nicht ausreichend ist. Ohne Einhaltung irgendeiner Art von offizieller Spezifikation, sind Versionsnummern nicht besonders hilfreich beim Verwalten von Abhängigkeiten. Durch das Benennen und Aufstellen von Regeln für die am Anfang dieses Dokuments angesprochenen Ideen, wird es einfach, Nutzer der Software über die Art und den Umfang der Änderungen zu informieren. Sobald diese Informationen ersichtlich sind, können endlich flexible (aber nicht zu flexible) Abhängigkeitsangaben gemacht werden.\nWie Semantic Versioning die Dependency Hell ein Problem der Vergangenheit werden lassen kann, wird hier an einem einfachen Beispiel veranschaulicht. Geh von einer Library namens „Firetruck“ aus. Sie ist abhängig von einem Semantically versioned Paket namens „Ladder“. Zum Zeitpunkt der Erstellung von Firetruck befindet sich Ladder in Version 3.1.0. Da Firetruck eine Funktion von Ladder verwendet, die erst ab Version 3.1.0 verfügbar ist, kann die Abhängigkeit als größer oder gleich 3.1.0, aber kleiner als 4.0.0 definiert werden. Wenn also jetzt Version 3.1.1 oder 3.2.0 von Ladder veröffentlicht wird, kann diese einfach im Package-Management-System freigeschaltet werden, mit der Gewissheit, dass sie mit der abhängigen Software (Firetruck) kompatibel ist.\nAls ein verantwortungsbewusster Programmierer will man natürlich prüfen, ob die aktualisierten Pakete wie beschrieben funktionieren. Die richtige Welt ist ein chaotischer Ort; es gibt nichts, was wir tun können, um dies sicherstellen, aber sei wachsam! Was wir tun können, ist, Semantic Versioning zu nutzen, um auf eine angemessen einfache Art und Weise Pakete zu aktualisieren, ohne auch deren abhängige Pakete aktualisieren zu müssen und damit Zeit und Aufwand zu sparen.\nWenn das alles wünschenswert klingt und von den Vorteilen profitiert werden soll, muss nichts Weiteres getan werden, als anzugeben, dass ein Projekt Semantic Versioning verwendet und anschließend den oben genannten Regeln Folge zu leisten. Verweise in der README auf diese Webseite, sodass auch andere über die Regeln Bescheid wissen und von ihnen profitieren können.\nWie soll ich bei der Versionierung in der initialen Entwicklungsphase (0.y.z) verfahren?\nDas Einfachste ist, die Versionierung bei 0.1.0 zu beginnen und dann bei jeder folgenden Veröffentlichung die Minor-Version zu erhöhen.\nWoher weiß ich, wann es Zeit ist, Version 1.0.0 zu veröffentlichen?\nWenn die Software schon in der Produktion verwendet wird, sollte sie bereits in Version 1.0.0 vorliegen. Falls eine stable API existiert, auf die sich Nutzer bereits verlassen, sollte es ebenfalls die Version 1.0.0 sein. Auch wenn Kompatibilität zu vorherigen Versionen bereits eine wichtige Rolle spielt, ist Version 1.0.0 angebracht.\nHält das nicht von Rapid Development und Fast Iteration ab?\nIn Versionen mit einer Major-Version von Null dreht sich alles um Rapid Development. Wenn sich die API tagtäglich verändert, sollte sich das Projekt entweder noch in Version 0.y.z befinden oder es sollte auf einem separaten Entwicklungs-Branch an der nächsten Major-Veröffentlichung gearbeitet werden.\nWenn schon die kleinsten API-inkompatiblen Änderungen an der öffentlichen API eine Anhebung der Major-Version erfordern, wird eine Version wie 42.0.0 nicht sehr schnell erreicht werden?\nDas ist eine Frage von verantwortungsbewusster Entwicklung und Weitsicht. API-inkompatible Änderungen sollten nicht leichtfertig eingeführt werden, da das Aktualisieren des Pakets in Software von Dritten, die eine große Menge an API-spezifischem Code enthalten, mit drastischem Aufwand verbunden sein kann. Die Tatsache, dass die Major-Version beim Einführen von API-inkompatiblen Änderungen angehoben werden muss, drängt einen dazu, die Auswirkungen der Änderungen noch einmal zu überdenken und das Kosten-Nutzen-Verhältnis abzuwägen.\nDie gesamte öffentliche API zu dokumentieren, ist viel zu viel Arbeit!\nEs ist die Aufgabe eines professionellen Entwicklers, Software, die für die Verwendung durch andere bestimmt ist, ordentlich zu dokumentieren. Das Verwalten der Komplexität einer Software ist ein enorm wichtiger Teil, wenn es darum geht, ein Projekt erfolgreich zu betreiben, was schwer ist, wenn niemand weiß, wie eine Software zu verwenden ist oder welche Funktionen sie anbietet. Langfristig gesehen, werden Semantic Versioning und eine gut definierte öffentliche API ein System sicherstellen, in dem alles reibungslos ineinandergreift.\nWas soll ich tun, wenn ich versehentlich eine API-inkompatible Änderung in einer Minor-Version veröffentlicht habe?\nSobald du feststellst, dass du die Semantic Versioning Spezifikation nicht befolgt hast, korrigiere den Fehler, indem du eine neue Minor-Version veröffentlichst, die das Problem behebt und die Kompatibilität zur API wiederherstellt. Selbst unter diesen Umständen ist es nicht erlaubt, eine bereits veröffentlichte Version zu verändern. Falls es angemessen ist, dokumentiere, welche Version problematisch ist, sodass die Nutzer über diese Version Bescheid wissen.\nWas soll ich tun, wenn ich die Abhängigkeitsangaben meines Projekts ändere, aber keine Änderungen an der öffentlichen API einführe?\nDies würde als kompatibel angesehen werden, da es die öffentliche API nicht beeinflusst. Eine Software, die ausdrücklich dieselben Abhängigkeiten wie das Paket hat, sollte seine eigenen Abhängigkeitsangaben haben, und der Autor der Software wird mögliche Konflikte selbstständig feststellen. Ob nun die Minor-Version oder aber die Patch-Version erhöht wird, hängt davon ab, ob die Abhängigkeiten aktualisiert wurden, um einen Bug zu beseitigen oder um eine neue Funktionalität zu ergänzen. Normalerweise geschieht dies aus letzterem Grund, bei dem natürlich die Minor-Version angehoben werden müsste.\nWas soll ich tun, wenn ich die öffentliche API versehentlich derartig verändert habe, dass sie nicht mit der Änderung an der Versionsnummer harmoniert (das heißt, der Code zerstört fälschlicherweise in einer Patch-Version die API-Konformität)?\nEntscheide nach deinem eigenen Ermessen. Wenn du eine große Nutzergemeinde hast, die von der aktuellen API stark abhängt, dann wäre es wahrscheinlich das Beste, die Veröffentlichung als eine Major-Version zu publizieren, auch wenn die Änderungen eigentlich nur einen Patch darstellen sollten. Denk dran, bei Semantic Versioning dreht sich alles darum, die Art und den Umfang der Änderungen am Code durch die Änderungen an der Versionsnummer zu vermitteln.\nWie soll ich mit deprecated Funktionen verfahren?\nFunktionalitäten als deprecated zu markieren, ist ein gewöhnlicher Teil von Softwareentwicklung und ist häufig notwendig, um mit der Entwicklung voranzuschreiten. Wenn etwas in der öffentlichen API als deprecated markiert wird, sollte erstens, die Dokumentation bezüglich der Änderungen angepasst werden, und zweitens, eine neue Minor-Version mit der deprecated Funktionalität veröffentlicht werden. Bevor die Funktionalität in einer Major-Veröffentlichung vollständig entfernt wird, sollte mindestens eine Minor-Version, die die Deprecation enthält, veröffentlicht werden, sodass Nutzer einfach zur neuen API migrieren können.\nIst die Länge eines SemVer-Version-Strings limitiert?\nNein, aber sei vernünftig. Zum Beispiel wäre ein 255 Zeichen langer Version-String wahrscheinlich ein wenig übertrieben. Außerdem könnten bestimmte Systeme ihre eigenen Limits definieren.\nDie Semantic-Versioning-Spezifikation wurde von Tom Preston-Werner, Erfinder von Gravatars und Mitbegründer von GitHub, erstellt.\nFür Feedback, eröffne bitte ein Issue auf GitHub.\neröffne bitte ein Issue auf GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nΣημασιολογική Δημιουργία Εκδόσεων 2.0.0 (Semantic Versioning)

Περίληψη

Δοθέντος ενός αριθμού έκδοσης ΚΥΡΙΑ.ΔΕΥΤΕΡΕΥΟΥΣΑ.ΔΙΟΡΘΩΣΗ (MAJOR.MINOR.PATCH), αυξήστε την:


  ΚΥΡΙΑ έκδοση, όταν κάνετε ασύμβατες αλλαγές στο API
  ΔΕΥΤΕΡΕΥΟΥΣΑ έκδοση, όταν προσθέτετε λειτουργικότητα με τρόπο συμβατό προς τα πίσω
  ΔΙΟΡΘΩΤΙΚΗ έκδοση, όταν κάνετε επιδιορθώσεις σφαλμάτων με τρόπο συμβατό προς τα πίσω


Πρόσθετες ετικέτες για μεταδεδομένα προ-κυκλοφορίας και χτισίματος, είναι διαθέσιμες ως επεκτάσεις
στη μορφή ΚΥΡΙΑ.ΔΕΥΤΕΡΕΥΟΥΣΑ.ΔΙΟΡΘΩΣΗ.

Εισαγωγή

Στον κόσμο της διαχείρισης λογισμικού υπάρχει ένα διαβόητο μέρος που ονομάζεται 
«κόλαση εξαρτήσεων». Όσο περισσότερο μεγαλώνει το σύστημά σας και όσο περισσότερα
πακέτα ενσωματώνετε στο λογισμικό σας, τόσο πιο πιθανό είναι να βρεθείτε μια μέρα
σε απόγνωση.

Σε συστήματα με πολλές εξαρτήσεις, η κυκλοφορία νέων εκδόσεων πακέτων μπορεί να γίνει 
πολύ γρήγορα ένας εφιάλτης. Αν οι προδιαγραφές της εξάρτησης είναι πολύ αυστηρές, είστε
σε κίνδυνο κλειδώματος έκδοσης (σε αδυναμία αναβάθμισης ενός πακέτου χωρίς να πρέπει να
κυκλοφορήσουν νέες εκδόσεις από κάθε εξαρτώμενο πακέτο). Αν οι εξαρτήσεις ορίζονται πολύ
χαλαρά, αναπόφευκτα θα επηρεαστείτε από την αναμικτικότητα έκδοσης (υποθέτοντας συμβατότητα 
με περισσότερες μελλοντικές εκδόσεις απ’ ότι είναι λογικό). Η κόλαση εξαρτήσεων είναι εκεί
που το κλείδωμα έκδοσης ή/και η αναμικτικότητα έκδοσης, σας αποτρέπουν από το να προωθήσετε
εύκολα και με ασφάλεια το έργο σας.

Ως μια λύση σ’ αυτό το πρόβλημα, προτείνουμε ένα απλό σετ κανόνων και
απαιτήσεων που υπαγορεύουν το πως οι αριθμοί εκδόσεων καθορίζονται και αυξάνονται.
Αυτοί οι κανόνες βασίζονται, αλλά δεν περιορίζονται απαραίτητα, σε προϋπάρχουσες
διαδεδομένες κοινές πρακτικές σε χρήση τόσο σε κλειστό όσο και σε λογισμικό
ανοιχτού κώδικα. Για να λειτουργήσει αυτό το σύστημα, πρώτα πρέπει να δηλώσετε
ένα δημόσιο API. Αυτό μπορεί να αποτελείται από τεκμηρίωση ή να επιβάλλεται από
τον ίδιο τον κώδικα. Όπως και να ‘χει είναι σημαντικό αυτό το API να είναι
ξεκάθαρο και συγκεκριμένο. Μόλις ταυτοποιήσετε το δημόσιο API, κοινοποιείτε τις
αλλαγές σ’ αυτό με συγκεκριμένες αυξήσεις στον αριθμό έκδοσης. Σκεφτείτε μία
έκδοση της μορφής X.Y.Z (Κύρια.Δευτερεύουσα.Διόρθωση). Διορθώσεις σφαλμάτων που
δεν επηρεάζουν το API αυξάνουν την έκδοση διόρθωσης, προσθήκες/αλλαγές στο API
οι οποίες είναι συμβατές προς τα πίσω αυξάνουν τη δευτερεύουσα έκδοση, και 
αλλαγές ασύμβατες με το API αυξάνουν την κύρια έκδοση.

Ονομάζουμε αυτό το σύστημα «Σημασιολογική δημιουργία εκδόσεων».
Με αυτό το σχήμα, οι αριθμοί εκδόσεων και ο τρόπος που αλλάζουν, εκφράζουν
κάποιο νόημα σχετικά με τον υποκείμενο κώδικα και το τι έχει τροποποιηθεί
από τη μία έκδοση στην επόμενη.

Προδιαγραφή της Σημασιολογικής Δημιουργίας Εκδόσεων (SemVer)

Οι λέξεις κλειδιά «ΠΡΕΠΕΙ» (MUST), «ΔΕΝ ΠΡΕΠΕΙ» (MUST NOT), «ΑΠΑΙΤΕΙΤΑΙ» (REQUIRED),
«ΠΡΕΠΕΙ» (SHALL), «ΔΕΝ ΠΡΕΠΕΙ» (SHALL NOT), «ΣΥΝΙΣΤΆΤΑΙ» (SHOULD), «ΔΕ ΣΥΝΙΣΤΆΤΑΙ»
(SHOULD NOT), «ΣΥΝΙΣΤΆΤΑΙ» (RECOMMENDED), «ΜΠΟΡΕΙ» (MAY), και «ΠΡΟΑΙΡΕΤΙΚΑ» (OPTIONAL)
σε αυτό το έγγραφο, πρέπει να ερμηνεύονται όπως περιγράφεται στο
RFC 2119.


  
    Λογισμικό που χρησιμοποιεί Σημασιολογική δημιουργία εκδόσεων ΠΡΕΠΕΙ να δηλώνει
ένα δημόσιο API. Αυτό το API μπορεί να δηλωθεί στον ίδιο τον κώδικα του ή να υπάρχει
αποκλειστικά στην τεκμηρίωση. Όπως και αν γίνει, ΣΥΝΙΣΤΆΤΑΙ να είναι ακριβές και
εμπεριστατωμένο.
  
  
    Ένας φυσιολογικός αριθμός έκδοσης ΠΡΕΠΕΙ να έχει τη μορφή X.Y.Z όπου X, Y, και Z
είναι μη-αρνητικοί ακέραιοι, που ΔΕΝ ΠΡΕΠΕΙ να περιέχουν προπορευόμενα μηδενικά.
Το Χ είναι η κύρια έκδοση, το Υ είναι η δευτερεύουσα έκδοση, και το Ζ είναι η
έκδοση διόρθωσης. Κάθε στοιχείο ΠΡΕΠΕΙ να αυξάνεται αριθμητικά.
Για παράδειγμα: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Μόλις ένα πακέτο με έκδοση κυκλοφορήσει, τα περιεχόμενα αυτής της έκδοσης
ΔΕΝ ΠΡΕΠΕΙ να τροποποιηθούν. Κάθε τροποποίηση ΠΡΕΠΕΙ να κυκλοφορεί με νέα έκδοση.
  
  
    Ο αριθμός κύριας έκδοσης μηδέν (0.y.z) είναι για την αρχική ανάπτυξη.
Οτιδήποτε ΜΠΟΡΕΙ να αλλάξει οποιαδήποτε στιγμή. Το δημόσιο API ΔΕ ΣΥΝΙΣΤΆΤΑΙ
να θεωρείται σταθερό.
  
  
    Η έκδοση 1.0.0 ορίζει το δημόσιο API. Ο τρόπος με τον οποίο ο αριθμός έκδοσης
αυξάνεται μετά από κάθε κυκλοφορία, εξαρτάται από αυτό το δημόσιο API και το
πως αλλάζει.
  
  
    Η Διορθωτική έκδοση Z (x.y.Z | x > 0) ΠΡΕΠΕΙ να αυξάνεται μόνο αν εισάγονται
διορθώσεις σφαλμάτων συμβατές προς τα πίσω. Μία διόρθωση σφάλματος ορίζεται
ως μια εσωτερική αλλαγή που διορθώνει μια εσφαλμένη συμπεριφορά.
  
  
    Η Δευτερεύουσα έκδοση Y (x.Y.z | x > 0) ΠΡΕΠΕΙ να αυξάνεται αν μια νέα,
συμβατή προς τα πίσω, λειτουργικότητα, εισάγεται στο δημόσιο API. ΠΡΕΠΕΙ να
αυξάνεται αν κάποια λειτουργικότητα, οποιουδήποτε δημόσιου API, χαρακτηρίζεται
ως καταργημένη. ΜΠΟΡΕΙ να αυξηθεί αν σημαντική νέα λειτουργικότητα ή βελτιώσεις
εισάγονται μαζί με τον ιδιωτικό κώδικα. ΜΠΟΡΕΙ να περιλαμβάνει αλλαγές επιπέδου
διόρθωσης. Η έκδοση διόρθωσης ΠΡΕΠΕΙ να επανέλθει στο 0 όταν μία δευτερεύουσα
έκδοση αυξάνεται.
  
  
    Η Κύρια έκδοση X (X.y.z | X > 0) ΠΡΕΠΕΙ να αυξάνεται αν εισάγονται στο δημόσιο
API οποιεσδήποτε αλλαγές που είναι ασύμβατες προς τα πίσω. ΜΠΟΡΕΙ επίσης να
συμπεριλαμβάνει δευτερεύουσες και διορθωτικές αλλαγές. Οι διορθωτικές και οι
δευτερεύουσες εκδόσεις ΠΡΕΠΕΙ να επανέρχονται στο 0 όταν η κύρια έκδοση αυξάνεται.
  
  
    Μια έκδοση προ-κυκλοφορίας ΜΠΟΡΕΙ να επισημαίνεται επισυνάπτοντας μία παύλα
και μία σειρά από αναγνωριστικά διαχωρισμένα με τελεία, αμέσως μετά την έκδοση
διόρθωσης. Τα αναγνωριστικά ΠΡΕΠΕΙ να αποτελούνται μόνο από αλφαριθμητικούς
χαρακτήρες ASCII και παύλες [0-9A-Za-z-]. Τα αναγνωριστικά ΔΕΝ ΠΡΕΠΕΙ να είναι
κενά. Τα αριθμητικά αναγνωριστικά ΔΕΝ ΠΡΕΠΕΙ να περιλαμβάνουν προπορευόμενα
μηδενικά. Οι εκδόσεις προ-κυκλοφορίας έχουν χαμηλότερη προτεραιότητα από
τη συσχετιζόμενη φυσιολογική έκδοση. Μία έκδοση προ-κυκλοφορίας υποδεικνύει
ότι η έκδοση είναι ασταθής και μπορεί να μην ικανοποιεί τις επιθυμητές απαιτήσεις
συμβατότητας όπως επισημαίνεται από τη συσχετιζόμενη φυσιολογική έκδοση.
Παραδείγματα: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.--.
  
  
    Μεταδεδομένα χτισίματος ΜΠΟΡΕΙ να επισημαίνονται επισυνάπτοντας το σύμβολο
της πρόσθεσης και μία σειρά από αναγνωριστικά διαχωρισμένα με τελεία, αμέσως
μετά τη διόρθωση ή την έκδοση προ-κυκλοφορίας. Τα αναγνωριστικά ΠΡΕΠΕΙ να
αποτελούνται μόνο από αλφαριθμητικούς χαρακτήρες ASCII και παύλες [0-9A-Za-z-].
Τα αναγνωριστικά ΔΕΝ ΠΡΕΠΕΙ να είναι κενά. Τα μεταδεδομένα χτισίματος ΠΡΕΠΕΙ να
αγνοούνται όταν αποφασίζεται η προτεραιότητα έκδοσης. Συνεπώς, όταν δύο
εκδόσεις διαφέρουν μόνο στα μεταδεδομένα χτισίματος, τότε έχουν την ίδια
προτεραιότητα. Παραδείγματα: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3----117B344092BD.
  
  
    Ως προτεραιότητα αναφέρεται το πως δύο εκδόσεις συγκρίνονται μεταξύ τους
όταν ταξινομούνται.

    
      
        Η προτεραιότητα ΠΡΕΠΕΙ να υπολογίζεται διαχωρίζοντας την έκδοση στα
επιμέρους κύρια, δευτερεύοντα, διορθωτικά και προ-κυκλοφορίας
αναγνωριστικά, με αυτή τη σειρά (Τα μεταδεδομένα χτισίματος δε 
λαμβάνονται υπόψη στην προτεραιότητα).
      
      
        Η προτεραιότητα αποφασίζεται από την πρώτη διαφορά όταν συγκρίνεται το
καθένα από αυτά τα αναγνωριστικά, από αριστερά προς τα δεξιά ως εξής:
Κύριες, δευτερεύουσες, και διορθωτικές εκδόσεις συγκρίνονται πάντα
αριθμητικά.

        Παράδειγμα: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Όταν κύρια, δευτερεύουσα και διορθωτική είναι ίσα, η έκδοση 
προ-κυκλοφορίας έχει χαμηλότερη προτεραιότητα από μία φυσιολογική έκδοση:

        Παράδειγμα: 1.0.0-alpha < 1.0.0.
      
      
        Η προτεραιότητα για δύο εκδόσεις προ-κυκλοφορίας, με ίδια κύρια, 
δευτερεύουσα, και διορθωτική έκδοση, ΠΡΕΠΕΙ να αποφασίζεται συγκρίνοντας
κάθε αναγνωριστικό διαχωρισμένο με τελεία, από αριστερά προς δεξιά,
μέχρι να βρεθεί διαφορά ως εξής:

        
          
            Αναγνωριστικά που αποτελούνται μόνο από ψηφία συγκρίνονται αριθμητικά.
          
          
            Αναγνωριστικά με γράμματα ή παύλες συγκρίνονται λεξιλογικά με
σειρά ταξινόμησης ASCII.
          
          
            Τα αριθμητικά αναγνωριστικά πάντα έχουν χαμηλότερη προτεραιότητα
από τα μη-αριθμητικά αναγνωριστικά.
          
          
            Ένα μεγαλύτερο σετ από πεδία προ-κυκλοφορίας έχει υψηλότερη
προτεραιότητα από ένα μικρότερο σετ, αν όλα τα προηγούμενα
αναγνωριστικά είναι ίσα.
          
        

        Παράδειγμα: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
      
    
  


Γραμματική της Μορφής Μπάκους-Νάουρ για έγκυρες εκδόσεις SemVer
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


Γιατί να χρησιμοποιήσετε Σημασιολογική Δημιουργία Εκδόσεων;

Αυτή δεν είναι μια νέα ή επαναστατική ιδέα. Στην πραγματικότητα, πιθανά ήδη
κάνετε κάτι κοντινό σ’ αυτό. Το πρόβλημα είναι ότι το «κοντινό» δεν είναι 
αρκετά καλό. Χωρίς συμμόρφωση σε κάποια μορφή επίσημης προδιαγραφής, οι
αριθμοί εκδόσεων είναι ουσιαστικά ανώφελοι στη διαχείριση εξαρτήσεων.
Δίνοντας ένα όνομα και ξεκάθαρη ερμηνεία στις παραπάνω ιδέες, γίνεται εύκολο
να κοινοποιήσετε τις προθέσεις σας στους χρήστες του λογισμικού σας.
Μόλις αυτές οι προθέσεις ξεκαθαριστούν, μπορούν τελικά να κατασκευαστούν
ευέλικτες (αλλά όχι πολύ ευέλικτες) προδιαγραφές εξαρτήσεων.

Ένα απλό παράδειγμα θα επιδείξει πως η Σημασιολογική Δημιουργία Εκδόσεων
μπορεί να κάνει την κόλαση εξαρτήσεων παρελθόν.
Σκεφτείτε μια βιβλιοθήκη που ονομάζεται «Πυροσβεστικό». Αυτή χρειάζεται
ένα πακέτο που χρησιμοποιεί Σημασιολογική Δημιουργία Εκδόσεων και ονομάζεται
«Σκάλα». Κατά τη χρονική στιγμή που το Πυροσβεστικό δημιουργείται, η Σκάλα
είναι στην έκδοση 3.1.0. Επειδή το Πυροσβεστικό χρησιμοποιεί κάποια 
λειτουργικότητα που πρωτοεισάχθηκε στην 3.1.0, μπορείτε με ασφάλεια να
ορίσετε την εξάρτηση από την Σκάλα ως μεγαλύτερη ή ίση με 3.1.0, αλλά
μικρότερη από 4.0.0. Τώρα, όταν γίνει διαθέσιμη η έκδοση 3.1.1 και 3.2.0
της Σκάλας, μπορείτε να τις κυκλοφορήσετε στο δικό σας σύστημα διαχείρισης
πακέτων, και να γνωρίζετε ότι θα είναι συμβατές με το υπάρχον εξαρτημένο
λογισμικό.

Ως ένας υπεύθυνος προγραμματιστής, φυσικά θα θέλετε να επαληθεύσετε ότι
οποιεσδήποτε αναβαθμίσεις πακέτων, λειτουργούν όπως διαφημίζονται.
Ο πραγματικός κόσμος είναι ένα ακατάστατο μέρος και δεν μπορούμε να κάνουμε
τίποτα άλλο εκτός από το να είμαστε σε εγρήγορση. Αυτό που μπορείτε να
κάνετε είναι να επιτρέψετε στη Σημασιολογική Δημιουργία Εκδόσεων να
σας παρέχει έναν λογικό τρόπο να κυκλοφορείτε και να αναβαθμίζετε πακέτα
χωρίς να πρέπει να κυκλοφορείτε νέες εκδόσεις για τα εξαρτημένα πακέτα,
εξοικονομώντας έτσι χρόνο και ταλαιπωρία.

Αν όλα αυτά ακούγονται επιθυμητά, όλα όσα πρέπει να κάνετε για να αρχίσετε
να χρησιμοποιείτε τη Σημασιολογική Δημιουργία Εκδόσεων, είναι να δηλώσετε
ότι πρόκειται να το κάνετε και να ακολουθήσετε τους κανόνες. Δημιουργήστε ένα
σύνδεσμο από το README προς αυτό τον ιστότοπο, ώστε οι άλλοι να γνωρίζουν
τους κανόνες και να μπορούν να επωφεληθούν από αυτούς.

Συχνές Ερωτήσεις

Πώς να χειριστώ τις αλλαγές στη φάση της αρχικής ανάπτυξης 0.y.z;

Το απλούστερο πράγμα που μπορείτε να κάνετε, είναι να ξεκινήσετε την αρχική
σας κυκλοφορία ανάπτυξης στο 0.1.0 και μετά να αυξάνετε τη δευτερεύουσα
έκδοση με κάθε επακόλουθη κυκλοφορία.

Πώς μπορώ να γνωρίζω πότε να κυκλοφορήσω την 1.0.0;

Αν το λογισμικό σας χρησιμοποιείται στην παραγωγή, πιθανά πρέπει ήδη να
είναι 1.0.0. Αν έχετε ένα σταθερό API στο οποίο οι χρήστες βασίζονται,
πρέπει να είναι 1.0.0. Αν ανησυχείτε πολύ σχετικά με τη συμβατότητα
προς τα πίσω, πιθανά πρέπει ήδη να είναι 1.0.0.

Μήπως αυτό αποθαρρύνει την ταχεία ανάπτυξη και τη γρήγορη επανάληψη;

Η κύρια έκδοση μηδέν είναι για την ταχεία ανάπτυξη. Αν αλλάζετε το API
κάθε μέρα, είτε παραμείνετε στην έκδοση 0.y.z, είτε μεταβείτε σε ένα
διαφορετικό κλάδο ανάπτυξης, καθώς εργάζεστε για την επόμενη κύρια έκδοση.

Αν ακόμη και η μικρότερη αλλαγή στο δημόσιο API, που είναι ασύμβατη προς τα πίσω, απαιτεί αύξηση της κύριας έκδοσης, δε θα καταλήξω στην έκδοση 42.0.0 πολύ γρήγορα;

Αυτή είναι μια ερώτηση υπεύθυνης ανάπτυξης και προνοητικότητας. Ασύμβατες
αλλαγές δε θα πρέπει να εισάγονται εύκολα σε λογισμικό που έχει πολύ
εξαρτώμενο κώδικα. Το κόστος που πρέπει να πραγματοποιηθεί για την αναβάθμιση
μπορεί να είναι σημαντικό. Το να χρειάζεται να προσαρμόσετε τις κύριες εκδόσεις
για να κυκλοφορήσετε μη συμβατές αλλαγές σημαίνει ότι θα σκεφτείτε τον αντίκτυπο
των αλλαγών σας και θα αξιολογήσετε την αναλογία κόστους/οφέλους.

Η πλήρης τεκμηρίωση του δημόσιου API είναι πολύ δουλειά!

Είναι δική σας ευθύνη ως επαγγελματίας προγραμματιστής να τεκμηριώσετε σωστά
το λογισμικό που προορίζεται για χρήση από άλλους. Η διαχείριση της πολυπλοκότητας
του λογισμικού είναι ένα εξαιρετικά σημαντικό μέρος για τη διατήρηση της
αποτελεσματικότητας ενός εγχειρήματος και αυτό είναι δύσκολο να γίνει εάν κανείς
δεν ξέρει πώς να χρησιμοποιεί το λογισμικό σας ή ποιες μεθόδους είναι ασφαλείς να
καλέσει. Μακροπρόθεσμα, η Σημασιολογική Δημιουργία Εκδόσεων και η επιμονή σε ένα
καλά καθορισμένο δημόσιο API μπορούν να διατηρήσουν όλους και όλα σε ομαλή λειτουργία.

Τι κάνω εάν κατά λάθος κυκλοφορήσω μια μη συμβατή αλλαγή ως δευτερεύουσα έκδοση;

Μόλις συνειδητοποιήσετε ότι έχετε παραβιάσει την προδιαγραφή της Σημασιολογικής
Δημιουργίας Εκδόσεων, διορθώστε το πρόβλημα και κυκλοφορήστε μια νέα δευτερεύουσα
έκδοση που διορθώνει το πρόβλημα και αποκαθιστά τη συμβατότητα προς τα πίσω.
Ακόμη και υπό αυτές τις συνθήκες, είναι απαράδεκτη η τροποποίηση των κυκλοφορημένων
εκδόσεων. Εάν είναι κατάλληλο, τεκμηριώστε την ανάρμοστη έκδοση και ενημερώστε
τους χρήστες σας για το πρόβλημα, ώστε να γνωρίζουν ποια είναι η ανάρμοστη έκδοση.

Τι πρέπει να κάνω αν ενημερώσω τις δικές μου εξαρτήσεις χωρίς να αλλάξω το δημόσιο API;

Αυτό θα θεωρηθεί συμβατό, καθώς δεν επηρεάζει το δημόσιο API. Το λογισμικό
που εξαρτάται ρητά από τις ίδιες εξαρτήσεις με το πακέτο σας θα πρέπει να έχει
τις δικές του προδιαγραφές εξάρτησης και ο συγγραφέας θα παρατηρήσει τυχόν
διενέξεις. Ο προσδιορισμός εάν η αλλαγή είναι επίπεδο διόρθωσης ή 
δευτερεύουσας τροποποίησης, εξαρτάται από το αν ενημερώσατε τις εξαρτήσεις σας
για να διορθώσετε ένα σφάλμα ή να εισαγάγετε νέα λειτουργικότητα. Συνήθως θα
περιμέναμε πρόσθετο κώδικα για την τελευταία περίπτωση, η οποία προφανώς 
είναι μια αύξηση δευτερεύοντος επιπέδου.

Τι θα συμβεί αν κατά λάθος αλλάξω το δημόσιο API με τρόπο που δε συμμορφώνεται με την αλλαγή του αριθμού έκδοσης (δηλαδή ο κώδικας εισάγει εσφαλμένα μια κύρια ασύμβατη αλλαγή, σε μια διορθωτική κυκλοφορία);

Χρησιμοποιήστε την καλύτερη κρίση σας. Εάν έχετε τεράστιο κοινό που θα επηρεαστεί
δραστικά με την αλλαγή της συμπεριφοράς, πίσω σε αυτό που προόριζε το δημόσιο API,
τότε ίσως είναι καλύτερο να εκτελέσετε μια κυκλοφορία κύριας έκδοσης, παρόλο που
η επισκευή θα μπορούσε να θεωρηθεί αυστηρά ως διορθωτική κυκλοφορία. Θυμηθείτε,
η Σημασιολογική Δημιουργία Εκδόσεων έχει να κάνει με τη μετάδοση νοήματος με τον
τρόπο που αλλάζει ο αριθμός έκδοσης. Εάν αυτές οι αλλαγές είναι σημαντικές για
τους χρήστες σας, χρησιμοποιήστε τον αριθμό έκδοσης για να τους ενημερώσετε.

Πώς πρέπει να χειριστώ τη λειτουργικότητα που καταργείται;

Η κατάργηση υπάρχουσας λειτουργικότητας είναι φυσιολογικό μέρος της ανάπτυξης
λογισμικού και συχνά απαιτείται για να σημειωθεί πρόοδος. Όταν καταργείτε μέρος
του δημόσιου API σας, θα πρέπει να κάνετε δύο πράγματα: (1) να ενημερώσετε την
τεκμηρίωσή για να μάθουν οι χρήστες σχετικά με την αλλαγή, (2) να εκδώσετε μια
νέα δευτερεύουσα κυκλοφορία με την κατάργηση. Προτού αφαιρέσετε εντελώς τη
λειτουργικότητα σε μια νέα κύρια κυκλοφορία, θα πρέπει να υπάρχει τουλάχιστον
μία δευτερεύουσα κυκλοφορία που να περιέχει την κατάργηση, ώστε οι χρήστες να
μπορούν να μεταβούν ομαλά στο νέο API.

Έχει το SemVer όριο μεγέθους στη συμβολοσειρά έκδοσης;

Όχι, αλλά χρησιμοποιήστε καλή κρίση. Μια συμβολοσειρά έκδοσης 255 χαρακτήρων
για παράδειγμα, είναι πιθανώς υπερβολική. Επίσης, συγκεκριμένα συστήματα μπορεί
να επιβάλλουν τα δικά τους όρια στο μέγεθος της συμβολοσειράς.

Είναι το «v1.2.3» μια σημασιολογική έκδοση;

Όχι, το «v1.2.3» δεν είναι σημασιολογική έκδοση. Ωστόσο, το πρόθεμα μιας
σημασιολογικής έκδοσης με ένα «v», είναι ένας συνηθισμένος τρόπος (στα Αγγλικά)
για να δηλωθεί ότι είναι αριθμός έκδοσης. Η συντομογραφία του «version» ως «v»
εμφανίζεται συχνά με τον έλεγχο εκδόσεων. Παράδειγμα:
git tag v1.2.3 -m "Έκδοση κυκλοφορίας 1.2.3", στην περίπτωση αυτή το «v1.2.3»
είναι το όνομα μιας ετικέτας και η σημασιολογική έκδοση είναι «1.2.3».

Υπάρχει μια προτεινόμενη κανονική έκφραση (RegEx) για τον έλεγχο μιας συμβολοσειράς SemVer;

Υπάρχουν δύο. Μία με ονοματισμένες ομάδες, named groups, για εκείνα τα συστήματα
που τα υποστηρίζουν (PCRE [Perl Compatible Regular Expressions, δηλ. Perl, PHP και R], Python και Go).

Δείτε: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Και μία με αριθμημένες ομάδες σύληψης, capture groups, (έτσι cg1 = κύρια,
cg2 = δευτερεύουσα, cg3 = διορθωτική, cg4 = προκυκλοφορία και 
cg5 = μεταδεδομέναχτισίματος) που είναι συμβατή με ECMA Script (JavaScript),
PCRE (Perl Compatible Regular Expressions, δηλαδή Perl, PHP και R), Python και Go.

Δείτε: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Περί

Η προδιαγραφή Σημασιολογικής Δημιουργίας Εκδόσεων συγγράφηκε αρχικά από
τον Tom Preston-Werner, δημιουργό του Gravatar
και συνιδρυτή του GitHub.

Την αρχική μετάφραση στα Ελληνικά έκανε ο Ευάγγελος Σκαρμούτσος

Αν θέλετε να αφήσετε τα σχόλιά σας, παρακαλώ ανοίξτε ένα issue στο
GitHub.

Άδεια

Creative Commons ― CC BY 3.0\nΣημασιολογική Δημιουργία Εκδόσεων 2.0.0 (Semantic Versioning)\nΔοθέντος ενός αριθμού έκδοσης ΚΥΡΙΑ.ΔΕΥΤΕΡΕΥΟΥΣΑ.ΔΙΟΡΘΩΣΗ (MAJOR.MINOR.PATCH), αυξήστε την:\nΚΥΡΙΑ έκδοση, όταν κάνετε ασύμβατες αλλαγές στο API\nΔΕΥΤΕΡΕΥΟΥΣΑ έκδοση, όταν προσθέτετε λειτουργικότητα με τρόπο συμβατό προς τα πίσω\nΔΙΟΡΘΩΤΙΚΗ έκδοση, όταν κάνετε επιδιορθώσεις σφαλμάτων με τρόπο συμβατό προς τα πίσω\nΠρόσθετες ετικέτες για μεταδεδομένα προ-κυκλοφορίας και χτισίματος, είναι διαθέσιμες ως επεκτάσεις
στη μορφή ΚΥΡΙΑ.ΔΕΥΤΕΡΕΥΟΥΣΑ.ΔΙΟΡΘΩΣΗ.\nΣτον κόσμο της διαχείρισης λογισμικού υπάρχει ένα διαβόητο μέρος που ονομάζεται 
«κόλαση εξαρτήσεων». Όσο περισσότερο μεγαλώνει το σύστημά σας και όσο περισσότερα
πακέτα ενσωματώνετε στο λογισμικό σας, τόσο πιο πιθανό είναι να βρεθείτε μια μέρα
σε απόγνωση.\nΣε συστήματα με πολλές εξαρτήσεις, η κυκλοφορία νέων εκδόσεων πακέτων μπορεί να γίνει 
πολύ γρήγορα ένας εφιάλτης. Αν οι προδιαγραφές της εξάρτησης είναι πολύ αυστηρές, είστε
σε κίνδυνο κλειδώματος έκδοσης (σε αδυναμία αναβάθμισης ενός πακέτου χωρίς να πρέπει να
κυκλοφορήσουν νέες εκδόσεις από κάθε εξαρτώμενο πακέτο). Αν οι εξαρτήσεις ορίζονται πολύ
χαλαρά, αναπόφευκτα θα επηρεαστείτε από την αναμικτικότητα έκδοσης (υποθέτοντας συμβατότητα 
με περισσότερες μελλοντικές εκδόσεις απ’ ότι είναι λογικό). Η κόλαση εξαρτήσεων είναι εκεί
που το κλείδωμα έκδοσης ή/και η αναμικτικότητα έκδοσης, σας αποτρέπουν από το να προωθήσετε
εύκολα και με ασφάλεια το έργο σας.\nΩς μια λύση σ’ αυτό το πρόβλημα, προτείνουμε ένα απλό σετ κανόνων και
απαιτήσεων που υπαγορεύουν το πως οι αριθμοί εκδόσεων καθορίζονται και αυξάνονται.
Αυτοί οι κανόνες βασίζονται, αλλά δεν περιορίζονται απαραίτητα, σε προϋπάρχουσες
διαδεδομένες κοινές πρακτικές σε χρήση τόσο σε κλειστό όσο και σε λογισμικό
ανοιχτού κώδικα. Για να λειτουργήσει αυτό το σύστημα, πρώτα πρέπει να δηλώσετε
ένα δημόσιο API. Αυτό μπορεί να αποτελείται από τεκμηρίωση ή να επιβάλλεται από
τον ίδιο τον κώδικα. Όπως και να ‘χει είναι σημαντικό αυτό το API να είναι
ξεκάθαρο και συγκεκριμένο. Μόλις ταυτοποιήσετε το δημόσιο API, κοινοποιείτε τις
αλλαγές σ’ αυτό με συγκεκριμένες αυξήσεις στον αριθμό έκδοσης. Σκεφτείτε μία
έκδοση της μορφής X.Y.Z (Κύρια.Δευτερεύουσα.Διόρθωση). Διορθώσεις σφαλμάτων που
δεν επηρεάζουν το API αυξάνουν την έκδοση διόρθωσης, προσθήκες/αλλαγές στο API
οι οποίες είναι συμβατές προς τα πίσω αυξάνουν τη δευτερεύουσα έκδοση, και 
αλλαγές ασύμβατες με το API αυξάνουν την κύρια έκδοση.\nΟνομάζουμε αυτό το σύστημα «Σημασιολογική δημιουργία εκδόσεων».
Με αυτό το σχήμα, οι αριθμοί εκδόσεων και ο τρόπος που αλλάζουν, εκφράζουν
κάποιο νόημα σχετικά με τον υποκείμενο κώδικα και το τι έχει τροποποιηθεί
από τη μία έκδοση στην επόμενη.\nΠροδιαγραφή της Σημασιολογικής Δημιουργίας Εκδόσεων (SemVer)\nΟι λέξεις κλειδιά «ΠΡΕΠΕΙ» (MUST), «ΔΕΝ ΠΡΕΠΕΙ» (MUST NOT), «ΑΠΑΙΤΕΙΤΑΙ» (REQUIRED),
«ΠΡΕΠΕΙ» (SHALL), «ΔΕΝ ΠΡΕΠΕΙ» (SHALL NOT), «ΣΥΝΙΣΤΆΤΑΙ» (SHOULD), «ΔΕ ΣΥΝΙΣΤΆΤΑΙ»
(SHOULD NOT), «ΣΥΝΙΣΤΆΤΑΙ» (RECOMMENDED), «ΜΠΟΡΕΙ» (MAY), και «ΠΡΟΑΙΡΕΤΙΚΑ» (OPTIONAL)
σε αυτό το έγγραφο, πρέπει να ερμηνεύονται όπως περιγράφεται στο
RFC 2119.\nΛογισμικό που χρησιμοποιεί Σημασιολογική δημιουργία εκδόσεων ΠΡΕΠΕΙ να δηλώνει
ένα δημόσιο API. Αυτό το API μπορεί να δηλωθεί στον ίδιο τον κώδικα του ή να υπάρχει
αποκλειστικά στην τεκμηρίωση. Όπως και αν γίνει, ΣΥΝΙΣΤΆΤΑΙ να είναι ακριβές και
εμπεριστατωμένο.\nΛογισμικό που χρησιμοποιεί Σημασιολογική δημιουργία εκδόσεων ΠΡΕΠΕΙ να δηλώνει
ένα δημόσιο API. Αυτό το API μπορεί να δηλωθεί στον ίδιο τον κώδικα του ή να υπάρχει
αποκλειστικά στην τεκμηρίωση. Όπως και αν γίνει, ΣΥΝΙΣΤΆΤΑΙ να είναι ακριβές και
εμπεριστατωμένο.\nΈνας φυσιολογικός αριθμός έκδοσης ΠΡΕΠΕΙ να έχει τη μορφή X.Y.Z όπου X, Y, και Z
είναι μη-αρνητικοί ακέραιοι, που ΔΕΝ ΠΡΕΠΕΙ να περιέχουν προπορευόμενα μηδενικά.
Το Χ είναι η κύρια έκδοση, το Υ είναι η δευτερεύουσα έκδοση, και το Ζ είναι η
έκδοση διόρθωσης. Κάθε στοιχείο ΠΡΕΠΕΙ να αυξάνεται αριθμητικά.
Για παράδειγμα: 1.9.0 -> 1.10.0 -> 1.11.0.\nΈνας φυσιολογικός αριθμός έκδοσης ΠΡΕΠΕΙ να έχει τη μορφή X.Y.Z όπου X, Y, και Z
είναι μη-αρνητικοί ακέραιοι, που ΔΕΝ ΠΡΕΠΕΙ να περιέχουν προπορευόμενα μηδενικά.
Το Χ είναι η κύρια έκδοση, το Υ είναι η δευτερεύουσα έκδοση, και το Ζ είναι η
έκδοση διόρθωσης. Κάθε στοιχείο ΠΡΕΠΕΙ να αυξάνεται αριθμητικά.
Για παράδειγμα: 1.9.0 -> 1.10.0 -> 1.11.0.\nΜόλις ένα πακέτο με έκδοση κυκλοφορήσει, τα περιεχόμενα αυτής της έκδοσης
ΔΕΝ ΠΡΕΠΕΙ να τροποποιηθούν. Κάθε τροποποίηση ΠΡΕΠΕΙ να κυκλοφορεί με νέα έκδοση.\nΜόλις ένα πακέτο με έκδοση κυκλοφορήσει, τα περιεχόμενα αυτής της έκδοσης
ΔΕΝ ΠΡΕΠΕΙ να τροποποιηθούν. Κάθε τροποποίηση ΠΡΕΠΕΙ να κυκλοφορεί με νέα έκδοση.\nΟ αριθμός κύριας έκδοσης μηδέν (0.y.z) είναι για την αρχική ανάπτυξη.
Οτιδήποτε ΜΠΟΡΕΙ να αλλάξει οποιαδήποτε στιγμή. Το δημόσιο API ΔΕ ΣΥΝΙΣΤΆΤΑΙ
να θεωρείται σταθερό.\nΟ αριθμός κύριας έκδοσης μηδέν (0.y.z) είναι για την αρχική ανάπτυξη.
Οτιδήποτε ΜΠΟΡΕΙ να αλλάξει οποιαδήποτε στιγμή. Το δημόσιο API ΔΕ ΣΥΝΙΣΤΆΤΑΙ
να θεωρείται σταθερό.\nΗ έκδοση 1.0.0 ορίζει το δημόσιο API. Ο τρόπος με τον οποίο ο αριθμός έκδοσης
αυξάνεται μετά από κάθε κυκλοφορία, εξαρτάται από αυτό το δημόσιο API και το
πως αλλάζει.\nΗ έκδοση 1.0.0 ορίζει το δημόσιο API. Ο τρόπος με τον οποίο ο αριθμός έκδοσης
αυξάνεται μετά από κάθε κυκλοφορία, εξαρτάται από αυτό το δημόσιο API και το
πως αλλάζει.\nΗ Διορθωτική έκδοση Z (x.y.Z | x > 0) ΠΡΕΠΕΙ να αυξάνεται μόνο αν εισάγονται
διορθώσεις σφαλμάτων συμβατές προς τα πίσω. Μία διόρθωση σφάλματος ορίζεται
ως μια εσωτερική αλλαγή που διορθώνει μια εσφαλμένη συμπεριφορά.\nΗ Διορθωτική έκδοση Z (x.y.Z | x > 0) ΠΡΕΠΕΙ να αυξάνεται μόνο αν εισάγονται
διορθώσεις σφαλμάτων συμβατές προς τα πίσω. Μία διόρθωση σφάλματος ορίζεται
ως μια εσωτερική αλλαγή που διορθώνει μια εσφαλμένη συμπεριφορά.\nΗ Δευτερεύουσα έκδοση Y (x.Y.z | x > 0) ΠΡΕΠΕΙ να αυξάνεται αν μια νέα,
συμβατή προς τα πίσω, λειτουργικότητα, εισάγεται στο δημόσιο API. ΠΡΕΠΕΙ να
αυξάνεται αν κάποια λειτουργικότητα, οποιουδήποτε δημόσιου API, χαρακτηρίζεται
ως καταργημένη. ΜΠΟΡΕΙ να αυξηθεί αν σημαντική νέα λειτουργικότητα ή βελτιώσεις
εισάγονται μαζί με τον ιδιωτικό κώδικα. ΜΠΟΡΕΙ να περιλαμβάνει αλλαγές επιπέδου
διόρθωσης. Η έκδοση διόρθωσης ΠΡΕΠΕΙ να επανέλθει στο 0 όταν μία δευτερεύουσα
έκδοση αυξάνεται.\nΗ Δευτερεύουσα έκδοση Y (x.Y.z | x > 0) ΠΡΕΠΕΙ να αυξάνεται αν μια νέα,
συμβατή προς τα πίσω, λειτουργικότητα, εισάγεται στο δημόσιο API. ΠΡΕΠΕΙ να
αυξάνεται αν κάποια λειτουργικότητα, οποιουδήποτε δημόσιου API, χαρακτηρίζεται
ως καταργημένη. ΜΠΟΡΕΙ να αυξηθεί αν σημαντική νέα λειτουργικότητα ή βελτιώσεις
εισάγονται μαζί με τον ιδιωτικό κώδικα. ΜΠΟΡΕΙ να περιλαμβάνει αλλαγές επιπέδου
διόρθωσης. Η έκδοση διόρθωσης ΠΡΕΠΕΙ να επανέλθει στο 0 όταν μία δευτερεύουσα
έκδοση αυξάνεται.\nΗ Κύρια έκδοση X (X.y.z | X > 0) ΠΡΕΠΕΙ να αυξάνεται αν εισάγονται στο δημόσιο
API οποιεσδήποτε αλλαγές που είναι ασύμβατες προς τα πίσω. ΜΠΟΡΕΙ επίσης να
συμπεριλαμβάνει δευτερεύουσες και διορθωτικές αλλαγές. Οι διορθωτικές και οι
δευτερεύουσες εκδόσεις ΠΡΕΠΕΙ να επανέρχονται στο 0 όταν η κύρια έκδοση αυξάνεται.\nΗ Κύρια έκδοση X (X.y.z | X > 0) ΠΡΕΠΕΙ να αυξάνεται αν εισάγονται στο δημόσιο
API οποιεσδήποτε αλλαγές που είναι ασύμβατες προς τα πίσω. ΜΠΟΡΕΙ επίσης να
συμπεριλαμβάνει δευτερεύουσες και διορθωτικές αλλαγές. Οι διορθωτικές και οι
δευτερεύουσες εκδόσεις ΠΡΕΠΕΙ να επανέρχονται στο 0 όταν η κύρια έκδοση αυξάνεται.\nΜια έκδοση προ-κυκλοφορίας ΜΠΟΡΕΙ να επισημαίνεται επισυνάπτοντας μία παύλα
και μία σειρά από αναγνωριστικά διαχωρισμένα με τελεία, αμέσως μετά την έκδοση
διόρθωσης. Τα αναγνωριστικά ΠΡΕΠΕΙ να αποτελούνται μόνο από αλφαριθμητικούς
χαρακτήρες ASCII και παύλες [0-9A-Za-z-]. Τα αναγνωριστικά ΔΕΝ ΠΡΕΠΕΙ να είναι
κενά. Τα αριθμητικά αναγνωριστικά ΔΕΝ ΠΡΕΠΕΙ να περιλαμβάνουν προπορευόμενα
μηδενικά. Οι εκδόσεις προ-κυκλοφορίας έχουν χαμηλότερη προτεραιότητα από
τη συσχετιζόμενη φυσιολογική έκδοση. Μία έκδοση προ-κυκλοφορίας υποδεικνύει
ότι η έκδοση είναι ασταθής και μπορεί να μην ικανοποιεί τις επιθυμητές απαιτήσεις
συμβατότητας όπως επισημαίνεται από τη συσχετιζόμενη φυσιολογική έκδοση.
Παραδείγματα: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.--.\nΜια έκδοση προ-κυκλοφορίας ΜΠΟΡΕΙ να επισημαίνεται επισυνάπτοντας μία παύλα
και μία σειρά από αναγνωριστικά διαχωρισμένα με τελεία, αμέσως μετά την έκδοση
διόρθωσης. Τα αναγνωριστικά ΠΡΕΠΕΙ να αποτελούνται μόνο από αλφαριθμητικούς
χαρακτήρες ASCII και παύλες [0-9A-Za-z-]. Τα αναγνωριστικά ΔΕΝ ΠΡΕΠΕΙ να είναι
κενά. Τα αριθμητικά αναγνωριστικά ΔΕΝ ΠΡΕΠΕΙ να περιλαμβάνουν προπορευόμενα
μηδενικά. Οι εκδόσεις προ-κυκλοφορίας έχουν χαμηλότερη προτεραιότητα από
τη συσχετιζόμενη φυσιολογική έκδοση. Μία έκδοση προ-κυκλοφορίας υποδεικνύει
ότι η έκδοση είναι ασταθής και μπορεί να μην ικανοποιεί τις επιθυμητές απαιτήσεις
συμβατότητας όπως επισημαίνεται από τη συσχετιζόμενη φυσιολογική έκδοση.
Παραδείγματα: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.--.\nΜεταδεδομένα χτισίματος ΜΠΟΡΕΙ να επισημαίνονται επισυνάπτοντας το σύμβολο
της πρόσθεσης και μία σειρά από αναγνωριστικά διαχωρισμένα με τελεία, αμέσως
μετά τη διόρθωση ή την έκδοση προ-κυκλοφορίας. Τα αναγνωριστικά ΠΡΕΠΕΙ να
αποτελούνται μόνο από αλφαριθμητικούς χαρακτήρες ASCII και παύλες [0-9A-Za-z-].
Τα αναγνωριστικά ΔΕΝ ΠΡΕΠΕΙ να είναι κενά. Τα μεταδεδομένα χτισίματος ΠΡΕΠΕΙ να
αγνοούνται όταν αποφασίζεται η προτεραιότητα έκδοσης. Συνεπώς, όταν δύο
εκδόσεις διαφέρουν μόνο στα μεταδεδομένα χτισίματος, τότε έχουν την ίδια
προτεραιότητα. Παραδείγματα: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3----117B344092BD.\nΜεταδεδομένα χτισίματος ΜΠΟΡΕΙ να επισημαίνονται επισυνάπτοντας το σύμβολο
της πρόσθεσης και μία σειρά από αναγνωριστικά διαχωρισμένα με τελεία, αμέσως
μετά τη διόρθωση ή την έκδοση προ-κυκλοφορίας. Τα αναγνωριστικά ΠΡΕΠΕΙ να
αποτελούνται μόνο από αλφαριθμητικούς χαρακτήρες ASCII και παύλες [0-9A-Za-z-].
Τα αναγνωριστικά ΔΕΝ ΠΡΕΠΕΙ να είναι κενά. Τα μεταδεδομένα χτισίματος ΠΡΕΠΕΙ να
αγνοούνται όταν αποφασίζεται η προτεραιότητα έκδοσης. Συνεπώς, όταν δύο
εκδόσεις διαφέρουν μόνο στα μεταδεδομένα χτισίματος, τότε έχουν την ίδια
προτεραιότητα. Παραδείγματα: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3----117B344092BD.\nΩς προτεραιότητα αναφέρεται το πως δύο εκδόσεις συγκρίνονται μεταξύ τους
όταν ταξινομούνται.

    
      
        Η προτεραιότητα ΠΡΕΠΕΙ να υπολογίζεται διαχωρίζοντας την έκδοση στα
επιμέρους κύρια, δευτερεύοντα, διορθωτικά και προ-κυκλοφορίας
αναγνωριστικά, με αυτή τη σειρά (Τα μεταδεδομένα χτισίματος δε 
λαμβάνονται υπόψη στην προτεραιότητα).
      
      
        Η προτεραιότητα αποφασίζεται από την πρώτη διαφορά όταν συγκρίνεται το
καθένα από αυτά τα αναγνωριστικά, από αριστερά προς τα δεξιά ως εξής:
Κύριες, δευτερεύουσες, και διορθωτικές εκδόσεις συγκρίνονται πάντα
αριθμητικά.

        Παράδειγμα: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Όταν κύρια, δευτερεύουσα και διορθωτική είναι ίσα, η έκδοση 
προ-κυκλοφορίας έχει χαμηλότερη προτεραιότητα από μία φυσιολογική έκδοση:

        Παράδειγμα: 1.0.0-alpha < 1.0.0.
      
      
        Η προτεραιότητα για δύο εκδόσεις προ-κυκλοφορίας, με ίδια κύρια, 
δευτερεύουσα, και διορθωτική έκδοση, ΠΡΕΠΕΙ να αποφασίζεται συγκρίνοντας
κάθε αναγνωριστικό διαχωρισμένο με τελεία, από αριστερά προς δεξιά,
μέχρι να βρεθεί διαφορά ως εξής:

        
          
            Αναγνωριστικά που αποτελούνται μόνο από ψηφία συγκρίνονται αριθμητικά.
          
          
            Αναγνωριστικά με γράμματα ή παύλες συγκρίνονται λεξιλογικά με
σειρά ταξινόμησης ASCII.
          
          
            Τα αριθμητικά αναγνωριστικά πάντα έχουν χαμηλότερη προτεραιότητα
από τα μη-αριθμητικά αναγνωριστικά.
          
          
            Ένα μεγαλύτερο σετ από πεδία προ-κυκλοφορίας έχει υψηλότερη
προτεραιότητα από ένα μικρότερο σετ, αν όλα τα προηγούμενα
αναγνωριστικά είναι ίσα.
          
        

        Παράδειγμα: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nΩς προτεραιότητα αναφέρεται το πως δύο εκδόσεις συγκρίνονται μεταξύ τους
όταν ταξινομούνται.\nΗ προτεραιότητα ΠΡΕΠΕΙ να υπολογίζεται διαχωρίζοντας την έκδοση στα
επιμέρους κύρια, δευτερεύοντα, διορθωτικά και προ-κυκλοφορίας
αναγνωριστικά, με αυτή τη σειρά (Τα μεταδεδομένα χτισίματος δε 
λαμβάνονται υπόψη στην προτεραιότητα).\nΗ προτεραιότητα ΠΡΕΠΕΙ να υπολογίζεται διαχωρίζοντας την έκδοση στα
επιμέρους κύρια, δευτερεύοντα, διορθωτικά και προ-κυκλοφορίας
αναγνωριστικά, με αυτή τη σειρά (Τα μεταδεδομένα χτισίματος δε 
λαμβάνονται υπόψη στην προτεραιότητα).\nΗ προτεραιότητα αποφασίζεται από την πρώτη διαφορά όταν συγκρίνεται το
καθένα από αυτά τα αναγνωριστικά, από αριστερά προς τα δεξιά ως εξής:
Κύριες, δευτερεύουσες, και διορθωτικές εκδόσεις συγκρίνονται πάντα
αριθμητικά.

        Παράδειγμα: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nΗ προτεραιότητα αποφασίζεται από την πρώτη διαφορά όταν συγκρίνεται το
καθένα από αυτά τα αναγνωριστικά, από αριστερά προς τα δεξιά ως εξής:
Κύριες, δευτερεύουσες, και διορθωτικές εκδόσεις συγκρίνονται πάντα
αριθμητικά.\nΠαράδειγμα: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nΌταν κύρια, δευτερεύουσα και διορθωτική είναι ίσα, η έκδοση 
προ-κυκλοφορίας έχει χαμηλότερη προτεραιότητα από μία φυσιολογική έκδοση:

        Παράδειγμα: 1.0.0-alpha < 1.0.0.\nΌταν κύρια, δευτερεύουσα και διορθωτική είναι ίσα, η έκδοση 
προ-κυκλοφορίας έχει χαμηλότερη προτεραιότητα από μία φυσιολογική έκδοση:\nΠαράδειγμα: 1.0.0-alpha < 1.0.0.\nΗ προτεραιότητα για δύο εκδόσεις προ-κυκλοφορίας, με ίδια κύρια, 
δευτερεύουσα, και διορθωτική έκδοση, ΠΡΕΠΕΙ να αποφασίζεται συγκρίνοντας
κάθε αναγνωριστικό διαχωρισμένο με τελεία, από αριστερά προς δεξιά,
μέχρι να βρεθεί διαφορά ως εξής:

        
          
            Αναγνωριστικά που αποτελούνται μόνο από ψηφία συγκρίνονται αριθμητικά.
          
          
            Αναγνωριστικά με γράμματα ή παύλες συγκρίνονται λεξιλογικά με
σειρά ταξινόμησης ASCII.
          
          
            Τα αριθμητικά αναγνωριστικά πάντα έχουν χαμηλότερη προτεραιότητα
από τα μη-αριθμητικά αναγνωριστικά.
          
          
            Ένα μεγαλύτερο σετ από πεδία προ-κυκλοφορίας έχει υψηλότερη
προτεραιότητα από ένα μικρότερο σετ, αν όλα τα προηγούμενα
αναγνωριστικά είναι ίσα.
          
        

        Παράδειγμα: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nΗ προτεραιότητα για δύο εκδόσεις προ-κυκλοφορίας, με ίδια κύρια, 
δευτερεύουσα, και διορθωτική έκδοση, ΠΡΕΠΕΙ να αποφασίζεται συγκρίνοντας
κάθε αναγνωριστικό διαχωρισμένο με τελεία, από αριστερά προς δεξιά,
μέχρι να βρεθεί διαφορά ως εξής:\nΑναγνωριστικά που αποτελούνται μόνο από ψηφία συγκρίνονται αριθμητικά.\nΑναγνωριστικά που αποτελούνται μόνο από ψηφία συγκρίνονται αριθμητικά.\nΑναγνωριστικά με γράμματα ή παύλες συγκρίνονται λεξιλογικά με
σειρά ταξινόμησης ASCII.\nΑναγνωριστικά με γράμματα ή παύλες συγκρίνονται λεξιλογικά με
σειρά ταξινόμησης ASCII.\nΤα αριθμητικά αναγνωριστικά πάντα έχουν χαμηλότερη προτεραιότητα
από τα μη-αριθμητικά αναγνωριστικά.\nΤα αριθμητικά αναγνωριστικά πάντα έχουν χαμηλότερη προτεραιότητα
από τα μη-αριθμητικά αναγνωριστικά.\nΈνα μεγαλύτερο σετ από πεδία προ-κυκλοφορίας έχει υψηλότερη
προτεραιότητα από ένα μικρότερο σετ, αν όλα τα προηγούμενα
αναγνωριστικά είναι ίσα.\nΈνα μεγαλύτερο σετ από πεδία προ-κυκλοφορίας έχει υψηλότερη
προτεραιότητα από ένα μικρότερο σετ, αν όλα τα προηγούμενα
αναγνωριστικά είναι ίσα.\nΠαράδειγμα: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nΓραμματική της Μορφής Μπάκους-Νάουρ για έγκυρες εκδόσεις SemVer\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nΓιατί να χρησιμοποιήσετε Σημασιολογική Δημιουργία Εκδόσεων;\nΑυτή δεν είναι μια νέα ή επαναστατική ιδέα. Στην πραγματικότητα, πιθανά ήδη
κάνετε κάτι κοντινό σ’ αυτό. Το πρόβλημα είναι ότι το «κοντινό» δεν είναι 
αρκετά καλό. Χωρίς συμμόρφωση σε κάποια μορφή επίσημης προδιαγραφής, οι
αριθμοί εκδόσεων είναι ουσιαστικά ανώφελοι στη διαχείριση εξαρτήσεων.
Δίνοντας ένα όνομα και ξεκάθαρη ερμηνεία στις παραπάνω ιδέες, γίνεται εύκολο
να κοινοποιήσετε τις προθέσεις σας στους χρήστες του λογισμικού σας.
Μόλις αυτές οι προθέσεις ξεκαθαριστούν, μπορούν τελικά να κατασκευαστούν
ευέλικτες (αλλά όχι πολύ ευέλικτες) προδιαγραφές εξαρτήσεων.\nΈνα απλό παράδειγμα θα επιδείξει πως η Σημασιολογική Δημιουργία Εκδόσεων
μπορεί να κάνει την κόλαση εξαρτήσεων παρελθόν.
Σκεφτείτε μια βιβλιοθήκη που ονομάζεται «Πυροσβεστικό». Αυτή χρειάζεται
ένα πακέτο που χρησιμοποιεί Σημασιολογική Δημιουργία Εκδόσεων και ονομάζεται
«Σκάλα». Κατά τη χρονική στιγμή που το Πυροσβεστικό δημιουργείται, η Σκάλα
είναι στην έκδοση 3.1.0. Επειδή το Πυροσβεστικό χρησιμοποιεί κάποια 
λειτουργικότητα που πρωτοεισάχθηκε στην 3.1.0, μπορείτε με ασφάλεια να
ορίσετε την εξάρτηση από την Σκάλα ως μεγαλύτερη ή ίση με 3.1.0, αλλά
μικρότερη από 4.0.0. Τώρα, όταν γίνει διαθέσιμη η έκδοση 3.1.1 και 3.2.0
της Σκάλας, μπορείτε να τις κυκλοφορήσετε στο δικό σας σύστημα διαχείρισης
πακέτων, και να γνωρίζετε ότι θα είναι συμβατές με το υπάρχον εξαρτημένο
λογισμικό.\nΩς ένας υπεύθυνος προγραμματιστής, φυσικά θα θέλετε να επαληθεύσετε ότι
οποιεσδήποτε αναβαθμίσεις πακέτων, λειτουργούν όπως διαφημίζονται.
Ο πραγματικός κόσμος είναι ένα ακατάστατο μέρος και δεν μπορούμε να κάνουμε
τίποτα άλλο εκτός από το να είμαστε σε εγρήγορση. Αυτό που μπορείτε να
κάνετε είναι να επιτρέψετε στη Σημασιολογική Δημιουργία Εκδόσεων να
σας παρέχει έναν λογικό τρόπο να κυκλοφορείτε και να αναβαθμίζετε πακέτα
χωρίς να πρέπει να κυκλοφορείτε νέες εκδόσεις για τα εξαρτημένα πακέτα,
εξοικονομώντας έτσι χρόνο και ταλαιπωρία.\nΑν όλα αυτά ακούγονται επιθυμητά, όλα όσα πρέπει να κάνετε για να αρχίσετε
να χρησιμοποιείτε τη Σημασιολογική Δημιουργία Εκδόσεων, είναι να δηλώσετε
ότι πρόκειται να το κάνετε και να ακολουθήσετε τους κανόνες. Δημιουργήστε ένα
σύνδεσμο από το README προς αυτό τον ιστότοπο, ώστε οι άλλοι να γνωρίζουν
τους κανόνες και να μπορούν να επωφεληθούν από αυτούς.\nΠώς να χειριστώ τις αλλαγές στη φάση της αρχικής ανάπτυξης 0.y.z;\nΤο απλούστερο πράγμα που μπορείτε να κάνετε, είναι να ξεκινήσετε την αρχική
σας κυκλοφορία ανάπτυξης στο 0.1.0 και μετά να αυξάνετε τη δευτερεύουσα
έκδοση με κάθε επακόλουθη κυκλοφορία.\nΠώς μπορώ να γνωρίζω πότε να κυκλοφορήσω την 1.0.0;\nΑν το λογισμικό σας χρησιμοποιείται στην παραγωγή, πιθανά πρέπει ήδη να
είναι 1.0.0. Αν έχετε ένα σταθερό API στο οποίο οι χρήστες βασίζονται,
πρέπει να είναι 1.0.0. Αν ανησυχείτε πολύ σχετικά με τη συμβατότητα
προς τα πίσω, πιθανά πρέπει ήδη να είναι 1.0.0.\nΜήπως αυτό αποθαρρύνει την ταχεία ανάπτυξη και τη γρήγορη επανάληψη;\nΗ κύρια έκδοση μηδέν είναι για την ταχεία ανάπτυξη. Αν αλλάζετε το API
κάθε μέρα, είτε παραμείνετε στην έκδοση 0.y.z, είτε μεταβείτε σε ένα
διαφορετικό κλάδο ανάπτυξης, καθώς εργάζεστε για την επόμενη κύρια έκδοση.\nΑν ακόμη και η μικρότερη αλλαγή στο δημόσιο API, που είναι ασύμβατη προς τα πίσω, απαιτεί αύξηση της κύριας έκδοσης, δε θα καταλήξω στην έκδοση 42.0.0 πολύ γρήγορα;\nΑυτή είναι μια ερώτηση υπεύθυνης ανάπτυξης και προνοητικότητας. Ασύμβατες
αλλαγές δε θα πρέπει να εισάγονται εύκολα σε λογισμικό που έχει πολύ
εξαρτώμενο κώδικα. Το κόστος που πρέπει να πραγματοποιηθεί για την αναβάθμιση
μπορεί να είναι σημαντικό. Το να χρειάζεται να προσαρμόσετε τις κύριες εκδόσεις
για να κυκλοφορήσετε μη συμβατές αλλαγές σημαίνει ότι θα σκεφτείτε τον αντίκτυπο
των αλλαγών σας και θα αξιολογήσετε την αναλογία κόστους/οφέλους.\nΗ πλήρης τεκμηρίωση του δημόσιου API είναι πολύ δουλειά!\nΕίναι δική σας ευθύνη ως επαγγελματίας προγραμματιστής να τεκμηριώσετε σωστά
το λογισμικό που προορίζεται για χρήση από άλλους. Η διαχείριση της πολυπλοκότητας
του λογισμικού είναι ένα εξαιρετικά σημαντικό μέρος για τη διατήρηση της
αποτελεσματικότητας ενός εγχειρήματος και αυτό είναι δύσκολο να γίνει εάν κανείς
δεν ξέρει πώς να χρησιμοποιεί το λογισμικό σας ή ποιες μεθόδους είναι ασφαλείς να
καλέσει. Μακροπρόθεσμα, η Σημασιολογική Δημιουργία Εκδόσεων και η επιμονή σε ένα
καλά καθορισμένο δημόσιο API μπορούν να διατηρήσουν όλους και όλα σε ομαλή λειτουργία.\nΤι κάνω εάν κατά λάθος κυκλοφορήσω μια μη συμβατή αλλαγή ως δευτερεύουσα έκδοση;\nΜόλις συνειδητοποιήσετε ότι έχετε παραβιάσει την προδιαγραφή της Σημασιολογικής
Δημιουργίας Εκδόσεων, διορθώστε το πρόβλημα και κυκλοφορήστε μια νέα δευτερεύουσα
έκδοση που διορθώνει το πρόβλημα και αποκαθιστά τη συμβατότητα προς τα πίσω.
Ακόμη και υπό αυτές τις συνθήκες, είναι απαράδεκτη η τροποποίηση των κυκλοφορημένων
εκδόσεων. Εάν είναι κατάλληλο, τεκμηριώστε την ανάρμοστη έκδοση και ενημερώστε
τους χρήστες σας για το πρόβλημα, ώστε να γνωρίζουν ποια είναι η ανάρμοστη έκδοση.\nΤι πρέπει να κάνω αν ενημερώσω τις δικές μου εξαρτήσεις χωρίς να αλλάξω το δημόσιο API;\nΑυτό θα θεωρηθεί συμβατό, καθώς δεν επηρεάζει το δημόσιο API. Το λογισμικό
που εξαρτάται ρητά από τις ίδιες εξαρτήσεις με το πακέτο σας θα πρέπει να έχει
τις δικές του προδιαγραφές εξάρτησης και ο συγγραφέας θα παρατηρήσει τυχόν
διενέξεις. Ο προσδιορισμός εάν η αλλαγή είναι επίπεδο διόρθωσης ή 
δευτερεύουσας τροποποίησης, εξαρτάται από το αν ενημερώσατε τις εξαρτήσεις σας
για να διορθώσετε ένα σφάλμα ή να εισαγάγετε νέα λειτουργικότητα. Συνήθως θα
περιμέναμε πρόσθετο κώδικα για την τελευταία περίπτωση, η οποία προφανώς 
είναι μια αύξηση δευτερεύοντος επιπέδου.\nΤι θα συμβεί αν κατά λάθος αλλάξω το δημόσιο API με τρόπο που δε συμμορφώνεται με την αλλαγή του αριθμού έκδοσης (δηλαδή ο κώδικας εισάγει εσφαλμένα μια κύρια ασύμβατη αλλαγή, σε μια διορθωτική κυκλοφορία);\nΧρησιμοποιήστε την καλύτερη κρίση σας. Εάν έχετε τεράστιο κοινό που θα επηρεαστεί
δραστικά με την αλλαγή της συμπεριφοράς, πίσω σε αυτό που προόριζε το δημόσιο API,
τότε ίσως είναι καλύτερο να εκτελέσετε μια κυκλοφορία κύριας έκδοσης, παρόλο που
η επισκευή θα μπορούσε να θεωρηθεί αυστηρά ως διορθωτική κυκλοφορία. Θυμηθείτε,
η Σημασιολογική Δημιουργία Εκδόσεων έχει να κάνει με τη μετάδοση νοήματος με τον
τρόπο που αλλάζει ο αριθμός έκδοσης. Εάν αυτές οι αλλαγές είναι σημαντικές για
τους χρήστες σας, χρησιμοποιήστε τον αριθμό έκδοσης για να τους ενημερώσετε.\nΠώς πρέπει να χειριστώ τη λειτουργικότητα που καταργείται;\nΗ κατάργηση υπάρχουσας λειτουργικότητας είναι φυσιολογικό μέρος της ανάπτυξης
λογισμικού και συχνά απαιτείται για να σημειωθεί πρόοδος. Όταν καταργείτε μέρος
του δημόσιου API σας, θα πρέπει να κάνετε δύο πράγματα: (1) να ενημερώσετε την
τεκμηρίωσή για να μάθουν οι χρήστες σχετικά με την αλλαγή, (2) να εκδώσετε μια
νέα δευτερεύουσα κυκλοφορία με την κατάργηση. Προτού αφαιρέσετε εντελώς τη
λειτουργικότητα σε μια νέα κύρια κυκλοφορία, θα πρέπει να υπάρχει τουλάχιστον
μία δευτερεύουσα κυκλοφορία που να περιέχει την κατάργηση, ώστε οι χρήστες να
μπορούν να μεταβούν ομαλά στο νέο API.\nΈχει το SemVer όριο μεγέθους στη συμβολοσειρά έκδοσης;\nΌχι, αλλά χρησιμοποιήστε καλή κρίση. Μια συμβολοσειρά έκδοσης 255 χαρακτήρων
για παράδειγμα, είναι πιθανώς υπερβολική. Επίσης, συγκεκριμένα συστήματα μπορεί
να επιβάλλουν τα δικά τους όρια στο μέγεθος της συμβολοσειράς.\nΕίναι το «v1.2.3» μια σημασιολογική έκδοση;\nΌχι, το «v1.2.3» δεν είναι σημασιολογική έκδοση. Ωστόσο, το πρόθεμα μιας
σημασιολογικής έκδοσης με ένα «v», είναι ένας συνηθισμένος τρόπος (στα Αγγλικά)
για να δηλωθεί ότι είναι αριθμός έκδοσης. Η συντομογραφία του «version» ως «v»
εμφανίζεται συχνά με τον έλεγχο εκδόσεων. Παράδειγμα:
git tag v1.2.3 -m "Έκδοση κυκλοφορίας 1.2.3", στην περίπτωση αυτή το «v1.2.3»
είναι το όνομα μιας ετικέτας και η σημασιολογική έκδοση είναι «1.2.3».\nΥπάρχει μια προτεινόμενη κανονική έκφραση (RegEx) για τον έλεγχο μιας συμβολοσειράς SemVer;\nΥπάρχουν δύο. Μία με ονοματισμένες ομάδες, named groups, για εκείνα τα συστήματα
που τα υποστηρίζουν (PCRE [Perl Compatible Regular Expressions, δηλ. Perl, PHP και R], Python και Go).\nΔείτε: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nΚαι μία με αριθμημένες ομάδες σύληψης, capture groups, (έτσι cg1 = κύρια,
cg2 = δευτερεύουσα, cg3 = διορθωτική, cg4 = προκυκλοφορία και 
cg5 = μεταδεδομέναχτισίματος) που είναι συμβατή με ECMA Script (JavaScript),
PCRE (Perl Compatible Regular Expressions, δηλαδή Perl, PHP και R), Python και Go.\nΔείτε: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nΗ προδιαγραφή Σημασιολογικής Δημιουργίας Εκδόσεων συγγράφηκε αρχικά από
τον Tom Preston-Werner, δημιουργό του Gravatar
και συνιδρυτή του GitHub.\nΤην αρχική μετάφραση στα Ελληνικά έκανε ο Ευάγγελος Σκαρμούτσος\nΕυάγγελος Σκαρμούτσος\nΑν θέλετε να αφήσετε τα σχόλιά σας, παρακαλώ ανοίξτε ένα issue στο
GitHub.\nανοίξτε ένα issue στο
GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSemantic Versioning 2.0.0

Summary

Given a version number MAJOR.MINOR.PATCH, increment the:


  MAJOR version when you make incompatible API changes
  MINOR version when you add functionality in a backward compatible
manner
  PATCH version when you make backward compatible bug fixes


Additional labels for pre-release and build metadata are available as extensions
to the MAJOR.MINOR.PATCH format.

Introduction

In the world of software management there exists a dreaded place called
“dependency hell.” The bigger your system grows and the more packages you
integrate into your software, the more likely you are to find yourself, one
day, in this pit of despair.

In systems with many dependencies, releasing new package versions can quickly
become a nightmare. If the dependency specifications are too tight, you are in
danger of version lock (the inability to upgrade a package without having to
release new versions of every dependent package). If dependencies are
specified too loosely, you will inevitably be bitten by version promiscuity
(assuming compatibility with more future versions than is reasonable).
Dependency hell is where you are when version lock and/or version promiscuity
prevent you from easily and safely moving your project forward.

As a solution to this problem, we propose a simple set of rules and
requirements that dictate how version numbers are assigned and incremented.
These rules are based on but not necessarily limited to pre-existing
widespread common practices in use in both closed and open-source software.
For this system to work, you first need to declare a public API. This may
consist of documentation or be enforced by the code itself. Regardless, it is
important that this API be clear and precise. Once you identify your public
API, you communicate changes to it with specific increments to your version
number. Consider a version format of X.Y.Z (Major.Minor.Patch). Bug fixes not
affecting the API increment the patch version, backward compatible API
additions/changes increment the minor version, and backward incompatible API
changes increment the major version.

We call this system “Semantic Versioning.” Under this scheme, version numbers
and the way they change convey meaning about the underlying code and what has
been modified from one version to the next.

Semantic Versioning Specification (SemVer)

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,
“SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be
interpreted as described in RFC 2119.


  
    Software using Semantic Versioning MUST declare a public API. This API
could be declared in the code itself or exist strictly in documentation.
However it is done, it SHOULD be precise and comprehensive.
  
  
    A normal version number MUST take the form X.Y.Z where X, Y, and Z are
non-negative integers, and MUST NOT contain leading zeroes. X is the
major version, Y is the minor version, and Z is the patch version.
Each element MUST increase numerically. For instance: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Once a versioned package has been released, the contents of that version
MUST NOT be modified. Any modifications MUST be released as a new version.
  
  
    Major version zero (0.y.z) is for initial development. Anything MAY change
at any time. The public API SHOULD NOT be considered stable.
  
  
    Version 1.0.0 defines the public API. The way in which the version number
is incremented after this release is dependent on this public API and how it
changes.
  
  
    Patch version Z (x.y.Z | x > 0) MUST be incremented if only backward
compatible bug fixes are introduced. A bug fix is defined as an internal
change that fixes incorrect behavior.
  
  
    Minor version Y (x.Y.z | x > 0) MUST be incremented if new, backward
compatible functionality is introduced to the public API. It MUST be
incremented if any public API functionality is marked as deprecated. It MAY be
incremented if substantial new functionality or improvements are introduced
within the private code. It MAY include patch level changes. Patch version
MUST be reset to 0 when minor version is incremented.
  
  
    Major version X (X.y.z | X > 0) MUST be incremented if any backward
incompatible changes are introduced to the public API. It MAY also include minor
and patch level changes. Patch and minor versions MUST be reset to 0 when major
version is incremented.
  
  
    A pre-release version MAY be denoted by appending a hyphen and a
series of dot separated identifiers immediately following the patch
version. Identifiers MUST comprise only ASCII alphanumerics and hyphens
[0-9A-Za-z-]. Identifiers MUST NOT be empty. Numeric identifiers MUST
NOT include leading zeroes. Pre-release versions have a lower
precedence than the associated normal version. A pre-release version
indicates that the version is unstable and might not satisfy the
intended compatibility requirements as denoted by its associated
normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.--.
  
  
    Build metadata MAY be denoted by appending a plus sign and a series of dot
separated identifiers immediately following the patch or pre-release version.
Identifiers MUST comprise only ASCII alphanumerics and hyphens [0-9A-Za-z-].
Identifiers MUST NOT be empty. Build metadata MUST be ignored when determining
version precedence. Thus two versions that differ only in the build metadata,
have the same precedence. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3----117B344092BD.
  
  
    Precedence refers to how versions are compared to each other when ordered.

    
      
        Precedence MUST be calculated by separating the version into major,
minor, patch and pre-release identifiers in that order (Build metadata
does not figure into precedence).
      
      
        Precedence is determined by the first difference when comparing each of
these identifiers from left to right as follows: Major, minor, and patch
versions are always compared numerically.

        Example: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        When major, minor, and patch are equal, a pre-release version has lower
precedence than a normal version:

        Example: 1.0.0-alpha < 1.0.0.
      
      
        Precedence for two pre-release versions with the same major, minor, and
patch version MUST be determined by comparing each dot separated identifier
from left to right until a difference is found as follows:

        
          
            Identifiers consisting of only digits are compared numerically.
          
          
            Identifiers with letters or hyphens are compared lexically in ASCII
sort order.
          
          
            Numeric identifiers always have lower precedence than non-numeric
identifiers.
          
          
            A larger set of pre-release fields has a higher precedence than a
smaller set, if all of the preceding identifiers are equal.
          
        

        Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
      
    
  


Backus–Naur Form Grammar for Valid SemVer Versions
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


Why Use Semantic Versioning?

This is not a new or revolutionary idea. In fact, you probably do something
close to this already. The problem is that “close” isn’t good enough. Without
compliance to some sort of formal specification, version numbers are
essentially useless for dependency management. By giving a name and clear
definition to the above ideas, it becomes easy to communicate your intentions
to the users of your software. Once these intentions are clear, flexible (but
not too flexible) dependency specifications can finally be made.

A simple example will demonstrate how Semantic Versioning can make dependency
hell a thing of the past. Consider a library called “Firetruck.” It requires a
Semantically Versioned package named “Ladder.” At the time that Firetruck is
created, Ladder is at version 3.1.0. Since Firetruck uses some functionality
that was first introduced in 3.1.0, you can safely specify the Ladder
dependency as greater than or equal to 3.1.0 but less than 4.0.0. Now, when
Ladder version 3.1.1 and 3.2.0 become available, you can release them to your
package management system and know that they will be compatible with existing
dependent software.

As a responsible developer you will, of course, want to verify that any
package upgrades function as advertised. The real world is a messy place;
there’s nothing we can do about that but be vigilant. What you can do is let
Semantic Versioning provide you with a sane way to release and upgrade
packages without having to roll new versions of dependent packages, saving you
time and hassle.

If all of this sounds desirable, all you need to do to start using Semantic
Versioning is to declare that you are doing so and then follow the rules. Link
to this website from your README so others know the rules and can benefit from
them.

FAQ

How should I deal with revisions in the 0.y.z initial development phase?

The simplest thing to do is start your initial development release at 0.1.0
and then increment the minor version for each subsequent release.

How do I know when to release 1.0.0?

If your software is being used in production, it should probably already be
1.0.0. If you have a stable API on which users have come to depend, you should
be 1.0.0. If you’re worrying a lot about backward compatibility, you should
probably already be 1.0.0.

Doesn’t this discourage rapid development and fast iteration?

Major version zero is all about rapid development. If you’re changing the API
every day you should either still be in version 0.y.z or on a separate
development branch working on the next major version.

If even the tiniest backward incompatible changes to the public API require a major version bump, won’t I end up at version 42.0.0 very rapidly?

This is a question of responsible development and foresight. Incompatible
changes should not be introduced lightly to software that has a lot of
dependent code. The cost that must be incurred to upgrade can be significant.
Having to bump major versions to release incompatible changes means you’ll
think through the impact of your changes, and evaluate the cost/benefit ratio
involved.

Documenting the entire public API is too much work!

It is your responsibility as a professional developer to properly document
software that is intended for use by others. Managing software complexity is a
hugely important part of keeping a project efficient, and that’s hard to do if
nobody knows how to use your software, or what methods are safe to call. In
the long run, Semantic Versioning, and the insistence on a well defined public
API can keep everyone and everything running smoothly.

What do I do if I accidentally release a backward incompatible change as a minor version?

As soon as you realize that you’ve broken the Semantic Versioning spec, fix
the problem and release a new minor version that corrects the problem and
restores backward compatibility. Even under this circumstance, it is
unacceptable to modify versioned releases. If it’s appropriate,
document the offending version and inform your users of the problem so that
they are aware of the offending version.

What should I do if I update my own dependencies without changing the public API?

That would be considered compatible since it does not affect the public API.
Software that explicitly depends on the same dependencies as your package
should have their own dependency specifications and the author will notice any
conflicts. Determining whether the change is a patch level or minor level
modification depends on whether you updated your dependencies in order to fix
a bug or introduce new functionality. We would usually expect additional code
for the latter instance, in which case it’s obviously a minor level increment.

What if I inadvertently alter the public API in a way that is not compliant with the version number change (i.e. the code incorrectly introduces a major breaking change in a patch release)?

Use your best judgment. If you have a huge audience that will be drastically
impacted by changing the behavior back to what the public API intended, then
it may be best to perform a major version release, even though the fix could
strictly be considered a patch release. Remember, Semantic Versioning is all
about conveying meaning by how the version number changes. If these changes
are important to your users, use the version number to inform them.

How should I handle deprecating functionality?

Deprecating existing functionality is a normal part of software development and
is often required to make forward progress. When you deprecate part of your
public API, you should do two things: (1) update your documentation to let
users know about the change, (2) issue a new minor release with the deprecation
in place. Before you completely remove the functionality in a new major release
there should be at least one minor release that contains the deprecation so
that users can smoothly transition to the new API.

Does SemVer have a size limit on the version string?

No, but use good judgment. A 255 character version string is probably overkill,
for example. Also, specific systems may impose their own limits on the size of
the string.

Is “v1.2.3” a semantic version?

No, “v1.2.3” is not a semantic version. However, prefixing a semantic version
with a “v” is a common way (in English) to indicate it is a version number.
Abbreviating “version” as “v” is often seen with version control. Example:
git tag v1.2.3 -m "Release version 1.2.3", in which case “v1.2.3” is a tag
name and the semantic version is “1.2.3”.

Is there a suggested regular expression (RegEx) to check a SemVer string?

There are two. One with named groups for those systems that support them
(PCRE [Perl Compatible Regular Expressions, i.e. Perl, PHP and R], Python
and Go).

See: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


And one with numbered capture groups instead (so cg1 = major, cg2 = minor,
cg3 = patch, cg4 = prerelease and cg5 = buildmetadata) that is compatible
with ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
i.e. Perl, PHP and R), Python and Go.

See: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


About

The Semantic Versioning specification was originally authored by Tom
Preston-Werner, inventor of Gravatar and
cofounder of GitHub.

If you’d like to leave feedback, please open an issue on
GitHub.

License

Creative Commons ― CC BY 3.0\nSemantic Versioning 2.0.0\nGiven a version number MAJOR.MINOR.PATCH, increment the:\nMAJOR version when you make incompatible API changes\nMINOR version when you add functionality in a backward compatible
manner\nPATCH version when you make backward compatible bug fixes\nAdditional labels for pre-release and build metadata are available as extensions
to the MAJOR.MINOR.PATCH format.\nIn the world of software management there exists a dreaded place called
“dependency hell.” The bigger your system grows and the more packages you
integrate into your software, the more likely you are to find yourself, one
day, in this pit of despair.\nIn systems with many dependencies, releasing new package versions can quickly
become a nightmare. If the dependency specifications are too tight, you are in
danger of version lock (the inability to upgrade a package without having to
release new versions of every dependent package). If dependencies are
specified too loosely, you will inevitably be bitten by version promiscuity
(assuming compatibility with more future versions than is reasonable).
Dependency hell is where you are when version lock and/or version promiscuity
prevent you from easily and safely moving your project forward.\nAs a solution to this problem, we propose a simple set of rules and
requirements that dictate how version numbers are assigned and incremented.
These rules are based on but not necessarily limited to pre-existing
widespread common practices in use in both closed and open-source software.
For this system to work, you first need to declare a public API. This may
consist of documentation or be enforced by the code itself. Regardless, it is
important that this API be clear and precise. Once you identify your public
API, you communicate changes to it with specific increments to your version
number. Consider a version format of X.Y.Z (Major.Minor.Patch). Bug fixes not
affecting the API increment the patch version, backward compatible API
additions/changes increment the minor version, and backward incompatible API
changes increment the major version.\nWe call this system “Semantic Versioning.” Under this scheme, version numbers
and the way they change convey meaning about the underlying code and what has
been modified from one version to the next.\nSemantic Versioning Specification (SemVer)\nThe key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,
“SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be
interpreted as described in RFC 2119.\nSoftware using Semantic Versioning MUST declare a public API. This API
could be declared in the code itself or exist strictly in documentation.
However it is done, it SHOULD be precise and comprehensive.\nSoftware using Semantic Versioning MUST declare a public API. This API
could be declared in the code itself or exist strictly in documentation.
However it is done, it SHOULD be precise and comprehensive.\nA normal version number MUST take the form X.Y.Z where X, Y, and Z are
non-negative integers, and MUST NOT contain leading zeroes. X is the
major version, Y is the minor version, and Z is the patch version.
Each element MUST increase numerically. For instance: 1.9.0 -> 1.10.0 -> 1.11.0.\nA normal version number MUST take the form X.Y.Z where X, Y, and Z are
non-negative integers, and MUST NOT contain leading zeroes. X is the
major version, Y is the minor version, and Z is the patch version.
Each element MUST increase numerically. For instance: 1.9.0 -> 1.10.0 -> 1.11.0.\nOnce a versioned package has been released, the contents of that version
MUST NOT be modified. Any modifications MUST be released as a new version.\nOnce a versioned package has been released, the contents of that version
MUST NOT be modified. Any modifications MUST be released as a new version.\nMajor version zero (0.y.z) is for initial development. Anything MAY change
at any time. The public API SHOULD NOT be considered stable.\nMajor version zero (0.y.z) is for initial development. Anything MAY change
at any time. The public API SHOULD NOT be considered stable.\nVersion 1.0.0 defines the public API. The way in which the version number
is incremented after this release is dependent on this public API and how it
changes.\nVersion 1.0.0 defines the public API. The way in which the version number
is incremented after this release is dependent on this public API and how it
changes.\nPatch version Z (x.y.Z | x > 0) MUST be incremented if only backward
compatible bug fixes are introduced. A bug fix is defined as an internal
change that fixes incorrect behavior.\nPatch version Z (x.y.Z | x > 0) MUST be incremented if only backward
compatible bug fixes are introduced. A bug fix is defined as an internal
change that fixes incorrect behavior.\nMinor version Y (x.Y.z | x > 0) MUST be incremented if new, backward
compatible functionality is introduced to the public API. It MUST be
incremented if any public API functionality is marked as deprecated. It MAY be
incremented if substantial new functionality or improvements are introduced
within the private code. It MAY include patch level changes. Patch version
MUST be reset to 0 when minor version is incremented.\nMinor version Y (x.Y.z | x > 0) MUST be incremented if new, backward
compatible functionality is introduced to the public API. It MUST be
incremented if any public API functionality is marked as deprecated. It MAY be
incremented if substantial new functionality or improvements are introduced
within the private code. It MAY include patch level changes. Patch version
MUST be reset to 0 when minor version is incremented.\nMajor version X (X.y.z | X > 0) MUST be incremented if any backward
incompatible changes are introduced to the public API. It MAY also include minor
and patch level changes. Patch and minor versions MUST be reset to 0 when major
version is incremented.\nMajor version X (X.y.z | X > 0) MUST be incremented if any backward
incompatible changes are introduced to the public API. It MAY also include minor
and patch level changes. Patch and minor versions MUST be reset to 0 when major
version is incremented.\nA pre-release version MAY be denoted by appending a hyphen and a
series of dot separated identifiers immediately following the patch
version. Identifiers MUST comprise only ASCII alphanumerics and hyphens
[0-9A-Za-z-]. Identifiers MUST NOT be empty. Numeric identifiers MUST
NOT include leading zeroes. Pre-release versions have a lower
precedence than the associated normal version. A pre-release version
indicates that the version is unstable and might not satisfy the
intended compatibility requirements as denoted by its associated
normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.--.\nA pre-release version MAY be denoted by appending a hyphen and a
series of dot separated identifiers immediately following the patch
version. Identifiers MUST comprise only ASCII alphanumerics and hyphens
[0-9A-Za-z-]. Identifiers MUST NOT be empty. Numeric identifiers MUST
NOT include leading zeroes. Pre-release versions have a lower
precedence than the associated normal version. A pre-release version
indicates that the version is unstable and might not satisfy the
intended compatibility requirements as denoted by its associated
normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.--.\nBuild metadata MAY be denoted by appending a plus sign and a series of dot
separated identifiers immediately following the patch or pre-release version.
Identifiers MUST comprise only ASCII alphanumerics and hyphens [0-9A-Za-z-].
Identifiers MUST NOT be empty. Build metadata MUST be ignored when determining
version precedence. Thus two versions that differ only in the build metadata,
have the same precedence. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3----117B344092BD.\nBuild metadata MAY be denoted by appending a plus sign and a series of dot
separated identifiers immediately following the patch or pre-release version.
Identifiers MUST comprise only ASCII alphanumerics and hyphens [0-9A-Za-z-].
Identifiers MUST NOT be empty. Build metadata MUST be ignored when determining
version precedence. Thus two versions that differ only in the build metadata,
have the same precedence. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3----117B344092BD.\nPrecedence refers to how versions are compared to each other when ordered.

    
      
        Precedence MUST be calculated by separating the version into major,
minor, patch and pre-release identifiers in that order (Build metadata
does not figure into precedence).
      
      
        Precedence is determined by the first difference when comparing each of
these identifiers from left to right as follows: Major, minor, and patch
versions are always compared numerically.

        Example: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        When major, minor, and patch are equal, a pre-release version has lower
precedence than a normal version:

        Example: 1.0.0-alpha < 1.0.0.
      
      
        Precedence for two pre-release versions with the same major, minor, and
patch version MUST be determined by comparing each dot separated identifier
from left to right until a difference is found as follows:

        
          
            Identifiers consisting of only digits are compared numerically.
          
          
            Identifiers with letters or hyphens are compared lexically in ASCII
sort order.
          
          
            Numeric identifiers always have lower precedence than non-numeric
identifiers.
          
          
            A larger set of pre-release fields has a higher precedence than a
smaller set, if all of the preceding identifiers are equal.
          
        

        Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPrecedence refers to how versions are compared to each other when ordered.\nPrecedence MUST be calculated by separating the version into major,
minor, patch and pre-release identifiers in that order (Build metadata
does not figure into precedence).\nPrecedence MUST be calculated by separating the version into major,
minor, patch and pre-release identifiers in that order (Build metadata
does not figure into precedence).\nPrecedence is determined by the first difference when comparing each of
these identifiers from left to right as follows: Major, minor, and patch
versions are always compared numerically.

        Example: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nPrecedence is determined by the first difference when comparing each of
these identifiers from left to right as follows: Major, minor, and patch
versions are always compared numerically.\nExample: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nWhen major, minor, and patch are equal, a pre-release version has lower
precedence than a normal version:

        Example: 1.0.0-alpha < 1.0.0.\nWhen major, minor, and patch are equal, a pre-release version has lower
precedence than a normal version:\nExample: 1.0.0-alpha < 1.0.0.\nPrecedence for two pre-release versions with the same major, minor, and
patch version MUST be determined by comparing each dot separated identifier
from left to right until a difference is found as follows:

        
          
            Identifiers consisting of only digits are compared numerically.
          
          
            Identifiers with letters or hyphens are compared lexically in ASCII
sort order.
          
          
            Numeric identifiers always have lower precedence than non-numeric
identifiers.
          
          
            A larger set of pre-release fields has a higher precedence than a
smaller set, if all of the preceding identifiers are equal.
          
        

        Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPrecedence for two pre-release versions with the same major, minor, and
patch version MUST be determined by comparing each dot separated identifier
from left to right until a difference is found as follows:\nIdentifiers consisting of only digits are compared numerically.\nIdentifiers consisting of only digits are compared numerically.\nIdentifiers with letters or hyphens are compared lexically in ASCII
sort order.\nIdentifiers with letters or hyphens are compared lexically in ASCII
sort order.\nNumeric identifiers always have lower precedence than non-numeric
identifiers.\nNumeric identifiers always have lower precedence than non-numeric
identifiers.\nA larger set of pre-release fields has a higher precedence than a
smaller set, if all of the preceding identifiers are equal.\nA larger set of pre-release fields has a higher precedence than a
smaller set, if all of the preceding identifiers are equal.\nExample: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nBackus–Naur Form Grammar for Valid SemVer Versions\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nWhy Use Semantic Versioning?\nThis is not a new or revolutionary idea. In fact, you probably do something
close to this already. The problem is that “close” isn’t good enough. Without
compliance to some sort of formal specification, version numbers are
essentially useless for dependency management. By giving a name and clear
definition to the above ideas, it becomes easy to communicate your intentions
to the users of your software. Once these intentions are clear, flexible (but
not too flexible) dependency specifications can finally be made.\nA simple example will demonstrate how Semantic Versioning can make dependency
hell a thing of the past. Consider a library called “Firetruck.” It requires a
Semantically Versioned package named “Ladder.” At the time that Firetruck is
created, Ladder is at version 3.1.0. Since Firetruck uses some functionality
that was first introduced in 3.1.0, you can safely specify the Ladder
dependency as greater than or equal to 3.1.0 but less than 4.0.0. Now, when
Ladder version 3.1.1 and 3.2.0 become available, you can release them to your
package management system and know that they will be compatible with existing
dependent software.\nAs a responsible developer you will, of course, want to verify that any
package upgrades function as advertised. The real world is a messy place;
there’s nothing we can do about that but be vigilant. What you can do is let
Semantic Versioning provide you with a sane way to release and upgrade
packages without having to roll new versions of dependent packages, saving you
time and hassle.\nIf all of this sounds desirable, all you need to do to start using Semantic
Versioning is to declare that you are doing so and then follow the rules. Link
to this website from your README so others know the rules and can benefit from
them.\nHow should I deal with revisions in the 0.y.z initial development phase?\nThe simplest thing to do is start your initial development release at 0.1.0
and then increment the minor version for each subsequent release.\nHow do I know when to release 1.0.0?\nIf your software is being used in production, it should probably already be
1.0.0. If you have a stable API on which users have come to depend, you should
be 1.0.0. If you’re worrying a lot about backward compatibility, you should
probably already be 1.0.0.\nDoesn’t this discourage rapid development and fast iteration?\nMajor version zero is all about rapid development. If you’re changing the API
every day you should either still be in version 0.y.z or on a separate
development branch working on the next major version.\nIf even the tiniest backward incompatible changes to the public API require a major version bump, won’t I end up at version 42.0.0 very rapidly?\nThis is a question of responsible development and foresight. Incompatible
changes should not be introduced lightly to software that has a lot of
dependent code. The cost that must be incurred to upgrade can be significant.
Having to bump major versions to release incompatible changes means you’ll
think through the impact of your changes, and evaluate the cost/benefit ratio
involved.\nDocumenting the entire public API is too much work!\nIt is your responsibility as a professional developer to properly document
software that is intended for use by others. Managing software complexity is a
hugely important part of keeping a project efficient, and that’s hard to do if
nobody knows how to use your software, or what methods are safe to call. In
the long run, Semantic Versioning, and the insistence on a well defined public
API can keep everyone and everything running smoothly.\nWhat do I do if I accidentally release a backward incompatible change as a minor version?\nAs soon as you realize that you’ve broken the Semantic Versioning spec, fix
the problem and release a new minor version that corrects the problem and
restores backward compatibility. Even under this circumstance, it is
unacceptable to modify versioned releases. If it’s appropriate,
document the offending version and inform your users of the problem so that
they are aware of the offending version.\nWhat should I do if I update my own dependencies without changing the public API?\nThat would be considered compatible since it does not affect the public API.
Software that explicitly depends on the same dependencies as your package
should have their own dependency specifications and the author will notice any
conflicts. Determining whether the change is a patch level or minor level
modification depends on whether you updated your dependencies in order to fix
a bug or introduce new functionality. We would usually expect additional code
for the latter instance, in which case it’s obviously a minor level increment.\nWhat if I inadvertently alter the public API in a way that is not compliant with the version number change (i.e. the code incorrectly introduces a major breaking change in a patch release)?\nUse your best judgment. If you have a huge audience that will be drastically
impacted by changing the behavior back to what the public API intended, then
it may be best to perform a major version release, even though the fix could
strictly be considered a patch release. Remember, Semantic Versioning is all
about conveying meaning by how the version number changes. If these changes
are important to your users, use the version number to inform them.\nHow should I handle deprecating functionality?\nDeprecating existing functionality is a normal part of software development and
is often required to make forward progress. When you deprecate part of your
public API, you should do two things: (1) update your documentation to let
users know about the change, (2) issue a new minor release with the deprecation
in place. Before you completely remove the functionality in a new major release
there should be at least one minor release that contains the deprecation so
that users can smoothly transition to the new API.\nDoes SemVer have a size limit on the version string?\nNo, but use good judgment. A 255 character version string is probably overkill,
for example. Also, specific systems may impose their own limits on the size of
the string.\nIs “v1.2.3” a semantic version?\nNo, “v1.2.3” is not a semantic version. However, prefixing a semantic version
with a “v” is a common way (in English) to indicate it is a version number.
Abbreviating “version” as “v” is often seen with version control. Example:
git tag v1.2.3 -m "Release version 1.2.3", in which case “v1.2.3” is a tag
name and the semantic version is “1.2.3”.\nIs there a suggested regular expression (RegEx) to check a SemVer string?\nThere are two. One with named groups for those systems that support them
(PCRE [Perl Compatible Regular Expressions, i.e. Perl, PHP and R], Python
and Go).\nSee: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nAnd one with numbered capture groups instead (so cg1 = major, cg2 = minor,
cg3 = patch, cg4 = prerelease and cg5 = buildmetadata) that is compatible
with ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
i.e. Perl, PHP and R), Python and Go.\nSee: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nThe Semantic Versioning specification was originally authored by Tom
Preston-Werner, inventor of Gravatar and
cofounder of GitHub.\nIf you’d like to leave feedback, please open an issue on
GitHub.\nopen an issue on
GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nVersionado Semántico 2.0.0

Resumen

Dado un número de versión MAYOR.MENOR.PARCHE, se incrementa:


  La versión MAYOR cuando realizas un cambio incompatible en el API,
  La versión MENOR cuando añades funcionalidad compatible con versiones anteriores, y
  La versión PARCHE cuando reparas errores compatibles con versiones anteriores.


Hay disponibles etiquetas para prelanzamiento y metadata de compilación como extensiones al formato MAYOR.MENOR.PARCHE.

Introducción

En el mundo de la administración de software existe un temido lugar llamado “Infierno de Dependencias”. Mientras más crece tu sistema y más paquetes integras dentro de tu software, más probable se hace que un día te encuentres en este pozo de desesperación.

En sistemas con muchas dependencias, lanzar nuevas versiones de los paquetes puede convertirse en una pesadilla. Si las especificaciones de la dependencias son muy estrictas, estarás en peligro de bloquear una versión (la inhabilidad de actualizar un paquete sin tener que publicar una nueva versión de cada otro paquete dependiente). Si las dependencias son especificadas de forma muy relajada, inevitablemente serás mordido por versiones promiscuas (asumir la compatibilidad con próximas versiones más allá de lo razonable). El Infierno de Dependencias es donde estás cuando una versión bloqueada y/o promiscua previenen que muevas tu proyecto adelante de forma fácil y segura.

Como solución a este problema, propuse un conjunto simple de reglas y requerimientos que dicten cómo asignar e incrementar los números de la versión. Estas reglas están basadas en prácticas preexistentes de uso generalizado tanto en software de código cerrado como de código abierto, pero no necesariamente limitadas a éstas. Para que este sistema funcione, primero debes declarar un API público. Éste puede consistir en documentación aparte o ser impuesto por el código mismo. Independientemente de lo anterior, es importante que este API sea claro y preciso. Una vez identifiques tu API público, debes comunicar los cambios realizados a éste con incrementos específicos a tu número de versión. Considera un formato de versión X.Y.Z (Mayor.Menor.Parche). Las correcciones de errores que no afectan el API incrementan la versión parche. Adiciones o sustracciones compatibles con versiones anteriores incrementan la versión menor, y cambios en el API incompatibles con versiones anteriores incrementan la versión mayor.

Llamo a este sistema “Versionado Semántico”. Bajo este esquema, los números de versión y la forma en la que cambian transmiten el sentido del código y lo que ha sido modificado de una versión a otra.

Especificación del Versionado Semántico (SemVer)

Las palabras clave “DEBE”, “NO DEBE”, “OBLIGATORIO”, “DEBERÁ”, “NO DEBERÁ”, “DEBERÍA”, “NO DEBERÍA”, “RECOMENDADO”, “PUEDE” y “OPCIONAL” en este documento serán interpretadas como se describe en RFC 2119-es.


  
    El Software que usa Versionado Semántico DEBE declarar un API público. Este API puede ser declarado en el propio código o debe existir estrictamente en la documentación. Sin importar como sea realizado, este DEBERÍA ser preciso y comprehensivo.
  
  
    Un número de versión normal DEBE tener la forma de X.Y.Z donde X, Y y Z son números enteros no negativos, y NO DEBEN ser precedidos de ceros. X es la versión mayor, Y es la versión menor, y Z es la versión parche. Cada elemento DEBE incrementarse numéricamente. Por ejemplo: 1.9.0 -> 1.10.0 -> 1.11.0
  
  
    Una vez que el paquete versionado ha sido publicado, el contenido de esa versión NO DEBE ser modificado. Cualquier modificación DEBE ser publicada como una nueva versión.
  
  
    Una versión mayor en cero (0.y.z) se considera como desarrollo inicial. Todo PUEDE cambiar en cualquier momento. El API público NO DEBERÍA ser considerado estable.
  
  
    La versión 1.0.0 define el API público. La manera en que cada número de versión es incrementado después de esta publicación dependerá de su API público y cómo cambia.
  
  
    
      
        
          La versión parche Z (x.y.Z
          x > 0) DEBE ser incrementada si solamente se introducen correcciones de errores compatibles con versiones anteriores. Una corrección de error se define como un cambio interno que corrige un comportamiento incorrecto.
        
      
    
  
  
    
      
        
          La versión menor Y (x.Y.z
          x > 0) DEBE ser incrementada si se introduce funcionalidad nueva y compatible con la versión anterior del API público. Ésta DEBE ser incrementada si se introduce cualquier funcionalidad al API público o mejora al código privado. Este PUEDE incluir cambios a nivel de parches. La versión parche DEBE reiniciarse a 0 cuando una versión menor se incrementa.
        
      
    
  
  
    
      
        
          La versión mayor (X.y.z
          X > 0) DEBE ser incrementada solamente si se introducen cambios incompatibles con la versión anterior del API público. Este PUEDE incluir cambios de nivel menor y parches. Versiones parche y menores DEBEN ser reiniciadas a 0 cuando una versión mayor es incrementada.
        
      
    
  
  
    Una versión de prelanzamiento PUEDE ser denotada agregando un guión y una serie de identificadores separados por puntos, inmediatamente seguida de la versión parche. Los identificadores DEBEN ser compuestos sólo de caracteres alfanuméricos ASCII y guión ([0-9A-Za-z-]). Los identificadores NO DEBEN estar vacíos. Identificadores numéricos NO DEBEN ser precedidos de cero. Versiones de prelanzamiento tienen una precedencia inferior que una versión normal. Una versión de prelanzamiento indica que esa versión no es estable y puede no satisfacer los requerimientos de compatibilidad destinados como se denota en la versión normal asociada. Por ejemplo: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Metadatos de compilación PUEDEN ser denotados agregando el signo más y una serie de identificadores separados por puntos, inmediatamente seguido de la versión parche o prelanzamiento.  Los identificadores DEBEN ser compuestos de sólo caracteres alfanuméricos ASCII y guión ([0-9A-Za-z-]). Los identificadores NO DEBEN estar vacíos. Identificadores numéricos NO DEBEN ser precedidos de cero. Los metadatos de compilación DEBEN ser ignorados cuando se determina la precedencia de la versión. Por lo tanto, dos versiones que difieren solamente en los metadatos de compilación tienen la misma precedencia. Por ejemplo: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    La precedencia se refiere a cómo las versiones se comparan entre ellas cuando se ordenan.

    
      La precedencia DEBE ser calculada separando los identificadores de la versión en mayor, menor, parche y prelanzamiento (dejando de lado los metadatos de compilación).
      
        La precedencia es determinada por la primera diferencia al comparar cada uno de los identificadores de izquierda a derecha como se indica: mayor, menor y parche son siempre comparadas numéricamente.

        Por ejemplo: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Cuando la versión mayor, menor y parche son iguales, la versión de prelanzamiento tiene menor precedencia que la versión normal.

        Por ejemplo: 1.0.0-alpha < 1.0.0.
      
      
        La precedencia para dos versiones de prelanzamiento con la misma versión mayor, menor y parche DEBE ser determinada comparando cada identificador separado por punto, de izquierda a derecha, hasta que una diferencia sea encontrada como se indica:

        
          
            identificadores compuestos solamente por números son comparados numéricamente
          
          
            los identificadores con letras o guiones son comparados léxicamente en orden ASCII.
          
          
            Identificadores numéricos siempre tienen menor precedencia que identificadores no numéricos.
          
          
            Un conjunto de campos de prelanzamiento más numeroso tiene mayor precedencia que un conjunto menos numeroso, si todos los identificadores anteriores son iguales.
          
        

        Por ejemplo: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
      
    
  


Forma Gramatical Backus–Naur para Versiones Válidas SemVer

<semver válido> ::= <versión núcleo>
                  | <versión núcleo> "-" <prelanzamiento>
                  | <versión núcleo> "+" <compilación>
                  | <versión núcleo> "-" <prelanzamiento> "+" <compilación>

<versión núcleo> ::= <mayor> "." <menor> "." <parche>

<mayor> ::= <identificador numérico>

<menor> ::= <identificador numérico>

<parche> ::= <identificador numérico>

<prelanzamiento> ::= <identificadores prelanzamiento separados-por-puntos>

<identificadores prelanzamiento separados-por-puntos> ::= <identificador prelanzamiento>
                                                        | <identificador prelanzamiento> "." <identificadores prelanzamiento separados-por-puntos>

<compilación> ::= <identificadores compilación separados-por-puntos>

<identificadores compilación separados-por-puntos> ::= <identificador compilación>
                                                     | <identificador compilación> "." <identificadores compilación separados-por-puntos>

<identificador prelanzamiento> ::= <identificador alfanumérico>
                                 | <identificador numérico>

<identificador compilación> ::= <identificador alfanumérico>
                              | <dígitos>

<identificador alfanumérico> ::= <no-dígito>
                               | <no-dígito> <caracteres identificadores>
                               | <caracteres identificadores> <no-dígito>
                               | <caracteres identificadores> <no-dígito> <caracteres identificadores>

<identificador numérico> ::= "0"
                           | <dígito positivo>
                           | <dígito positivo> <dígitos>

<caracteres identificadores> ::= <carácter identificador>
                               | <carácter identificador> <caracteres identificadores>

<identificador caracter> ::= <dígito>
                           | <no-dígito>

<no-dígito> ::= <letra>
              | "-"

<dígitos> ::= <dígito>
            | <dígito> <dígitos>

<dígito> ::= "0"
           | <dígito positivo>

<dígito positivo> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letra> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
          | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
          | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
          | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
          | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
          | "y" | "z"


¿Por qué usar Versionado Semántico?

Esto no es una idea nueva o revolucionaria. De hecho, probablemente ya tengas algo parecido a ésto. El problema es que “parecido” no significa suficientemente bueno. Sin el cumplimiento de alguna especie de especificación formal, los números de versión son esencialmente inútiles para el manejo de dependencias. Dándole un nombre y una definición clara a las ideas anteriores, se hace fácil comunicar tus intenciones a los usuarios de tu software. Una vez estas intenciones son claras y flexibles (pero no tanto) las especificaciones de dependencia finalmente se pueden generar.

Un simple ejemplo demuestra cómo el Versionado Semántico puede hacer el Infierno de Dependencias una cosa del pasado. Considera una librería llamada “Camión de bomberos”. Este requiere un paquete versionado semánticamente llamado “Escalera”. Al mismo tiempo que el “Camión de bomberos” es creado, “Escalera” está en su versión 3.1.0. Dado que “Camión de bomberos” usa una funcionalidad que fue introducida en 3.1.0, puedes especificar con seguridad la dependencia “Escalera” igual o mayor a 3.1.0 pero menor a 4.0.0. Ahora, cuando la versión “Escalera” 3.1.1 y 3.2.0 se hagan disponibles, puedes recibirlas en tu gestor de paquetes y saber que son compatibles con tu software existente.

Como desarrollador responsable vas a querer verificar, como deberías, que cada actualización de paquetes funciona como se indica. El mundo real es un lugar desordenado; no hay nada que podamos hacer excepto estar atentos. Lo que puedes hacer es dejar que el Versionado Semántico te otorgue una sana manera de publicar y actualizar paquetes sin tener que crear nuevas versiones de paquetes dependientes, ahorrándote tiempo y molestias.

Si todo esto suena demasiado bueno como para ocuparlo, todo lo que tienes que hacer para usar Versionado Semántico es declarar que los vas a hacer y seguir las reglas. Vincula este sitio web en tu LÉEME para que otros sepan estas reglas y puedan beneficiarse de ellas.

PREGUNTAS FRECUENTES

¿Cómo debería lidiar con las revisiones en la fase inicial de desarrollo 0.y.z?

La manera más simple de hacerlo es comenzar publicando tu desarrollo inicial en 0.1.0 y luego incrementar la versión menor por cada siguiente lanzamiento.

¿Cómo voy a saber cuando publique la versión 1.0.0?

Si tu software está siendo usado en producción, probablemente ya debería ser 1.0.0. Si tienes un API estable del cual los usuarios dependen, debería ser 1.0.0. Si te estás preocupando mucho por la retrocompatibilidad, probablemente ya debería ser 1.0.0.

¿Acaso esto no desalienta el desarrollo rápido y la iteración rápida?

La versión mayor en cero se trata de desarrollo rápido. Si estás cambiando el API cada día entonces aún deberías estar en la versión 0.y.z o en una rama separada de desarrollo trabajando en la siguiente versión.

Si incluso el más pequeño cambio incompatible con versiones anteriores del API público requiere incrementar la versión mayor, ¿Acaso no voy a terminar pronto con una versión 42.0.0?

Esto es una pregunta de desarrollo responsable y precaución. Cambios incompatibles no deberían ser introducidos a la ligera en un software que tiene mucho código del cual depender. El costo que se incurre en actualizar puede ser significativo. Tener que incrementar versiones mayores para publicar cambios incompatibles quiere decir que tendrás que pensar sobre el impacto de tus cambios, y evaluar la proporción costo/beneficio involucrado.

¡Documentar todo el API público es demasiado trabajo!

Es tu responsabilidad como desarrollador profesional el documentar apropiadamente el software destinado a ser utilizados por otros. Administrar la complejidad del software es una parte muy importante para mantener un proyecto eficiente, y eso es difícil de hacer si nadie sabe cómo se usa tu software, o qué métodos son seguros de llamar. A largo plazo, el Versionado Semántico, y la insistencia de un API público bien definido puede mantener a todos y todo funcionando sin contratiempos.

¿Qué pasa si accidentalmente publico una versión incompatible como versión menor?

Tan pronto como te des cuenta que has roto las especificaciones del Versionado Semántico, arregla el problema y publica una nueva versión menor que corrija el problema y restaure la retrocompatibilidad. Incluso bajo estas circunstancias, es inaceptable modificar publicaciones versionadas. Si es apropiado, documenta la versión problemática e informa a tus usuarios sobre el percance para que todos sepan de esta versión problemática.

¿Qué debería hacer si actualizo mis propias dependencias sin cambiar el API público?

Eso sería considerado compatible dado que no afecta el API público. El sofware que explícitamente dependa de las mismas dependencias que tu paquete deberían tener su propias especificaciones de dependencias y el autor se dará cuenta de cualquier conflicto. Determinar si el cambio requiere modificar la versión parche o la versión menor dependerá en si has actualizado tus dependencias para arreglar un error o introducir nueva funcionalidad. Usualmente sospecho de código adicional sobre lo último, en ese caso es obviamente un incremento a la versión menor.

¿Qué pasa si altero el API público sin darme cuenta, de una manera que deja de cumplir con el número de la versión, como cuando el código incorrectamente introduce un cambio importante en una versión parche?

Usa tu mejor juicio. Si tienes una gran audiencia que será drásticamente impactada al devolver el comportamiento a lo que pretendía el API público, entonces quizás sea mejor realizar un lanzamiento de una versión mayor, incluso si una corrección pudiera ser estrictamente considerada una versión parche. Recuerda, el Versionado Semántico se trata de darle sentido a cómo un número de versión cambia. Si estos cambios son importantes para tus usuarios, usa el número de versión para informarles.

¿Cómo debería manejar funcionalidad obsoleta?

Desechar funcionalidad existente es algo normal en el desarrollo de software y es usualmente requerido para progresar. Cuando desechas parte de tu API público, deberías hacer dos cosas: (1) actualizar tu documentación para avisar a tus usuarios sobre el cambio, (2) lanzar una nueva versión menor manteniendo la obsolescencia en su lugar. Antes que remuevas completamente la funcionalidad en una nueva versión mayor debería haber al menos una versión menor anterior que contenga la obsolescencia para que todos los usuarios puedan planear una transición sin sobresaltos al nuevo API.

¿Tiene SemVer una longitud límite en el texto de la versión?

No, pero usa tu juicio. Por ejemplo, una versión de 255 caracteres probablemente sea exagerada. También, algunos sistemas en específico pueden imponer sus propios límites en la longitud del texto.

¿Es “v1.2.3” una versión semántica?

No, “v1.2.3” no es una versión semántica. Sin embargo, anteponer una versión semántica con un “v” es una forma muy generalizada (en inglés) de indicar que es un número de versión. Abreviar “version” como “v” es visto muy a menudo en programas de control de versiones. Por ejemplo: git tag v1.2.3 -m "Release version 1.2.3", en donde “v1.2.3” es el nombre de la etiqueta y la versión semántica es “1.2.3”.

¿Hay alguna expresión regular (RegEx) sugerida para verificar un texto SemVer?

Hay dos. Uno incluye grupos con nombre para sistemas que los soportan (PCRE [Perl Compatible Regular Expressions, i.e. Perl, PHP and R], Python y Go)

Mira: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Y el otro, en cambio, incluye grupos capturados numéricamente (así que cg1 = mayor, cg2 = menor, cg3 = parche, cg4 = prelanzamiento y cg5 = metadatos de compilación) que es compatible con ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions, i.e. Perl, PHP and R), Python y Go.

Mira: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Acerca de

La especificación de Versionado Semántico ha sido escrita por Tom Preston-Werner, inventor de Gravatar y co-fundador de GitHub.

Si quieres dejar comentarios, porfavor abre un problema (issue) en Github.

Traducción

Esta traducción ha sido realizada por Italo Baeza Cabrera. Si deseas editar esta traducción, puedes dirigirte al respectivo repositorio en Github

Licencia

Creative Commons ― CC BY 3.0 (en español)\nVersionado Semántico 2.0.0\nDado un número de versión MAYOR.MENOR.PARCHE, se incrementa:\nLa versión MAYOR cuando realizas un cambio incompatible en el API,\nLa versión MENOR cuando añades funcionalidad compatible con versiones anteriores, y\nLa versión PARCHE cuando reparas errores compatibles con versiones anteriores.\nHay disponibles etiquetas para prelanzamiento y metadata de compilación como extensiones al formato MAYOR.MENOR.PARCHE.\nEn el mundo de la administración de software existe un temido lugar llamado “Infierno de Dependencias”. Mientras más crece tu sistema y más paquetes integras dentro de tu software, más probable se hace que un día te encuentres en este pozo de desesperación.\nEn sistemas con muchas dependencias, lanzar nuevas versiones de los paquetes puede convertirse en una pesadilla. Si las especificaciones de la dependencias son muy estrictas, estarás en peligro de bloquear una versión (la inhabilidad de actualizar un paquete sin tener que publicar una nueva versión de cada otro paquete dependiente). Si las dependencias son especificadas de forma muy relajada, inevitablemente serás mordido por versiones promiscuas (asumir la compatibilidad con próximas versiones más allá de lo razonable). El Infierno de Dependencias es donde estás cuando una versión bloqueada y/o promiscua previenen que muevas tu proyecto adelante de forma fácil y segura.\nComo solución a este problema, propuse un conjunto simple de reglas y requerimientos que dicten cómo asignar e incrementar los números de la versión. Estas reglas están basadas en prácticas preexistentes de uso generalizado tanto en software de código cerrado como de código abierto, pero no necesariamente limitadas a éstas. Para que este sistema funcione, primero debes declarar un API público. Éste puede consistir en documentación aparte o ser impuesto por el código mismo. Independientemente de lo anterior, es importante que este API sea claro y preciso. Una vez identifiques tu API público, debes comunicar los cambios realizados a éste con incrementos específicos a tu número de versión. Considera un formato de versión X.Y.Z (Mayor.Menor.Parche). Las correcciones de errores que no afectan el API incrementan la versión parche. Adiciones o sustracciones compatibles con versiones anteriores incrementan la versión menor, y cambios en el API incompatibles con versiones anteriores incrementan la versión mayor.\nLlamo a este sistema “Versionado Semántico”. Bajo este esquema, los números de versión y la forma en la que cambian transmiten el sentido del código y lo que ha sido modificado de una versión a otra.\nEspecificación del Versionado Semántico (SemVer)\nLas palabras clave “DEBE”, “NO DEBE”, “OBLIGATORIO”, “DEBERÁ”, “NO DEBERÁ”, “DEBERÍA”, “NO DEBERÍA”, “RECOMENDADO”, “PUEDE” y “OPCIONAL” en este documento serán interpretadas como se describe en RFC 2119-es.\nEl Software que usa Versionado Semántico DEBE declarar un API público. Este API puede ser declarado en el propio código o debe existir estrictamente en la documentación. Sin importar como sea realizado, este DEBERÍA ser preciso y comprehensivo.\nEl Software que usa Versionado Semántico DEBE declarar un API público. Este API puede ser declarado en el propio código o debe existir estrictamente en la documentación. Sin importar como sea realizado, este DEBERÍA ser preciso y comprehensivo.\nUn número de versión normal DEBE tener la forma de X.Y.Z donde X, Y y Z son números enteros no negativos, y NO DEBEN ser precedidos de ceros. X es la versión mayor, Y es la versión menor, y Z es la versión parche. Cada elemento DEBE incrementarse numéricamente. Por ejemplo: 1.9.0 -> 1.10.0 -> 1.11.0\nUn número de versión normal DEBE tener la forma de X.Y.Z donde X, Y y Z son números enteros no negativos, y NO DEBEN ser precedidos de ceros. X es la versión mayor, Y es la versión menor, y Z es la versión parche. Cada elemento DEBE incrementarse numéricamente. Por ejemplo: 1.9.0 -> 1.10.0 -> 1.11.0\nUna vez que el paquete versionado ha sido publicado, el contenido de esa versión NO DEBE ser modificado. Cualquier modificación DEBE ser publicada como una nueva versión.\nUna vez que el paquete versionado ha sido publicado, el contenido de esa versión NO DEBE ser modificado. Cualquier modificación DEBE ser publicada como una nueva versión.\nUna versión mayor en cero (0.y.z) se considera como desarrollo inicial. Todo PUEDE cambiar en cualquier momento. El API público NO DEBERÍA ser considerado estable.\nUna versión mayor en cero (0.y.z) se considera como desarrollo inicial. Todo PUEDE cambiar en cualquier momento. El API público NO DEBERÍA ser considerado estable.\nLa versión 1.0.0 define el API público. La manera en que cada número de versión es incrementado después de esta publicación dependerá de su API público y cómo cambia.\nLa versión 1.0.0 define el API público. La manera en que cada número de versión es incrementado después de esta publicación dependerá de su API público y cómo cambia.\nLa versión parche Z (x.y.Z
          x > 0) DEBE ser incrementada si solamente se introducen correcciones de errores compatibles con versiones anteriores. Una corrección de error se define como un cambio interno que corrige un comportamiento incorrecto.\nLa versión parche Z (x.y.Z\nx > 0) DEBE ser incrementada si solamente se introducen correcciones de errores compatibles con versiones anteriores. Una corrección de error se define como un cambio interno que corrige un comportamiento incorrecto.\nLa versión menor Y (x.Y.z
          x > 0) DEBE ser incrementada si se introduce funcionalidad nueva y compatible con la versión anterior del API público. Ésta DEBE ser incrementada si se introduce cualquier funcionalidad al API público o mejora al código privado. Este PUEDE incluir cambios a nivel de parches. La versión parche DEBE reiniciarse a 0 cuando una versión menor se incrementa.\nLa versión menor Y (x.Y.z\nx > 0) DEBE ser incrementada si se introduce funcionalidad nueva y compatible con la versión anterior del API público. Ésta DEBE ser incrementada si se introduce cualquier funcionalidad al API público o mejora al código privado. Este PUEDE incluir cambios a nivel de parches. La versión parche DEBE reiniciarse a 0 cuando una versión menor se incrementa.\nLa versión mayor (X.y.z
          X > 0) DEBE ser incrementada solamente si se introducen cambios incompatibles con la versión anterior del API público. Este PUEDE incluir cambios de nivel menor y parches. Versiones parche y menores DEBEN ser reiniciadas a 0 cuando una versión mayor es incrementada.\nLa versión mayor (X.y.z\nX > 0) DEBE ser incrementada solamente si se introducen cambios incompatibles con la versión anterior del API público. Este PUEDE incluir cambios de nivel menor y parches. Versiones parche y menores DEBEN ser reiniciadas a 0 cuando una versión mayor es incrementada.\nUna versión de prelanzamiento PUEDE ser denotada agregando un guión y una serie de identificadores separados por puntos, inmediatamente seguida de la versión parche. Los identificadores DEBEN ser compuestos sólo de caracteres alfanuméricos ASCII y guión ([0-9A-Za-z-]). Los identificadores NO DEBEN estar vacíos. Identificadores numéricos NO DEBEN ser precedidos de cero. Versiones de prelanzamiento tienen una precedencia inferior que una versión normal. Una versión de prelanzamiento indica que esa versión no es estable y puede no satisfacer los requerimientos de compatibilidad destinados como se denota en la versión normal asociada. Por ejemplo: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nUna versión de prelanzamiento PUEDE ser denotada agregando un guión y una serie de identificadores separados por puntos, inmediatamente seguida de la versión parche. Los identificadores DEBEN ser compuestos sólo de caracteres alfanuméricos ASCII y guión ([0-9A-Za-z-]). Los identificadores NO DEBEN estar vacíos. Identificadores numéricos NO DEBEN ser precedidos de cero. Versiones de prelanzamiento tienen una precedencia inferior que una versión normal. Una versión de prelanzamiento indica que esa versión no es estable y puede no satisfacer los requerimientos de compatibilidad destinados como se denota en la versión normal asociada. Por ejemplo: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nMetadatos de compilación PUEDEN ser denotados agregando el signo más y una serie de identificadores separados por puntos, inmediatamente seguido de la versión parche o prelanzamiento.  Los identificadores DEBEN ser compuestos de sólo caracteres alfanuméricos ASCII y guión ([0-9A-Za-z-]). Los identificadores NO DEBEN estar vacíos. Identificadores numéricos NO DEBEN ser precedidos de cero. Los metadatos de compilación DEBEN ser ignorados cuando se determina la precedencia de la versión. Por lo tanto, dos versiones que difieren solamente en los metadatos de compilación tienen la misma precedencia. Por ejemplo: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nMetadatos de compilación PUEDEN ser denotados agregando el signo más y una serie de identificadores separados por puntos, inmediatamente seguido de la versión parche o prelanzamiento.  Los identificadores DEBEN ser compuestos de sólo caracteres alfanuméricos ASCII y guión ([0-9A-Za-z-]). Los identificadores NO DEBEN estar vacíos. Identificadores numéricos NO DEBEN ser precedidos de cero. Los metadatos de compilación DEBEN ser ignorados cuando se determina la precedencia de la versión. Por lo tanto, dos versiones que difieren solamente en los metadatos de compilación tienen la misma precedencia. Por ejemplo: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nLa precedencia se refiere a cómo las versiones se comparan entre ellas cuando se ordenan.

    
      La precedencia DEBE ser calculada separando los identificadores de la versión en mayor, menor, parche y prelanzamiento (dejando de lado los metadatos de compilación).
      
        La precedencia es determinada por la primera diferencia al comparar cada uno de los identificadores de izquierda a derecha como se indica: mayor, menor y parche son siempre comparadas numéricamente.

        Por ejemplo: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Cuando la versión mayor, menor y parche son iguales, la versión de prelanzamiento tiene menor precedencia que la versión normal.

        Por ejemplo: 1.0.0-alpha < 1.0.0.
      
      
        La precedencia para dos versiones de prelanzamiento con la misma versión mayor, menor y parche DEBE ser determinada comparando cada identificador separado por punto, de izquierda a derecha, hasta que una diferencia sea encontrada como se indica:

        
          
            identificadores compuestos solamente por números son comparados numéricamente
          
          
            los identificadores con letras o guiones son comparados léxicamente en orden ASCII.
          
          
            Identificadores numéricos siempre tienen menor precedencia que identificadores no numéricos.
          
          
            Un conjunto de campos de prelanzamiento más numeroso tiene mayor precedencia que un conjunto menos numeroso, si todos los identificadores anteriores son iguales.
          
        

        Por ejemplo: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nLa precedencia se refiere a cómo las versiones se comparan entre ellas cuando se ordenan.\nLa precedencia DEBE ser calculada separando los identificadores de la versión en mayor, menor, parche y prelanzamiento (dejando de lado los metadatos de compilación).\nLa precedencia es determinada por la primera diferencia al comparar cada uno de los identificadores de izquierda a derecha como se indica: mayor, menor y parche son siempre comparadas numéricamente.

        Por ejemplo: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nLa precedencia es determinada por la primera diferencia al comparar cada uno de los identificadores de izquierda a derecha como se indica: mayor, menor y parche son siempre comparadas numéricamente.\nPor ejemplo: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nCuando la versión mayor, menor y parche son iguales, la versión de prelanzamiento tiene menor precedencia que la versión normal.

        Por ejemplo: 1.0.0-alpha < 1.0.0.\nCuando la versión mayor, menor y parche son iguales, la versión de prelanzamiento tiene menor precedencia que la versión normal.\nPor ejemplo: 1.0.0-alpha < 1.0.0.\nLa precedencia para dos versiones de prelanzamiento con la misma versión mayor, menor y parche DEBE ser determinada comparando cada identificador separado por punto, de izquierda a derecha, hasta que una diferencia sea encontrada como se indica:

        
          
            identificadores compuestos solamente por números son comparados numéricamente
          
          
            los identificadores con letras o guiones son comparados léxicamente en orden ASCII.
          
          
            Identificadores numéricos siempre tienen menor precedencia que identificadores no numéricos.
          
          
            Un conjunto de campos de prelanzamiento más numeroso tiene mayor precedencia que un conjunto menos numeroso, si todos los identificadores anteriores son iguales.
          
        

        Por ejemplo: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nLa precedencia para dos versiones de prelanzamiento con la misma versión mayor, menor y parche DEBE ser determinada comparando cada identificador separado por punto, de izquierda a derecha, hasta que una diferencia sea encontrada como se indica:\nidentificadores compuestos solamente por números son comparados numéricamente\nidentificadores compuestos solamente por números son comparados numéricamente\nlos identificadores con letras o guiones son comparados léxicamente en orden ASCII.\nlos identificadores con letras o guiones son comparados léxicamente en orden ASCII.\nIdentificadores numéricos siempre tienen menor precedencia que identificadores no numéricos.\nIdentificadores numéricos siempre tienen menor precedencia que identificadores no numéricos.\nUn conjunto de campos de prelanzamiento más numeroso tiene mayor precedencia que un conjunto menos numeroso, si todos los identificadores anteriores son iguales.\nUn conjunto de campos de prelanzamiento más numeroso tiene mayor precedencia que un conjunto menos numeroso, si todos los identificadores anteriores son iguales.\nPor ejemplo: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nForma Gramatical Backus–Naur para Versiones Válidas SemVer\n<semver válido> ::= <versión núcleo>
                  | <versión núcleo> "-" <prelanzamiento>
                  | <versión núcleo> "+" <compilación>
                  | <versión núcleo> "-" <prelanzamiento> "+" <compilación>

<versión núcleo> ::= <mayor> "." <menor> "." <parche>

<mayor> ::= <identificador numérico>

<menor> ::= <identificador numérico>

<parche> ::= <identificador numérico>

<prelanzamiento> ::= <identificadores prelanzamiento separados-por-puntos>

<identificadores prelanzamiento separados-por-puntos> ::= <identificador prelanzamiento>
                                                        | <identificador prelanzamiento> "." <identificadores prelanzamiento separados-por-puntos>

<compilación> ::= <identificadores compilación separados-por-puntos>

<identificadores compilación separados-por-puntos> ::= <identificador compilación>
                                                     | <identificador compilación> "." <identificadores compilación separados-por-puntos>

<identificador prelanzamiento> ::= <identificador alfanumérico>
                                 | <identificador numérico>

<identificador compilación> ::= <identificador alfanumérico>
                              | <dígitos>

<identificador alfanumérico> ::= <no-dígito>
                               | <no-dígito> <caracteres identificadores>
                               | <caracteres identificadores> <no-dígito>
                               | <caracteres identificadores> <no-dígito> <caracteres identificadores>

<identificador numérico> ::= "0"
                           | <dígito positivo>
                           | <dígito positivo> <dígitos>

<caracteres identificadores> ::= <carácter identificador>
                               | <carácter identificador> <caracteres identificadores>

<identificador caracter> ::= <dígito>
                           | <no-dígito>

<no-dígito> ::= <letra>
              | "-"

<dígitos> ::= <dígito>
            | <dígito> <dígitos>

<dígito> ::= "0"
           | <dígito positivo>

<dígito positivo> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letra> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
          | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
          | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
          | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
          | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
          | "y" | "z"\n<semver válido> ::= <versión núcleo>
                  | <versión núcleo> "-" <prelanzamiento>
                  | <versión núcleo> "+" <compilación>
                  | <versión núcleo> "-" <prelanzamiento> "+" <compilación>

<versión núcleo> ::= <mayor> "." <menor> "." <parche>

<mayor> ::= <identificador numérico>

<menor> ::= <identificador numérico>

<parche> ::= <identificador numérico>

<prelanzamiento> ::= <identificadores prelanzamiento separados-por-puntos>

<identificadores prelanzamiento separados-por-puntos> ::= <identificador prelanzamiento>
                                                        | <identificador prelanzamiento> "." <identificadores prelanzamiento separados-por-puntos>

<compilación> ::= <identificadores compilación separados-por-puntos>

<identificadores compilación separados-por-puntos> ::= <identificador compilación>
                                                     | <identificador compilación> "." <identificadores compilación separados-por-puntos>

<identificador prelanzamiento> ::= <identificador alfanumérico>
                                 | <identificador numérico>

<identificador compilación> ::= <identificador alfanumérico>
                              | <dígitos>

<identificador alfanumérico> ::= <no-dígito>
                               | <no-dígito> <caracteres identificadores>
                               | <caracteres identificadores> <no-dígito>
                               | <caracteres identificadores> <no-dígito> <caracteres identificadores>

<identificador numérico> ::= "0"
                           | <dígito positivo>
                           | <dígito positivo> <dígitos>

<caracteres identificadores> ::= <carácter identificador>
                               | <carácter identificador> <caracteres identificadores>

<identificador caracter> ::= <dígito>
                           | <no-dígito>

<no-dígito> ::= <letra>
              | "-"

<dígitos> ::= <dígito>
            | <dígito> <dígitos>

<dígito> ::= "0"
           | <dígito positivo>

<dígito positivo> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letra> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
          | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
          | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
          | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
          | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
          | "y" | "z"\n¿Por qué usar Versionado Semántico?\nEsto no es una idea nueva o revolucionaria. De hecho, probablemente ya tengas algo parecido a ésto. El problema es que “parecido” no significa suficientemente bueno. Sin el cumplimiento de alguna especie de especificación formal, los números de versión son esencialmente inútiles para el manejo de dependencias. Dándole un nombre y una definición clara a las ideas anteriores, se hace fácil comunicar tus intenciones a los usuarios de tu software. Una vez estas intenciones son claras y flexibles (pero no tanto) las especificaciones de dependencia finalmente se pueden generar.\nUn simple ejemplo demuestra cómo el Versionado Semántico puede hacer el Infierno de Dependencias una cosa del pasado. Considera una librería llamada “Camión de bomberos”. Este requiere un paquete versionado semánticamente llamado “Escalera”. Al mismo tiempo que el “Camión de bomberos” es creado, “Escalera” está en su versión 3.1.0. Dado que “Camión de bomberos” usa una funcionalidad que fue introducida en 3.1.0, puedes especificar con seguridad la dependencia “Escalera” igual o mayor a 3.1.0 pero menor a 4.0.0. Ahora, cuando la versión “Escalera” 3.1.1 y 3.2.0 se hagan disponibles, puedes recibirlas en tu gestor de paquetes y saber que son compatibles con tu software existente.\nComo desarrollador responsable vas a querer verificar, como deberías, que cada actualización de paquetes funciona como se indica. El mundo real es un lugar desordenado; no hay nada que podamos hacer excepto estar atentos. Lo que puedes hacer es dejar que el Versionado Semántico te otorgue una sana manera de publicar y actualizar paquetes sin tener que crear nuevas versiones de paquetes dependientes, ahorrándote tiempo y molestias.\nSi todo esto suena demasiado bueno como para ocuparlo, todo lo que tienes que hacer para usar Versionado Semántico es declarar que los vas a hacer y seguir las reglas. Vincula este sitio web en tu LÉEME para que otros sepan estas reglas y puedan beneficiarse de ellas.\n¿Cómo debería lidiar con las revisiones en la fase inicial de desarrollo 0.y.z?\nLa manera más simple de hacerlo es comenzar publicando tu desarrollo inicial en 0.1.0 y luego incrementar la versión menor por cada siguiente lanzamiento.\n¿Cómo voy a saber cuando publique la versión 1.0.0?\nSi tu software está siendo usado en producción, probablemente ya debería ser 1.0.0. Si tienes un API estable del cual los usuarios dependen, debería ser 1.0.0. Si te estás preocupando mucho por la retrocompatibilidad, probablemente ya debería ser 1.0.0.\n¿Acaso esto no desalienta el desarrollo rápido y la iteración rápida?\nLa versión mayor en cero se trata de desarrollo rápido. Si estás cambiando el API cada día entonces aún deberías estar en la versión 0.y.z o en una rama separada de desarrollo trabajando en la siguiente versión.\nSi incluso el más pequeño cambio incompatible con versiones anteriores del API público requiere incrementar la versión mayor, ¿Acaso no voy a terminar pronto con una versión 42.0.0?\nEsto es una pregunta de desarrollo responsable y precaución. Cambios incompatibles no deberían ser introducidos a la ligera en un software que tiene mucho código del cual depender. El costo que se incurre en actualizar puede ser significativo. Tener que incrementar versiones mayores para publicar cambios incompatibles quiere decir que tendrás que pensar sobre el impacto de tus cambios, y evaluar la proporción costo/beneficio involucrado.\n¡Documentar todo el API público es demasiado trabajo!\nEs tu responsabilidad como desarrollador profesional el documentar apropiadamente el software destinado a ser utilizados por otros. Administrar la complejidad del software es una parte muy importante para mantener un proyecto eficiente, y eso es difícil de hacer si nadie sabe cómo se usa tu software, o qué métodos son seguros de llamar. A largo plazo, el Versionado Semántico, y la insistencia de un API público bien definido puede mantener a todos y todo funcionando sin contratiempos.\n¿Qué pasa si accidentalmente publico una versión incompatible como versión menor?\nTan pronto como te des cuenta que has roto las especificaciones del Versionado Semántico, arregla el problema y publica una nueva versión menor que corrija el problema y restaure la retrocompatibilidad. Incluso bajo estas circunstancias, es inaceptable modificar publicaciones versionadas. Si es apropiado, documenta la versión problemática e informa a tus usuarios sobre el percance para que todos sepan de esta versión problemática.\n¿Qué debería hacer si actualizo mis propias dependencias sin cambiar el API público?\nEso sería considerado compatible dado que no afecta el API público. El sofware que explícitamente dependa de las mismas dependencias que tu paquete deberían tener su propias especificaciones de dependencias y el autor se dará cuenta de cualquier conflicto. Determinar si el cambio requiere modificar la versión parche o la versión menor dependerá en si has actualizado tus dependencias para arreglar un error o introducir nueva funcionalidad. Usualmente sospecho de código adicional sobre lo último, en ese caso es obviamente un incremento a la versión menor.\n¿Qué pasa si altero el API público sin darme cuenta, de una manera que deja de cumplir con el número de la versión, como cuando el código incorrectamente introduce un cambio importante en una versión parche?\nUsa tu mejor juicio. Si tienes una gran audiencia que será drásticamente impactada al devolver el comportamiento a lo que pretendía el API público, entonces quizás sea mejor realizar un lanzamiento de una versión mayor, incluso si una corrección pudiera ser estrictamente considerada una versión parche. Recuerda, el Versionado Semántico se trata de darle sentido a cómo un número de versión cambia. Si estos cambios son importantes para tus usuarios, usa el número de versión para informarles.\n¿Cómo debería manejar funcionalidad obsoleta?\nDesechar funcionalidad existente es algo normal en el desarrollo de software y es usualmente requerido para progresar. Cuando desechas parte de tu API público, deberías hacer dos cosas: (1) actualizar tu documentación para avisar a tus usuarios sobre el cambio, (2) lanzar una nueva versión menor manteniendo la obsolescencia en su lugar. Antes que remuevas completamente la funcionalidad en una nueva versión mayor debería haber al menos una versión menor anterior que contenga la obsolescencia para que todos los usuarios puedan planear una transición sin sobresaltos al nuevo API.\n¿Tiene SemVer una longitud límite en el texto de la versión?\nNo, pero usa tu juicio. Por ejemplo, una versión de 255 caracteres probablemente sea exagerada. También, algunos sistemas en específico pueden imponer sus propios límites en la longitud del texto.\n¿Es “v1.2.3” una versión semántica?\nNo, “v1.2.3” no es una versión semántica. Sin embargo, anteponer una versión semántica con un “v” es una forma muy generalizada (en inglés) de indicar que es un número de versión. Abreviar “version” como “v” es visto muy a menudo en programas de control de versiones. Por ejemplo: git tag v1.2.3 -m "Release version 1.2.3", en donde “v1.2.3” es el nombre de la etiqueta y la versión semántica es “1.2.3”.\n¿Hay alguna expresión regular (RegEx) sugerida para verificar un texto SemVer?\nHay dos. Uno incluye grupos con nombre para sistemas que los soportan (PCRE [Perl Compatible Regular Expressions, i.e. Perl, PHP and R], Python y Go)\nMira: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nY el otro, en cambio, incluye grupos capturados numéricamente (así que cg1 = mayor, cg2 = menor, cg3 = parche, cg4 = prelanzamiento y cg5 = metadatos de compilación) que es compatible con ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions, i.e. Perl, PHP and R), Python y Go.\nMira: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nLa especificación de Versionado Semántico ha sido escrita por Tom Preston-Werner, inventor de Gravatar y co-fundador de GitHub.\nSi quieres dejar comentarios, porfavor abre un problema (issue) en Github.\nabre un problema (issue) en Github\nEsta traducción ha sido realizada por Italo Baeza Cabrera. Si deseas editar esta traducción, puedes dirigirte al respectivo repositorio en Github\ndirigirte al respectivo repositorio en Github\nCreative Commons ― CC BY 3.0 (en español)\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nنسخه‌بندی معنایی 2.0.0

خلاصه

به فرض اینکه نسخهٔ MAJOR.MINOR.PATCH یا اصلی.جزیی.وصله داده شده است:


  شمارهٔ نسخهٔ اصلی (MAJOR) را زمانی افزایش دهید که تغییرات API ناسازگار اعمال کرده‌اید،
  شمارهٔ نسخهٔ جزیی (MINOR) را زمانی افزایش دهید که قابلیت‌هایی اضافه کرده‌اید که با نسخه‌های قبل سازگار هستند،
  شمارهٔ نسخهٔ وصله (PATCH) را زمانی افزایش دهید که تصحیح خطاهایی (bug) اعمال کرده‌اید که با نسخه‌های قبل سازگار هستند.


برچسب‌های اضافی برای پیش‌نشر و ساختن فراداده به صورت پسوندهایی برای قالب MAJOR.MINOR.PATCH فراهم است.

مقدمه

در دنیای مدیریت نرم‌افزار مکان مخوفی به نام «جهنم وابستگی» (dependency hell) وجود دارد. هر چه سیستم شما بزرگتر باشد و بسته‌های (package) بیشتری با نرم‌افزار شما یکپارچه شده باشند، احتمال بیشتری وجود دارد که روزی خود را دراین گودال ناامیدی بیابید.

در سیستم‌هایی با وابستگی‌های زیاد، انتشار بستهٔ جدید به زودی می‌تواند تبدیل به یک کابوس شود. اگر ویژگی‌های وابستگی‌ها بسیار جزئی‌نگرانه باشد، در خطر قفل نسخه (version lock) خواهید بود (ناتوانی برای بروزرسانی یک بسته، بدون اجبار جهت انتشار نسخه‌های جدید همهٔ بسته‌های وابسته). اگر وابستگی‌ها بسیار ضعیف مشخص شده باشند، به ناچار زخم بی‌قاعدگی نسخه را خواهید خورد (به فرض سازگاری بیش از حد معقول با نسخه‌های آتی‌تر). جهنم وابستگی آنجایی است که قفل نسخه و یا بی‌قاعدگی نسخه از پیشرفت رو به جلوی آسان و امن پروژهٔ شما جلوگیری می‌کند.

برای پاسخگویی به این مشکل، من یکسری قوانین و پیش‌نیازهای ساده را پیشنهاد میدهم که نحوهٔ تخصیص و افزایش شماره‌های نسخه را دیکته میکند. این قوانین برپایهٔ شیوه‌های موجود رایج و گستردهٔ در حال استفاده، هم در نرم‌افزارهای متن‌باز و غیر متن‌باز است، اگرچه لزوماً محدود به آن نیست. برای آنکه این سیستم کار کند نخست لازم است یک API عمومی (public) تعریف کنید. این امر ممکن است شامل مستندسازی، یا بوسیلهٔ خود کد مقید شده باشد. صرف نظر از این موضوع، مهم است که این API دقیق و واضح باشد. زمانیکه  API عمومی خود را مشخص کردید، تغییرات آن را با افزایش معین شمارهٔ نسخهٔ خود مرتبط می‌سازید. قالب نسخهای به صورت X.Y.Z را در نظر بگیرید. خطاهایی که تاثیری بر API ندارند، نسخهٔ وصله (Patch) را افزایش می‌دهند، افزایش یا تغییر API که با نسخه‌های قبلی سازگار است، نسخهٔ جزیی (Minor) را افزایش میدهند، و تغییرات API که با نسخه‌های قبل ناسازگار هستند، نسخهٔ اصلی (Major) را افزایش می‌دهند.

من این سیستم را «نسخه‌بندی معنایی» می‌نامم. بر اساس این طرح، شماره‌های نسخه و روشی که تغییر می‌کنند، معنی و مفهومی را دربارهٔ کد تحت آن نسخه، و آنچه که از یک نسخه تا نسخه‌ای دیگر ویرایش شده است، انتقال می‌دهد.

ویژگی‌های نسخه‌بندی معنایی (SemVer)

کلمات کلیدی «باید»، «نباید»، «نیاز است»، «می‌بایست»، «نمی‌بایست»، «توصیه شده است»، «ممکن است» و «اختیاری» در این مستند می‌بایست بر مبنای آنچه در  RFC 2119  تعریف شده است، معنا شوند.


  
    نرم‌افزارهایی که از نسخه‌بندی معنایی استفاده می‌کنند باید یک API عمومی اعلام کنند. این API می‌تواند در خود کد اعلام شود، یا به طور واضح در مستندسازی وجود داشته باشد. هر طور که انجام شود، می‌بایست دقیق و جامع باشد.
  
  
    یک شمارهٔ نسخهٔ عادی باید قالب X.Y.Z را داشته باشه طوری که در آن X ،Y و Z اعداد صحیح غیرمنفی هستند و نباید صفر اضافه (leading zero) داشته باشند.  X نسخهٔ اصلی، Y  نسخه جزیی، و Z نسخهٔ وصله است. هر عنصر باید به صورت شمارشی افزایش یابد. به عنوان مثال  1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    زمانی‌که یک بستهٔ نسخه‌بندی شده منتشر شد، محتوای آن نسخه نباید دستکاری شود. هرگونه تغییری باید به عنوان نسخهٔ جدید منتشر شود.
  
  
    نسخهٔ اصلی شمارهٔ صفر (0.y.z) برای توسعه‌های ابتدایی است. هرچیزی در هر زمانی ممکن است تغییر کند. API  عمومی نمی‌بایست ماندگار در نظر گرفته شود.
  
  
    نسخهٔ 1.0.0 API عمومی را تعریف می‌کند. روشی که شمارهٔ نسخهٔ بعد از این انتشار افزوده می‌شود، به این API عمومی و نحوهٔ تغییر آن وابسته است.
  
  
    نسخهٔ وصله Z  (x.y.Z | x > 0)  باید در صورتی افزوده شود که تصحیح‌های خطای سازگار با نسخهٔ قبلی معرفی شده باشند. یک تصحیح خطا به عنوان یک تغییر داخلی تعریف می‌شود که رفتارهای نادرست را اصلاح می‌کند.
  
  
    نسخهٔ جزیی Y (x.Y.z | x > 0) باید در صورتی افزوده شود که عملکرد سازگار با نسخه‌های قبل جدیدی به API عمومی معرفی شده باشد. همچنین اگر هرگونه عملکرد API عمومی به عنوان منسوخ‌شده برچسب خورده باشد، این شماره باید افزوده شود. اگر عملکرد جدید یا بهبود قابل توجهی در کدهای داخلی معرفی شده باشد، ممکن است نسخهٔ جزیی افزوده شود. ممکن است که شامل تغییرات سطح وصله هم باشد. زمانیکه نسخه جزیی افزوده شود، نسخهٔ وصله باید به 0 بازنشانده شود.
  
  
    نسخهٔ اصلی X (X.y.z | X > 0) باید در صورتی افزوده شود که هرگونه تغییرات ناسازگار با نسخه‌های قبل به API عمومی معرفی شده باشد. ممکن است این تغییرات شامل سطوح جزیی و وصله نیز باشد. نسخهٔ جزیی و وصله زمانیکه نسخهٔ اصلی افزوده می‌شود باید به 0 بازنشانی شوند.
  
  
    یک نسخهٔ پیش‌انتشار ممکن است با اضافه کردن یک خط تیره و یک سری شناسه‌هایی که به وسیلهٔ نقطه از هم جدا ‌شده‌اند و بلافاصله به دنبال نسخهٔ وصله می‌آیند، نشانه‌گذاری شود. شناسه‌ها باید تنها شامل اعداد و حروف الفبای اَسکی (ASCII)  و خط تیره [A-Za-z0-9] باشند. شناسه‌ها نباید تهی باشند. شناسه‌های عددی نباید با صفر اضافه آغاز شوند. نسخهٔ پیش‌انتشار از اولویت پایین‌تری نسبت به نسخهٔ عادی مرتبط برخوردار است. یک نسخهٔ پیش‌انتشار حاکی از آن است که نسخهٔ ناپایدار است و ممکن است نیازمندی‌های سازگاری مورد نظر را آنگونه که در نسخهٔ عادی مرتبط نشان داده شده است، برآورده نکند. مثال: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    متادیتای ساخت (build metadata) ممکن است با افزودن یک علامت جمع (+) و یک سری شناسه‌هایی که به وسیلهٔ نقطه ازهم جدا شده‌اند، و بلافاصله به دنبال نسخهٔ وصله یا پیش‌انتشار می‌آیند، نشانه‌گذاری شود. شناسه‌ها باید تنها شامل اعداد و حروف الفبای اَسکی (ASCII)  و خط تیره [A-Za-z0-9] باشند. شناسه‌ها نباید تهی باشند. متادیتای ساخت می‌بایست در زمان تعیین اولویت نسخه درنظر گرفته نشود. بنابراین دو نسخه که تنها در متادیتای ساخت با یکدیگر متفاوت هستند، اولویت یکسان دارند. مثال: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f8
  
  
    اولویت اشاره دارد به اینکه چگونه نسخه‌ها زمانی‌که مرتب شده‌اند با یکدیگر مقایسه می‌شوند. اولویت باید به وسیلهٔ جداسازی نسخه به اصلی، جزیی، وصله و شناسه‌های پیش‌انتشار به همین ترتیب، محاسبه شود (متادیتای ساخت در اولویت نمایان نمی‌شود). اولویت، به وسیلهٔ اولین تفاوت تعیین می‌شود هنگامی که این مشخصه‌ها از چپ به راست مقایسه شوند، بدین صورت: نسخه‌های اصلی، جزیی و وصله همیشه به صورت عددی مقایسه می‌شوند. مثال: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. زمانی که اصلی و جزیی و وصله برابر هستند، یک نسخهٔ پیش‌انتشار از اولویت کمتری نسبت به نسخهٔ عادی برخوردار است. مثال: 1.0.0-   alpha < 1.0.0  اولویت برای دو نسخهٔ پیش‌انتشار با نسخهٔ اصلی، جزیی و وصلهٔ مشابه باید به وسیلهٔ مقایسهٔ هر مشخصه‌ای که با نقطه جدا شده، از چپ به راست مشخص شود تا زمانی که یک تفاوت به شرح زیر یافت شود: شناسه‌هایی که تنها شامل اعداد صحیح هستند به صورت عددی و شناسه‌هایی که با حروف یا خط‌های تیره به صورت الفبایی به ترتیب ASCII مقایسه می شوند. مشخصه‌های عددی همیشه از اولویت کمتری نسبت به مشخصه‌های غیرعددی برخوردار هستند. مجموعه‌های بزرگتری از بخشهای پیش‌انتشار اولویت بیشتری نسبت به مجموعه‌های کوچکتر دارند، اگر همه مشخصه‌های اولویت برابر باشند. مثال: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


چرا از نسخه‌بندی معنایی استفاده شود؟

این ایده‌ای جدید یا انقلابی نیست. در واقع، احتمالاً شما چیزی مشابه به این را پیش از این انجام داده‌اید. مشکل اینجاست که «مشابه» به اندازهٔ کافی خوب نیست. بدون انطباق با نوعی تعریف رسمی، شماره‌های نسخه ضرورتاً برای مدیریت وابستگی (dependency) بلااستفاده هستند. بوسیلهٔ اختصاص اعداد و تعاریف واضح به ایده‌های بالا، برقراری ارتباط میان کاربران نرم‌افزار شما و اهدافتان آسان‌تر می‌شود. به‌مجرد اینکه این اهداف واضح شود، مشخصات وابستگی انعطاف‌پذیر (نه آن‌چنان انعطاف‌پذیر) می‌تواند نهایتاً ایجاد شود.

یک مثال ساده می‌تواند نشان دهد که چگونه نسخه‌بندی معنایی می‌تواند جهنم وابستگی را به خاطره‌ای از گذشته تبدیل کند. کتابخانه‌ای به نام «Firetruck» را در نظر بگیرید. این کتابخانه به یک بسته به نام «Ladder» که به صورت معنایی نسخه‌بندی شده، احتیاج دارد. در زمانی که firetruck ساخته شده، Ladder در نسخهٔ 3.1.0 است، شما می‌توانید وابستگی Ladder را با آسودگی به عنوان بزرگتر یا برابر با 3.1.0 و نه کمتر از 4.0.0 تعیین کنید. شما می‌توانید آن‌ها را در سیستم مدیریت بستهٔ خود منتشر کنید و بدانید که آن‌ها با نرم‌افزار وابسته موجود سازگار هستند.

بدون شک به عنوان یک توسعه‌دهندهٔ مسئولیت‌پذیر شما خواهید خواست که هر بسته همان‌طورکه اعلان شده ارتقاء یابد. دنیای واقعی مکان به هم ریخته ایست، ما جز اینکه هشیار باشیم نمی‌توانیم کاری دربارهٔ آن انجام دهیم. آنچه شما می‌توانید انجام دهید این است که بگذارید نسخه‌بندی معنایی به شما یک راه عاقلانه ارائه دهد، تا بسته‌ها را منتشر کرده و ارتقاء دهد بدون آنکه نسخه‌های جدیدی از بسته‌های مستقل را راه اندازی کند و شما را عذاب نداده، در وقت شما صرفه‌جویی کند..

اگر همهٔ این‌ها مطلوب به نظر می‌رسد، همهٔ آنچه شما برای شروع استفاده از نسخه‌بندی معنایی احتیاج دارید این است که اعلام کنید که در حال انجام این کار هستید و از قوانین پیروی کنید. به این وب‌سایت از طریق صفحه README خود لینک بزنید، در نتیجه دیگران دربارهٔ قوانین خواهند دانست و از آن نفع خواهند برد.

سوالات متداول

چگونه باید با نسخه‌ها در فاز توسعهٔ ابتدایی 0.y.z  کنار بیایم؟

ساده‌ترین کار برای انجام دادن این است که توسعهٔ ابتدایی خود را از انتشار 0.1.0  آغاز کنید و سپس نسخهٔ جزیی را برای هر انتشار آتی افزایش دهید.

چگونه بدانم چه زمانی باید 1.0.0 را منتشر کنم؟

اگر نرم‌افزار شما در طول تولید مورد استفاده قرار گرفته است، احتمالاً می‌بایست هم‌اکنون 1.0.0 باشد. اگر یک API ماندگار دارید که کاربران روی آن حساب می‌کنند، شما باید 1.0.0 باشید. اگر در مورد سازگاری با نسخه‌های قبل خیلی نگران هستید، احتمالاً می‌بایست هم‌اکنون 1.0.0 باشید.

آیا این روش، توسعه و تکرار سریع را کند نمی کند؟

نسخهٔ اصلی صفر تماماً در مورد توسعهٔ سریع است. اگر شما API را هر روز تغییر می‌دهید، یا باید هنوز در نسخهٔ 0.y.z  باشید یا در یک شاخهٔ توسعهٔ جداگانه که بر نسخهٔ اصلی بعدی کار می‌کند هستید.

اگر حتی کوچکترین تغییرات ناسازگار با نسخه‌های قبل در API عمومی نیازمند یک نسخهٔ اصلی باشد، آیا من خیلی سریع به نسخه 42.0.0 نخواهم رسید؟

این سوال یک توسعه‌دهندهٔ مسئولیت‌پذیر و آینده‌نگر است. تغییرات ناسازگار نمی‌بایست به راحتی در نرم‌افزاری که کدهای وابستهٔ زیادی دارد معرفی شود. هزینه‌ای که برای ارتقاء باید متحمل شد می‌تواند قابل توجه باشد. اجبار برای ایجاد نسخه‌های اصلی برای انتشار تغییرات ناسازگار، یعنی شما به تأثیر تغییراتتان فکر خواهید کرد و نرخ هزینه/سود مورد نظر را خواهید سنجید.

مستندسازی تمامی  API عمومی کار بسیار زیاد می‌برد!

این مسئولیت شما به عنوان یک توسعه‌دهندهٔ حرفه‌ای است تا به طور مناسب نرم‌افزار که می‌بایست توسط دیگران مورد استفاده قرار گیرد را مستندسازی کنید. مدیریت پیچیدگی نرم‌افزار یک بخش فوق‌العاده مهم ازکارآمد نگه‌داشتن پروژه است، و انجام آن سخت است اگر کسی نداند که چگونه نرم‌افزار شما را استفاده کند یا چه متدهایی برای صدا زدن امن است. در دراز مدت، نسخه‌بندی معنایی و پافشاری بر یک API عمومی خوش‌تعریف می‌تواند همه چیز و همه کس را در اجرا کردن راحت در موقعیت مناسبی نگه دارد.

چه کار می‌توانم بکنم اگر تصادفاً یک تغییر ناسازگار با نسخه‌های قبل را به عنوان نسخهٔ جزیی منتشر کردم؟

به مجرد اینکه متوجه این مورد بشوید، تنظیمات نسخه‌بندی معنایی را به هم زده‌اید، مشکل را حل کنید و یک نسخهٔ جزیی جدید که مشکل را تصحیح کند و سازگاری با نسخه‌های قبل را بازگرداند، منتشر سازید. حتی تحت این شرایط، این پذیرفته شده نیست که انتشارهای نسخه‌بندی شده را دستکاری کنید. اگر مناسب است نسخهٔ متخلف را مستند‌سازی کنید و کاربران خود را از مشکل مطلع سازید تا آن ها نیز از نسخهٔ متخلف آگاه باشند.

چه کار باید بکنم اگر وابستگی‌های خودم را بدون تغییر دادن API عمومی به‌روزرسانی کردم؟

این مورد تا زمانی که API عمومی را متأثر نسازد سازگار تلقی خواهد شد. نرم‌افزاری که صریحاً به همان وابستگی‌هایی که بستهٔ شما وابسته است، وابسته باشد، باید مشخصات وابستگی خود را داشته باشد و نویسنده باید هرگونه مغایرت را ذکر کند. تشخیص اینکه آیا تغییر ازنوع دستکاری در سطح جزیی است یا سطح وصله، به این بستگی دارد که آیا شما وابستگی‌های خود را جهت تصحیح یک خطا یا برای یک کاربرد جدید به‌روزرسانی کرده‌اید. من معمولاً کد اضافی برای موارد آتی در نظر می‌گیرم، که بدون شک این موارد افزایش سطح جزیی می‌باشد.

چه می شود اگر من بدون اعلام قبلی API عمومی را به صورتی تغییر دهم که با تغییر عدد نسخه سازگار نباشد؟ (یعنی کد به نادرست تغییر اصلی‌ای را در انتشار وصله معرفی می‌کند)

از بهترین قضاوت خود استفاده کنید. اگر شما مخاطبان زیادی دارید که به شدت به وسیلهٔ تغییر رفتار به آنچه قبلاً برای API  عمومی در نظر گرفته شده، متأثر خواهند شد، پس بهترین کار انجام یک انتشار نسخهٔ اصلی است، حتی اگر اصلاح اعمال شده مؤکداً یک انتشار وصله محسوب شود. به یاد داشته باشید، نسخه‌بندی معنایی تماماً دربارهٔ انتقال معنا بوسیله چگونگی تغییر عدد نسخه می‌باشد. اگر این تغییرات برای کاربران شما مهم است، از عدد نسخه برای آگاه‌سازی آن‌ها استفاده کنید.

چگونه باید با منسوخ کردن عملکرد (deprecating functionality) کنار بیایم؟

منسوخ کردن عملکرد موجود بخشی عادی از توسعهٔ نرم‌افزار است و معمولاً برای این‌که پیشرفت رو به جلو حاصل شود مورد نیاز است. زمانی‌که بخشی از API عمومی خود را منسوخ می‌کنید، باید دو کار انجام دهید: ۱) مستندسازی خود را به‌روزرسانی کنید تا به کاربر اجازه دهید از تغییرات باخبر شود. ۲) یک انتشار جزیی که در آن قسمت منسوخ شده در جایگاه خود باشد منتشر کنید. قبل از آنکه عملکرد را به طورکامل در یک انتشار اصلی حذف کنید حتماً باید حداقل یک انتشار جزیی که شامل قسمت منسوخ شده است وجود داشته باشد تا کاربران به راحتی بتوانند به API جدید منتقل شوند.

آیا SemVer محدودیت اندازه بر روی رشتهٔ نسخه دارد؟

خیر، اما از قضاوت مناسبی استفاده کنید. به عنوان مثال یک نسخهٔ ۲۵۵ نویسه‌ای احتمالاً مفید نخواهد بود! همچنین، سیستم‌های خاص ممکن است محدودیت‌های خود برای اندازهٔ رشته اعمال کنند.

در مورد من

نویسنده : Tom Preston-Werner, سازنده Gravatars و
 بنیان‌گذار GitHub.

اگر مایل به ارائهٔ بازخورد خود هستید، لطفاً یک مورد در بخش issue سایت GitHub باز کنید.
 open an issue on GitHub.

مترجم بخش فارسی : مجید حاجیان Majid Hajian 
ویراستار: فرزاد قانعی Farzad Ghanei

مجوز
Creative Commons ― CC BY 3.0\nنسخه‌بندی معنایی 2.0.0\nبه فرض اینکه نسخهٔ MAJOR.MINOR.PATCH یا اصلی.جزیی.وصله داده شده است:\nشمارهٔ نسخهٔ اصلی (MAJOR) را زمانی افزایش دهید که تغییرات API ناسازگار اعمال کرده‌اید،\nشمارهٔ نسخهٔ جزیی (MINOR) را زمانی افزایش دهید که قابلیت‌هایی اضافه کرده‌اید که با نسخه‌های قبل سازگار هستند،\nشمارهٔ نسخهٔ وصله (PATCH) را زمانی افزایش دهید که تصحیح خطاهایی (bug) اعمال کرده‌اید که با نسخه‌های قبل سازگار هستند.\nبرچسب‌های اضافی برای پیش‌نشر و ساختن فراداده به صورت پسوندهایی برای قالب MAJOR.MINOR.PATCH فراهم است.\nدر دنیای مدیریت نرم‌افزار مکان مخوفی به نام «جهنم وابستگی» (dependency hell) وجود دارد. هر چه سیستم شما بزرگتر باشد و بسته‌های (package) بیشتری با نرم‌افزار شما یکپارچه شده باشند، احتمال بیشتری وجود دارد که روزی خود را دراین گودال ناامیدی بیابید.\nدر سیستم‌هایی با وابستگی‌های زیاد، انتشار بستهٔ جدید به زودی می‌تواند تبدیل به یک کابوس شود. اگر ویژگی‌های وابستگی‌ها بسیار جزئی‌نگرانه باشد، در خطر قفل نسخه (version lock) خواهید بود (ناتوانی برای بروزرسانی یک بسته، بدون اجبار جهت انتشار نسخه‌های جدید همهٔ بسته‌های وابسته). اگر وابستگی‌ها بسیار ضعیف مشخص شده باشند، به ناچار زخم بی‌قاعدگی نسخه را خواهید خورد (به فرض سازگاری بیش از حد معقول با نسخه‌های آتی‌تر). جهنم وابستگی آنجایی است که قفل نسخه و یا بی‌قاعدگی نسخه از پیشرفت رو به جلوی آسان و امن پروژهٔ شما جلوگیری می‌کند.\nبرای پاسخگویی به این مشکل، من یکسری قوانین و پیش‌نیازهای ساده را پیشنهاد میدهم که نحوهٔ تخصیص و افزایش شماره‌های نسخه را دیکته میکند. این قوانین برپایهٔ شیوه‌های موجود رایج و گستردهٔ در حال استفاده، هم در نرم‌افزارهای متن‌باز و غیر متن‌باز است، اگرچه لزوماً محدود به آن نیست. برای آنکه این سیستم کار کند نخست لازم است یک API عمومی (public) تعریف کنید. این امر ممکن است شامل مستندسازی، یا بوسیلهٔ خود کد مقید شده باشد. صرف نظر از این موضوع، مهم است که این API دقیق و واضح باشد. زمانیکه  API عمومی خود را مشخص کردید، تغییرات آن را با افزایش معین شمارهٔ نسخهٔ خود مرتبط می‌سازید. قالب نسخهای به صورت X.Y.Z را در نظر بگیرید. خطاهایی که تاثیری بر API ندارند، نسخهٔ وصله (Patch) را افزایش می‌دهند، افزایش یا تغییر API که با نسخه‌های قبلی سازگار است، نسخهٔ جزیی (Minor) را افزایش میدهند، و تغییرات API که با نسخه‌های قبل ناسازگار هستند، نسخهٔ اصلی (Major) را افزایش می‌دهند.\nمن این سیستم را «نسخه‌بندی معنایی» می‌نامم. بر اساس این طرح، شماره‌های نسخه و روشی که تغییر می‌کنند، معنی و مفهومی را دربارهٔ کد تحت آن نسخه، و آنچه که از یک نسخه تا نسخه‌ای دیگر ویرایش شده است، انتقال می‌دهد.\nویژگی‌های نسخه‌بندی معنایی (SemVer)\nکلمات کلیدی «باید»، «نباید»، «نیاز است»، «می‌بایست»، «نمی‌بایست»، «توصیه شده است»، «ممکن است» و «اختیاری» در این مستند می‌بایست بر مبنای آنچه در  RFC 2119  تعریف شده است، معنا شوند.\nنرم‌افزارهایی که از نسخه‌بندی معنایی استفاده می‌کنند باید یک API عمومی اعلام کنند. این API می‌تواند در خود کد اعلام شود، یا به طور واضح در مستندسازی وجود داشته باشد. هر طور که انجام شود، می‌بایست دقیق و جامع باشد.\nنرم‌افزارهایی که از نسخه‌بندی معنایی استفاده می‌کنند باید یک API عمومی اعلام کنند. این API می‌تواند در خود کد اعلام شود، یا به طور واضح در مستندسازی وجود داشته باشد. هر طور که انجام شود، می‌بایست دقیق و جامع باشد.\nیک شمارهٔ نسخهٔ عادی باید قالب X.Y.Z را داشته باشه طوری که در آن X ،Y و Z اعداد صحیح غیرمنفی هستند و نباید صفر اضافه (leading zero) داشته باشند.  X نسخهٔ اصلی، Y  نسخه جزیی، و Z نسخهٔ وصله است. هر عنصر باید به صورت شمارشی افزایش یابد. به عنوان مثال  1.9.0 -> 1.10.0 -> 1.11.0.\nیک شمارهٔ نسخهٔ عادی باید قالب X.Y.Z را داشته باشه طوری که در آن X ،Y و Z اعداد صحیح غیرمنفی هستند و نباید صفر اضافه (leading zero) داشته باشند.  X نسخهٔ اصلی، Y  نسخه جزیی، و Z نسخهٔ وصله است. هر عنصر باید به صورت شمارشی افزایش یابد. به عنوان مثال  1.9.0 -> 1.10.0 -> 1.11.0.\n1.9.0 -> 1.10.0 -> 1.11.0\nزمانی‌که یک بستهٔ نسخه‌بندی شده منتشر شد، محتوای آن نسخه نباید دستکاری شود. هرگونه تغییری باید به عنوان نسخهٔ جدید منتشر شود.\nزمانی‌که یک بستهٔ نسخه‌بندی شده منتشر شد، محتوای آن نسخه نباید دستکاری شود. هرگونه تغییری باید به عنوان نسخهٔ جدید منتشر شود.\nنسخهٔ اصلی شمارهٔ صفر (0.y.z) برای توسعه‌های ابتدایی است. هرچیزی در هر زمانی ممکن است تغییر کند. API  عمومی نمی‌بایست ماندگار در نظر گرفته شود.\nنسخهٔ اصلی شمارهٔ صفر (0.y.z) برای توسعه‌های ابتدایی است. هرچیزی در هر زمانی ممکن است تغییر کند. API  عمومی نمی‌بایست ماندگار در نظر گرفته شود.\nنسخهٔ 1.0.0 API عمومی را تعریف می‌کند. روشی که شمارهٔ نسخهٔ بعد از این انتشار افزوده می‌شود، به این API عمومی و نحوهٔ تغییر آن وابسته است.\nنسخهٔ 1.0.0 API عمومی را تعریف می‌کند. روشی که شمارهٔ نسخهٔ بعد از این انتشار افزوده می‌شود، به این API عمومی و نحوهٔ تغییر آن وابسته است.\nنسخهٔ وصله Z  (x.y.Z | x > 0)  باید در صورتی افزوده شود که تصحیح‌های خطای سازگار با نسخهٔ قبلی معرفی شده باشند. یک تصحیح خطا به عنوان یک تغییر داخلی تعریف می‌شود که رفتارهای نادرست را اصلاح می‌کند.\nنسخهٔ وصله Z  (x.y.Z | x > 0)  باید در صورتی افزوده شود که تصحیح‌های خطای سازگار با نسخهٔ قبلی معرفی شده باشند. یک تصحیح خطا به عنوان یک تغییر داخلی تعریف می‌شود که رفتارهای نادرست را اصلاح می‌کند.\nنسخهٔ جزیی Y (x.Y.z | x > 0) باید در صورتی افزوده شود که عملکرد سازگار با نسخه‌های قبل جدیدی به API عمومی معرفی شده باشد. همچنین اگر هرگونه عملکرد API عمومی به عنوان منسوخ‌شده برچسب خورده باشد، این شماره باید افزوده شود. اگر عملکرد جدید یا بهبود قابل توجهی در کدهای داخلی معرفی شده باشد، ممکن است نسخهٔ جزیی افزوده شود. ممکن است که شامل تغییرات سطح وصله هم باشد. زمانیکه نسخه جزیی افزوده شود، نسخهٔ وصله باید به 0 بازنشانده شود.\nنسخهٔ جزیی Y (x.Y.z | x > 0) باید در صورتی افزوده شود که عملکرد سازگار با نسخه‌های قبل جدیدی به API عمومی معرفی شده باشد. همچنین اگر هرگونه عملکرد API عمومی به عنوان منسوخ‌شده برچسب خورده باشد، این شماره باید افزوده شود. اگر عملکرد جدید یا بهبود قابل توجهی در کدهای داخلی معرفی شده باشد، ممکن است نسخهٔ جزیی افزوده شود. ممکن است که شامل تغییرات سطح وصله هم باشد. زمانیکه نسخه جزیی افزوده شود، نسخهٔ وصله باید به 0 بازنشانده شود.\n(x.Y.z | x > 0) باید در صورتی افزوده شود که عملکرد سازگار با نسخه‌های قبل جدیدی به API عمومی معرفی شده باشد. همچنین اگر هرگونه عملکرد API عمومی به عنوان منسوخ‌شده برچسب خورده باشد، این شماره باید افزوده شود. اگر عملکرد جدید یا بهبود قابل توجهی در کدهای داخلی معرفی شده باشد، ممکن است نسخهٔ جزیی افزوده شود. ممکن است که شامل تغییرات سطح وصله هم باشد. زمانیکه نسخه جزیی افزوده شود، نسخهٔ وصله باید به 0 بازنشانده شود.\nنسخهٔ اصلی X (X.y.z | X > 0) باید در صورتی افزوده شود که هرگونه تغییرات ناسازگار با نسخه‌های قبل به API عمومی معرفی شده باشد. ممکن است این تغییرات شامل سطوح جزیی و وصله نیز باشد. نسخهٔ جزیی و وصله زمانیکه نسخهٔ اصلی افزوده می‌شود باید به 0 بازنشانی شوند.\nنسخهٔ اصلی X (X.y.z | X > 0) باید در صورتی افزوده شود که هرگونه تغییرات ناسازگار با نسخه‌های قبل به API عمومی معرفی شده باشد. ممکن است این تغییرات شامل سطوح جزیی و وصله نیز باشد. نسخهٔ جزیی و وصله زمانیکه نسخهٔ اصلی افزوده می‌شود باید به 0 بازنشانی شوند.\nیک نسخهٔ پیش‌انتشار ممکن است با اضافه کردن یک خط تیره و یک سری شناسه‌هایی که به وسیلهٔ نقطه از هم جدا ‌شده‌اند و بلافاصله به دنبال نسخهٔ وصله می‌آیند، نشانه‌گذاری شود. شناسه‌ها باید تنها شامل اعداد و حروف الفبای اَسکی (ASCII)  و خط تیره [A-Za-z0-9] باشند. شناسه‌ها نباید تهی باشند. شناسه‌های عددی نباید با صفر اضافه آغاز شوند. نسخهٔ پیش‌انتشار از اولویت پایین‌تری نسبت به نسخهٔ عادی مرتبط برخوردار است. یک نسخهٔ پیش‌انتشار حاکی از آن است که نسخهٔ ناپایدار است و ممکن است نیازمندی‌های سازگاری مورد نظر را آنگونه که در نسخهٔ عادی مرتبط نشان داده شده است، برآورده نکند. مثال: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nیک نسخهٔ پیش‌انتشار ممکن است با اضافه کردن یک خط تیره و یک سری شناسه‌هایی که به وسیلهٔ نقطه از هم جدا ‌شده‌اند و بلافاصله به دنبال نسخهٔ وصله می‌آیند، نشانه‌گذاری شود. شناسه‌ها باید تنها شامل اعداد و حروف الفبای اَسکی (ASCII)  و خط تیره [A-Za-z0-9] باشند. شناسه‌ها نباید تهی باشند. شناسه‌های عددی نباید با صفر اضافه آغاز شوند. نسخهٔ پیش‌انتشار از اولویت پایین‌تری نسبت به نسخهٔ عادی مرتبط برخوردار است. یک نسخهٔ پیش‌انتشار حاکی از آن است که نسخهٔ ناپایدار است و ممکن است نیازمندی‌های سازگاری مورد نظر را آنگونه که در نسخهٔ عادی مرتبط نشان داده شده است، برآورده نکند. مثال: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\n1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92\nمتادیتای ساخت (build metadata) ممکن است با افزودن یک علامت جمع (+) و یک سری شناسه‌هایی که به وسیلهٔ نقطه ازهم جدا شده‌اند، و بلافاصله به دنبال نسخهٔ وصله یا پیش‌انتشار می‌آیند، نشانه‌گذاری شود. شناسه‌ها باید تنها شامل اعداد و حروف الفبای اَسکی (ASCII)  و خط تیره [A-Za-z0-9] باشند. شناسه‌ها نباید تهی باشند. متادیتای ساخت می‌بایست در زمان تعیین اولویت نسخه درنظر گرفته نشود. بنابراین دو نسخه که تنها در متادیتای ساخت با یکدیگر متفاوت هستند، اولویت یکسان دارند. مثال: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f8\nمتادیتای ساخت (build metadata) ممکن است با افزودن یک علامت جمع (+) و یک سری شناسه‌هایی که به وسیلهٔ نقطه ازهم جدا شده‌اند، و بلافاصله به دنبال نسخهٔ وصله یا پیش‌انتشار می‌آیند، نشانه‌گذاری شود. شناسه‌ها باید تنها شامل اعداد و حروف الفبای اَسکی (ASCII)  و خط تیره [A-Za-z0-9] باشند. شناسه‌ها نباید تهی باشند. متادیتای ساخت می‌بایست در زمان تعیین اولویت نسخه درنظر گرفته نشود. بنابراین دو نسخه که تنها در متادیتای ساخت با یکدیگر متفاوت هستند، اولویت یکسان دارند. مثال: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f8\n1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f8\nاولویت اشاره دارد به اینکه چگونه نسخه‌ها زمانی‌که مرتب شده‌اند با یکدیگر مقایسه می‌شوند. اولویت باید به وسیلهٔ جداسازی نسخه به اصلی، جزیی، وصله و شناسه‌های پیش‌انتشار به همین ترتیب، محاسبه شود (متادیتای ساخت در اولویت نمایان نمی‌شود). اولویت، به وسیلهٔ اولین تفاوت تعیین می‌شود هنگامی که این مشخصه‌ها از چپ به راست مقایسه شوند، بدین صورت: نسخه‌های اصلی، جزیی و وصله همیشه به صورت عددی مقایسه می‌شوند. مثال: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. زمانی که اصلی و جزیی و وصله برابر هستند، یک نسخهٔ پیش‌انتشار از اولویت کمتری نسبت به نسخهٔ عادی برخوردار است. مثال: 1.0.0-   alpha < 1.0.0  اولویت برای دو نسخهٔ پیش‌انتشار با نسخهٔ اصلی، جزیی و وصلهٔ مشابه باید به وسیلهٔ مقایسهٔ هر مشخصه‌ای که با نقطه جدا شده، از چپ به راست مشخص شود تا زمانی که یک تفاوت به شرح زیر یافت شود: شناسه‌هایی که تنها شامل اعداد صحیح هستند به صورت عددی و شناسه‌هایی که با حروف یا خط‌های تیره به صورت الفبایی به ترتیب ASCII مقایسه می شوند. مشخصه‌های عددی همیشه از اولویت کمتری نسبت به مشخصه‌های غیرعددی برخوردار هستند. مجموعه‌های بزرگتری از بخشهای پیش‌انتشار اولویت بیشتری نسبت به مجموعه‌های کوچکتر دارند، اگر همه مشخصه‌های اولویت برابر باشند. مثال: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nاولویت اشاره دارد به اینکه چگونه نسخه‌ها زمانی‌که مرتب شده‌اند با یکدیگر مقایسه می‌شوند. اولویت باید به وسیلهٔ جداسازی نسخه به اصلی، جزیی، وصله و شناسه‌های پیش‌انتشار به همین ترتیب، محاسبه شود (متادیتای ساخت در اولویت نمایان نمی‌شود). اولویت، به وسیلهٔ اولین تفاوت تعیین می‌شود هنگامی که این مشخصه‌ها از چپ به راست مقایسه شوند، بدین صورت: نسخه‌های اصلی، جزیی و وصله همیشه به صورت عددی مقایسه می‌شوند. مثال: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. زمانی که اصلی و جزیی و وصله برابر هستند، یک نسخهٔ پیش‌انتشار از اولویت کمتری نسبت به نسخهٔ عادی برخوردار است. مثال: 1.0.0-   alpha < 1.0.0  اولویت برای دو نسخهٔ پیش‌انتشار با نسخهٔ اصلی، جزیی و وصلهٔ مشابه باید به وسیلهٔ مقایسهٔ هر مشخصه‌ای که با نقطه جدا شده، از چپ به راست مشخص شود تا زمانی که یک تفاوت به شرح زیر یافت شود: شناسه‌هایی که تنها شامل اعداد صحیح هستند به صورت عددی و شناسه‌هایی که با حروف یا خط‌های تیره به صورت الفبایی به ترتیب ASCII مقایسه می شوند. مشخصه‌های عددی همیشه از اولویت کمتری نسبت به مشخصه‌های غیرعددی برخوردار هستند. مجموعه‌های بزرگتری از بخشهای پیش‌انتشار اولویت بیشتری نسبت به مجموعه‌های کوچکتر دارند، اگر همه مشخصه‌های اولویت برابر باشند. مثال: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\n1.0.0 < 2.0.0 < 2.1.0 < 2.1.1\n1.0.0-   alpha < 1.0.0\n1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0\nچرا از نسخه‌بندی معنایی استفاده شود؟\nاین ایده‌ای جدید یا انقلابی نیست. در واقع، احتمالاً شما چیزی مشابه به این را پیش از این انجام داده‌اید. مشکل اینجاست که «مشابه» به اندازهٔ کافی خوب نیست. بدون انطباق با نوعی تعریف رسمی، شماره‌های نسخه ضرورتاً برای مدیریت وابستگی (dependency) بلااستفاده هستند. بوسیلهٔ اختصاص اعداد و تعاریف واضح به ایده‌های بالا، برقراری ارتباط میان کاربران نرم‌افزار شما و اهدافتان آسان‌تر می‌شود. به‌مجرد اینکه این اهداف واضح شود، مشخصات وابستگی انعطاف‌پذیر (نه آن‌چنان انعطاف‌پذیر) می‌تواند نهایتاً ایجاد شود.\nیک مثال ساده می‌تواند نشان دهد که چگونه نسخه‌بندی معنایی می‌تواند جهنم وابستگی را به خاطره‌ای از گذشته تبدیل کند. کتابخانه‌ای به نام «Firetruck» را در نظر بگیرید. این کتابخانه به یک بسته به نام «Ladder» که به صورت معنایی نسخه‌بندی شده، احتیاج دارد. در زمانی که firetruck ساخته شده، Ladder در نسخهٔ 3.1.0 است، شما می‌توانید وابستگی Ladder را با آسودگی به عنوان بزرگتر یا برابر با 3.1.0 و نه کمتر از 4.0.0 تعیین کنید. شما می‌توانید آن‌ها را در سیستم مدیریت بستهٔ خود منتشر کنید و بدانید که آن‌ها با نرم‌افزار وابسته موجود سازگار هستند.\nبدون شک به عنوان یک توسعه‌دهندهٔ مسئولیت‌پذیر شما خواهید خواست که هر بسته همان‌طورکه اعلان شده ارتقاء یابد. دنیای واقعی مکان به هم ریخته ایست، ما جز اینکه هشیار باشیم نمی‌توانیم کاری دربارهٔ آن انجام دهیم. آنچه شما می‌توانید انجام دهید این است که بگذارید نسخه‌بندی معنایی به شما یک راه عاقلانه ارائه دهد، تا بسته‌ها را منتشر کرده و ارتقاء دهد بدون آنکه نسخه‌های جدیدی از بسته‌های مستقل را راه اندازی کند و شما را عذاب نداده، در وقت شما صرفه‌جویی کند..\nاگر همهٔ این‌ها مطلوب به نظر می‌رسد، همهٔ آنچه شما برای شروع استفاده از نسخه‌بندی معنایی احتیاج دارید این است که اعلام کنید که در حال انجام این کار هستید و از قوانین پیروی کنید. به این وب‌سایت از طریق صفحه README خود لینک بزنید، در نتیجه دیگران دربارهٔ قوانین خواهند دانست و از آن نفع خواهند برد.\nچگونه باید با نسخه‌ها در فاز توسعهٔ ابتدایی 0.y.z  کنار بیایم؟\nساده‌ترین کار برای انجام دادن این است که توسعهٔ ابتدایی خود را از انتشار 0.1.0  آغاز کنید و سپس نسخهٔ جزیی را برای هر انتشار آتی افزایش دهید.\nچگونه بدانم چه زمانی باید 1.0.0 را منتشر کنم؟\nاگر نرم‌افزار شما در طول تولید مورد استفاده قرار گرفته است، احتمالاً می‌بایست هم‌اکنون 1.0.0 باشد. اگر یک API ماندگار دارید که کاربران روی آن حساب می‌کنند، شما باید 1.0.0 باشید. اگر در مورد سازگاری با نسخه‌های قبل خیلی نگران هستید، احتمالاً می‌بایست هم‌اکنون 1.0.0 باشید.\nآیا این روش، توسعه و تکرار سریع را کند نمی کند؟\nنسخهٔ اصلی صفر تماماً در مورد توسعهٔ سریع است. اگر شما API را هر روز تغییر می‌دهید، یا باید هنوز در نسخهٔ 0.y.z  باشید یا در یک شاخهٔ توسعهٔ جداگانه که بر نسخهٔ اصلی بعدی کار می‌کند هستید.\nاگر حتی کوچکترین تغییرات ناسازگار با نسخه‌های قبل در API عمومی نیازمند یک نسخهٔ اصلی باشد، آیا من خیلی سریع به نسخه 42.0.0 نخواهم رسید؟\nاین سوال یک توسعه‌دهندهٔ مسئولیت‌پذیر و آینده‌نگر است. تغییرات ناسازگار نمی‌بایست به راحتی در نرم‌افزاری که کدهای وابستهٔ زیادی دارد معرفی شود. هزینه‌ای که برای ارتقاء باید متحمل شد می‌تواند قابل توجه باشد. اجبار برای ایجاد نسخه‌های اصلی برای انتشار تغییرات ناسازگار، یعنی شما به تأثیر تغییراتتان فکر خواهید کرد و نرخ هزینه/سود مورد نظر را خواهید سنجید.\nمستندسازی تمامی  API عمومی کار بسیار زیاد می‌برد!\nاین مسئولیت شما به عنوان یک توسعه‌دهندهٔ حرفه‌ای است تا به طور مناسب نرم‌افزار که می‌بایست توسط دیگران مورد استفاده قرار گیرد را مستندسازی کنید. مدیریت پیچیدگی نرم‌افزار یک بخش فوق‌العاده مهم ازکارآمد نگه‌داشتن پروژه است، و انجام آن سخت است اگر کسی نداند که چگونه نرم‌افزار شما را استفاده کند یا چه متدهایی برای صدا زدن امن است. در دراز مدت، نسخه‌بندی معنایی و پافشاری بر یک API عمومی خوش‌تعریف می‌تواند همه چیز و همه کس را در اجرا کردن راحت در موقعیت مناسبی نگه دارد.\nچه کار می‌توانم بکنم اگر تصادفاً یک تغییر ناسازگار با نسخه‌های قبل را به عنوان نسخهٔ جزیی منتشر کردم؟\nبه مجرد اینکه متوجه این مورد بشوید، تنظیمات نسخه‌بندی معنایی را به هم زده‌اید، مشکل را حل کنید و یک نسخهٔ جزیی جدید که مشکل را تصحیح کند و سازگاری با نسخه‌های قبل را بازگرداند، منتشر سازید. حتی تحت این شرایط، این پذیرفته شده نیست که انتشارهای نسخه‌بندی شده را دستکاری کنید. اگر مناسب است نسخهٔ متخلف را مستند‌سازی کنید و کاربران خود را از مشکل مطلع سازید تا آن ها نیز از نسخهٔ متخلف آگاه باشند.\nچه کار باید بکنم اگر وابستگی‌های خودم را بدون تغییر دادن API عمومی به‌روزرسانی کردم؟\nاین مورد تا زمانی که API عمومی را متأثر نسازد سازگار تلقی خواهد شد. نرم‌افزاری که صریحاً به همان وابستگی‌هایی که بستهٔ شما وابسته است، وابسته باشد، باید مشخصات وابستگی خود را داشته باشد و نویسنده باید هرگونه مغایرت را ذکر کند. تشخیص اینکه آیا تغییر ازنوع دستکاری در سطح جزیی است یا سطح وصله، به این بستگی دارد که آیا شما وابستگی‌های خود را جهت تصحیح یک خطا یا برای یک کاربرد جدید به‌روزرسانی کرده‌اید. من معمولاً کد اضافی برای موارد آتی در نظر می‌گیرم، که بدون شک این موارد افزایش سطح جزیی می‌باشد.\nچه می شود اگر من بدون اعلام قبلی API عمومی را به صورتی تغییر دهم که با تغییر عدد نسخه سازگار نباشد؟ (یعنی کد به نادرست تغییر اصلی‌ای را در انتشار وصله معرفی می‌کند)\nاز بهترین قضاوت خود استفاده کنید. اگر شما مخاطبان زیادی دارید که به شدت به وسیلهٔ تغییر رفتار به آنچه قبلاً برای API  عمومی در نظر گرفته شده، متأثر خواهند شد، پس بهترین کار انجام یک انتشار نسخهٔ اصلی است، حتی اگر اصلاح اعمال شده مؤکداً یک انتشار وصله محسوب شود. به یاد داشته باشید، نسخه‌بندی معنایی تماماً دربارهٔ انتقال معنا بوسیله چگونگی تغییر عدد نسخه می‌باشد. اگر این تغییرات برای کاربران شما مهم است، از عدد نسخه برای آگاه‌سازی آن‌ها استفاده کنید.\nچگونه باید با منسوخ کردن عملکرد (deprecating functionality) کنار بیایم؟\nمنسوخ کردن عملکرد موجود بخشی عادی از توسعهٔ نرم‌افزار است و معمولاً برای این‌که پیشرفت رو به جلو حاصل شود مورد نیاز است. زمانی‌که بخشی از API عمومی خود را منسوخ می‌کنید، باید دو کار انجام دهید: ۱) مستندسازی خود را به‌روزرسانی کنید تا به کاربر اجازه دهید از تغییرات باخبر شود. ۲) یک انتشار جزیی که در آن قسمت منسوخ شده در جایگاه خود باشد منتشر کنید. قبل از آنکه عملکرد را به طورکامل در یک انتشار اصلی حذف کنید حتماً باید حداقل یک انتشار جزیی که شامل قسمت منسوخ شده است وجود داشته باشد تا کاربران به راحتی بتوانند به API جدید منتقل شوند.\nآیا SemVer محدودیت اندازه بر روی رشتهٔ نسخه دارد؟\nخیر، اما از قضاوت مناسبی استفاده کنید. به عنوان مثال یک نسخهٔ ۲۵۵ نویسه‌ای احتمالاً مفید نخواهد بود! همچنین، سیستم‌های خاص ممکن است محدودیت‌های خود برای اندازهٔ رشته اعمال کنند.\nنویسنده : Tom Preston-Werner, سازنده Gravatars و
 بنیان‌گذار GitHub.\nاگر مایل به ارائهٔ بازخورد خود هستید، لطفاً یک مورد در بخش issue سایت GitHub باز کنید.
 open an issue on GitHub.\nopen an issue on GitHub\nمترجم بخش فارسی : مجید حاجیان Majid Hajian 
ویراستار: فرزاد قانعی Farzad Ghanei\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nGestion sémantique de version 2.0.0

En bref

Étant donné un numéro de version MAJEUR.MINEUR.CORRECTIF, il faut incrémenter :


  le numéro de version MAJEUR quand il y a des changements non rétrocompatibles,
  le numéro de version MINEUR quand il y a des ajouts de fonctionnalités rétrocompatibles,
  le numéro de version de CORRECTIF quand il y a des corrections d’anomalies rétrocompatibles.


Des libellés supplémentaires peuvent être ajoutés pour les versions de pré-livraison et pour
des méta-données de construction sous forme d’extension du format MAJEURE.MINEURE.CORRECTIF.

Introduction

Dans le monde de la gestion des logiciels, il existe un endroit redouté appelé
« l’enfer des dépendances » (de l’anglais dependency hell). Plus votre système se
développe et plus vous intégrez de composants dans votre logiciel, plus vous êtes
susceptible de vous trouver un jour dans cet abîme de désespoir.

Dans les systèmes comportant de nombreuses dépendances, publier une nouvelle
version d’un composant peut vite devenir un cauchemar. Si les règles de
dépendance sont trop strictes, vous risquez de verrouiller vos versions
(incapacité de mettre à jour un composant sans avoir à publier une nouvelle
version de chaque composant qui en dépend). Si les règles de dépendances sont
trop lâches, vous allez inévitablement subir la promiscuité de version (supposer
une compatibilité avec plus de futures versions que raisonnable). L’enfer des
dépendances est l’endroit où vous vous trouvez lorsque vous êtes bloqué dans
une version et/ou qu’une incompatibilité de version vous empêche d’avancer
sans risque dans votre projet.

Comme solution à ce problème, je propose un ensemble de règles et d’exigences
simples qui dictent la façon dont les numéros de version sont attribués et
incrémentés. Ces règles sont basées mais pas nécessairement limitées à des
pratiques très répandues aussi bien dans les domaines du logiciel privé que du
logiciel libre. Pour que ce système fonctionne, vous devez d’abord déclarer une API
publique. Il peut s’agir d’un document ou de règles imposées par le code lui-même. Quoi qu’il en soit, il est important que cette API soit claire et précise.
Une fois celle-ci prête, vous communiquez ses modifications par des incrémentations
successives de son numéro de version. Considérons le format de version X.Y.Z
où X, Y et Z identifient la version (Majeure.Mineure.Corrective). Les corrections qui
n’affectent pas l’API incrémentent le dernier identifiant qui est l’identifiant de
version de correction. Lors d’ajouts ou de modifications rétrocompatibles de l’API,
il faut incrémenter l’identifiant de version mineure. Enfin, pour des modifications
non rétrocompatibles, il faut incrémenter l’identifiant de version majeure.

J’appelle ce système « gestion sémantique de version ». Avec ce système, les numéros de
version, et la façon dont ils changent, donnent du sens au code sous-jacent et à ce
qui a été modifié d’une version à l’autre.

Spécification de la gestion sémantique de version (SemVer)

Les mots clés “DOIT”, “NE DOIT PAS”, “OBLIGATOIRE”, “DEVRA”, “NE DEVRA PAS”,
“DEVRAIT”, “NE DEVRAIT PAS”, “RECOMMANDÉ”, “PEUT”, et “OPTIONNEL” dans ce
document doivent être interprétés comme décrit dans la RFC 2119.


  
    Tout logiciel utilisant la gestion sémantique de version DOIT déclarer une API
publique. Cette API peut être déclarée dans le code lui-même ou dans un document.
Dans tous les cas, elle doit être précise et claire.
  
  
    Un numéro de version standard DOIT prendre la forme X.Y.Z où X, Y et Z sont
des entiers non négatifs et NE DOIVENT PAS être préfixés par des zéros. X
représente l’identifiant de version majeure, Y représente l’identifiant de version mineure
et Z l’identifiant de version de correction. Chaque élément DOIT s’incrémenter
numériquement.
Exemple : 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Une fois qu’un composant est publié, le contenu de sa version NE DOIT PAS
être modifié. Toute modification DOIT être publiée dans une nouvelle version.
  
  
    L’identifiant de version majeure zéro (0.y.z) est destiné au développement initial.
Tout ou partie peut être modifié à tout moment. L’API publique ne devrait pas
être considérée comme stable.
  
  
    La version 1.0.0 définit l’API publique. La façon dont le numéro de version
est incrémenté après cette publication est dépendante de cette API publique et
de ses évolutions.
  
  
    L’identifiant de version de correction Z (x.y.Z | x > 0) DOIT être incrémenté
si seules des corrections rétrocompatibles sont introduites. Une correction
est définie comme un changement interne qui corrige un comportement incorrect.
  
  
    L’identifiant de version mineure Y (x.Y.z | x > 0) DOIT être incrémenté si de
nouvelles fonctionnalités rétrocompatibles sont introduites dans l’API
publique. Il DOIT être incrémenté si une fonctionnalité de l’API publique
est marquée comme obsolète. Il PEUT être incrémenté si de nouvelles fonctionnalités
ou améliorations substantielles sont introduites dans le code privé. Il PEUT
inclure dans le même temps des corrections. L’identifiant de version de correction
DOIT être remis à zéro lorsque l’identifiant de version mineure est incrémenté.
  
  
    L’identifiant de version majeur X (X.y.z | X > 0) DOIT être incrémenté si des
changements non rétrocompatibles sont introduits dans l’API publique. Cela PEUT
inclure dans le même temps des changements mineurs et des corrections. Les
identifiants de version mineure et de correction DOIVENT être remis à zéro quand
l’identifiant de version majeure est incrémenté.
  
  
    Une version de pré-livraison PEUT être notée par l’ajout d’un trait d’union et d’une
série d’identifiants séparés par des points suivant immédiatement l’identifiant de version
de correction. Les identifiants DOIVENT être composés uniquement de caractères
alphanumériques ASCII et de traits d’union [0-9A-Za-z-]. Les identifiants NE DOIVENT PAS
être vides. Les identifiants numériques NE DOIVENT PAS être préfixés par des zéros.
Les versions de pré-livraison précèdent la version normale associée (version de
pré-livraison < version normale). Une version de pré-livraison indique que la version
n’est pas stable et ne satisfait pas forcément les exigences de compatibilité
associées à une version normale.
Exemples : 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Les méta-données de construction PEUVENT être notées par l’ajout d’un signe
« plus » et d’une série d’identifiants séparés par des points suivant immédiatement
l’identifiant de version de correction ou de pré-livraison. Les identifiants DOIVENT
être composés uniquement de caractères alphanumériques ASCII et de traits d’union [0-9A-Za-z-].
Les identifiants NE DOIVENT PAS être vides. Les méta-données de construction DEVRAIENT
être ignorées dans l’ordre des versions. Autrement dit, deux versions qui diffèrent
seulement par leurs informations de construction ont la même priorité.
Exemples : 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    La priorité définit la façon dont sont ordonnées les versions entre elles.
La priorité DOIT être calculée en séparant les identifiants de versions entre
majeures, mineures, de correction et de pré-livraison, en suivant cet ordre
(les informations de construction n’entrent pas en compte dans la comparaison).
La priorité est déterminée par la première différence apparaissant dans la comparaison
de chacun de ces identifiants dans l’ordre : majeur, mineur et correctif. Ces
identifiants sont toujours comparés numériquement.
Exemple : 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
Lorsque ces identifiants sont identiques, une version de pré-livraison est moins
prioritaire qu’une version normale.
Exemple : 1.0.0-alpha < 1.0.0.
La priorité pour deux versions de pré-livraison ayant les mêmes identifiants de
version majeure, mineure et de correction DOIT être déterminée en comparant chaque
identifiant séparé par un point de la gauche vers la droite jusqu’à ce qu’une
différence soit trouvée, comme suit : les identifiants composés uniquement de
chiffres sont comparés numériquement et les identifiants contenant des lettres
ou des traits d’union sont comparés dans l’ordre ASCII. Les identifiants numériques
sont toujours moins prioritaires que les identifiants non numériques (identifiants
numériques < identifiants non-numériques). Un ensemble de champs plus long est
prioritaire par rapport à un ensemble de champs plus court si tous les identifiants
précédents sont identiques.
Exemple : 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Pourquoi utiliser la gestion sémantique de version ?

Il ne s’agit pas d’une idée nouvelle ou révolutionnaire. En fait, vous faites
probablement déjà quelque chose d’approchant. Et le problème vient du fait que
« quelque chose de proche » n’est pas suffisant. Sans conformité avec une méthode
formelle, les numéros de version deviennent inutilisables pour la gestion de
vos dépendances. En donnant un nom et une définition claire aux idées exposées
ci-dessus, il devient facile de communiquer vos intentions aux utilisateurs
de votre logiciel. Une fois que vos intentions sont claires, une spécification
souple (mais pas « trop » souple) des dépendances peut être réalisée.

Un exemple simple permet de montrer comment la gestion sémantique de version peut
faire de l’enfer des dépendances, une chose du passé. Considérons une bibliothèque
appelée « CamionDePompier ». Elle nécessite un composant appelé « Échelle » dont la
version est gérée sémantiquement. Lorsque la librairie CamionDePompier est créée,
Échelle en est à sa version 3.1.0. Et puisque CamionDePompier utilise des fonctionnalités
qui ont été introduites en 3.1.0, vous pouvez spécifier, sans courir le moindre risque,
une dépendance vers Échelle plus grande ou égale à 3.1.0 mais inférieure à 4.0.0.
Maintenant, lorsque les versions 3.1.1 et 3.2.0 de Échelle seront disponibles, vous
pourrez les publier dans votre système de gestion de dépendances en sachant qu’elles
seront compatibles avec les logiciels existants qui en dépendent.

En tant que développeur responsable, bien entendu, vous voudrez vérifier que toute
mise à jour de composant fonctionne comme annoncée. Dans la réalité, les choses ne
sont pas forcément toujours très cohérentes ; il n’y a donc rien d’autre à faire que
de rester vigilant. Ce que vous pouvez cependant faire est de laisser la gestion
sémantique de version vous fournir une manière saine de publier et mettre à jour vos
composants et ainsi ne pas avoir besoin de déployer de nouvelles versions de vos
sous-composants vous permettant ainsi d’économiser du temps et du souci.

Si tout cela vous semble intéressant, tout ce que vous avez à faire pour commencer
à utiliser la gestion sémantique de version est de déclarer que vous le faites
et d’en suivre les règles. Ajoutez ensuite un lien vers ce site web dans votre
README pour que d’autres puissent en connaître les règles et en bénéficier.

FAQ

Comment dois-je gérer les révisions dans la phase initiale de développement 0.y.z ?

La chose la plus simple à faire est de commencer vos développements avec
une version initiale à 0.1.0 puis d’incrémenter l’identifiant de version mineure
pour chaque nouvelle publication.

Comment savoir quand publier la version 1.0.0 ?

Si votre logiciel est utilisé en environnement de production ou que vous avez
une API stable de laquelle des utilisateurs ont commencé à dépendre, vous devriez
probablement déjà être en version 1.0.0. Et si vous vous faites déjà du souci
pour la rétro-compatibilité, vous devriez également avoir dépassé la 1.0.0.

N’est-ce pas décourager le développement rapide et les itérations courtes ?

La version majeure zéro est faite pour un développement
rapide. Si vous changez votre API tous les jours, vous devriez toujours être
en version 0.y.z ou sur une branche de développement séparée en préparant la
prochaine version majeure.

Si le moindre changement non rétrocompatible de l’API publique nécessite une incrémentation de l’identifiant de version majeure, ne vais-je pas me retrouver à la version 42.0.0 très rapidement ?

C’est une question de développement responsable et d’anticipation. Les changements
incompatibles ne doivent pas être introduits à la légère dans du logiciel dont
beaucoup de code source dépend. Le coût d’une mise à jour vers une nouvelle version
peut être important. Le besoin de faire évoluer la version majeure pour publier des
changements non rétrocompatibles signifie que vous aurez mesuré les implications de
vos modifications et évalué le rapport entre leur coût et leurs bénéfices.

Documenter l’ensemble de l’API publique demande trop de travail !

Il est de votre responsabilité en tant que développeur professionnel de documenter
correctement le logiciel qui est destiné à être utilisé par d’autres. Gérer la
complexité d’un logiciel est un élément extrêmement important pour maintenir son
projet efficacement. Cela devient difficile à faire quand personne ne sait comment
utiliser votre logiciel ou ne connaît les bonnes méthodes à appeler. Sur le long
terme, la gestion sémantique de version et les efforts dans la conservation d’une
API publique bien définie permettront à tout le monde d’avancer sans problème.

Que faire si j’ai accidentellement publié un changement non rétrocompatible dans une version mineure ?

Dès que vous réalisez que vous avez cassé votre gestion sémantique de version,
corrigez le problème et publiez une nouvelle version mineure qui rétablit la
compatibilité avec les versions précédentes. Même dans de telles circonstances,
il est inacceptable de modifier une version déjà publiée. Mettez à jour la
documentation en signalant la version défectueuse et informez vos utilisateurs
de ce problème.

Que dois-je faire lorsque je mets à jour mes propres dépendances sans changer l’API publique ?

Cela peut être considéré comme compatible dans la mesure où cela n’affecte pas l’API
publique. Les logiciels qui dépendent des mêmes librairies que votre composant
devraient avoir leur propre spécification de dépendances et l’auteur remarquera ainsi
tout conflit. Pour déterminer si la modification est de niveau correctif ou mineur,
il faut vous poser la question de savoir si vous avez mis à jour vos dépendances pour
corriger un bug ou pour introduire une nouvelle fonctionnalité. Je considère
généralement l’ajout de nouveau code comme la deuxième option ce qui sous-entend
évidemment un incrément de l’identifiant de version mineure.

Que faire si par mégarde je modifie l’API publique d’une façon qui ne correspond pas au changement de numéro de version (exemple : le code introduit un changement non rétrocompatible dans une publication de correctif) ?

C’est à vous de décider. Si vous avez une large audience qui sera considérablement
affectée par un retour à ce que l’API publique prévoyait, alors il est peut être préférable
de publier une version majeure, même si la livraison pourrait être uniquement considérée
comme un correctif. Souvenez-vous encore que la gestion sémantique de version consiste
essentiellement à transmettre du sens dans la façon dont le numéro de version change. Si
ces changements sont importants pour vos utilisateurs, utilisez les numéros de version
pour les en informer.

Comment dois-je traiter les fonctionnalités obsolètes ?

Rendre des fonctionnalités obsolètes est une part normale du développement de logiciels
et cela est souvent nécessaire pour aller de l’avant. Lorsque vous dépréciez une partie
de votre API publique, vous devez faire deux choses : (1) mettre à jour la documentation
pour informer les utilisateurs du changement, (2) publier une nouvelle version mineure
avec la dépréciation en place. Avant que vous ne supprimiez complètement la fonctionnalité
dans une nouvelle version majeure, il devrait y avoir au moins une version mineure qui
contient la dépréciation pour que les utilisateurs puissent effectuer la transition en douceur.

Est-ce que la gestion sémantique de version spécifie une limite de taille pour la chaîne de caractères d’un numéro de version ?

Non, mais faites preuve de bon sens. Par exemple, un numéro de version de 255 caractères
est probablement excessif. De plus, certains systèmes peuvent imposer leurs propres limites
sur cette taille.

À propos

La spécification de la gestion sémantique de version est écrite par Tom
Preston-Werner, inventeur de Gravatars et
cofondateur de GitHub.

Si vous souhaitez laisser des commentaires, veuillez ouvrir un ticket sur
GitHub.

Licence

Creative Commons ― CC BY 3.0\nGestion sémantique de version 2.0.0\nÉtant donné un numéro de version MAJEUR.MINEUR.CORRECTIF, il faut incrémenter :\nle numéro de version MAJEUR quand il y a des changements non rétrocompatibles,\nle numéro de version MINEUR quand il y a des ajouts de fonctionnalités rétrocompatibles,\nle numéro de version de CORRECTIF quand il y a des corrections d’anomalies rétrocompatibles.\nDes libellés supplémentaires peuvent être ajoutés pour les versions de pré-livraison et pour
des méta-données de construction sous forme d’extension du format MAJEURE.MINEURE.CORRECTIF.\nDans le monde de la gestion des logiciels, il existe un endroit redouté appelé
« l’enfer des dépendances » (de l’anglais dependency hell). Plus votre système se
développe et plus vous intégrez de composants dans votre logiciel, plus vous êtes
susceptible de vous trouver un jour dans cet abîme de désespoir.\nDans les systèmes comportant de nombreuses dépendances, publier une nouvelle
version d’un composant peut vite devenir un cauchemar. Si les règles de
dépendance sont trop strictes, vous risquez de verrouiller vos versions
(incapacité de mettre à jour un composant sans avoir à publier une nouvelle
version de chaque composant qui en dépend). Si les règles de dépendances sont
trop lâches, vous allez inévitablement subir la promiscuité de version (supposer
une compatibilité avec plus de futures versions que raisonnable). L’enfer des
dépendances est l’endroit où vous vous trouvez lorsque vous êtes bloqué dans
une version et/ou qu’une incompatibilité de version vous empêche d’avancer
sans risque dans votre projet.\nComme solution à ce problème, je propose un ensemble de règles et d’exigences
simples qui dictent la façon dont les numéros de version sont attribués et
incrémentés. Ces règles sont basées mais pas nécessairement limitées à des
pratiques très répandues aussi bien dans les domaines du logiciel privé que du
logiciel libre. Pour que ce système fonctionne, vous devez d’abord déclarer une API
publique. Il peut s’agir d’un document ou de règles imposées par le code lui-même. Quoi qu’il en soit, il est important que cette API soit claire et précise.
Une fois celle-ci prête, vous communiquez ses modifications par des incrémentations
successives de son numéro de version. Considérons le format de version X.Y.Z
où X, Y et Z identifient la version (Majeure.Mineure.Corrective). Les corrections qui
n’affectent pas l’API incrémentent le dernier identifiant qui est l’identifiant de
version de correction. Lors d’ajouts ou de modifications rétrocompatibles de l’API,
il faut incrémenter l’identifiant de version mineure. Enfin, pour des modifications
non rétrocompatibles, il faut incrémenter l’identifiant de version majeure.\nJ’appelle ce système « gestion sémantique de version ». Avec ce système, les numéros de
version, et la façon dont ils changent, donnent du sens au code sous-jacent et à ce
qui a été modifié d’une version à l’autre.\nSpécification de la gestion sémantique de version (SemVer)\nLes mots clés “DOIT”, “NE DOIT PAS”, “OBLIGATOIRE”, “DEVRA”, “NE DEVRA PAS”,
“DEVRAIT”, “NE DEVRAIT PAS”, “RECOMMANDÉ”, “PEUT”, et “OPTIONNEL” dans ce
document doivent être interprétés comme décrit dans la RFC 2119.\nTout logiciel utilisant la gestion sémantique de version DOIT déclarer une API
publique. Cette API peut être déclarée dans le code lui-même ou dans un document.
Dans tous les cas, elle doit être précise et claire.\nTout logiciel utilisant la gestion sémantique de version DOIT déclarer une API
publique. Cette API peut être déclarée dans le code lui-même ou dans un document.
Dans tous les cas, elle doit être précise et claire.\nUn numéro de version standard DOIT prendre la forme X.Y.Z où X, Y et Z sont
des entiers non négatifs et NE DOIVENT PAS être préfixés par des zéros. X
représente l’identifiant de version majeure, Y représente l’identifiant de version mineure
et Z l’identifiant de version de correction. Chaque élément DOIT s’incrémenter
numériquement.
Exemple : 1.9.0 -> 1.10.0 -> 1.11.0.\nUn numéro de version standard DOIT prendre la forme X.Y.Z où X, Y et Z sont
des entiers non négatifs et NE DOIVENT PAS être préfixés par des zéros. X
représente l’identifiant de version majeure, Y représente l’identifiant de version mineure
et Z l’identifiant de version de correction. Chaque élément DOIT s’incrémenter
numériquement.
Exemple : 1.9.0 -> 1.10.0 -> 1.11.0.\nUne fois qu’un composant est publié, le contenu de sa version NE DOIT PAS
être modifié. Toute modification DOIT être publiée dans une nouvelle version.\nUne fois qu’un composant est publié, le contenu de sa version NE DOIT PAS
être modifié. Toute modification DOIT être publiée dans une nouvelle version.\nL’identifiant de version majeure zéro (0.y.z) est destiné au développement initial.
Tout ou partie peut être modifié à tout moment. L’API publique ne devrait pas
être considérée comme stable.\nL’identifiant de version majeure zéro (0.y.z) est destiné au développement initial.
Tout ou partie peut être modifié à tout moment. L’API publique ne devrait pas
être considérée comme stable.\nLa version 1.0.0 définit l’API publique. La façon dont le numéro de version
est incrémenté après cette publication est dépendante de cette API publique et
de ses évolutions.\nLa version 1.0.0 définit l’API publique. La façon dont le numéro de version
est incrémenté après cette publication est dépendante de cette API publique et
de ses évolutions.\nL’identifiant de version de correction Z (x.y.Z | x > 0) DOIT être incrémenté
si seules des corrections rétrocompatibles sont introduites. Une correction
est définie comme un changement interne qui corrige un comportement incorrect.\nL’identifiant de version de correction Z (x.y.Z | x > 0) DOIT être incrémenté
si seules des corrections rétrocompatibles sont introduites. Une correction
est définie comme un changement interne qui corrige un comportement incorrect.\nL’identifiant de version mineure Y (x.Y.z | x > 0) DOIT être incrémenté si de
nouvelles fonctionnalités rétrocompatibles sont introduites dans l’API
publique. Il DOIT être incrémenté si une fonctionnalité de l’API publique
est marquée comme obsolète. Il PEUT être incrémenté si de nouvelles fonctionnalités
ou améliorations substantielles sont introduites dans le code privé. Il PEUT
inclure dans le même temps des corrections. L’identifiant de version de correction
DOIT être remis à zéro lorsque l’identifiant de version mineure est incrémenté.\nL’identifiant de version mineure Y (x.Y.z | x > 0) DOIT être incrémenté si de
nouvelles fonctionnalités rétrocompatibles sont introduites dans l’API
publique. Il DOIT être incrémenté si une fonctionnalité de l’API publique
est marquée comme obsolète. Il PEUT être incrémenté si de nouvelles fonctionnalités
ou améliorations substantielles sont introduites dans le code privé. Il PEUT
inclure dans le même temps des corrections. L’identifiant de version de correction
DOIT être remis à zéro lorsque l’identifiant de version mineure est incrémenté.\nL’identifiant de version majeur X (X.y.z | X > 0) DOIT être incrémenté si des
changements non rétrocompatibles sont introduits dans l’API publique. Cela PEUT
inclure dans le même temps des changements mineurs et des corrections. Les
identifiants de version mineure et de correction DOIVENT être remis à zéro quand
l’identifiant de version majeure est incrémenté.\nL’identifiant de version majeur X (X.y.z | X > 0) DOIT être incrémenté si des
changements non rétrocompatibles sont introduits dans l’API publique. Cela PEUT
inclure dans le même temps des changements mineurs et des corrections. Les
identifiants de version mineure et de correction DOIVENT être remis à zéro quand
l’identifiant de version majeure est incrémenté.\nUne version de pré-livraison PEUT être notée par l’ajout d’un trait d’union et d’une
série d’identifiants séparés par des points suivant immédiatement l’identifiant de version
de correction. Les identifiants DOIVENT être composés uniquement de caractères
alphanumériques ASCII et de traits d’union [0-9A-Za-z-]. Les identifiants NE DOIVENT PAS
être vides. Les identifiants numériques NE DOIVENT PAS être préfixés par des zéros.
Les versions de pré-livraison précèdent la version normale associée (version de
pré-livraison < version normale). Une version de pré-livraison indique que la version
n’est pas stable et ne satisfait pas forcément les exigences de compatibilité
associées à une version normale.
Exemples : 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nUne version de pré-livraison PEUT être notée par l’ajout d’un trait d’union et d’une
série d’identifiants séparés par des points suivant immédiatement l’identifiant de version
de correction. Les identifiants DOIVENT être composés uniquement de caractères
alphanumériques ASCII et de traits d’union [0-9A-Za-z-]. Les identifiants NE DOIVENT PAS
être vides. Les identifiants numériques NE DOIVENT PAS être préfixés par des zéros.
Les versions de pré-livraison précèdent la version normale associée (version de
pré-livraison < version normale). Une version de pré-livraison indique que la version
n’est pas stable et ne satisfait pas forcément les exigences de compatibilité
associées à une version normale.
Exemples : 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nLes méta-données de construction PEUVENT être notées par l’ajout d’un signe
« plus » et d’une série d’identifiants séparés par des points suivant immédiatement
l’identifiant de version de correction ou de pré-livraison. Les identifiants DOIVENT
être composés uniquement de caractères alphanumériques ASCII et de traits d’union [0-9A-Za-z-].
Les identifiants NE DOIVENT PAS être vides. Les méta-données de construction DEVRAIENT
être ignorées dans l’ordre des versions. Autrement dit, deux versions qui diffèrent
seulement par leurs informations de construction ont la même priorité.
Exemples : 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nLes méta-données de construction PEUVENT être notées par l’ajout d’un signe
« plus » et d’une série d’identifiants séparés par des points suivant immédiatement
l’identifiant de version de correction ou de pré-livraison. Les identifiants DOIVENT
être composés uniquement de caractères alphanumériques ASCII et de traits d’union [0-9A-Za-z-].
Les identifiants NE DOIVENT PAS être vides. Les méta-données de construction DEVRAIENT
être ignorées dans l’ordre des versions. Autrement dit, deux versions qui diffèrent
seulement par leurs informations de construction ont la même priorité.
Exemples : 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nLa priorité définit la façon dont sont ordonnées les versions entre elles.
La priorité DOIT être calculée en séparant les identifiants de versions entre
majeures, mineures, de correction et de pré-livraison, en suivant cet ordre
(les informations de construction n’entrent pas en compte dans la comparaison).
La priorité est déterminée par la première différence apparaissant dans la comparaison
de chacun de ces identifiants dans l’ordre : majeur, mineur et correctif. Ces
identifiants sont toujours comparés numériquement.
Exemple : 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
Lorsque ces identifiants sont identiques, une version de pré-livraison est moins
prioritaire qu’une version normale.
Exemple : 1.0.0-alpha < 1.0.0.
La priorité pour deux versions de pré-livraison ayant les mêmes identifiants de
version majeure, mineure et de correction DOIT être déterminée en comparant chaque
identifiant séparé par un point de la gauche vers la droite jusqu’à ce qu’une
différence soit trouvée, comme suit : les identifiants composés uniquement de
chiffres sont comparés numériquement et les identifiants contenant des lettres
ou des traits d’union sont comparés dans l’ordre ASCII. Les identifiants numériques
sont toujours moins prioritaires que les identifiants non numériques (identifiants
numériques < identifiants non-numériques). Un ensemble de champs plus long est
prioritaire par rapport à un ensemble de champs plus court si tous les identifiants
précédents sont identiques.
Exemple : 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nLa priorité définit la façon dont sont ordonnées les versions entre elles.
La priorité DOIT être calculée en séparant les identifiants de versions entre
majeures, mineures, de correction et de pré-livraison, en suivant cet ordre
(les informations de construction n’entrent pas en compte dans la comparaison).
La priorité est déterminée par la première différence apparaissant dans la comparaison
de chacun de ces identifiants dans l’ordre : majeur, mineur et correctif. Ces
identifiants sont toujours comparés numériquement.
Exemple : 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
Lorsque ces identifiants sont identiques, une version de pré-livraison est moins
prioritaire qu’une version normale.
Exemple : 1.0.0-alpha < 1.0.0.
La priorité pour deux versions de pré-livraison ayant les mêmes identifiants de
version majeure, mineure et de correction DOIT être déterminée en comparant chaque
identifiant séparé par un point de la gauche vers la droite jusqu’à ce qu’une
différence soit trouvée, comme suit : les identifiants composés uniquement de
chiffres sont comparés numériquement et les identifiants contenant des lettres
ou des traits d’union sont comparés dans l’ordre ASCII. Les identifiants numériques
sont toujours moins prioritaires que les identifiants non numériques (identifiants
numériques < identifiants non-numériques). Un ensemble de champs plus long est
prioritaire par rapport à un ensemble de champs plus court si tous les identifiants
précédents sont identiques.
Exemple : 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPourquoi utiliser la gestion sémantique de version ?\nIl ne s’agit pas d’une idée nouvelle ou révolutionnaire. En fait, vous faites
probablement déjà quelque chose d’approchant. Et le problème vient du fait que
« quelque chose de proche » n’est pas suffisant. Sans conformité avec une méthode
formelle, les numéros de version deviennent inutilisables pour la gestion de
vos dépendances. En donnant un nom et une définition claire aux idées exposées
ci-dessus, il devient facile de communiquer vos intentions aux utilisateurs
de votre logiciel. Une fois que vos intentions sont claires, une spécification
souple (mais pas « trop » souple) des dépendances peut être réalisée.\nUn exemple simple permet de montrer comment la gestion sémantique de version peut
faire de l’enfer des dépendances, une chose du passé. Considérons une bibliothèque
appelée « CamionDePompier ». Elle nécessite un composant appelé « Échelle » dont la
version est gérée sémantiquement. Lorsque la librairie CamionDePompier est créée,
Échelle en est à sa version 3.1.0. Et puisque CamionDePompier utilise des fonctionnalités
qui ont été introduites en 3.1.0, vous pouvez spécifier, sans courir le moindre risque,
une dépendance vers Échelle plus grande ou égale à 3.1.0 mais inférieure à 4.0.0.
Maintenant, lorsque les versions 3.1.1 et 3.2.0 de Échelle seront disponibles, vous
pourrez les publier dans votre système de gestion de dépendances en sachant qu’elles
seront compatibles avec les logiciels existants qui en dépendent.\nEn tant que développeur responsable, bien entendu, vous voudrez vérifier que toute
mise à jour de composant fonctionne comme annoncée. Dans la réalité, les choses ne
sont pas forcément toujours très cohérentes ; il n’y a donc rien d’autre à faire que
de rester vigilant. Ce que vous pouvez cependant faire est de laisser la gestion
sémantique de version vous fournir une manière saine de publier et mettre à jour vos
composants et ainsi ne pas avoir besoin de déployer de nouvelles versions de vos
sous-composants vous permettant ainsi d’économiser du temps et du souci.\nSi tout cela vous semble intéressant, tout ce que vous avez à faire pour commencer
à utiliser la gestion sémantique de version est de déclarer que vous le faites
et d’en suivre les règles. Ajoutez ensuite un lien vers ce site web dans votre
README pour que d’autres puissent en connaître les règles et en bénéficier.\nComment dois-je gérer les révisions dans la phase initiale de développement 0.y.z ?\nLa chose la plus simple à faire est de commencer vos développements avec
une version initiale à 0.1.0 puis d’incrémenter l’identifiant de version mineure
pour chaque nouvelle publication.\nComment savoir quand publier la version 1.0.0 ?\nSi votre logiciel est utilisé en environnement de production ou que vous avez
une API stable de laquelle des utilisateurs ont commencé à dépendre, vous devriez
probablement déjà être en version 1.0.0. Et si vous vous faites déjà du souci
pour la rétro-compatibilité, vous devriez également avoir dépassé la 1.0.0.\nN’est-ce pas décourager le développement rapide et les itérations courtes ?\nLa version majeure zéro est faite pour un développement
rapide. Si vous changez votre API tous les jours, vous devriez toujours être
en version 0.y.z ou sur une branche de développement séparée en préparant la
prochaine version majeure.\nSi le moindre changement non rétrocompatible de l’API publique nécessite une incrémentation de l’identifiant de version majeure, ne vais-je pas me retrouver à la version 42.0.0 très rapidement ?\nC’est une question de développement responsable et d’anticipation. Les changements
incompatibles ne doivent pas être introduits à la légère dans du logiciel dont
beaucoup de code source dépend. Le coût d’une mise à jour vers une nouvelle version
peut être important. Le besoin de faire évoluer la version majeure pour publier des
changements non rétrocompatibles signifie que vous aurez mesuré les implications de
vos modifications et évalué le rapport entre leur coût et leurs bénéfices.\nDocumenter l’ensemble de l’API publique demande trop de travail !\nIl est de votre responsabilité en tant que développeur professionnel de documenter
correctement le logiciel qui est destiné à être utilisé par d’autres. Gérer la
complexité d’un logiciel est un élément extrêmement important pour maintenir son
projet efficacement. Cela devient difficile à faire quand personne ne sait comment
utiliser votre logiciel ou ne connaît les bonnes méthodes à appeler. Sur le long
terme, la gestion sémantique de version et les efforts dans la conservation d’une
API publique bien définie permettront à tout le monde d’avancer sans problème.\nQue faire si j’ai accidentellement publié un changement non rétrocompatible dans une version mineure ?\nDès que vous réalisez que vous avez cassé votre gestion sémantique de version,
corrigez le problème et publiez une nouvelle version mineure qui rétablit la
compatibilité avec les versions précédentes. Même dans de telles circonstances,
il est inacceptable de modifier une version déjà publiée. Mettez à jour la
documentation en signalant la version défectueuse et informez vos utilisateurs
de ce problème.\nQue dois-je faire lorsque je mets à jour mes propres dépendances sans changer l’API publique ?\nCela peut être considéré comme compatible dans la mesure où cela n’affecte pas l’API
publique. Les logiciels qui dépendent des mêmes librairies que votre composant
devraient avoir leur propre spécification de dépendances et l’auteur remarquera ainsi
tout conflit. Pour déterminer si la modification est de niveau correctif ou mineur,
il faut vous poser la question de savoir si vous avez mis à jour vos dépendances pour
corriger un bug ou pour introduire une nouvelle fonctionnalité. Je considère
généralement l’ajout de nouveau code comme la deuxième option ce qui sous-entend
évidemment un incrément de l’identifiant de version mineure.\nQue faire si par mégarde je modifie l’API publique d’une façon qui ne correspond pas au changement de numéro de version (exemple : le code introduit un changement non rétrocompatible dans une publication de correctif) ?\nC’est à vous de décider. Si vous avez une large audience qui sera considérablement
affectée par un retour à ce que l’API publique prévoyait, alors il est peut être préférable
de publier une version majeure, même si la livraison pourrait être uniquement considérée
comme un correctif. Souvenez-vous encore que la gestion sémantique de version consiste
essentiellement à transmettre du sens dans la façon dont le numéro de version change. Si
ces changements sont importants pour vos utilisateurs, utilisez les numéros de version
pour les en informer.\nComment dois-je traiter les fonctionnalités obsolètes ?\nRendre des fonctionnalités obsolètes est une part normale du développement de logiciels
et cela est souvent nécessaire pour aller de l’avant. Lorsque vous dépréciez une partie
de votre API publique, vous devez faire deux choses : (1) mettre à jour la documentation
pour informer les utilisateurs du changement, (2) publier une nouvelle version mineure
avec la dépréciation en place. Avant que vous ne supprimiez complètement la fonctionnalité
dans une nouvelle version majeure, il devrait y avoir au moins une version mineure qui
contient la dépréciation pour que les utilisateurs puissent effectuer la transition en douceur.\nEst-ce que la gestion sémantique de version spécifie une limite de taille pour la chaîne de caractères d’un numéro de version ?\nNon, mais faites preuve de bon sens. Par exemple, un numéro de version de 255 caractères
est probablement excessif. De plus, certains systèmes peuvent imposer leurs propres limites
sur cette taille.\nLa spécification de la gestion sémantique de version est écrite par Tom
Preston-Werner, inventeur de Gravatars et
cofondateur de GitHub.\nSi vous souhaitez laisser des commentaires, veuillez ouvrir un ticket sur
GitHub.\nouvrir un ticket sur
GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nגרסאות סמנטיות 2.0.0

סיכום

בהינתן מספר גרסה MAJOR.MINOR.PATCH, העלה את:


  גרסה ראשית (MAJOR) כאשר אתה עושה שינויים שאינם עולים בקנה אחד עם ה API
  גרסה משנית (MINOR) כשאר אתה מוסיף פונקציונאליות בצורה שתואמת אחורנית
  גרסת תיקון (PATCH) כאשר אתה מבצע תיקוני באגים שתואמים אחורנית


תוויות נוספות עבור גרסאות קדם הפצה ובניית מטא-דאטה זמינות כתוספת לפורמט MAJOR.MINOR.PATCH.

מבוא

בעולם של ניהול תוכנה קיים מקום מפחיד בשם “גיהנום התלויות (dependency hell)”. ככל שהמערכת גדלה ואתה משלב יותר ויותר חבילות לתוכנה, קיים סיכוי גבוה יותר שתמצא את עצמך, יום אחד, בבור של יאוש.

בתוכנות עם המון תלויות, שחרור גרסה של חבילה חדשה יכול במהירות להפוך לסיוט. אם מפרט התלויות הדוק מידי, אתה בסכנה של “נעילת גרסה (version lock)” (חוסר היכולת לשדרג חבילה מבלי לשחרר גרסה חדשה של כל חבילה תלויה). אם מפרט התלויות רופף מידי, באופן בלתי נמנע אתה תכווה ע”י “מתירנות גרסה (version promiscuity)” (השערה של תאימות, יותר מהסביר, עם גרסאות עתידיות). “גיהנום התלויות” הוא כאשר אתה נמצא במקום בו נעילת גרסה ו/או מתירנות גרסה מונעים ממך להניע את הפרויקט שלך קדימה בקלות ובבטחה.

על מנת לפתור בעיה זו, מוצע סט פשוט של כללים ודרישות המכתיבים כיצד מספרי גרסאות יוקצו ויוגדלו. כללים אלה מבוססים על מנהגים משותפים, קיימים ונפוצים בפרויקטי קוד פתוח וסגור. על מנת שמערכת זו תעבוד, תחילה צריך להכריז על API ציבורי. זה אולי יהיה מורכב מתיעוד או יאכף על ידי הקוד עצמו. בכל מקרה, זה חשוב שה API יהיה ברור ומדויק. ברגע שאתה מגדיר את ה API הציבורי שלך, אתה מתקשר בו את השינויים עם תוספות ספציפיות למספר הגרסה. הסתכל על תבנית גרסה של X.Y.Z (בפורמט Major.Minor.Patch). תיקוני באגים שלא משפיעים על ה API יגדילו את מספר את מספר התיקון (Patch), תוספות / שינויים תואמי API לאחור יגדילו את הגרסה המשנית (Minor), ושינויים שאינם נתמכים לאחור ב API יגדילו את הגרסה הראשית (Major).

אני קורא למערכת “גרסאות סמנטיות”. במסגרת זו, מספרי גרסאות והדרך שבה הם משתנים מעבירה משמעות על הקוד ועל מה שהשתנה מגרסה אחת לאחרת.

מפרט גרסאות סמנטיות (SemVer)

מילות המפתח “חייב (MUST)”, “אסור (MUST NOT)”, “חובה (REQUIRED)”, “תהא (SHALL)”, “לא (SHALL NOT)”, “צריך (SHOULD)”, “לא צריך (SHOULD NOT)”, “מומלץ (RECOMMENDED)”, “יכול (MAY)”, “אפשרי (OPTIONAL)” אשר מופיעות במסמך, צריכות להיות מפורשות כמתואר במסמך RFC 2119.


  
    תוכנה באמצעות גרסאות סמנטיות נדרשת להכריז על API ציבורי. ניתן להכריז על API זה בקוד עצמו או אך ורק בתיעוד. עם זאת זה צריך להיעשות מדויק ומקיף.
  
  
    מספר גרסה רגילה חייב (MUST) להיות בצורה X.Y.Z כאשר Y, X, ו Z הם מספרים שלמים (Integers) שאינם שליליים, ואסור (Must Not) שיכילו אפסים מובילים. X הוא גרסה ראשית (Major), לאחריו Y הוא גרסה משנית (Minor), ולבסוף Z הוא גרסת תיקון (Patch).
כל רכיב במספר הגרסה חייב (MUST) להגדיל את המספר נומרית. לדוגמה: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    לאחר שחבילה שוחררה, אסור לשנות את התוכן של החבילה באותה גרסה. כל שינוי חייב להשתחרר כגרסה חדשה.
  
  
    גרסה ראשית אפס (0.z.y) היא עבור פיתוח ראשוני. בהינתן שכל דבר יכול להשתנות בכל זמן, ה API הציבורי לא צריך להיחשב יציב.
  
  
    גרסה 1.0.0 מגדירה את ה API הציבורי. הדרך שבה מספר הגרסה עולה לאחר שחרור גרסה זו תלוי ב-API הציבורי ובאופן בו הוא משתנה.
  
  
    
      
        
          גרסת תיקון (Patch) במיקום Z (כלומר x > 0
          Z.y.x) חייבת לעלות אם ורק אם הוצגו תיקוני באגים תואמים לאחור. תיקון באג שתואם לאחור מוגדר כשינוי פנימי שמתקן התנהגות לא נכונה.
        
      
    
  
  
    
      
        
          גרסה משנית (Minor) במיקום Y (כלומר x > 0
          z.Y.x) חייבת לעלות שינויי פונקציונאליות חדש, תואם אחורה, שהוצג ב API הציבורי. הוא חייב (MUST) לעלות אם פונקציונאליות כלשהי ב API הציבורי הוגדרה כ-deprecated. הוא יכול (MAY) לעלות אם הוצגו שינויים או חידושיים משמעותיים בתוך הקוד הפרטי. הוא יכול (MAY) לכלול שינויים ברמת תיקון (Patch). מספר הגרסה ברמת תיקון (Patch) חייב (MUST) להיות מאופס ל-0 כאשר מספר הגרסה המשנית (Minor) עולה.
        
      
    
  
  
    
      
        
          גרסה ראשית (Major) במיקום X (כלומר X > 0
          z.y.X) חייבת (MUST) לעלות אם הוצגו שינויים כלשהם ל API הציבורי שאינם תואמים אחורה. היא יכולה (MAY) לכלול שינויים ברמת משנית (Minor) וברמת תיקון (Patch). מספרי גרסאות ברמת תיקון (Patch) וברמה משנית (Minor) חייבים (MUST) להיות מאופסים ל 0 כאשר עולים מספר גרסה ראשית (Major).
        
      
    
  
  
    גרסת קדם הפצה יכולה (MAY) להיות מסומנת על ידי מקף ומזהים מופרדים בנקודות מיד לאחר גרסת התיקון (Patch). מזהים חייבים (MUST) להיות מורכבים מאותיות, מקף, ומספרים בתקן ASCII בלבד [0-9A-Za-z-]. אסור שהמזהה יהיה ריק. אסור שמזהים מספריים יכילו אפסים מובילים. לגרסאות קדם הפצה יש זכות נמוכה מלגרסאות רגילות. גרסת קדם הפצה מציינת כי הגרסה אינה יציבה ויכול להיות שלא תספק את הדרישות כמו גרסה רגילה. דוגמאות: 1.0.0-alpha,  1.0.0-alpha.1,   1.0.0-0.3.7,   1.0.0-x.7.z.92
  
  
    גרסה בעלת מטא נתונים (metadata build) יכולה (MAY) להיות מסומנת על ידי סימן פלוס ומזהים המפורדים בנקודות הבאים מיד לאחר גרסת התיקון (Patch) או גרסת קדם הפצה. מזהים חייבים (MUST) להיות מורכבים מאותיות, מקף, ומספרים בתקן ASCII בלבד [0-9A-Za-z-]. אסור שהמזהה יהיה ריק. בעת קביעת עדיפות גרסה צריך (SHOULD) להתעלם מגרסת מטא נתונים. לשתי גרסאות שההבדל היחיד ביניהן הוא גרסת המטא נתונים יש אותה עדיפות. דוגמאות: 1.0.0-alpha+001,  1.0.0+20130313144700,   1.0.0-beta+exp.sha.5114f85
  
  עדיפות מתייחסת לאופן בו משווים גרסאות זה לזה כאשר הם מסודרים. עדיפות חייבת (MUST) להיות מחושבת על ידי הפרדת הגרסה לראשי (Major), משני (Minor), תיקון (Patch) ומזהי קדם הפצה בסדר הזה (נתוני מטה אינם נלקחים בחשבון בעדיפות). העדיפות נקבעת על ידי ההבדל הראשון כאשר משווים את כל המזהים מספרית משמאל לימין כדלקמן: ראשי (Major), משני (Minor) ותיקון (Patch) תמיד משווים מספרית. דוגמה 2.1.1 > 2.1.0 > 2.0.0 > 1.0.0. כאשר ראשי (Major), משני (Minor) ותיקון (Patch) שווים, ולגרסת קדם הפצה יש עדיפות נמוכה יותר מאשר לגרסה רגילה. דוגמה ֿ1.0.0 > 1.0.0-alpha. עדיפות עבור שתי גרסאות קדם הפצה עם גרסאות ראשי (Major), משני (Minor), תיקון (Patch) זהים חייב (MUST) להיקבע על ידי השוואה של מזהה בין הנקודות משמאל לימין עד שנמצא הבדל כדלקמן: מזהים המורכבים מספרות בלבד משווים בצורה מספרית (נומרית) ומזהים עם אותיות או מקפים משווים לקסיקלית בסדר מיון של תקן ASCII. למזהים מספריים תמיד תהיה עדיפות נמוכה ממזהים שאינם מספריים. לקבוצה גדולה יותר של מזהים בגרסת קדם הפצה יש עדיפות גבוהה יותר מקבוצה קטנה יותר, אם כל אמצעי ההשוואה למזהים שקדמו שווים. דוגמאות: 1.0.0 > 1.0.0-rc.1 > 1.0.0-beta.11 > 1.0.0-beta.2 > 1.0.0-beta > 1.0.0-alpha.beta > 1.0.0-alpha.1 > 1.0.0-alpha 


למה להשתמש בגרסאות סמנטיות?

זה לא רעיון חדש או מהפכני. למעשה, כנראה שאתה עושה משהו קרוב לזה כבר עכשיו. הבעיה היא ש”קרוב” זה לא מספיק טוב. ללא תאימות כלשהי למפרט פורמלי, מספרי גרסה הם למעשה חסרי תועלת לניהול תלויות. על ידי מתן שם ברור והגדרה ברורה לרעיונות שהוצגו כאן, תקשור הכוונות שלנו למשתמשי התוכנה נעשה קל יותר. לאחר שהכוונות האלו ברורות וגמישות (אבל לא גמישות מידי), יכול בסופו של דבר להתבצע מפרט תלויות.

דוגמא פשוטה תדגים כיצד גרסאות סמנטיות יכולות להפוך את “גהינום התלויות” לנחלת העבר. דמיינו ספריה בשם “כבאית”. שדורשת ספרייה בשם “סולם” שעומדת במפרט של גרסאות סמנטיות. באותו הזמן שבו הכבאית נוצרה, ספריית סולם הייתה בגרסה 3.1.0. מכיוון שהכבאית משתמשמת בפונקציונליות שהוצגה בגרסה 3.1.0, ניתן לציין את התלות של ספריית כבאית בספריית סולם כגדול או שווה לגרסה מספר 3.1.0 אך פחות מ 4.0.0. עכשיו כאשר גרסת סולם מספר 3.1.1 ומספר 3.2.0 מתפרסמות, אפשר להשתמש בהן בספריית הכבאית בבטחה, ולדעת שהן תהיינה תואמות את ה API הקיים של הספרייה עליו אנו מסתמכים בספריית הכבאית שלנו.

כמפתח אחראי תוכל, כמובן, לוודא כי כל שדרוגי החבילה מתפקדים כפי שפורסם. העולם האמיתי הינו מקום מבולגן; אין שום דבר שאנחנו יכולים לעשות לגבי זה למעט להיות על המשמר. מה שאתה יכול לעשות זה לתת למפרט הגרסאות הסמנטיות לספק לך דרך שפויה לשחרר ולשדרג חבילות מבלי לגלגל גרסה חדשה של חבילות תלויות, מה שחוסך לך זמן וטרחה.

אם כל זה נשמע טוב, כל מה שאתה צריך לעשות כדי להתחיל להשתמש בגרסאות סמנטיות הוא להכריז שאתה עושה כך, ולאחר מכן להקפיד על הכללים. כלול קישור לאתר זה בקובץ ה-README שלך כדי שאחרים ידעו את הכללים ויוכלו להפיק מהם תועלת.

שאלות נפוצות

כיצד עלי להתמודד עם תיקונים בשלב הפיתוח הראשוני O.y.z?

הדבר הפשוט ביותר לעשות הוא להתחיל לשחרר את הפיתוח הראשוני שלך בגרסה 0.1.0 ואז להגדיל את הגרסה המשנית (Minor) לכל גרסה שבא אחריה.

איך אדע מתי אוכל לשחרר את גרסה 1.0.0?

אם התוכנה שלך נמצאת בשימוש בשימוש לקוחות אמיתיים (Production), אתה כנראה צריך להיות כבר בגרסה 1.0.0. אם יש לך API יציב שעליו המשתמש יכול לסמוך, אתה צריך להיות על גרסה 1.0.0. אם אתה דואג הרבה לגבי תאימות לאחור, אתה בוודאי כבר צריך להיות בגרסה 1.0.0.

האם זה לא מונע פיתוח מהיר?

כל העניין של גרסה ראשית (Major) אפס הוא פיתוח מהיר. אם אתה משנה את ה API כל יום אתה צריך להיות על גרסה 0.z.y או על ענף פיתוח נפרד בשביל הגרסה ראשית (Major) הבאה.

אם אפילו השינויים הקטנים ביותר ל API ששוברים תמיכה לאחור מחייבים להעלות גרסה ראשית, האם אני לא אגיע מהר מאוד לגרסה 42.0.0?

זוהי שאלה של פיתוח אחראי וראיית הנולד. שינויים ששוברים תמיכה צריכים לקרות בצורה קלילה לתוכנה בעלת הרבה תלויות. העלות שנגרמת משדרוג יכולה להיות משמעותית. מכיוון שאתה חייב להעלות גרסה ראשית (Major) כדי לשחרר שינויים שוברי תאימות, אתה תחשוב היטב על ההשפעה של השינויים שלך, ותעריך את יחס העלות ― תועלת המעורב בכך.

תיעוד כל הAPI הציבורי זה יותר מדי עבודה!

זוהי האחריות שלך בתור מפתח מקצועי לתעד תוכנה שמיועדת לשימוש על ידי אחרים. ניהול המורכבות של התכונה הינו חשוב מאין כמוהו לשמירת הפרויקט יעיל, וזה משהו שקשה לעשות אם אף אחד לא יודע כיצד להשתמש בתוכנה שלך, או לאיזה מתודות אפשר לקרוא בבטחה. בטווח הארוך, גרסאות סמנטיות, וההתעקשות על API מוגדר היטב יכול לשמור על כולם והכל יפעל בצורה חלקה.

מה עלי לעשות אם בטעות שחררתי שינויים לא תואמים אחורה כגרסה משנית (Minor)?

ברגע שאתה מבין ששברת את מפרט הגרסאות הסמנטיות, תקן את הבעיה ושחרר גרסה משנית (Minor) חדשה עם שחזור התאימות לאחור. אפילו בנסיבות כאלו זה בלתי מקובל לשנות תוכן של גרסאות קיימות. אם זה מתאים, תעד את הגרסה הסוררת ויידע את המשתמשים שלך על הבעיה כדי שיהיו מודעים לבעיה שבגרסה זו.

מה עלי לעשות אם אני מעדכן את התלויות שלי מבלי לשנות את ה API הציבורי?

זה יחשב כתואם מכיוון שזה לא משפיע על ה API הציבורי. תוכנה שתלויה באופן מפורש באותן תלויות בהן התוכנה שלך תלויה צריכה לכלול מפרט תלויות משלה והמחבר של אותה התוכנה יבחין בקונפליקטים. קביעה האם מדובר בשינוי ברמת תיקון (Patch) או ברמה משנית (Minor) תלויה בהאם אתה מעדכן את התלויות שלך כדי לתקן באג או להציג פונקציונליות חדשה. בדרך כלל בהוספת פונקציונליות צפוי גם קוד נוסף, ובמקרה כזה זה כמובן מצריך העלה של גרסה משנית (Minor).

מה אם אני משנה בטעות את ה API הציבורי באופן שאינו תואם עם שינוי מספר הגרסה (למשל קוד מציג שינוי שובר תאימות ראשי (Major) בשחרור בעל שינוי בגרסת התיקון (Patch) בלבד)

השתמש בשיקול הדעת שלך. אם יש לך קהל ענק שיושפע באופן גדול משינוי ההתנהגות אחורה לכוונה המקורית של ה API הציבורי, אז יכול להיות שהכי טוב יהיה לבצע שחרור של גרסה ראשית (Major), אפילו אם התיקון יכול להיחשב כגרסת תיקון (Patch) בלבד. זכור, ניהול גרסאות סמנטי הוא העברת מסר באמצעות הצורה שמספר הגרסה משתנה. אם השינויים האלה חשובים למשתמשים שלך, השתמש במספר הגרסה כדי ליידע אותם.

איך אני צריך לטפל ב deprecating?

פונקציונליות שהופכת לdeprecated (מיושנת) הינו תהליך נורמלי בפיתוח תוכנה, ולפעמים הוא אף נדרש כדי להתקדם. כאשר אתה הופך חלק מה API הציבורי שלך לdeprecated, אתה צריך לעשות שני דברים: (1) לעדכן את התיעוד שלך כדי לתת למשתמשים לדעת על השינוי (2) לשחרר גרסה משנית (Minor) עם הפונקציונליות שבמצב deprecated. לפי שאתה מסיר לחלוטין את הפונקציונליות הזאת בגרסה ראשית (Major) חדשה, צריכה להיות לפחות גרסה אחת משנית (Minor) שמכילה את הפונקציונליות עם הודעת הdeprecated כדי שהמשתמשים יוכלו לעבור בקלות ל API החדש.

האם ל semver יש מגבלת גודל על ה String של הגרסה?

לא, אבל הפעל שיקול דעת. לדוגמה, מחרוזת גרסה בעלת 255 תווים היא כנראה מוגזמת. כמו כן, מערכות ספציפיות עשויות להטיל מגבלות משלהן על גודל המחרוזת.

האם “v1.2.3” היא גרסה סמנטית?

לא, “v1.2.3” אינו גרסה סמנטית. עם זאת, קידומת “v” לגרסה סמנטית היא דרך נפוצה (באנגלית) לציין מספר גרסה.
לעתים קיצור המילה “גרסה”  (version)כ-“v” מופיע בניהול גרסאות.

האם יש ביטוי רגולרי (RegEx) מומלץ לבדיקת גרסה סמנטית?

יש שניים. אחד עם קבוצות שמות (מערכות תומכות:PCRE, Perl, PHP, R, Python  ו-Go), כאן: https://regex101.com/r/Ly7O1x/3

ואחד עם קבוצות לכידה ממוספרות (תואם ל-ECMA Script (JavaScript), PCRE, Perl, PHP, R, Python ו-Go), כאן: https://regex101.com/r/vkijKf/1

אודות

מפרט הגרסאות הסמנטיות נכתב על ידי טום פרסון-ורנר, ממציא ה Gravatars וממייסדי GitHub.

אם אתה רוצה להשאיר משוב, אנא פתח issue ב GitHub.

רישיון

Creative Commons ― CC BY 3.0\nבהינתן מספר גרסה MAJOR.MINOR.PATCH, העלה את:\nגרסה ראשית (MAJOR) כאשר אתה עושה שינויים שאינם עולים בקנה אחד עם ה API\nגרסה משנית (MINOR) כשאר אתה מוסיף פונקציונאליות בצורה שתואמת אחורנית\nגרסת תיקון (PATCH) כאשר אתה מבצע תיקוני באגים שתואמים אחורנית\nתוויות נוספות עבור גרסאות קדם הפצה ובניית מטא-דאטה זמינות כתוספת לפורמט MAJOR.MINOR.PATCH.\nבעולם של ניהול תוכנה קיים מקום מפחיד בשם “גיהנום התלויות (dependency hell)”. ככל שהמערכת גדלה ואתה משלב יותר ויותר חבילות לתוכנה, קיים סיכוי גבוה יותר שתמצא את עצמך, יום אחד, בבור של יאוש.\nבתוכנות עם המון תלויות, שחרור גרסה של חבילה חדשה יכול במהירות להפוך לסיוט. אם מפרט התלויות הדוק מידי, אתה בסכנה של “נעילת גרסה (version lock)” (חוסר היכולת לשדרג חבילה מבלי לשחרר גרסה חדשה של כל חבילה תלויה). אם מפרט התלויות רופף מידי, באופן בלתי נמנע אתה תכווה ע”י “מתירנות גרסה (version promiscuity)” (השערה של תאימות, יותר מהסביר, עם גרסאות עתידיות). “גיהנום התלויות” הוא כאשר אתה נמצא במקום בו נעילת גרסה ו/או מתירנות גרסה מונעים ממך להניע את הפרויקט שלך קדימה בקלות ובבטחה.\nעל מנת לפתור בעיה זו, מוצע סט פשוט של כללים ודרישות המכתיבים כיצד מספרי גרסאות יוקצו ויוגדלו. כללים אלה מבוססים על מנהגים משותפים, קיימים ונפוצים בפרויקטי קוד פתוח וסגור. על מנת שמערכת זו תעבוד, תחילה צריך להכריז על API ציבורי. זה אולי יהיה מורכב מתיעוד או יאכף על ידי הקוד עצמו. בכל מקרה, זה חשוב שה API יהיה ברור ומדויק. ברגע שאתה מגדיר את ה API הציבורי שלך, אתה מתקשר בו את השינויים עם תוספות ספציפיות למספר הגרסה. הסתכל על תבנית גרסה של X.Y.Z (בפורמט Major.Minor.Patch). תיקוני באגים שלא משפיעים על ה API יגדילו את מספר את מספר התיקון (Patch), תוספות / שינויים תואמי API לאחור יגדילו את הגרסה המשנית (Minor), ושינויים שאינם נתמכים לאחור ב API יגדילו את הגרסה הראשית (Major).\nאני קורא למערכת “גרסאות סמנטיות”. במסגרת זו, מספרי גרסאות והדרך שבה הם משתנים מעבירה משמעות על הקוד ועל מה שהשתנה מגרסה אחת לאחרת.\nמפרט גרסאות סמנטיות (SemVer)\nמילות המפתח “חייב (MUST)”, “אסור (MUST NOT)”, “חובה (REQUIRED)”, “תהא (SHALL)”, “לא (SHALL NOT)”, “צריך (SHOULD)”, “לא צריך (SHOULD NOT)”, “מומלץ (RECOMMENDED)”, “יכול (MAY)”, “אפשרי (OPTIONAL)” אשר מופיעות במסמך, צריכות להיות מפורשות כמתואר במסמך RFC 2119.\nתוכנה באמצעות גרסאות סמנטיות נדרשת להכריז על API ציבורי. ניתן להכריז על API זה בקוד עצמו או אך ורק בתיעוד. עם זאת זה צריך להיעשות מדויק ומקיף.\nתוכנה באמצעות גרסאות סמנטיות נדרשת להכריז על API ציבורי. ניתן להכריז על API זה בקוד עצמו או אך ורק בתיעוד. עם זאת זה צריך להיעשות מדויק ומקיף.\nמספר גרסה רגילה חייב (MUST) להיות בצורה X.Y.Z כאשר Y, X, ו Z הם מספרים שלמים (Integers) שאינם שליליים, ואסור (Must Not) שיכילו אפסים מובילים. X הוא גרסה ראשית (Major), לאחריו Y הוא גרסה משנית (Minor), ולבסוף Z הוא גרסת תיקון (Patch).
כל רכיב במספר הגרסה חייב (MUST) להגדיל את המספר נומרית. לדוגמה: 1.9.0 -> 1.10.0 -> 1.11.0.\nמספר גרסה רגילה חייב (MUST) להיות בצורה X.Y.Z כאשר Y, X, ו Z הם מספרים שלמים (Integers) שאינם שליליים, ואסור (Must Not) שיכילו אפסים מובילים. X הוא גרסה ראשית (Major), לאחריו Y הוא גרסה משנית (Minor), ולבסוף Z הוא גרסת תיקון (Patch).
כל רכיב במספר הגרסה חייב (MUST) להגדיל את המספר נומרית. לדוגמה: 1.9.0 -> 1.10.0 -> 1.11.0.\nלאחר שחבילה שוחררה, אסור לשנות את התוכן של החבילה באותה גרסה. כל שינוי חייב להשתחרר כגרסה חדשה.\nלאחר שחבילה שוחררה, אסור לשנות את התוכן של החבילה באותה גרסה. כל שינוי חייב להשתחרר כגרסה חדשה.\nגרסה ראשית אפס (0.z.y) היא עבור פיתוח ראשוני. בהינתן שכל דבר יכול להשתנות בכל זמן, ה API הציבורי לא צריך להיחשב יציב.\nגרסה ראשית אפס (0.z.y) היא עבור פיתוח ראשוני. בהינתן שכל דבר יכול להשתנות בכל זמן, ה API הציבורי לא צריך להיחשב יציב.\nגרסה 1.0.0 מגדירה את ה API הציבורי. הדרך שבה מספר הגרסה עולה לאחר שחרור גרסה זו תלוי ב-API הציבורי ובאופן בו הוא משתנה.\nגרסה 1.0.0 מגדירה את ה API הציבורי. הדרך שבה מספר הגרסה עולה לאחר שחרור גרסה זו תלוי ב-API הציבורי ובאופן בו הוא משתנה.\nגרסת תיקון (Patch) במיקום Z (כלומר x > 0
          Z.y.x) חייבת לעלות אם ורק אם הוצגו תיקוני באגים תואמים לאחור. תיקון באג שתואם לאחור מוגדר כשינוי פנימי שמתקן התנהגות לא נכונה.\nגרסת תיקון (Patch) במיקום Z (כלומר x > 0\nZ.y.x) חייבת לעלות אם ורק אם הוצגו תיקוני באגים תואמים לאחור. תיקון באג שתואם לאחור מוגדר כשינוי פנימי שמתקן התנהגות לא נכונה.\nגרסה משנית (Minor) במיקום Y (כלומר x > 0
          z.Y.x) חייבת לעלות שינויי פונקציונאליות חדש, תואם אחורה, שהוצג ב API הציבורי. הוא חייב (MUST) לעלות אם פונקציונאליות כלשהי ב API הציבורי הוגדרה כ-deprecated. הוא יכול (MAY) לעלות אם הוצגו שינויים או חידושיים משמעותיים בתוך הקוד הפרטי. הוא יכול (MAY) לכלול שינויים ברמת תיקון (Patch). מספר הגרסה ברמת תיקון (Patch) חייב (MUST) להיות מאופס ל-0 כאשר מספר הגרסה המשנית (Minor) עולה.\nגרסה משנית (Minor) במיקום Y (כלומר x > 0\nz.Y.x) חייבת לעלות שינויי פונקציונאליות חדש, תואם אחורה, שהוצג ב API הציבורי. הוא חייב (MUST) לעלות אם פונקציונאליות כלשהי ב API הציבורי הוגדרה כ-deprecated. הוא יכול (MAY) לעלות אם הוצגו שינויים או חידושיים משמעותיים בתוך הקוד הפרטי. הוא יכול (MAY) לכלול שינויים ברמת תיקון (Patch). מספר הגרסה ברמת תיקון (Patch) חייב (MUST) להיות מאופס ל-0 כאשר מספר הגרסה המשנית (Minor) עולה.\nגרסה ראשית (Major) במיקום X (כלומר X > 0
          z.y.X) חייבת (MUST) לעלות אם הוצגו שינויים כלשהם ל API הציבורי שאינם תואמים אחורה. היא יכולה (MAY) לכלול שינויים ברמת משנית (Minor) וברמת תיקון (Patch). מספרי גרסאות ברמת תיקון (Patch) וברמה משנית (Minor) חייבים (MUST) להיות מאופסים ל 0 כאשר עולים מספר גרסה ראשית (Major).\nגרסה ראשית (Major) במיקום X (כלומר X > 0\nz.y.X) חייבת (MUST) לעלות אם הוצגו שינויים כלשהם ל API הציבורי שאינם תואמים אחורה. היא יכולה (MAY) לכלול שינויים ברמת משנית (Minor) וברמת תיקון (Patch). מספרי גרסאות ברמת תיקון (Patch) וברמה משנית (Minor) חייבים (MUST) להיות מאופסים ל 0 כאשר עולים מספר גרסה ראשית (Major).\nגרסת קדם הפצה יכולה (MAY) להיות מסומנת על ידי מקף ומזהים מופרדים בנקודות מיד לאחר גרסת התיקון (Patch). מזהים חייבים (MUST) להיות מורכבים מאותיות, מקף, ומספרים בתקן ASCII בלבד [0-9A-Za-z-]. אסור שהמזהה יהיה ריק. אסור שמזהים מספריים יכילו אפסים מובילים. לגרסאות קדם הפצה יש זכות נמוכה מלגרסאות רגילות. גרסת קדם הפצה מציינת כי הגרסה אינה יציבה ויכול להיות שלא תספק את הדרישות כמו גרסה רגילה. דוגמאות: 1.0.0-alpha,  1.0.0-alpha.1,   1.0.0-0.3.7,   1.0.0-x.7.z.92\nגרסת קדם הפצה יכולה (MAY) להיות מסומנת על ידי מקף ומזהים מופרדים בנקודות מיד לאחר גרסת התיקון (Patch). מזהים חייבים (MUST) להיות מורכבים מאותיות, מקף, ומספרים בתקן ASCII בלבד [0-9A-Za-z-]. אסור שהמזהה יהיה ריק. אסור שמזהים מספריים יכילו אפסים מובילים. לגרסאות קדם הפצה יש זכות נמוכה מלגרסאות רגילות. גרסת קדם הפצה מציינת כי הגרסה אינה יציבה ויכול להיות שלא תספק את הדרישות כמו גרסה רגילה. דוגמאות: 1.0.0-alpha,  1.0.0-alpha.1,   1.0.0-0.3.7,   1.0.0-x.7.z.92\n1.0.0-alpha,  1.0.0-alpha.1,   1.0.0-0.3.7,   1.0.0-x.7.z.92\nגרסה בעלת מטא נתונים (metadata build) יכולה (MAY) להיות מסומנת על ידי סימן פלוס ומזהים המפורדים בנקודות הבאים מיד לאחר גרסת התיקון (Patch) או גרסת קדם הפצה. מזהים חייבים (MUST) להיות מורכבים מאותיות, מקף, ומספרים בתקן ASCII בלבד [0-9A-Za-z-]. אסור שהמזהה יהיה ריק. בעת קביעת עדיפות גרסה צריך (SHOULD) להתעלם מגרסת מטא נתונים. לשתי גרסאות שההבדל היחיד ביניהן הוא גרסת המטא נתונים יש אותה עדיפות. דוגמאות: 1.0.0-alpha+001,  1.0.0+20130313144700,   1.0.0-beta+exp.sha.5114f85\nגרסה בעלת מטא נתונים (metadata build) יכולה (MAY) להיות מסומנת על ידי סימן פלוס ומזהים המפורדים בנקודות הבאים מיד לאחר גרסת התיקון (Patch) או גרסת קדם הפצה. מזהים חייבים (MUST) להיות מורכבים מאותיות, מקף, ומספרים בתקן ASCII בלבד [0-9A-Za-z-]. אסור שהמזהה יהיה ריק. בעת קביעת עדיפות גרסה צריך (SHOULD) להתעלם מגרסת מטא נתונים. לשתי גרסאות שההבדל היחיד ביניהן הוא גרסת המטא נתונים יש אותה עדיפות. דוגמאות: 1.0.0-alpha+001,  1.0.0+20130313144700,   1.0.0-beta+exp.sha.5114f85\n1.0.0-alpha+001,  1.0.0+20130313144700,   1.0.0-beta+exp.sha.5114f85\nעדיפות מתייחסת לאופן בו משווים גרסאות זה לזה כאשר הם מסודרים. עדיפות חייבת (MUST) להיות מחושבת על ידי הפרדת הגרסה לראשי (Major), משני (Minor), תיקון (Patch) ומזהי קדם הפצה בסדר הזה (נתוני מטה אינם נלקחים בחשבון בעדיפות). העדיפות נקבעת על ידי ההבדל הראשון כאשר משווים את כל המזהים מספרית משמאל לימין כדלקמן: ראשי (Major), משני (Minor) ותיקון (Patch) תמיד משווים מספרית. דוגמה 2.1.1 > 2.1.0 > 2.0.0 > 1.0.0. כאשר ראשי (Major), משני (Minor) ותיקון (Patch) שווים, ולגרסת קדם הפצה יש עדיפות נמוכה יותר מאשר לגרסה רגילה. דוגמה ֿ1.0.0 > 1.0.0-alpha. עדיפות עבור שתי גרסאות קדם הפצה עם גרסאות ראשי (Major), משני (Minor), תיקון (Patch) זהים חייב (MUST) להיקבע על ידי השוואה של מזהה בין הנקודות משמאל לימין עד שנמצא הבדל כדלקמן: מזהים המורכבים מספרות בלבד משווים בצורה מספרית (נומרית) ומזהים עם אותיות או מקפים משווים לקסיקלית בסדר מיון של תקן ASCII. למזהים מספריים תמיד תהיה עדיפות נמוכה ממזהים שאינם מספריים. לקבוצה גדולה יותר של מזהים בגרסת קדם הפצה יש עדיפות גבוהה יותר מקבוצה קטנה יותר, אם כל אמצעי ההשוואה למזהים שקדמו שווים. דוגמאות: 1.0.0 > 1.0.0-rc.1 > 1.0.0-beta.11 > 1.0.0-beta.2 > 1.0.0-beta > 1.0.0-alpha.beta > 1.0.0-alpha.1 > 1.0.0-alpha\n1.0.0 > 1.0.0-rc.1 > 1.0.0-beta.11 > 1.0.0-beta.2 > 1.0.0-beta > 1.0.0-alpha.beta > 1.0.0-alpha.1 > 1.0.0-alpha\nלמה להשתמש בגרסאות סמנטיות?\nזה לא רעיון חדש או מהפכני. למעשה, כנראה שאתה עושה משהו קרוב לזה כבר עכשיו. הבעיה היא ש”קרוב” זה לא מספיק טוב. ללא תאימות כלשהי למפרט פורמלי, מספרי גרסה הם למעשה חסרי תועלת לניהול תלויות. על ידי מתן שם ברור והגדרה ברורה לרעיונות שהוצגו כאן, תקשור הכוונות שלנו למשתמשי התוכנה נעשה קל יותר. לאחר שהכוונות האלו ברורות וגמישות (אבל לא גמישות מידי), יכול בסופו של דבר להתבצע מפרט תלויות.\nדוגמא פשוטה תדגים כיצד גרסאות סמנטיות יכולות להפוך את “גהינום התלויות” לנחלת העבר. דמיינו ספריה בשם “כבאית”. שדורשת ספרייה בשם “סולם” שעומדת במפרט של גרסאות סמנטיות. באותו הזמן שבו הכבאית נוצרה, ספריית סולם הייתה בגרסה 3.1.0. מכיוון שהכבאית משתמשמת בפונקציונליות שהוצגה בגרסה 3.1.0, ניתן לציין את התלות של ספריית כבאית בספריית סולם כגדול או שווה לגרסה מספר 3.1.0 אך פחות מ 4.0.0. עכשיו כאשר גרסת סולם מספר 3.1.1 ומספר 3.2.0 מתפרסמות, אפשר להשתמש בהן בספריית הכבאית בבטחה, ולדעת שהן תהיינה תואמות את ה API הקיים של הספרייה עליו אנו מסתמכים בספריית הכבאית שלנו.\nכמפתח אחראי תוכל, כמובן, לוודא כי כל שדרוגי החבילה מתפקדים כפי שפורסם. העולם האמיתי הינו מקום מבולגן; אין שום דבר שאנחנו יכולים לעשות לגבי זה למעט להיות על המשמר. מה שאתה יכול לעשות זה לתת למפרט הגרסאות הסמנטיות לספק לך דרך שפויה לשחרר ולשדרג חבילות מבלי לגלגל גרסה חדשה של חבילות תלויות, מה שחוסך לך זמן וטרחה.\nאם כל זה נשמע טוב, כל מה שאתה צריך לעשות כדי להתחיל להשתמש בגרסאות סמנטיות הוא להכריז שאתה עושה כך, ולאחר מכן להקפיד על הכללים. כלול קישור לאתר זה בקובץ ה-README שלך כדי שאחרים ידעו את הכללים ויוכלו להפיק מהם תועלת.\nכיצד עלי להתמודד עם תיקונים בשלב הפיתוח הראשוני O.y.z?\nהדבר הפשוט ביותר לעשות הוא להתחיל לשחרר את הפיתוח הראשוני שלך בגרסה 0.1.0 ואז להגדיל את הגרסה המשנית (Minor) לכל גרסה שבא אחריה.\nאיך אדע מתי אוכל לשחרר את גרסה 1.0.0?\nאם התוכנה שלך נמצאת בשימוש בשימוש לקוחות אמיתיים (Production), אתה כנראה צריך להיות כבר בגרסה 1.0.0. אם יש לך API יציב שעליו המשתמש יכול לסמוך, אתה צריך להיות על גרסה 1.0.0. אם אתה דואג הרבה לגבי תאימות לאחור, אתה בוודאי כבר צריך להיות בגרסה 1.0.0.\nהאם זה לא מונע פיתוח מהיר?\nכל העניין של גרסה ראשית (Major) אפס הוא פיתוח מהיר. אם אתה משנה את ה API כל יום אתה צריך להיות על גרסה 0.z.y או על ענף פיתוח נפרד בשביל הגרסה ראשית (Major) הבאה.\nאם אפילו השינויים הקטנים ביותר ל API ששוברים תמיכה לאחור מחייבים להעלות גרסה ראשית, האם אני לא אגיע מהר מאוד לגרסה 42.0.0?\nזוהי שאלה של פיתוח אחראי וראיית הנולד. שינויים ששוברים תמיכה צריכים לקרות בצורה קלילה לתוכנה בעלת הרבה תלויות. העלות שנגרמת משדרוג יכולה להיות משמעותית. מכיוון שאתה חייב להעלות גרסה ראשית (Major) כדי לשחרר שינויים שוברי תאימות, אתה תחשוב היטב על ההשפעה של השינויים שלך, ותעריך את יחס העלות ― תועלת המעורב בכך.\nתיעוד כל הAPI הציבורי זה יותר מדי עבודה!\nזוהי האחריות שלך בתור מפתח מקצועי לתעד תוכנה שמיועדת לשימוש על ידי אחרים. ניהול המורכבות של התכונה הינו חשוב מאין כמוהו לשמירת הפרויקט יעיל, וזה משהו שקשה לעשות אם אף אחד לא יודע כיצד להשתמש בתוכנה שלך, או לאיזה מתודות אפשר לקרוא בבטחה. בטווח הארוך, גרסאות סמנטיות, וההתעקשות על API מוגדר היטב יכול לשמור על כולם והכל יפעל בצורה חלקה.\nמה עלי לעשות אם בטעות שחררתי שינויים לא תואמים אחורה כגרסה משנית (Minor)?\nברגע שאתה מבין ששברת את מפרט הגרסאות הסמנטיות, תקן את הבעיה ושחרר גרסה משנית (Minor) חדשה עם שחזור התאימות לאחור. אפילו בנסיבות כאלו זה בלתי מקובל לשנות תוכן של גרסאות קיימות. אם זה מתאים, תעד את הגרסה הסוררת ויידע את המשתמשים שלך על הבעיה כדי שיהיו מודעים לבעיה שבגרסה זו.\nמה עלי לעשות אם אני מעדכן את התלויות שלי מבלי לשנות את ה API הציבורי?\nזה יחשב כתואם מכיוון שזה לא משפיע על ה API הציבורי. תוכנה שתלויה באופן מפורש באותן תלויות בהן התוכנה שלך תלויה צריכה לכלול מפרט תלויות משלה והמחבר של אותה התוכנה יבחין בקונפליקטים. קביעה האם מדובר בשינוי ברמת תיקון (Patch) או ברמה משנית (Minor) תלויה בהאם אתה מעדכן את התלויות שלך כדי לתקן באג או להציג פונקציונליות חדשה. בדרך כלל בהוספת פונקציונליות צפוי גם קוד נוסף, ובמקרה כזה זה כמובן מצריך העלה של גרסה משנית (Minor).\nמה אם אני משנה בטעות את ה API הציבורי באופן שאינו תואם עם שינוי מספר הגרסה (למשל קוד מציג שינוי שובר תאימות ראשי (Major) בשחרור בעל שינוי בגרסת התיקון (Patch) בלבד)\nהשתמש בשיקול הדעת שלך. אם יש לך קהל ענק שיושפע באופן גדול משינוי ההתנהגות אחורה לכוונה המקורית של ה API הציבורי, אז יכול להיות שהכי טוב יהיה לבצע שחרור של גרסה ראשית (Major), אפילו אם התיקון יכול להיחשב כגרסת תיקון (Patch) בלבד. זכור, ניהול גרסאות סמנטי הוא העברת מסר באמצעות הצורה שמספר הגרסה משתנה. אם השינויים האלה חשובים למשתמשים שלך, השתמש במספר הגרסה כדי ליידע אותם.\nאיך אני צריך לטפל ב deprecating?\nפונקציונליות שהופכת לdeprecated (מיושנת) הינו תהליך נורמלי בפיתוח תוכנה, ולפעמים הוא אף נדרש כדי להתקדם. כאשר אתה הופך חלק מה API הציבורי שלך לdeprecated, אתה צריך לעשות שני דברים: (1) לעדכן את התיעוד שלך כדי לתת למשתמשים לדעת על השינוי (2) לשחרר גרסה משנית (Minor) עם הפונקציונליות שבמצב deprecated. לפי שאתה מסיר לחלוטין את הפונקציונליות הזאת בגרסה ראשית (Major) חדשה, צריכה להיות לפחות גרסה אחת משנית (Minor) שמכילה את הפונקציונליות עם הודעת הdeprecated כדי שהמשתמשים יוכלו לעבור בקלות ל API החדש.\nהאם ל semver יש מגבלת גודל על ה String של הגרסה?\nלא, אבל הפעל שיקול דעת. לדוגמה, מחרוזת גרסה בעלת 255 תווים היא כנראה מוגזמת. כמו כן, מערכות ספציפיות עשויות להטיל מגבלות משלהן על גודל המחרוזת.\nהאם “v1.2.3” היא גרסה סמנטית?\nלא, “v1.2.3” אינו גרסה סמנטית. עם זאת, קידומת “v” לגרסה סמנטית היא דרך נפוצה (באנגלית) לציין מספר גרסה.
לעתים קיצור המילה “גרסה”  (version)כ-“v” מופיע בניהול גרסאות.\nהאם יש ביטוי רגולרי (RegEx) מומלץ לבדיקת גרסה סמנטית?\nיש שניים. אחד עם קבוצות שמות (מערכות תומכות:PCRE, Perl, PHP, R, Python  ו-Go), כאן: https://regex101.com/r/Ly7O1x/3\nhttps://regex101.com/r/Ly7O1x/3\nואחד עם קבוצות לכידה ממוספרות (תואם ל-ECMA Script (JavaScript), PCRE, Perl, PHP, R, Python ו-Go), כאן: https://regex101.com/r/vkijKf/1\nhttps://regex101.com/r/vkijKf/1\nמפרט הגרסאות הסמנטיות נכתב על ידי טום פרסון-ורנר, ממציא ה Gravatars וממייסדי GitHub.\nאם אתה רוצה להשאיר משוב, אנא פתח issue ב GitHub.\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nअर्थपूर्ण संस्करण 2.0.0

सारांश

एक संस्करण संख्या MAJOR.MINOR.PATCH को देखते हुए, वृद्धि:


  जब आप असंगत एपीआई परिवर्तन करते हैं तो प्रमुख संस्करण,
  MINOR संस्करण जब आप पिछड़े-संगत तरीके से कार्यक्षमता जोड़ते हैं, और
  जब आप पीछे-संगत बग फिक्स करते हैं तो पैच संस्करण।


प्री-रिलीज और मेटाडेटा के लिए अतिरिक्त लेबल MAJOR.MINOR.PATCH प्रारूप में एक्सटेंशन के रूप में उपलब्ध हैं।

परिचय

सॉफ्टवेयर प्रबंधन की दुनिया में “निर्भरता नरक” नामक एक डरावनी जगह मौजूद है। आपका सिस्टम बड़ा हो जाता है और जितना अधिक पैकेज आप अपने सॉफ़्टवेयर में एकीकृत करते हैं, उतना ही अधिक आप निराशा के इस गड्ढे में खुद को ढूंढने की संभावना रखते हैं।

कई निर्भरताओं वाले सिस्टम में, नए पैकेज संस्करण जारी करने से जल्दी ही एक दुःस्वप्न बन सकता है। यदि निर्भरता विनिर्देश बहुत तंग हैं, तो आप संस्करण लॉक (प्रत्येक आश्रित पैकेज के नए संस्करणों को जारी किए बिना पैकेज को अपग्रेड करने में असमर्थता) के खतरे में हैं। यदि निर्भरताओं को बहुत कम निर्दिष्ट किया गया है, तो आप अनिवार्य रूप से संस्करण संविधान द्वारा काट लेंगे (उचित से अधिक भविष्य के संस्करणों के साथ संगतता मानते हैं)। निर्भरता नरक वह जगह है जहां आप संस्करण लॉक और / या संस्करण संविधान आपको अपने प्रोजेक्ट को आगे और आसानी से स्थानांतरित करने से रोकते हैं।

इस समस्या के समाधान के रूप में, मैं नियमों और आवश्यकताओं का एक सरल सेट प्रस्तावित करता हूं जो निर्देश देते हैं कि संस्करण संख्याएं कैसे आवंटित की जाती हैं और वृद्धि हुई हैं। ये नियम बंद और खुले स्रोत सॉफ्टवेयर दोनों में उपयोग में पूर्व-मौजूदा व्यापक सामान्य प्रथाओं तक सीमित नहीं हैं, बल्कि यह आवश्यक नहीं हैं। इस प्रणाली के लिए काम करने के लिए, आपको सबसे पहले एक सार्वजनिक एपीआई घोषित करने की आवश्यकता है। इसमें दस्तावेज शामिल हो सकते हैं या कोड द्वारा ही लागू किया जा सकता है। भले ही, यह महत्वपूर्ण है कि यह एपीआई स्पष्ट और सटीक हो। एक बार जब आप अपनी सार्वजनिक एपीआई की पहचान कर लेंगे, तो आप अपने संस्करण संख्या में विशिष्ट वृद्धि के साथ इसमें परिवर्तनों को संवाद करेंगे। XYZ (Major.Minor.Patch) के संस्करण प्रारूप पर विचार करें। बग फिक्स एपीआई वृद्धि को प्रभावित नहीं करते हैं, पैच संस्करण, पिछड़ा संगत एपीआई जोड़ / परिवर्तन मामूली संस्करण में वृद्धि करता है, और पीछे की असंगत एपीआई परिवर्तन प्रमुख संस्करण में वृद्धि करता है।

मैं इस प्रणाली को “अर्थपूर्ण संस्करण” कहता हूं। इस योजना के तहत, संस्करण संख्याएं और जिस तरह से वे बदलते हैं, अंतर्निहित कोड के बारे में अर्थ बताते हैं और एक संस्करण से अगले संस्करण में क्या संशोधित किया गया है।

अर्थपूर्ण संस्करण विशिष्टता (सेमवीर)

मुख्य शब्द “जरूरी”, “आवश्यक नहीं”, “आवश्यक”, “साझा करें”, “नहीं होगा”, “चाहिए”, “नहीं होना चाहिए”, “अनुशंसित”, “मई” और “वैकल्पिक” इस दस्तावेज़ में हैं आरएफसी 2119 में वर्णित के रूप में व्याख्या किया जाना है ।


  
    अर्थपूर्ण संस्करण का उपयोग कर सॉफ्टवेयर एक सार्वजनिक एपीआई घोषित करना चाहिए। इस एपीआई को कोड में ही घोषित किया जा सकता है या दस्तावेज़ीकरण में सख्ती से मौजूद है। हालांकि यह किया जाता है, यह सटीक और व्यापक होना चाहिए।
  
  
    एक सामान्य संस्करण संख्या को XYZ फॉर्म लेना चाहिए जहां एक्स, वाई, और जेड गैर-ऋणात्मक पूर्णांक हैं, और इसमें प्रमुख शून्य शामिल नहीं होनी चाहिए। एक्स प्रमुख संस्करण है, वाई मामूली संस्करण है, और जेड पैच संस्करण है। प्रत्येक तत्व संख्यात्मक रूप से बढ़ना चाहिए। उदाहरण के लिए: 1.9.0 -> 1.10.0 -> 1.11.0।
  
  
    एक बार एक संस्करण पैकेज जारी किया गया है, उस संस्करण की सामग्री को संशोधित नहीं किया जाना चाहिए। किसी भी संशोधन को एक नए संस्करण के रूप में जारी किया जाना चाहिए।
  
  
    प्रमुख संस्करण शून्य (0.yz) प्रारंभिक विकास के लिए है। कुछ भी किसी भी समय बदल सकता है। सार्वजनिक एपीआई को स्थिर नहीं माना जाना चाहिए।
  
  
    संस्करण 1.0.0 सार्वजनिक एपीआई को परिभाषित करता है। इस रिलीज के बाद जिस संस्करण में संस्करण संख्या बढ़ी है, इस सार्वजनिक एपीआई पर निर्भर है और यह कैसे बदलता है।
  
  
    
      
        
          पैच संस्करण जेड (xyZ
          x> 0) केवल पिछड़ा संगत बग फिक्स पेश किए जाने पर वृद्धि की जानी चाहिए। एक बग फिक्स को आंतरिक परिवर्तन के रूप में परिभाषित किया जाता है जो गलत व्यवहार को हल करता है।
        
      
    
  
  
    
      
        
          छोटे संस्करण वाई (xYz
          x> 0) को बढ़ाया जाना चाहिए यदि सार्वजनिक, एपीआई के लिए नई, पिछली संगत कार्यक्षमता पेश की गई हो। यदि किसी भी सार्वजनिक एपीआई कार्यक्षमता को बहिष्कृत के रूप में चिह्नित किया गया है तो इसे बढ़ाया जाना चाहिए। निजी कोड के भीतर पर्याप्त नई कार्यक्षमता या सुधार पेश किए जाने पर यह बढ़ाई जा सकती है। इसमें पैच स्तर परिवर्तन शामिल हो सकते हैं। छोटे संस्करण को बढ़ाए जाने पर पैच संस्करण को 0 पर रीसेट किया जाना चाहिए।
        
      
    
  
  
    
      
        
          प्रमुख संस्करण एक्स (Xyz
          X> 0) को बढ़ाया जाना चाहिए यदि सार्वजनिक एपीआई में कोई पिछड़ा असंगत परिवर्तन पेश किया गया हो। इसमें मामूली और पैच स्तर परिवर्तन शामिल हो सकते हैं। जब बड़े संस्करण में वृद्धि हुई है तो पैच और मामूली संस्करण को 0 पर रीसेट किया जाना चाहिए।
        
      
    
  
  
    एक प्री-रिलीज संस्करण पैच संस्करण के तुरंत बाद एक हाइफ़न और डॉट अलग पहचानकर्ताओं की एक श्रृंखला को जोड़कर दर्शाया जा सकता है। पहचानकर्ताओं में केवल एएससीआईआई अल्फान्यूमेरिक्स और हाइफ़न [0-9 ए-ज़ा-जेड-] शामिल होना चाहिए। पहचानकर्ता खाली नहीं होना चाहिए। संख्यात्मक पहचानकर्ताओं में अग्रणी शून्य शामिल नहीं होना चाहिए। प्री-रिलीज संस्करणों में संबंधित सामान्य संस्करण की तुलना में कम प्राथमिकता है। एक प्री-रिलीज संस्करण इंगित करता है कि संस्करण अस्थिर है और इसके अनुरूप सामान्य संस्करण द्वारा बताए गए इच्छित संगतता आवश्यकताओं को पूरा नहीं कर सकता है। उदाहरण: 1.0.0-अल्फा, 1.0.0-अल्फा .1, 1.0.0-0.3.7, 1.0.0-x.7.z.92।
  
  
    पैच या प्री-रिलीज संस्करण के तुरंत बाद एक प्लस साइन और डॉट से अलग पहचानकर्ताओं की एक श्रृंखला को जोड़कर मेटाडाटा मई को इंगित किया जा सकता है। पहचानकर्ताओं में केवल एएससीआईआई अल्फान्यूमेरिक्स और हाइफ़न [0-9 ए-ज़ा-जेड-] शामिल होना चाहिए। पहचानकर्ता खाली नहीं होना चाहिए। संस्करण प्राथमिकता निर्धारित करते समय मेटाडेटा को अनदेखा किया जाना चाहिए। इस प्रकार दो संस्करण जो बिल्ड मेटाडेटा में भिन्न होते हैं, वही प्राथमिकता रखते हैं। उदाहरण: 1.0.0-अल्फा + 001, 1.0.0 + 20130313144700, 1.0.0-बीटा + exp.sha.5114f85।
  
  प्राथमिकता यह दर्शाती है कि आदेश दिए जाने पर संस्करणों की तुलना एक दूसरे से कैसे की जाती है। प्राथमिकता को उस क्रम में प्रमुख, मामूली, पैच और प्री-रिलीज पहचानकर्ताओं में संस्करण को अलग करके गणना की जानी चाहिए (मेटाडाटा बनाएं प्राथमिकता में नहीं है)। प्राथमिकता को पहले अंतर से निर्धारित किया जाता है जब इन पहचानकर्ताओं में से प्रत्येक को बाएं से दाएं से तुलना करें: मेजर, नाबालिग और पैच संस्करणों की तुलना हमेशा संख्यात्मक रूप से की जाती है। उदाहरण: 1.0.0 <2.0.0 <2.1.0 <2.1.1। जब प्रमुख, नाबालिग और पैच बराबर होते हैं, तो प्री-रिलीज़ संस्करण में सामान्य संस्करण की तुलना में कम प्राथमिकता होती है। उदाहरण: 1.0.0-अल्फा <1.0.0। एक ही प्रमुख, नाबालिग और पैच संस्करण के साथ दो प्री-रिलीज संस्करणों की प्राथमिकता प्रत्येक डॉट से अलग पहचानकर्ता को बाएं से दाएं की तुलना करके निर्धारित किया जाना चाहिए जब तक कोई अंतर निम्नानुसार नहीं मिलता है: केवल अंकों की पहचान करने वाले पहचानकर्ताओं की संख्या संख्यात्मक रूप से तुलना की जाती है और अक्षरों या हाइफ़न वाले पहचानकर्ताओं की तुलना एएससीआईआई क्रमबद्ध क्रम में तुलनात्मक रूप से की जाती है। गैर-संख्यात्मक पहचानकर्ताओं की तुलना में संख्यात्मक पहचानकर्ताओं की हमेशा कम प्राथमिकता होती है। प्री-रिलीज फ़ील्ड्स का एक बड़ा सेट एक छोटे से सेट की तुलना में अधिक प्राथमिकता है, यदि पिछले सभी पहचानकर्ता बराबर हैं। उदाहरण: 1.0.0-अल्फा <1.0.0-alpha.1 <1.0.0-alpha.beta <1.0.0-beta <1.0.0-beta.2 <1.0.0-beta.11 <1.0.0- आरसी .1 <1.0.0।


अर्थपूर्ण संस्करण का उपयोग क्यों करें?

यह एक नया या क्रांतिकारी विचार नहीं है। असल में, आप शायद पहले से ही कुछ करीब कर सकते हैं। समस्या यह है कि “करीबी” पर्याप्त नहीं है। औपचारिक विनिर्देश के किसी प्रकार के अनुपालन के बिना, निर्भरता प्रबंधन के लिए संस्करण संख्या अनिवार्य रूप से बेकार हैं। उपर्युक्त विचारों को नाम और स्पष्ट परिभाषा देकर, अपने इरादे को अपने सॉफ़्टवेयर के उपयोगकर्ताओं को संवाद करना आसान हो जाता है। एक बार इन इरादों को स्पष्ट, लचीला (लेकिन बहुत लचीला नहीं) निर्भरता विनिर्देशों को अंत में बनाया जा सकता है।

एक साधारण उदाहरण यह दिखाएगा कि कैसे अर्थपूर्ण संस्करणिंग निर्भरता नरक को अतीत की बात कर सकती है। “फायरट्रुक” नामक एक लाइब्रेरी पर विचार करें। इसे “सीढ़ी” नामक एक सेमेन्टिकली वर्जन पैकेज की आवश्यकता होती है। जब फायरट्रुक बनाया जाता है, तो लेडर संस्करण 3.1.0 पर होता है। चूंकि फायरट्रुक कुछ कार्यक्षमता का उपयोग करता है जिसे पहली बार 3.1.0 में पेश किया गया था, आप सुरक्षित रूप से लेडर निर्भरता को 3.1.0 से अधिक या बराबर के रूप में निर्दिष्ट कर सकते हैं लेकिन 4.0.0 से कम। अब, जब लेडर संस्करण 3.1.1 और 3.2.0 उपलब्ध हो जाते हैं, तो आप उन्हें अपने पैकेज प्रबंधन प्रणाली में छोड़ सकते हैं और जानते हैं कि वे मौजूदा आश्रित सॉफ्टवेयर के साथ संगत होंगे।

एक जिम्मेदार डेवलपर के रूप में, आप निश्चित रूप से सत्यापित करना चाहते हैं कि विज्ञापन के रूप में किसी भी पैकेज अपग्रेड का कार्य करें। वास्तविक दुनिया एक गन्दा जगह है; इसके बारे में हम कुछ नहीं कर सकते लेकिन सतर्क रहें। आप क्या कर सकते हैं अर्थपूर्ण संस्करण आपको निर्भर पैकेज के नए संस्करणों को रोल किए बिना संकुल को रिलीज़ और अपग्रेड करने के लिए एक मौका तरीका प्रदान करता है, जिससे आप समय और परेशानी बचा सकते हैं।

यदि यह सब वांछनीय लगता है, तो आपको अर्थपूर्ण संस्करण का उपयोग शुरू करने के लिए केवल इतना करना है कि आप ऐसा कर रहे हैं और फिर नियमों का पालन करें। इस वेबसाइट से अपने रीडमे से लिंक करें ताकि अन्य नियमों को जान सकें और उनसे लाभ उठा सकें।

सामान्य प्रश्न

0.yz प्रारंभिक विकास चरण में संशोधन के साथ मुझे कैसे निपटना चाहिए?

करने के लिए सबसे सरल बात यह है कि अपनी शुरुआती विकास रिलीज 0.1.0 पर शुरू करें और फिर प्रत्येक आगामी रिलीज के लिए मामूली संस्करण को बढ़ाएं।

मुझे कैसे पता चलेगा कि 1.0.0 कब रिलीज़ किया जाए?

यदि आपके सॉफ़्टवेयर का उत्पादन में उपयोग किया जा रहा है, तो यह शायद पहले से ही 1.0.0 होना चाहिए। यदि आपके पास स्थिर API है जिस पर उपयोगकर्ता निर्भर हैं, तो आपको 1.0.0 होना चाहिए। यदि आप पीछे की संगतता के बारे में बहुत कुछ चिंता कर रहे हैं, तो आपको शायद पहले ही 1.0.0 होना चाहिए।

क्या यह तेजी से विकास और तेजी से पुनरावृत्ति को हतोत्साहित नहीं करता है?

प्रमुख संस्करण शून्य तेजी से विकास के बारे में है। यदि आप हर दिन एपीआई बदल रहे हैं तो आपको अभी भी संस्करण 0.yz या अगले प्रमुख संस्करण पर काम कर रहे एक अलग विकास शाखा में होना चाहिए।

यदि सार्वजनिक एपीआई में सबसे छोटा पिछड़ा असंगत परिवर्तन भी एक प्रमुख संस्करण टक्कर की आवश्यकता है, तो क्या मैं संस्करण 42.0.0 पर बहुत तेजी से समाप्त नहीं होगा?

यह जिम्मेदार विकास और दूरदर्शिता का सवाल है। असंगत परिवर्तनों को हल्के ढंग से सॉफ़्टवेयर में पेश नहीं किया जाना चाहिए जिसमें बहुत से निर्भर कोड हैं। अपग्रेड करने के लिए जो लागत होनी चाहिए वह महत्वपूर्ण हो सकती है। असंगत परिवर्तनों को जारी करने के लिए प्रमुख संस्करणों को टक्कर देने का मतलब है कि आप अपने परिवर्तनों के प्रभाव के माध्यम से सोचेंगे, और शामिल लागत / लाभ अनुपात का मूल्यांकन करेंगे।

पूरे सार्वजनिक एपीआई को दस्तावेज करना बहुत अधिक काम है!

एक पेशेवर डेवलपर के रूप में यह आपकी ज़िम्मेदारी है कि दूसरों द्वारा उपयोग के लिए सॉफ्टवेयर का सही तरीके से दस्तावेज किया जाए। सॉफ़्टवेयर जटिलता का प्रबंधन करना एक परियोजना को कुशल रखने का एक बेहद महत्वपूर्ण हिस्सा है, और यदि कोई नहीं जानता कि आपके सॉफ़्टवेयर का उपयोग कैसे करें, या कॉल करने के लिए कौन सी विधियां सुरक्षित हैं, तो यह करना मुश्किल है। लंबे समय तक, सेमेन्टिक वर्जनिंग, और एक अच्छी तरह से परिभाषित सार्वजनिक एपीआई पर जोर हर किसी और सबकुछ सुचारू रूप से चल रहा है।

यदि मैं गलती से एक मामूली संस्करण के रूप में पिछड़ा असंगत परिवर्तन जारी करता हूं तो मैं क्या करूँ?

जैसे ही आप महसूस करते हैं कि आपने अर्थात् संस्करण संस्करण को तोड़ दिया है, समस्या को ठीक करें और एक नया मामूली संस्करण जारी करें जो समस्या को सुधारता है और पीछे की संगतता को पुनर्स्थापित करता है। इस परिस्थिति में भी, संस्करण संस्करणों को संशोधित करने के लिए अस्वीकार्य है। यदि यह उचित है, तो अपमानजनक संस्करण दस्तावेज करें और समस्या के अपने उपयोगकर्ताओं को सूचित करें ताकि वे अपमानजनक संस्करण से अवगत हों।

यदि मैं सार्वजनिक एपीआई को बदले बिना अपनी निर्भरता अपडेट करता हूं तो मुझे क्या करना चाहिए?

इसे संगत माना जाएगा क्योंकि यह सार्वजनिक एपीआई को प्रभावित नहीं करता है। सॉफ़्टवेयर जो स्पष्ट रूप से समान निर्भरताओं पर निर्भर करता है क्योंकि आपके पैकेज में अपनी निर्भरता विनिर्देश होनी चाहिए और लेखक को कोई भी विवाद दिखाई देगा। यह निर्धारित करना कि परिवर्तन एक पैच स्तर है या नाबालिग स्तर संशोधन इस बात पर निर्भर करता है कि आपने बग को ठीक करने या नई कार्यक्षमता को पेश करने के लिए अपनी निर्भरताओं को अपडेट किया है या नहीं। मैं आमतौर पर बाद के उदाहरण के लिए अतिरिक्त कोड की अपेक्षा करता हूं, इस मामले में यह स्पष्ट रूप से मामूली स्तर की वृद्धि है।

क्या होगा यदि मैं अनजाने में सार्वजनिक एपीआई को ऐसे तरीके से बदलता हूं जो संस्करण संख्या में परिवर्तन के अनुरूप नहीं है (यानी कोड पैच रिलीज में गलत ब्रेकिंग परिवर्तन को गलत तरीके से पेश करता है)?

अपने सबसे अच्छे फैसले का प्रयोग करें। यदि आपके पास एक विशाल दर्शक हैं जो सार्वजनिक एपीआई के इरादे से व्यवहार को बदलकर बहुत प्रभावित होंगे, तो यह एक प्रमुख संस्करण रिलीज करने के लिए सबसे अच्छा हो सकता है, भले ही फिक्स को पैच रिलीज माना जा सके। याद रखें, अर्थात् वर्जनिंग सब कुछ बताता है कि संस्करण संख्या कैसे बदलती है। यदि ये परिवर्तन आपके उपयोगकर्ताओं के लिए महत्वपूर्ण हैं, तो उन्हें सूचित करने के लिए संस्करण संख्या का उपयोग करें।

मुझे बहिष्करण कार्यक्षमता को कैसे संभालना चाहिए?

मौजूदा कार्यक्षमता को कम करना सॉफ्टवेयर विकास का एक सामान्य हिस्सा है और अक्सर प्रगति को आगे बढ़ाने की आवश्यकता होती है। जब आप अपने सार्वजनिक एपीआई का हिस्सा बहिष्कृत करते हैं, तो आपको दो चीजें करना चाहिए: (1) उपयोगकर्ताओं को परिवर्तन के बारे में जानकारी देने के लिए अपने दस्तावेज़ों को अपडेट करें, (2) जगह पर बहिष्करण के साथ एक नई मामूली रिलीज जारी करें। एक नई बड़ी रिलीज में कार्यक्षमता को पूरी तरह से हटाने से पहले कम से कम एक मामूली रिलीज होनी चाहिए जिसमें बहिष्करण शामिल है ताकि उपयोगकर्ता आसानी से नए एपीआई में संक्रमण कर सकें।

क्या वर्जन स्ट्रिंग पर सेमेवर की आकार सीमा है?

नहीं, लेकिन अच्छे फैसले का प्रयोग करें। उदाहरण के लिए, 255 वर्ण संस्करण स्ट्रिंग शायद अधिक है। साथ ही, विशिष्ट सिस्टम स्ट्रिंग के आकार पर अपनी सीमा लगा सकते हैं।

के बारे में

अर्थात् संस्करण संस्करण विनिर्देशन ट्रा प्रेस्टन-वर्नर , ग्रेवाटर के आविष्कारक और गिटहब के कोफाउंडर द्वारा लिखा गया है।

अगर आप फीडबैक छोड़ना चाहते हैं, तो कृपया गिटहब पर एक समस्या खोलें।

लाइसेंस

क्रिएटिव कॉमन्स ― 3.0 द्वारा सीसी\nअर्थपूर्ण संस्करण 2.0.0\nएक संस्करण संख्या MAJOR.MINOR.PATCH को देखते हुए, वृद्धि:\nजब आप असंगत एपीआई परिवर्तन करते हैं तो प्रमुख संस्करण,\nMINOR संस्करण जब आप पिछड़े-संगत तरीके से कार्यक्षमता जोड़ते हैं, और\nजब आप पीछे-संगत बग फिक्स करते हैं तो पैच संस्करण।\nप्री-रिलीज और मेटाडेटा के लिए अतिरिक्त लेबल MAJOR.MINOR.PATCH प्रारूप में एक्सटेंशन के रूप में उपलब्ध हैं।\nसॉफ्टवेयर प्रबंधन की दुनिया में “निर्भरता नरक” नामक एक डरावनी जगह मौजूद है। आपका सिस्टम बड़ा हो जाता है और जितना अधिक पैकेज आप अपने सॉफ़्टवेयर में एकीकृत करते हैं, उतना ही अधिक आप निराशा के इस गड्ढे में खुद को ढूंढने की संभावना रखते हैं।\nकई निर्भरताओं वाले सिस्टम में, नए पैकेज संस्करण जारी करने से जल्दी ही एक दुःस्वप्न बन सकता है। यदि निर्भरता विनिर्देश बहुत तंग हैं, तो आप संस्करण लॉक (प्रत्येक आश्रित पैकेज के नए संस्करणों को जारी किए बिना पैकेज को अपग्रेड करने में असमर्थता) के खतरे में हैं। यदि निर्भरताओं को बहुत कम निर्दिष्ट किया गया है, तो आप अनिवार्य रूप से संस्करण संविधान द्वारा काट लेंगे (उचित से अधिक भविष्य के संस्करणों के साथ संगतता मानते हैं)। निर्भरता नरक वह जगह है जहां आप संस्करण लॉक और / या संस्करण संविधान आपको अपने प्रोजेक्ट को आगे और आसानी से स्थानांतरित करने से रोकते हैं।\nइस समस्या के समाधान के रूप में, मैं नियमों और आवश्यकताओं का एक सरल सेट प्रस्तावित करता हूं जो निर्देश देते हैं कि संस्करण संख्याएं कैसे आवंटित की जाती हैं और वृद्धि हुई हैं। ये नियम बंद और खुले स्रोत सॉफ्टवेयर दोनों में उपयोग में पूर्व-मौजूदा व्यापक सामान्य प्रथाओं तक सीमित नहीं हैं, बल्कि यह आवश्यक नहीं हैं। इस प्रणाली के लिए काम करने के लिए, आपको सबसे पहले एक सार्वजनिक एपीआई घोषित करने की आवश्यकता है। इसमें दस्तावेज शामिल हो सकते हैं या कोड द्वारा ही लागू किया जा सकता है। भले ही, यह महत्वपूर्ण है कि यह एपीआई स्पष्ट और सटीक हो। एक बार जब आप अपनी सार्वजनिक एपीआई की पहचान कर लेंगे, तो आप अपने संस्करण संख्या में विशिष्ट वृद्धि के साथ इसमें परिवर्तनों को संवाद करेंगे। XYZ (Major.Minor.Patch) के संस्करण प्रारूप पर विचार करें। बग फिक्स एपीआई वृद्धि को प्रभावित नहीं करते हैं, पैच संस्करण, पिछड़ा संगत एपीआई जोड़ / परिवर्तन मामूली संस्करण में वृद्धि करता है, और पीछे की असंगत एपीआई परिवर्तन प्रमुख संस्करण में वृद्धि करता है।\nमैं इस प्रणाली को “अर्थपूर्ण संस्करण” कहता हूं। इस योजना के तहत, संस्करण संख्याएं और जिस तरह से वे बदलते हैं, अंतर्निहित कोड के बारे में अर्थ बताते हैं और एक संस्करण से अगले संस्करण में क्या संशोधित किया गया है।\nअर्थपूर्ण संस्करण विशिष्टता (सेमवीर)\nमुख्य शब्द “जरूरी”, “आवश्यक नहीं”, “आवश्यक”, “साझा करें”, “नहीं होगा”, “चाहिए”, “नहीं होना चाहिए”, “अनुशंसित”, “मई” और “वैकल्पिक” इस दस्तावेज़ में हैं आरएफसी 2119 में वर्णित के रूप में व्याख्या किया जाना है ।\nअर्थपूर्ण संस्करण का उपयोग कर सॉफ्टवेयर एक सार्वजनिक एपीआई घोषित करना चाहिए। इस एपीआई को कोड में ही घोषित किया जा सकता है या दस्तावेज़ीकरण में सख्ती से मौजूद है। हालांकि यह किया जाता है, यह सटीक और व्यापक होना चाहिए।\nअर्थपूर्ण संस्करण का उपयोग कर सॉफ्टवेयर एक सार्वजनिक एपीआई घोषित करना चाहिए। इस एपीआई को कोड में ही घोषित किया जा सकता है या दस्तावेज़ीकरण में सख्ती से मौजूद है। हालांकि यह किया जाता है, यह सटीक और व्यापक होना चाहिए।\nएक सामान्य संस्करण संख्या को XYZ फॉर्म लेना चाहिए जहां एक्स, वाई, और जेड गैर-ऋणात्मक पूर्णांक हैं, और इसमें प्रमुख शून्य शामिल नहीं होनी चाहिए। एक्स प्रमुख संस्करण है, वाई मामूली संस्करण है, और जेड पैच संस्करण है। प्रत्येक तत्व संख्यात्मक रूप से बढ़ना चाहिए। उदाहरण के लिए: 1.9.0 -> 1.10.0 -> 1.11.0।\nएक सामान्य संस्करण संख्या को XYZ फॉर्म लेना चाहिए जहां एक्स, वाई, और जेड गैर-ऋणात्मक पूर्णांक हैं, और इसमें प्रमुख शून्य शामिल नहीं होनी चाहिए। एक्स प्रमुख संस्करण है, वाई मामूली संस्करण है, और जेड पैच संस्करण है। प्रत्येक तत्व संख्यात्मक रूप से बढ़ना चाहिए। उदाहरण के लिए: 1.9.0 -> 1.10.0 -> 1.11.0।\nएक बार एक संस्करण पैकेज जारी किया गया है, उस संस्करण की सामग्री को संशोधित नहीं किया जाना चाहिए। किसी भी संशोधन को एक नए संस्करण के रूप में जारी किया जाना चाहिए।\nएक बार एक संस्करण पैकेज जारी किया गया है, उस संस्करण की सामग्री को संशोधित नहीं किया जाना चाहिए। किसी भी संशोधन को एक नए संस्करण के रूप में जारी किया जाना चाहिए।\nप्रमुख संस्करण शून्य (0.yz) प्रारंभिक विकास के लिए है। कुछ भी किसी भी समय बदल सकता है। सार्वजनिक एपीआई को स्थिर नहीं माना जाना चाहिए।\nप्रमुख संस्करण शून्य (0.yz) प्रारंभिक विकास के लिए है। कुछ भी किसी भी समय बदल सकता है। सार्वजनिक एपीआई को स्थिर नहीं माना जाना चाहिए।\nसंस्करण 1.0.0 सार्वजनिक एपीआई को परिभाषित करता है। इस रिलीज के बाद जिस संस्करण में संस्करण संख्या बढ़ी है, इस सार्वजनिक एपीआई पर निर्भर है और यह कैसे बदलता है।\nसंस्करण 1.0.0 सार्वजनिक एपीआई को परिभाषित करता है। इस रिलीज के बाद जिस संस्करण में संस्करण संख्या बढ़ी है, इस सार्वजनिक एपीआई पर निर्भर है और यह कैसे बदलता है।\nपैच संस्करण जेड (xyZ
          x> 0) केवल पिछड़ा संगत बग फिक्स पेश किए जाने पर वृद्धि की जानी चाहिए। एक बग फिक्स को आंतरिक परिवर्तन के रूप में परिभाषित किया जाता है जो गलत व्यवहार को हल करता है।\nx> 0) केवल पिछड़ा संगत बग फिक्स पेश किए जाने पर वृद्धि की जानी चाहिए। एक बग फिक्स को आंतरिक परिवर्तन के रूप में परिभाषित किया जाता है जो गलत व्यवहार को हल करता है।\nछोटे संस्करण वाई (xYz
          x> 0) को बढ़ाया जाना चाहिए यदि सार्वजनिक, एपीआई के लिए नई, पिछली संगत कार्यक्षमता पेश की गई हो। यदि किसी भी सार्वजनिक एपीआई कार्यक्षमता को बहिष्कृत के रूप में चिह्नित किया गया है तो इसे बढ़ाया जाना चाहिए। निजी कोड के भीतर पर्याप्त नई कार्यक्षमता या सुधार पेश किए जाने पर यह बढ़ाई जा सकती है। इसमें पैच स्तर परिवर्तन शामिल हो सकते हैं। छोटे संस्करण को बढ़ाए जाने पर पैच संस्करण को 0 पर रीसेट किया जाना चाहिए।\nछोटे संस्करण वाई (xYz\nx> 0) को बढ़ाया जाना चाहिए यदि सार्वजनिक, एपीआई के लिए नई, पिछली संगत कार्यक्षमता पेश की गई हो। यदि किसी भी सार्वजनिक एपीआई कार्यक्षमता को बहिष्कृत के रूप में चिह्नित किया गया है तो इसे बढ़ाया जाना चाहिए। निजी कोड के भीतर पर्याप्त नई कार्यक्षमता या सुधार पेश किए जाने पर यह बढ़ाई जा सकती है। इसमें पैच स्तर परिवर्तन शामिल हो सकते हैं। छोटे संस्करण को बढ़ाए जाने पर पैच संस्करण को 0 पर रीसेट किया जाना चाहिए।\nप्रमुख संस्करण एक्स (Xyz
          X> 0) को बढ़ाया जाना चाहिए यदि सार्वजनिक एपीआई में कोई पिछड़ा असंगत परिवर्तन पेश किया गया हो। इसमें मामूली और पैच स्तर परिवर्तन शामिल हो सकते हैं। जब बड़े संस्करण में वृद्धि हुई है तो पैच और मामूली संस्करण को 0 पर रीसेट किया जाना चाहिए।\nप्रमुख संस्करण एक्स (Xyz\nX> 0) को बढ़ाया जाना चाहिए यदि सार्वजनिक एपीआई में कोई पिछड़ा असंगत परिवर्तन पेश किया गया हो। इसमें मामूली और पैच स्तर परिवर्तन शामिल हो सकते हैं। जब बड़े संस्करण में वृद्धि हुई है तो पैच और मामूली संस्करण को 0 पर रीसेट किया जाना चाहिए।\nएक प्री-रिलीज संस्करण पैच संस्करण के तुरंत बाद एक हाइफ़न और डॉट अलग पहचानकर्ताओं की एक श्रृंखला को जोड़कर दर्शाया जा सकता है। पहचानकर्ताओं में केवल एएससीआईआई अल्फान्यूमेरिक्स और हाइफ़न [0-9 ए-ज़ा-जेड-] शामिल होना चाहिए। पहचानकर्ता खाली नहीं होना चाहिए। संख्यात्मक पहचानकर्ताओं में अग्रणी शून्य शामिल नहीं होना चाहिए। प्री-रिलीज संस्करणों में संबंधित सामान्य संस्करण की तुलना में कम प्राथमिकता है। एक प्री-रिलीज संस्करण इंगित करता है कि संस्करण अस्थिर है और इसके अनुरूप सामान्य संस्करण द्वारा बताए गए इच्छित संगतता आवश्यकताओं को पूरा नहीं कर सकता है। उदाहरण: 1.0.0-अल्फा, 1.0.0-अल्फा .1, 1.0.0-0.3.7, 1.0.0-x.7.z.92।\nएक प्री-रिलीज संस्करण पैच संस्करण के तुरंत बाद एक हाइफ़न और डॉट अलग पहचानकर्ताओं की एक श्रृंखला को जोड़कर दर्शाया जा सकता है। पहचानकर्ताओं में केवल एएससीआईआई अल्फान्यूमेरिक्स और हाइफ़न [0-9 ए-ज़ा-जेड-] शामिल होना चाहिए। पहचानकर्ता खाली नहीं होना चाहिए। संख्यात्मक पहचानकर्ताओं में अग्रणी शून्य शामिल नहीं होना चाहिए। प्री-रिलीज संस्करणों में संबंधित सामान्य संस्करण की तुलना में कम प्राथमिकता है। एक प्री-रिलीज संस्करण इंगित करता है कि संस्करण अस्थिर है और इसके अनुरूप सामान्य संस्करण द्वारा बताए गए इच्छित संगतता आवश्यकताओं को पूरा नहीं कर सकता है। उदाहरण: 1.0.0-अल्फा, 1.0.0-अल्फा .1, 1.0.0-0.3.7, 1.0.0-x.7.z.92।\nपैच या प्री-रिलीज संस्करण के तुरंत बाद एक प्लस साइन और डॉट से अलग पहचानकर्ताओं की एक श्रृंखला को जोड़कर मेटाडाटा मई को इंगित किया जा सकता है। पहचानकर्ताओं में केवल एएससीआईआई अल्फान्यूमेरिक्स और हाइफ़न [0-9 ए-ज़ा-जेड-] शामिल होना चाहिए। पहचानकर्ता खाली नहीं होना चाहिए। संस्करण प्राथमिकता निर्धारित करते समय मेटाडेटा को अनदेखा किया जाना चाहिए। इस प्रकार दो संस्करण जो बिल्ड मेटाडेटा में भिन्न होते हैं, वही प्राथमिकता रखते हैं। उदाहरण: 1.0.0-अल्फा + 001, 1.0.0 + 20130313144700, 1.0.0-बीटा + exp.sha.5114f85।\nपैच या प्री-रिलीज संस्करण के तुरंत बाद एक प्लस साइन और डॉट से अलग पहचानकर्ताओं की एक श्रृंखला को जोड़कर मेटाडाटा मई को इंगित किया जा सकता है। पहचानकर्ताओं में केवल एएससीआईआई अल्फान्यूमेरिक्स और हाइफ़न [0-9 ए-ज़ा-जेड-] शामिल होना चाहिए। पहचानकर्ता खाली नहीं होना चाहिए। संस्करण प्राथमिकता निर्धारित करते समय मेटाडेटा को अनदेखा किया जाना चाहिए। इस प्रकार दो संस्करण जो बिल्ड मेटाडेटा में भिन्न होते हैं, वही प्राथमिकता रखते हैं। उदाहरण: 1.0.0-अल्फा + 001, 1.0.0 + 20130313144700, 1.0.0-बीटा + exp.sha.5114f85।\nप्राथमिकता यह दर्शाती है कि आदेश दिए जाने पर संस्करणों की तुलना एक दूसरे से कैसे की जाती है। प्राथमिकता को उस क्रम में प्रमुख, मामूली, पैच और प्री-रिलीज पहचानकर्ताओं में संस्करण को अलग करके गणना की जानी चाहिए (मेटाडाटा बनाएं प्राथमिकता में नहीं है)। प्राथमिकता को पहले अंतर से निर्धारित किया जाता है जब इन पहचानकर्ताओं में से प्रत्येक को बाएं से दाएं से तुलना करें: मेजर, नाबालिग और पैच संस्करणों की तुलना हमेशा संख्यात्मक रूप से की जाती है। उदाहरण: 1.0.0 <2.0.0 <2.1.0 <2.1.1। जब प्रमुख, नाबालिग और पैच बराबर होते हैं, तो प्री-रिलीज़ संस्करण में सामान्य संस्करण की तुलना में कम प्राथमिकता होती है। उदाहरण: 1.0.0-अल्फा <1.0.0। एक ही प्रमुख, नाबालिग और पैच संस्करण के साथ दो प्री-रिलीज संस्करणों की प्राथमिकता प्रत्येक डॉट से अलग पहचानकर्ता को बाएं से दाएं की तुलना करके निर्धारित किया जाना चाहिए जब तक कोई अंतर निम्नानुसार नहीं मिलता है: केवल अंकों की पहचान करने वाले पहचानकर्ताओं की संख्या संख्यात्मक रूप से तुलना की जाती है और अक्षरों या हाइफ़न वाले पहचानकर्ताओं की तुलना एएससीआईआई क्रमबद्ध क्रम में तुलनात्मक रूप से की जाती है। गैर-संख्यात्मक पहचानकर्ताओं की तुलना में संख्यात्मक पहचानकर्ताओं की हमेशा कम प्राथमिकता होती है। प्री-रिलीज फ़ील्ड्स का एक बड़ा सेट एक छोटे से सेट की तुलना में अधिक प्राथमिकता है, यदि पिछले सभी पहचानकर्ता बराबर हैं। उदाहरण: 1.0.0-अल्फा <1.0.0-alpha.1 <1.0.0-alpha.beta <1.0.0-beta <1.0.0-beta.2 <1.0.0-beta.11 <1.0.0- आरसी .1 <1.0.0।\nअर्थपूर्ण संस्करण का उपयोग क्यों करें?\nयह एक नया या क्रांतिकारी विचार नहीं है। असल में, आप शायद पहले से ही कुछ करीब कर सकते हैं। समस्या यह है कि “करीबी” पर्याप्त नहीं है। औपचारिक विनिर्देश के किसी प्रकार के अनुपालन के बिना, निर्भरता प्रबंधन के लिए संस्करण संख्या अनिवार्य रूप से बेकार हैं। उपर्युक्त विचारों को नाम और स्पष्ट परिभाषा देकर, अपने इरादे को अपने सॉफ़्टवेयर के उपयोगकर्ताओं को संवाद करना आसान हो जाता है। एक बार इन इरादों को स्पष्ट, लचीला (लेकिन बहुत लचीला नहीं) निर्भरता विनिर्देशों को अंत में बनाया जा सकता है।\nएक साधारण उदाहरण यह दिखाएगा कि कैसे अर्थपूर्ण संस्करणिंग निर्भरता नरक को अतीत की बात कर सकती है। “फायरट्रुक” नामक एक लाइब्रेरी पर विचार करें। इसे “सीढ़ी” नामक एक सेमेन्टिकली वर्जन पैकेज की आवश्यकता होती है। जब फायरट्रुक बनाया जाता है, तो लेडर संस्करण 3.1.0 पर होता है। चूंकि फायरट्रुक कुछ कार्यक्षमता का उपयोग करता है जिसे पहली बार 3.1.0 में पेश किया गया था, आप सुरक्षित रूप से लेडर निर्भरता को 3.1.0 से अधिक या बराबर के रूप में निर्दिष्ट कर सकते हैं लेकिन 4.0.0 से कम। अब, जब लेडर संस्करण 3.1.1 और 3.2.0 उपलब्ध हो जाते हैं, तो आप उन्हें अपने पैकेज प्रबंधन प्रणाली में छोड़ सकते हैं और जानते हैं कि वे मौजूदा आश्रित सॉफ्टवेयर के साथ संगत होंगे।\nएक जिम्मेदार डेवलपर के रूप में, आप निश्चित रूप से सत्यापित करना चाहते हैं कि विज्ञापन के रूप में किसी भी पैकेज अपग्रेड का कार्य करें। वास्तविक दुनिया एक गन्दा जगह है; इसके बारे में हम कुछ नहीं कर सकते लेकिन सतर्क रहें। आप क्या कर सकते हैं अर्थपूर्ण संस्करण आपको निर्भर पैकेज के नए संस्करणों को रोल किए बिना संकुल को रिलीज़ और अपग्रेड करने के लिए एक मौका तरीका प्रदान करता है, जिससे आप समय और परेशानी बचा सकते हैं।\nयदि यह सब वांछनीय लगता है, तो आपको अर्थपूर्ण संस्करण का उपयोग शुरू करने के लिए केवल इतना करना है कि आप ऐसा कर रहे हैं और फिर नियमों का पालन करें। इस वेबसाइट से अपने रीडमे से लिंक करें ताकि अन्य नियमों को जान सकें और उनसे लाभ उठा सकें।\n0.yz प्रारंभिक विकास चरण में संशोधन के साथ मुझे कैसे निपटना चाहिए?\nकरने के लिए सबसे सरल बात यह है कि अपनी शुरुआती विकास रिलीज 0.1.0 पर शुरू करें और फिर प्रत्येक आगामी रिलीज के लिए मामूली संस्करण को बढ़ाएं।\nमुझे कैसे पता चलेगा कि 1.0.0 कब रिलीज़ किया जाए?\nयदि आपके सॉफ़्टवेयर का उत्पादन में उपयोग किया जा रहा है, तो यह शायद पहले से ही 1.0.0 होना चाहिए। यदि आपके पास स्थिर API है जिस पर उपयोगकर्ता निर्भर हैं, तो आपको 1.0.0 होना चाहिए। यदि आप पीछे की संगतता के बारे में बहुत कुछ चिंता कर रहे हैं, तो आपको शायद पहले ही 1.0.0 होना चाहिए।\nक्या यह तेजी से विकास और तेजी से पुनरावृत्ति को हतोत्साहित नहीं करता है?\nप्रमुख संस्करण शून्य तेजी से विकास के बारे में है। यदि आप हर दिन एपीआई बदल रहे हैं तो आपको अभी भी संस्करण 0.yz या अगले प्रमुख संस्करण पर काम कर रहे एक अलग विकास शाखा में होना चाहिए।\nयदि सार्वजनिक एपीआई में सबसे छोटा पिछड़ा असंगत परिवर्तन भी एक प्रमुख संस्करण टक्कर की आवश्यकता है, तो क्या मैं संस्करण 42.0.0 पर बहुत तेजी से समाप्त नहीं होगा?\nयह जिम्मेदार विकास और दूरदर्शिता का सवाल है। असंगत परिवर्तनों को हल्के ढंग से सॉफ़्टवेयर में पेश नहीं किया जाना चाहिए जिसमें बहुत से निर्भर कोड हैं। अपग्रेड करने के लिए जो लागत होनी चाहिए वह महत्वपूर्ण हो सकती है। असंगत परिवर्तनों को जारी करने के लिए प्रमुख संस्करणों को टक्कर देने का मतलब है कि आप अपने परिवर्तनों के प्रभाव के माध्यम से सोचेंगे, और शामिल लागत / लाभ अनुपात का मूल्यांकन करेंगे।\nपूरे सार्वजनिक एपीआई को दस्तावेज करना बहुत अधिक काम है!\nएक पेशेवर डेवलपर के रूप में यह आपकी ज़िम्मेदारी है कि दूसरों द्वारा उपयोग के लिए सॉफ्टवेयर का सही तरीके से दस्तावेज किया जाए। सॉफ़्टवेयर जटिलता का प्रबंधन करना एक परियोजना को कुशल रखने का एक बेहद महत्वपूर्ण हिस्सा है, और यदि कोई नहीं जानता कि आपके सॉफ़्टवेयर का उपयोग कैसे करें, या कॉल करने के लिए कौन सी विधियां सुरक्षित हैं, तो यह करना मुश्किल है। लंबे समय तक, सेमेन्टिक वर्जनिंग, और एक अच्छी तरह से परिभाषित सार्वजनिक एपीआई पर जोर हर किसी और सबकुछ सुचारू रूप से चल रहा है।\nयदि मैं गलती से एक मामूली संस्करण के रूप में पिछड़ा असंगत परिवर्तन जारी करता हूं तो मैं क्या करूँ?\nजैसे ही आप महसूस करते हैं कि आपने अर्थात् संस्करण संस्करण को तोड़ दिया है, समस्या को ठीक करें और एक नया मामूली संस्करण जारी करें जो समस्या को सुधारता है और पीछे की संगतता को पुनर्स्थापित करता है। इस परिस्थिति में भी, संस्करण संस्करणों को संशोधित करने के लिए अस्वीकार्य है। यदि यह उचित है, तो अपमानजनक संस्करण दस्तावेज करें और समस्या के अपने उपयोगकर्ताओं को सूचित करें ताकि वे अपमानजनक संस्करण से अवगत हों।\nयदि मैं सार्वजनिक एपीआई को बदले बिना अपनी निर्भरता अपडेट करता हूं तो मुझे क्या करना चाहिए?\nइसे संगत माना जाएगा क्योंकि यह सार्वजनिक एपीआई को प्रभावित नहीं करता है। सॉफ़्टवेयर जो स्पष्ट रूप से समान निर्भरताओं पर निर्भर करता है क्योंकि आपके पैकेज में अपनी निर्भरता विनिर्देश होनी चाहिए और लेखक को कोई भी विवाद दिखाई देगा। यह निर्धारित करना कि परिवर्तन एक पैच स्तर है या नाबालिग स्तर संशोधन इस बात पर निर्भर करता है कि आपने बग को ठीक करने या नई कार्यक्षमता को पेश करने के लिए अपनी निर्भरताओं को अपडेट किया है या नहीं। मैं आमतौर पर बाद के उदाहरण के लिए अतिरिक्त कोड की अपेक्षा करता हूं, इस मामले में यह स्पष्ट रूप से मामूली स्तर की वृद्धि है।\nक्या होगा यदि मैं अनजाने में सार्वजनिक एपीआई को ऐसे तरीके से बदलता हूं जो संस्करण संख्या में परिवर्तन के अनुरूप नहीं है (यानी कोड पैच रिलीज में गलत ब्रेकिंग परिवर्तन को गलत तरीके से पेश करता है)?\nअपने सबसे अच्छे फैसले का प्रयोग करें। यदि आपके पास एक विशाल दर्शक हैं जो सार्वजनिक एपीआई के इरादे से व्यवहार को बदलकर बहुत प्रभावित होंगे, तो यह एक प्रमुख संस्करण रिलीज करने के लिए सबसे अच्छा हो सकता है, भले ही फिक्स को पैच रिलीज माना जा सके। याद रखें, अर्थात् वर्जनिंग सब कुछ बताता है कि संस्करण संख्या कैसे बदलती है। यदि ये परिवर्तन आपके उपयोगकर्ताओं के लिए महत्वपूर्ण हैं, तो उन्हें सूचित करने के लिए संस्करण संख्या का उपयोग करें।\nमुझे बहिष्करण कार्यक्षमता को कैसे संभालना चाहिए?\nमौजूदा कार्यक्षमता को कम करना सॉफ्टवेयर विकास का एक सामान्य हिस्सा है और अक्सर प्रगति को आगे बढ़ाने की आवश्यकता होती है। जब आप अपने सार्वजनिक एपीआई का हिस्सा बहिष्कृत करते हैं, तो आपको दो चीजें करना चाहिए: (1) उपयोगकर्ताओं को परिवर्तन के बारे में जानकारी देने के लिए अपने दस्तावेज़ों को अपडेट करें, (2) जगह पर बहिष्करण के साथ एक नई मामूली रिलीज जारी करें। एक नई बड़ी रिलीज में कार्यक्षमता को पूरी तरह से हटाने से पहले कम से कम एक मामूली रिलीज होनी चाहिए जिसमें बहिष्करण शामिल है ताकि उपयोगकर्ता आसानी से नए एपीआई में संक्रमण कर सकें।\nक्या वर्जन स्ट्रिंग पर सेमेवर की आकार सीमा है?\nनहीं, लेकिन अच्छे फैसले का प्रयोग करें। उदाहरण के लिए, 255 वर्ण संस्करण स्ट्रिंग शायद अधिक है। साथ ही, विशिष्ट सिस्टम स्ट्रिंग के आकार पर अपनी सीमा लगा सकते हैं।\nअर्थात् संस्करण संस्करण विनिर्देशन ट्रा प्रेस्टन-वर्नर , ग्रेवाटर के आविष्कारक और गिटहब के कोफाउंडर द्वारा लिखा गया है।\nअगर आप फीडबैक छोड़ना चाहते हैं, तो कृपया गिटहब पर एक समस्या खोलें।\nगिटहब पर एक समस्या खोलें\nक्रिएटिव कॉमन्स ― 3.0 द्वारा सीसी\nक्रिएटिव कॉमन्स ― 3.0 द्वारा सीसी\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSemantičko verzioniranje 2.0.0

Sažetak

Uzevši oznake verzije VEĆA.MANJA.ZAKRPA, inkrementirajte:


  VEĆU verziju kada napravite inkompatibilne promjene u APIju,
  MANJU verziju kada dodate unatrag-kompatibilne funkcionalnosti i
  ZAKRPA verziju kada napravite unatrag-kompatibilne ispravke bugova.


Dodatne oznake za pred-izdanja i metapodatke builda mogu se koristiti kao proširenje na VEĆA.MANJA.ZAKRPA format.

Uvod

U svijetu upravljanja softverom postoji strašno mjesto koje zovemo
“pakao ovisnosti.” Što više vaš sustav raste i što više paketa
integrirate u vaš softver, vjerojatnije je da ćete se, jednoga dana,
naći u toj jami očaja.

U sustavima s više ovisnosti, izdavanje novih verzija paketa, može se vrlo brzo
pretvoriti u noćnu moru. Ako su specifikacije ovisnosti previše stroge, postoji
opasnost zaključavanja verzije (nemogućnosti nadogradnje paketa bez potrebe
izdavanja nove verzije svakog ovisnog paketa). Ako su pak ovisnosti specificirane
previše slobodno, sigurno ćete osjetiti posljedice verzijskog promiskuiteta
(pretpostavke kompatibilnosti s više budućih verzija nego što je razumno).
Pakao ovisnosti je slučaj gdje zaključavanje verzije i/ili verzijski promiskuitet
sprječavaju lagano i sigurno napredovanje projekta.

Kao rješenje tog problema predlažem jednostavan set pravila i zahtjeva
koji će nalagati kako se dodjeljuju i inkrementiraju oznake verzija.
Ova se pravila temelje, no nisu nužno i ograničena, na već postojećoj
i raširenoj uobičajenoj praksi u projektima otvorenog i zatvorenog koda.
Kako bi ovaj sustav funkcionirao, potrebno je prvo objaviti javni API. Možemo
to primijeniti u dokumentaciji ili u samom kodu. U svakom slučaju, važno je da
API bude jasan i precizan. Jednom kad identificiramo javni API, komuniciramo
promjene u njemu kroz specificirane inkrementacije u oznake/broja verzije.
Uzmimo format verzije X.Y.Z (VEĆA.MANJA.ZAKRPA). Ispravci bugova koji ne utječu
na API inkrementiraju oznaku zakrpe, unatrag-kompatibilni dodaci/promjene u
APIju inkrementiraju manju verziju, a unatrag inkompatibilne promjene u APIju
inkrementiraju veću verziju.

Ovaj sam sustav nazvao “Semantičko verzioniranje”. Unutar ove sheme, oznake
verzije i način na koji se mijenjaju prenose određene informacije o kodu koji
se nalazi ispod i što se mijenjalo od jedne do druge verzije.

Specifikacija semantičkog verzioniranja (SemVer)

Ključne riječi “MORA”, “NE SMIJE”, “POTREBNO”, “BITI ĆE”, “NEĆE BITI”, “TREBALO BI”,
“NE BI TREBALO”, “PREPORUČENO”, “MOŽE”, i “OPCIONALNO” (“MUST”, “MUST NOT”,
“REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”,
“OPTIONAL”) u ovom dokumentu treba interpretirati kao što je opisano u
RFC 2119.


  
    Softver koji koristi Semantičko verzioniranje MORA objaviti javni API. API
može biti deklariran u samom kodu ili postojati samo unutar dokumentacije.
U svakom slučaju, mora biti precizan i jasan.
  
  
    Normalna oznaka verzije MORA biti u formatu X.Y.Z gdje su X, Y i Z ne-negativni
cijeli brojevi i ne smiju počinjati s nulom. X označava veću verziju, Y manju
verziju, a Z zakrpu. Svaki se element MORA numerički povećavati.
Na primjer: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Jednom kad je verzionirani paket izdan, sadržaj te verzije NE SMIJE se
mijenjati. Sve promjene MORAJU se izdavati s novom verzijom.
  
  
    Veća verzija nula (0.y.z) je za inicijalni razvoj. Bilo što se može mijenjati
u tom stadiju. Javni API se ne smatra stabilnim.
  
  
    Verzija 1.0.0 definira javni API. Način na koji će se oznaka verzije
inkrementirati ovisi o tom javnom APIju i načinu na koji se on mijenja.
  
  
    Oznaka verzije zakrpe Z (x.y.Z | x > 0) MORA se inkrementirati samo ako se
dodaju unatrag kompatibilni ispravci bugova. Ispravci bugova definiraju se kao
promjene unutar koda koje ispravljaju nepravilno ponašanje.
  
  
    Oznaka manje verzije Y (x.Y.z | x > 0) MORA se inkrementirati ako se javnom
APIju dodaju nove unatrag kompatibilne funkcionalnosti. Također se MORA
inkrementirati ako se neke funkcionalnosti označe kao zastarjele (deprecated).
MOŽE se inkrementirati ako se uvode značajne nove funkcionalnosti ili poboljšanja
unutar koda. MOŽE se inkrementirati ako se uvode promjene na razini zakrpe. Kada
se oznaka manje verzije inkrementira, oznaka verzije zakrpe mora se vratiti na 0.
  
  
    Oznaka veće verzije X (X.y.z | X > 0) MORA se inkrementirati ako se javnom
APIju dodaju unatrag inkompatibilne funkcionalnosti. MOŽE sadržavati promjene na
razini manje verzije i zakrpe. Kada se oznaka veće verzije inkrementira, oznake
manje verzije i zakrpe moraju se vratiti na 0.
  
  
    Verzija predizdanja MOŽE se označiti dodavanjem crtice i niza identifikatora
odvojenih točkom, koji se odmah nastavljaju na oznaku verzije zakrpe. Ti se
identifikatori MORAJU sastojati samo od ASCII alfanumeričkih znakova i crtica
[0-9A-Za-z-]. Identifikatori NE SMIJU biti prazni. Numerički identifikatori NE
SMIJU počinjati nulom. Normalne verzije imaju prednost nad vezanim verzijama
predizdanja. Oznaka verzije predizdanja označava nestabilnu verziju koja ne
zadovoljava nužno predviđene zahtjeve kompatibilnosti navedene u vezanoj
normalnoj verziji. Primjeri: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.
  
  
    Metapodaci builda MOGU se označiti dodavanjem znaka plus i niza identifikatora
odvojenih točkom, koji se odmah nastavljaju na oznaku verzije zakrpe ili
predizdanja. Ti se identifikatori MORAJU sastojati samo od ASCII alfanumeričkih
znakova i crtica [0-9A-Za-z-]. Identifikatori NE SMIJU biti prazni. Metapodaci
builda se ignoriraju kod procjene prednosti verzije. Dakle, dvije verzije koje
se razlikuju samo u metapodacima builda imaju jednaku prednost. Primjeri:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    Pojam prednosti odnosi se na to kako uspoređujemo verzije u poretku.
Prednost se MORA procjenjivati tako da zasebno promatramo oznaku verzije kao
veću, manju, zakrpu i identifikatore predizdanja tim redom. (Metapodaci builda
ne utječu na prednost). Prednost određuje prva razlika u usporedbi svake
oznake s lijeva na desno na sljedeći način: Oznake veće verzije, manje verzije i
verzije zakrpe uvijek se uspoređuju numerički. Na primjer: 1.0.0 < 2.0.0 <
2.1.0 < 2.1.1. Kad su oznake veće, manje i verzije zakrpe jednake, normalna
verzija ima prednost nad verzijom predizdanja. Primjer: 1.0.0-alpha < 1.0.0.
Prednost između dvije verzije predizdanja s istim oznakama veće, manje i verzije
zakrpe MORAJU se odrediti usporedbom svake oznake odvojene točkom s lijeva na
desno, dok ne dođemo do razlike na sljedeći način: identifikatori koji se
sastoje samo od broja uspoređuju se numerički, dok se slova i crtice uspoređuju
leksički u ASCII poretku. Nebrojčane oznake uvijek imaju prednost nad brojčanim.
Veći niz oznaka predizdanja ima prednost nad manjim nizom, ako su prethodne
oznake jednake. Primjer: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Zašto koristiti Semantičko verzioniranje?

Ovo nije nova, niti revolucionarna ideja. Štoviše, vjerojatno već koristite
nešto vrlo slično. Problem je u tome što “slično” nije dovoljno dobro. Bez
poštivanja neke formalne specifikacije, oznake verzije su u suštini beskorisne
za upravljanje ovisnostima. Ako damo ime i jasnu definiciju gore navedenim
idejama, postaje lakše iskomunicirati svoje namjere korisnicima softvera.
Jednom kada su te namjere jasne i fleksibilne (ali ne previše fleksibilne)
možemo definirati specifikacije ovisnosti.

Možemo jednostavnim primjerom pokazati kako Semantičko verzioniranje može
ostaviti pakao ovisnosti u prošlosti. Zamislite library “Vatrogasno_vozilo.”
Potreban joj je Semantički verzionirani paket “Ljestve”. U trenutku kad je
“Vatrogasno_vozilo” kreirano, “Ljestve” su na verziji 3.1.0. Budući da
“Vatrogasno_vozilo” koristi određene funkcionalnosti koje su uvedene u verziji
3.1.0, možete bez straha navesti ovisnost o paketu “Ljestve” verzije veće ili
jednake 3.1.0, ali manje od 4.0.0. Tako, kada “Ljestve” verzije 3.1.1 i 3.2.0
budu dostupne, možete ih dodati u svoj sustav upravljanja paketima i biti
sigurni da će biti kompatibilne s postojećim ovisnim softverom.

Kao odgovoran programer htjet ćete se, naravno, uvjeriti da će svaka nadogradnja
paketa funkcionirati kao što je navedeno. Stvarni je svijet zbrka i ne možemo
ništa poduzeti po tom pitanju osim biti oprezni. Ono što možete napraviti je
prihvatiti Semantičko verzioniranje kao siguran način za izdavanje i nadogradnju
paketa bez potrebe za izgradnjom novih verzija ovisnih paketa te tako sačuvati
vrijeme i živce.

Ako vam ovo sve dobro zvuči, sve što vam je potrebno da bi ste počeli koristiti
Semantičko verzioniranje je da navedete da ga koristite i slijedite pravila.
Stavite poveznicu na ovu stranicu u svoju README datoteku, kako bi i ostali bili
svjesni pravila i mogli imati koristi od njih.

Česta pitanja

Kako upravljati promjenama za inicijalne faze razvoja verzija 0.y.z?

Najjednostavniji je način da započnete inicijalni razvoj izdavanjem verzije
0.1.0 te inkrementirate oznaku manje verzije za svako sljedeće izdanje.

Kako znamo kada izdati verziju 1.0.0?

Ako se softver koristi u produkciji, već bi vjerojatno trebao biti na verziji
1.0.0. Ako već imamo stabilni API, na koji korisnici mogu računati, trebao bi
biti na verziji 1.0.0. Ako ste zabrinuti zbog kompatibilnosti unatrag, softver
bi već trebao biti izdan pod verzijom 1.0.0.

Ne sprječava li ovo ubrzani razvoj i brzo povećavanje verzija?

Veća verzija nula se svodi na brzi razvoj. Ako mijenjate API svaki dan, trebali
bi ostati na verziji 0.y.z ili na posebnoj grani raditi na sljedećoj većoj
verziji.

Ako i najmanje unatrag inkompatibilne promjene u APIju zahtijevaju povećanje veće verzije, neću li vrlo brzo doći do verzije 42.0.0?

Ovo je pitanje odgovornog razvoja i predviđanja. U softver koji ima puno
ovisnog koda, inkompatibilne promjene potrebno je uvoditi postupno. Cijena
nadogradnje može biti značajna. Ako morate povećati veću verziju, kako biste
izdali verziju s inkompatibilnim promjenama, morate razmisliti o posljedicama
tih promjenama i procijeniti odnos cijene i koristi.

Dokumentacija čitavog javnog APIja zahtijeva previše posla!

Vaša je odgovornost kao profesionalnih programera da ispravno dokumentirate
softver koji je namijenjen korisnicima. Upravljanje složenosti softvera vrlo
je važno kako biste projekt održali efikasnim, što je teško ako korisnici ne
znaju kako koristiti vaš softver ili koje metode mogu zvati. Semantičko
verzioniranje i kvalitetno definirani Semantički verzionirani javni API osigurat
će da sve funkcionira kako treba.

Što ako slučajno izdam unatrag inkompatibilne promjene kao manju verziju?

Čim primijetite da ste prekršili specifikaciju Semantičkog verzioniranja,
potrebno je ispraviti pogrešku te izdati manju verziju koja će ispraviti problem
i vratiti kompatibilnost. Čak i u takvim uvjetima, nije prihvatljivo mijenjati
verzionirana izdanja. Ako je prikladno, dokumentirajte verziju koja krši
specifikaciju te informirajte korisnike kako bi je bili svjesni.

Što činiti ako promijenim ovisnosti bez mijenjanja javnog APIja?

Takve promjene smatramo kompatibilnima jer ne utječu na javni API. Softver koji
eksplicitno ovisi o istim ovisnostima kao i vaš paket treba imati vlastite
specifikacije ovisnosti, a autor će se brinuti o konfliktima. Je li promjena
na razini zakrpe ili manje verzije, ovisi o tome jeste li dodali ovisnosti
kako bi ispravili bug ili dodali nove funkcionalnosti. U posljednjem slučaju
možemo očekivati i dodatni kod, pri čemu se očito radi o novoj manjoj verziji.

Što ako nehotice promijenim javni API na način koji ne odgovara promjeni oznake verzije (npr. u kodu neispravno uvodim veću unatrag inkompatibilnu promjenu unutar izdanja zakrpe)?

Pokušajte najbolje prosuditi sami. Ako imate velik broj korisnika, na koje će
značajno utjecati promjena unatrag, najbolje je da objavite veću verziju, iako
bi takav ispravak mogli smatrati izdanjem zakrpe. Upamtite, poanta Semantičkog
verzioniranja je dodavanje značenja promjenama oznake verzije. Ako su takve
promjene bitne korisnicima koristite oznake verzije kako biste ih informirali.

Kako upravljati zastarjelim (deprecating) funkcionalnostima?

Postojeće funkcionalnosti koje zastarijevaju, uobičajeni su dio razvoja softvera
i često su potrebne kako bi razvoj napredovao. Kad označavate dio javnog APIja
kao zastarjeli (deprecated), potrebno je učiniti dvije stvari: (1) ažurirati
dokumentaciju kako bismo informirali korisnika, (2) izdati novu manju verziju
s definiranim zastarjelim (deprecated) dijelovima softvera. Prije nego potpuno
uklonite zastarjele funkcionalnost u novoj većoj verziji, potrebno je izdati
barem jednu manju verziju koja sadrži zastarjele (deprecated) dijelove, kako
bi korisnici glatko prešli na novu verziju APIja.

Ima li semver ograničenu veličinu oznake verzije?

Ne, ali budite razumni. Oznaka verzije od 255 znakova je vjerojatno pretjerana,
na primjer. Također, neki sustavi mogu imati svoja ograničenja veličine oznake.

O projektu

Autor specifikacije Semantičkog Verzioniranja je Tom
Preston-Werner, izumitelj Gravatara i suosnivač
GitHuba.

Ako želite ostaviti povratne informacije, molimo otvorite issue na
GitHubu.

Licenca

Creative Commons ― CC BY 3.0\nSemantičko verzioniranje 2.0.0\nUzevši oznake verzije VEĆA.MANJA.ZAKRPA, inkrementirajte:\nVEĆU verziju kada napravite inkompatibilne promjene u APIju,\nMANJU verziju kada dodate unatrag-kompatibilne funkcionalnosti i\nZAKRPA verziju kada napravite unatrag-kompatibilne ispravke bugova.\nDodatne oznake za pred-izdanja i metapodatke builda mogu se koristiti kao proširenje na VEĆA.MANJA.ZAKRPA format.\nU svijetu upravljanja softverom postoji strašno mjesto koje zovemo
“pakao ovisnosti.” Što više vaš sustav raste i što više paketa
integrirate u vaš softver, vjerojatnije je da ćete se, jednoga dana,
naći u toj jami očaja.\nU sustavima s više ovisnosti, izdavanje novih verzija paketa, može se vrlo brzo
pretvoriti u noćnu moru. Ako su specifikacije ovisnosti previše stroge, postoji
opasnost zaključavanja verzije (nemogućnosti nadogradnje paketa bez potrebe
izdavanja nove verzije svakog ovisnog paketa). Ako su pak ovisnosti specificirane
previše slobodno, sigurno ćete osjetiti posljedice verzijskog promiskuiteta
(pretpostavke kompatibilnosti s više budućih verzija nego što je razumno).
Pakao ovisnosti je slučaj gdje zaključavanje verzije i/ili verzijski promiskuitet
sprječavaju lagano i sigurno napredovanje projekta.\nKao rješenje tog problema predlažem jednostavan set pravila i zahtjeva
koji će nalagati kako se dodjeljuju i inkrementiraju oznake verzija.
Ova se pravila temelje, no nisu nužno i ograničena, na već postojećoj
i raširenoj uobičajenoj praksi u projektima otvorenog i zatvorenog koda.
Kako bi ovaj sustav funkcionirao, potrebno je prvo objaviti javni API. Možemo
to primijeniti u dokumentaciji ili u samom kodu. U svakom slučaju, važno je da
API bude jasan i precizan. Jednom kad identificiramo javni API, komuniciramo
promjene u njemu kroz specificirane inkrementacije u oznake/broja verzije.
Uzmimo format verzije X.Y.Z (VEĆA.MANJA.ZAKRPA). Ispravci bugova koji ne utječu
na API inkrementiraju oznaku zakrpe, unatrag-kompatibilni dodaci/promjene u
APIju inkrementiraju manju verziju, a unatrag inkompatibilne promjene u APIju
inkrementiraju veću verziju.\nOvaj sam sustav nazvao “Semantičko verzioniranje”. Unutar ove sheme, oznake
verzije i način na koji se mijenjaju prenose određene informacije o kodu koji
se nalazi ispod i što se mijenjalo od jedne do druge verzije.\nSpecifikacija semantičkog verzioniranja (SemVer)\nKljučne riječi “MORA”, “NE SMIJE”, “POTREBNO”, “BITI ĆE”, “NEĆE BITI”, “TREBALO BI”,
“NE BI TREBALO”, “PREPORUČENO”, “MOŽE”, i “OPCIONALNO” (“MUST”, “MUST NOT”,
“REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”,
“OPTIONAL”) u ovom dokumentu treba interpretirati kao što je opisano u
RFC 2119.\nSoftver koji koristi Semantičko verzioniranje MORA objaviti javni API. API
može biti deklariran u samom kodu ili postojati samo unutar dokumentacije.
U svakom slučaju, mora biti precizan i jasan.\nSoftver koji koristi Semantičko verzioniranje MORA objaviti javni API. API
može biti deklariran u samom kodu ili postojati samo unutar dokumentacije.
U svakom slučaju, mora biti precizan i jasan.\nNormalna oznaka verzije MORA biti u formatu X.Y.Z gdje su X, Y i Z ne-negativni
cijeli brojevi i ne smiju počinjati s nulom. X označava veću verziju, Y manju
verziju, a Z zakrpu. Svaki se element MORA numerički povećavati.
Na primjer: 1.9.0 -> 1.10.0 -> 1.11.0.\nNormalna oznaka verzije MORA biti u formatu X.Y.Z gdje su X, Y i Z ne-negativni
cijeli brojevi i ne smiju počinjati s nulom. X označava veću verziju, Y manju
verziju, a Z zakrpu. Svaki se element MORA numerički povećavati.
Na primjer: 1.9.0 -> 1.10.0 -> 1.11.0.\nJednom kad je verzionirani paket izdan, sadržaj te verzije NE SMIJE se
mijenjati. Sve promjene MORAJU se izdavati s novom verzijom.\nJednom kad je verzionirani paket izdan, sadržaj te verzije NE SMIJE se
mijenjati. Sve promjene MORAJU se izdavati s novom verzijom.\nVeća verzija nula (0.y.z) je za inicijalni razvoj. Bilo što se može mijenjati
u tom stadiju. Javni API se ne smatra stabilnim.\nVeća verzija nula (0.y.z) je za inicijalni razvoj. Bilo što se može mijenjati
u tom stadiju. Javni API se ne smatra stabilnim.\nVerzija 1.0.0 definira javni API. Način na koji će se oznaka verzije
inkrementirati ovisi o tom javnom APIju i načinu na koji se on mijenja.\nVerzija 1.0.0 definira javni API. Način na koji će se oznaka verzije
inkrementirati ovisi o tom javnom APIju i načinu na koji se on mijenja.\nOznaka verzije zakrpe Z (x.y.Z | x > 0) MORA se inkrementirati samo ako se
dodaju unatrag kompatibilni ispravci bugova. Ispravci bugova definiraju se kao
promjene unutar koda koje ispravljaju nepravilno ponašanje.\nOznaka verzije zakrpe Z (x.y.Z | x > 0) MORA se inkrementirati samo ako se
dodaju unatrag kompatibilni ispravci bugova. Ispravci bugova definiraju se kao
promjene unutar koda koje ispravljaju nepravilno ponašanje.\nOznaka manje verzije Y (x.Y.z | x > 0) MORA se inkrementirati ako se javnom
APIju dodaju nove unatrag kompatibilne funkcionalnosti. Također se MORA
inkrementirati ako se neke funkcionalnosti označe kao zastarjele (deprecated).
MOŽE se inkrementirati ako se uvode značajne nove funkcionalnosti ili poboljšanja
unutar koda. MOŽE se inkrementirati ako se uvode promjene na razini zakrpe. Kada
se oznaka manje verzije inkrementira, oznaka verzije zakrpe mora se vratiti na 0.\nOznaka manje verzije Y (x.Y.z | x > 0) MORA se inkrementirati ako se javnom
APIju dodaju nove unatrag kompatibilne funkcionalnosti. Također se MORA
inkrementirati ako se neke funkcionalnosti označe kao zastarjele (deprecated).
MOŽE se inkrementirati ako se uvode značajne nove funkcionalnosti ili poboljšanja
unutar koda. MOŽE se inkrementirati ako se uvode promjene na razini zakrpe. Kada
se oznaka manje verzije inkrementira, oznaka verzije zakrpe mora se vratiti na 0.\nOznaka veće verzije X (X.y.z | X > 0) MORA se inkrementirati ako se javnom
APIju dodaju unatrag inkompatibilne funkcionalnosti. MOŽE sadržavati promjene na
razini manje verzije i zakrpe. Kada se oznaka veće verzije inkrementira, oznake
manje verzije i zakrpe moraju se vratiti na 0.\nOznaka veće verzije X (X.y.z | X > 0) MORA se inkrementirati ako se javnom
APIju dodaju unatrag inkompatibilne funkcionalnosti. MOŽE sadržavati promjene na
razini manje verzije i zakrpe. Kada se oznaka veće verzije inkrementira, oznake
manje verzije i zakrpe moraju se vratiti na 0.\nVerzija predizdanja MOŽE se označiti dodavanjem crtice i niza identifikatora
odvojenih točkom, koji se odmah nastavljaju na oznaku verzije zakrpe. Ti se
identifikatori MORAJU sastojati samo od ASCII alfanumeričkih znakova i crtica
[0-9A-Za-z-]. Identifikatori NE SMIJU biti prazni. Numerički identifikatori NE
SMIJU počinjati nulom. Normalne verzije imaju prednost nad vezanim verzijama
predizdanja. Oznaka verzije predizdanja označava nestabilnu verziju koja ne
zadovoljava nužno predviđene zahtjeve kompatibilnosti navedene u vezanoj
normalnoj verziji. Primjeri: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.\nVerzija predizdanja MOŽE se označiti dodavanjem crtice i niza identifikatora
odvojenih točkom, koji se odmah nastavljaju na oznaku verzije zakrpe. Ti se
identifikatori MORAJU sastojati samo od ASCII alfanumeričkih znakova i crtica
[0-9A-Za-z-]. Identifikatori NE SMIJU biti prazni. Numerički identifikatori NE
SMIJU počinjati nulom. Normalne verzije imaju prednost nad vezanim verzijama
predizdanja. Oznaka verzije predizdanja označava nestabilnu verziju koja ne
zadovoljava nužno predviđene zahtjeve kompatibilnosti navedene u vezanoj
normalnoj verziji. Primjeri: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.\nMetapodaci builda MOGU se označiti dodavanjem znaka plus i niza identifikatora
odvojenih točkom, koji se odmah nastavljaju na oznaku verzije zakrpe ili
predizdanja. Ti se identifikatori MORAJU sastojati samo od ASCII alfanumeričkih
znakova i crtica [0-9A-Za-z-]. Identifikatori NE SMIJU biti prazni. Metapodaci
builda se ignoriraju kod procjene prednosti verzije. Dakle, dvije verzije koje
se razlikuju samo u metapodacima builda imaju jednaku prednost. Primjeri:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nMetapodaci builda MOGU se označiti dodavanjem znaka plus i niza identifikatora
odvojenih točkom, koji se odmah nastavljaju na oznaku verzije zakrpe ili
predizdanja. Ti se identifikatori MORAJU sastojati samo od ASCII alfanumeričkih
znakova i crtica [0-9A-Za-z-]. Identifikatori NE SMIJU biti prazni. Metapodaci
builda se ignoriraju kod procjene prednosti verzije. Dakle, dvije verzije koje
se razlikuju samo u metapodacima builda imaju jednaku prednost. Primjeri:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nPojam prednosti odnosi se na to kako uspoređujemo verzije u poretku.
Prednost se MORA procjenjivati tako da zasebno promatramo oznaku verzije kao
veću, manju, zakrpu i identifikatore predizdanja tim redom. (Metapodaci builda
ne utječu na prednost). Prednost određuje prva razlika u usporedbi svake
oznake s lijeva na desno na sljedeći način: Oznake veće verzije, manje verzije i
verzije zakrpe uvijek se uspoređuju numerički. Na primjer: 1.0.0 < 2.0.0 <
2.1.0 < 2.1.1. Kad su oznake veće, manje i verzije zakrpe jednake, normalna
verzija ima prednost nad verzijom predizdanja. Primjer: 1.0.0-alpha < 1.0.0.
Prednost između dvije verzije predizdanja s istim oznakama veće, manje i verzije
zakrpe MORAJU se odrediti usporedbom svake oznake odvojene točkom s lijeva na
desno, dok ne dođemo do razlike na sljedeći način: identifikatori koji se
sastoje samo od broja uspoređuju se numerički, dok se slova i crtice uspoređuju
leksički u ASCII poretku. Nebrojčane oznake uvijek imaju prednost nad brojčanim.
Veći niz oznaka predizdanja ima prednost nad manjim nizom, ako su prethodne
oznake jednake. Primjer: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPojam prednosti odnosi se na to kako uspoređujemo verzije u poretku.
Prednost se MORA procjenjivati tako da zasebno promatramo oznaku verzije kao
veću, manju, zakrpu i identifikatore predizdanja tim redom. (Metapodaci builda
ne utječu na prednost). Prednost određuje prva razlika u usporedbi svake
oznake s lijeva na desno na sljedeći način: Oznake veće verzije, manje verzije i
verzije zakrpe uvijek se uspoređuju numerički. Na primjer: 1.0.0 < 2.0.0 <
2.1.0 < 2.1.1. Kad su oznake veće, manje i verzije zakrpe jednake, normalna
verzija ima prednost nad verzijom predizdanja. Primjer: 1.0.0-alpha < 1.0.0.
Prednost između dvije verzije predizdanja s istim oznakama veće, manje i verzije
zakrpe MORAJU se odrediti usporedbom svake oznake odvojene točkom s lijeva na
desno, dok ne dođemo do razlike na sljedeći način: identifikatori koji se
sastoje samo od broja uspoređuju se numerički, dok se slova i crtice uspoređuju
leksički u ASCII poretku. Nebrojčane oznake uvijek imaju prednost nad brojčanim.
Veći niz oznaka predizdanja ima prednost nad manjim nizom, ako su prethodne
oznake jednake. Primjer: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nZašto koristiti Semantičko verzioniranje?\nOvo nije nova, niti revolucionarna ideja. Štoviše, vjerojatno već koristite
nešto vrlo slično. Problem je u tome što “slično” nije dovoljno dobro. Bez
poštivanja neke formalne specifikacije, oznake verzije su u suštini beskorisne
za upravljanje ovisnostima. Ako damo ime i jasnu definiciju gore navedenim
idejama, postaje lakše iskomunicirati svoje namjere korisnicima softvera.
Jednom kada su te namjere jasne i fleksibilne (ali ne previše fleksibilne)
možemo definirati specifikacije ovisnosti.\nMožemo jednostavnim primjerom pokazati kako Semantičko verzioniranje može
ostaviti pakao ovisnosti u prošlosti. Zamislite library “Vatrogasno_vozilo.”
Potreban joj je Semantički verzionirani paket “Ljestve”. U trenutku kad je
“Vatrogasno_vozilo” kreirano, “Ljestve” su na verziji 3.1.0. Budući da
“Vatrogasno_vozilo” koristi određene funkcionalnosti koje su uvedene u verziji
3.1.0, možete bez straha navesti ovisnost o paketu “Ljestve” verzije veće ili
jednake 3.1.0, ali manje od 4.0.0. Tako, kada “Ljestve” verzije 3.1.1 i 3.2.0
budu dostupne, možete ih dodati u svoj sustav upravljanja paketima i biti
sigurni da će biti kompatibilne s postojećim ovisnim softverom.\nKao odgovoran programer htjet ćete se, naravno, uvjeriti da će svaka nadogradnja
paketa funkcionirati kao što je navedeno. Stvarni je svijet zbrka i ne možemo
ništa poduzeti po tom pitanju osim biti oprezni. Ono što možete napraviti je
prihvatiti Semantičko verzioniranje kao siguran način za izdavanje i nadogradnju
paketa bez potrebe za izgradnjom novih verzija ovisnih paketa te tako sačuvati
vrijeme i živce.\nAko vam ovo sve dobro zvuči, sve što vam je potrebno da bi ste počeli koristiti
Semantičko verzioniranje je da navedete da ga koristite i slijedite pravila.
Stavite poveznicu na ovu stranicu u svoju README datoteku, kako bi i ostali bili
svjesni pravila i mogli imati koristi od njih.\nKako upravljati promjenama za inicijalne faze razvoja verzija 0.y.z?\nNajjednostavniji je način da započnete inicijalni razvoj izdavanjem verzije
0.1.0 te inkrementirate oznaku manje verzije za svako sljedeće izdanje.\nKako znamo kada izdati verziju 1.0.0?\nAko se softver koristi u produkciji, već bi vjerojatno trebao biti na verziji
1.0.0. Ako već imamo stabilni API, na koji korisnici mogu računati, trebao bi
biti na verziji 1.0.0. Ako ste zabrinuti zbog kompatibilnosti unatrag, softver
bi već trebao biti izdan pod verzijom 1.0.0.\nNe sprječava li ovo ubrzani razvoj i brzo povećavanje verzija?\nVeća verzija nula se svodi na brzi razvoj. Ako mijenjate API svaki dan, trebali
bi ostati na verziji 0.y.z ili na posebnoj grani raditi na sljedećoj većoj
verziji.\nAko i najmanje unatrag inkompatibilne promjene u APIju zahtijevaju povećanje veće verzije, neću li vrlo brzo doći do verzije 42.0.0?\nOvo je pitanje odgovornog razvoja i predviđanja. U softver koji ima puno
ovisnog koda, inkompatibilne promjene potrebno je uvoditi postupno. Cijena
nadogradnje može biti značajna. Ako morate povećati veću verziju, kako biste
izdali verziju s inkompatibilnim promjenama, morate razmisliti o posljedicama
tih promjenama i procijeniti odnos cijene i koristi.\nDokumentacija čitavog javnog APIja zahtijeva previše posla!\nVaša je odgovornost kao profesionalnih programera da ispravno dokumentirate
softver koji je namijenjen korisnicima. Upravljanje složenosti softvera vrlo
je važno kako biste projekt održali efikasnim, što je teško ako korisnici ne
znaju kako koristiti vaš softver ili koje metode mogu zvati. Semantičko
verzioniranje i kvalitetno definirani Semantički verzionirani javni API osigurat
će da sve funkcionira kako treba.\nŠto ako slučajno izdam unatrag inkompatibilne promjene kao manju verziju?\nČim primijetite da ste prekršili specifikaciju Semantičkog verzioniranja,
potrebno je ispraviti pogrešku te izdati manju verziju koja će ispraviti problem
i vratiti kompatibilnost. Čak i u takvim uvjetima, nije prihvatljivo mijenjati
verzionirana izdanja. Ako je prikladno, dokumentirajte verziju koja krši
specifikaciju te informirajte korisnike kako bi je bili svjesni.\nŠto činiti ako promijenim ovisnosti bez mijenjanja javnog APIja?\nTakve promjene smatramo kompatibilnima jer ne utječu na javni API. Softver koji
eksplicitno ovisi o istim ovisnostima kao i vaš paket treba imati vlastite
specifikacije ovisnosti, a autor će se brinuti o konfliktima. Je li promjena
na razini zakrpe ili manje verzije, ovisi o tome jeste li dodali ovisnosti
kako bi ispravili bug ili dodali nove funkcionalnosti. U posljednjem slučaju
možemo očekivati i dodatni kod, pri čemu se očito radi o novoj manjoj verziji.\nŠto ako nehotice promijenim javni API na način koji ne odgovara promjeni oznake verzije (npr. u kodu neispravno uvodim veću unatrag inkompatibilnu promjenu unutar izdanja zakrpe)?\nPokušajte najbolje prosuditi sami. Ako imate velik broj korisnika, na koje će
značajno utjecati promjena unatrag, najbolje je da objavite veću verziju, iako
bi takav ispravak mogli smatrati izdanjem zakrpe. Upamtite, poanta Semantičkog
verzioniranja je dodavanje značenja promjenama oznake verzije. Ako su takve
promjene bitne korisnicima koristite oznake verzije kako biste ih informirali.\nKako upravljati zastarjelim (deprecating) funkcionalnostima?\nPostojeće funkcionalnosti koje zastarijevaju, uobičajeni su dio razvoja softvera
i često su potrebne kako bi razvoj napredovao. Kad označavate dio javnog APIja
kao zastarjeli (deprecated), potrebno je učiniti dvije stvari: (1) ažurirati
dokumentaciju kako bismo informirali korisnika, (2) izdati novu manju verziju
s definiranim zastarjelim (deprecated) dijelovima softvera. Prije nego potpuno
uklonite zastarjele funkcionalnost u novoj većoj verziji, potrebno je izdati
barem jednu manju verziju koja sadrži zastarjele (deprecated) dijelove, kako
bi korisnici glatko prešli na novu verziju APIja.\nIma li semver ograničenu veličinu oznake verzije?\nNe, ali budite razumni. Oznaka verzije od 255 znakova je vjerojatno pretjerana,
na primjer. Također, neki sustavi mogu imati svoja ograničenja veličine oznake.\nAutor specifikacije Semantičkog Verzioniranja je Tom
Preston-Werner, izumitelj Gravatara i suosnivač
GitHuba.\nAko želite ostaviti povratne informacije, molimo otvorite issue na
GitHubu.\notvorite issue na
GitHubu\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nClick here if you are not redirected.\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nՍեմանտիկ Տարբերակում 2.0.0

Համառոտ

Այս ֆորմատով ներկայացված տարբերակի համարի (version number) դեպքում՝
ՄԱԺՈՐ․ՄԻՆՈՐ․ՓԱԹՉ (MAJOR.MINOR.PATCH), պետք է մեծացնել՝


  ՄԱԺՈՐ տարբերակի համարը, երբ տեղի են ունեցել API֊ի այնպիսի փոփոխություններ,
որոնց արդյունքում խախտվել է հետ համատեղելիությունը։
  ՄԻՆՈՐ տարբերակի համարը, երբ ավելացվել է նոր ֆունկցիոնալ՝ հետ
համատեղելիությունը չխախտելով (backwards-compatible)։
  ՓԱԹՉ տարբերակի համարը, երբ տեղի են ունեցել հետ համատեղելի փոփոխություններ։


Կարելի է անել նաև հավելյալ նշանակումներ՝ որպես հավելում ՄԱԺՈՐ․ՄԻՆՈՐ․ՓԱԹՉ
ֆորմատին․ մինչթողարկումային (pre-release) պիտակ (label) և բիլդ-մետատվյալ
(build metadata)։

Ներածություն

Ծրագրային ապահովման մենեջմենթի աշխարհում գոյություն ունի «կախվածությունների
դժոխք» (dependency hell) հասկացություն։ Ձեր համակարգի մեծացման և դրան ինտեգրված
փեքիջների քանակի ավելացման հետ մեծանում է հավանականությունը, որ դուք վաղ թե ուշ
կկանգնեք այս խնդրի առաջ։

Այն համակարգերում, որոնք ունեն շատ կախվածություններ, նոր տարբերակի թողարկումը
կարող է արագ վերածվել մղձավանջի։ Եթե կախվածությունների սպեցիֆիկացիան շատ խիստ է,
դուք կարող եք կանգնել նոր տարբերակի թողարկման արգելքի (version lock) առաջ
(անհնար է դառնում թարմացնել ծրագիրը՝ առանց թարմացնելու կախման մեջ գտնվող բոլոր
փեքիջները)։ Մյուս կողմից էլ, եթե կախվածությունների սպեցիֆիկացիան շատ ազատ է,
դուք անխուսափելիորեն կբախվեք տարբերակի անհամապատասխանության (version
promiscuity) խնդրին․ անհիմն է ենթադրությունը, որ ձեր ծրագիրը կմնա համատեղելի
ապագա տարբերակների հետ։ «Կախվածությունների դժոխքը» մի իրավիճակ է, երբ տարբերակի
թողարկման և/կամ տարբերակի անհապատասխանության արգելքը թույլ չի տալիս ձեզ հեշտ և
անվտանգ զարգացնել ձեր նախագիծը։

Որպես այս խնդրի լուծում՝ ես առաջարկում եմ պարզ կանոններ և պահանջներ, որոնք
սահմանում են, թե ինչպես են սահմանվում և մեծացվում տարբերակների համարները։ Այս
կանոնները հիմնված են (բայց ոչ անպայման սահմանափակված) բաց (open source) և փակ
(closed source) ծրագրային ապահովման գոյություն ունեցող և լայն տարածում գտած
պրակտիկաների վրա։ Նախևառաջ, որպեսզի այս կանոններն աշխատեն, դուք պետք է սահմանեք
փաբլիք API: Այն կարող է նկարագրված լինել ինչպես դոկումենտացիայի, այնպես էլ կոդի
մեջ։ Կարևոր է, որ API֊ը լինի ճիշտ և հասկանալի։ Ձեր API֊ը հայտարարելուց հետո դուք
փոփոխությունների մասին կտեղեկացնեք տարբերակի համարը մեծացնելու միջոցով։
Դիտարկենք այս ֆորմատով ներկայացված տարբերակ՝ X.Y.Z (ՄԱԺՈՐ․ՄԻՆՈՐ․ՓԱԹՉ)։ Սխալների
ուղղումները (bug fix), որոենք չեն ազդել API-ի վրա, մեծացնում են ՓԱԹՉ֊ը։ Հետ
համատեղելի հավելումները և փոփոխությունները մեծացնում են ՄԻՆՈՐ֊ը, հետ
համատեղելիությունը խախտող փոփոխությունները մեծացնում են ՄԱԺՈՐ֊ը։

Ես անվանել եմ այս համակարգը «Սեմանտիկ տարբերակում» (Semantic Versioning): Այս
սխեմայի միջոցով տարբերակի համարը և դրա փոխվելը իմաստավորում են կոդի
պարունակությունը և նրանում եղած փոփոխությունները տարբերակից տարբերակ։

Սեմանտիկ տարբերակման սպեցիֆիկացիա (SemVer)

Նշված բառերը՝ «ՊԵՏՔ Է» (MUST, SHALL), «ՉՊԵՏՔ Է» (MUST NOT, SHALL NOT),
«ՊԱՐՏԱԴԻՐ Է» (REQUIRED), «ԱՆՀՐԱԺԵՇՏ Է» (SHOULD), «ԱՆՀՐԱԺԵՇՏ ՉԷ» (SHOULD NOT),
«ԽՈՐՀՈՒՐԴ Է ՏՐՎՈՒՄ» (RECOMMENDED), «ԿԱՐՈՂ Է» (MAY) և «ՊԱՐՏԱԴԻՐ ՉԷ» (OPTIONAL)
պետք է ինտերպրիտացվեն RFC 2119 ստանդարտին
համապատասխան։


  
    Ծրագրային ապահովումը, որն օգտագործվում է Սեմանտիկ տարբերակում, ՊԵՏՔ Է (MUST)
հայտարարի հասանելի փաբլիք API: Այդ API֊ը կարող է հայտարարվել ինչպես կոդի մեջ,
այնպես էլ՝ առանձին դոկումենտացիայում։ Երկու դեպքում էլ այն պետք է լինի ճշգրիտ
(precise) և սպառիչ (comprehensive)։
  
  
    Տարբերակի ՆՈՐՄԱԼ համարը (normal version) ՊԵՏՔ Է (MUST) ունենա այս ֆորմատը՝
X.Y.Z, որտեղ X, Y և Z թվերը ոչ բացասական ամբողջ թվեր են և ՉՊԵՏՔ է (MUST NOT)
սկսվեն զրոյով։ X֊ը տարբերակի ՄԱԺՈՐ համարն է, Y֊ը՝ ՄԻՆՈՐ և Z֊ը՝ ՓԱԹՉ։ Բոլոր
բաղադիրչները պետք է մեծացվեն թվայնորեն․ օրինակ՝ 1.9.0 -> 1.10.0 -> 1.11.0։
  
  
    Փեքիջի թողարկումից հետո այդ տարբերակի պարունակությունը ՉՊԵՏՔ է (MUST NOT)
փոփոխության ենթարկվի։ Ցանկացած փոփոխություն ՊԵՏՔ Է (MUST) թողարկվի որպես նոր
տարբերակ։
  
  
    Զրոյական ՄԱԺՈՐ տարբերակը (0.y.z) նախատեսված է ծրագրային ապահովման
ստեղծման/մշակման նախնական փուլի (initial development) համար։ Ամեն ինչ կարող է
փոխվել՝ կամայական պահի։ Փաբլիք API֊ը չպետք է դիտարկվի որպես ստաբիլ։
  
  
    1.0.0 տարբերակի թողարկումից հետո API-ը համարվում է ստաբիլ, և տարբերակի համարը
փոխվում է կախված նրանից, թե ինչպես է փոխվում փաբլիք API֊ը։
  
  
    Տարբերակի ՓԱԹՉ համարը՝ Z (x.y.Z | x > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե տեղի են
ունեցել միայն հետ համատեղելի սխալների ուղղումներ (bug fix)։ Սխալի ուղղում՝
նշանակում է ներքին փոփոխություն, որը ուղղում է սխալ պահվածքը։
  
  
    Տարբերակի ՄԻՆՈՐ համարը՝ Y (x.Y.z | x > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե փաբլիք
API֊ում ավելացել է նոր հետ համատեղելի ֆունկցիոնալ։ Տարբերակի համարը ՊԵՏՔ Է
(MUST) մեծացվի, եթե հասանելի փաբլիք API֊ի որևէ ֆունկցիոնալ պիտակավորվել է
որպես հնացած (deprecated)։ Տարբերակի համարը ԿԱՐՈՂ Է (MAY) մեծացվել, եթե տեղի
է ունեցել նոր ֆունկցիոնալի ինտեգրացիա, կամ զգալի բարելավումներ են տեղի
ունեցել փրայվիթ կոդում։ Այն ԿԱՐՈՂ Է (MAY) նաև պարունակել ՓԱԹՉ մակարդակի
փոփոխություններ։ Տարբերակի ՓԱԹՉ համարը ՊԵՏՔ Է (MUST) զրոյացվի, երբ մեծացվում
է ՄԻՆՈՐ համարը։
  
  
    Տարբերակի ՄԱԺՈՐ համարը՝ X (X.y.z | X > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե փաբլիք
API֊ում ներկայացվել են հետ համատեղելիությունը խախտող կամայական
փոփոխություններ։ Այն ԿԱՐՈՂ Է (MAY) պարունակել նաև ՓԱԹՉ և ՄԻՆՈՐ մակարդակի
փոփոխություններ։ Տարբերակի ՓԱԹՉ և ՄԻՆՈՐ համարները ՊԵՏՔ Է (MUST) զրոյացվեն,
երբ մեծացվում է ՄԱԺՈՐ համարը։
  
  
    Մինչթողարկումային (pre-release) տարբերակը ԿԱՐՈՂ Է (MAY) պիտակավորվել
տարբերակի ՓԱԹՉ համարից անմիջապես հետո գծիկ և դրան հետևող կետիկով առանձնացված
տարբեր իդենտիֆիկատորներ ավելացնելու միջոցով։ Իդենտիֆիկատորները ՊԵՏՔ Է (MUST)
պարունակեն միայն ASCII տառա֊թվային սիմվոլներ և գծիկ՝ [0-9A-Za-z-]։
Իդենտիֆիկատորները ՉՊԵՏՔ Է (MUST NOT) լինեն դատարկ։ Թվային իդենտիֆիկատորները
ՉՊԵՏՔ Է (MUST NOT) սկսվեն զրոյով։ Մինչթողարկումային տարբերակները ունեն ավելի
ցածր ԿԱՐԳԱՎԻՃԱԿ, քան համապատասխան ՆՈՐՄԱԼ֊ները։ Մինչթողարկումային տարբերակը
ցույց է տալիս, որ այդ տարբերակը ստաբիլ չէ և կարող է չբավարարել
համատեղելիության պահանջները, որոնք նշված են համապատասխան ՆՈՐՄԱԼ տարբերակում․
օրինակ՝ 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92։
  
  
    Բիլդ֊մետատվյալները (build-metadata) ԿԱՐՈՂ ԵՆ (MAY) պիտակավորվել տարբերակի
ՓԱԹՉ համարից կամ մինչթողարկումային տարբերակի իդենտիֆիկատորից անմիջապես հետո
գումարման նշան և դրան հետևող կետիկով առանձնացված տարբեր իդենտիֆիկատորներ
ավելացնելու միջոցով։ Իդենտիֆիկատորները ՊԵՏՔ Է (MUST) պարունակեն միայն ASCII
տառա֊թվային սիմվոլներ և գծիկ՝ [0-9A-Za-z-]։ Իդենտիֆիկատորները ՉՊԵՏՔ Է (MUST
NOT) լինեն դատարկ։ Բիլդ֊մետատվյալները ՊԵՏՔ Է (MUST) անտեսել տարբերակի
ԿԱՐԳԱՎԻՃԱԿԸ որոշելիս այսինքն, եթե նույն ծրագրի երկու տարբերակները տարբերվում
են միայն բիլդ֊մետատվյալներով, ուրեմն դրանք ունեն նույն ԿԱՐԳԱՎԻՃԱԿԸ․ օրինակ՝
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85։
  
  
    ԿԱՐԳԱՎԻՃԱԿԸ (precedence) որոշում է, թե ինչպես է պետք համեմատել տարբերակները
միմյանց հետ, երբ դրանք դասավորված են։ ԿԱՐԳԱՎԻՃԱԿԸ ՊԵՏՔ Է (MUST) հաշվել
տարբերակի համարը՝ ՄԱԺՈՐ, ՄԻՆՈՐ, ՓԱԹՉ, և մինչթողարկումային իդենտիֆիկատորները
բաժանելու միջոցով։ ԿԱՐԳԱՎԻՃԱԿԸ որոշելիս բիլդ֊մետատվյալները հաշվի չեն առնվում։
ԿԱՐԳԱՎԻՃԱԿԸ որոշվում է ՄԱԺՈՐ, ՄԻՆՈՐ, ՓԱԹՉ տարբերակի համարները ձախից աջ
թվայնորեն համեմատելու միջոցով․ օրինակ՝ 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1։ Երբ
ՄԱԺՈՐ, ՄԻՆՈՐ և ՓԱԹՉ տարբերակի համարները հավասար են, մինչթողարկումային
տարբերակը ունենում է ավելի փոքր ԿԱՐԳԱՎԻՃԱԿ, քան ՆՈՐՄԱԼ տարբերակը․ օրինակ՝
1.0.0-alpha < 1.0.0։ Երբ տարբերակների ՄԱԺՈՐ, ՄԻՆՈՐ և ՓԱԹՉ համարները հավասար
են, ԿԱՐԳԱՎԻՃԱԿԸ ՊԵՏՔ Է (MUST) որոշել մինչթողարկումային տարբերակի միջոցով՝
ձախից աջ կետով առանձնացված իդենտիֆիկատորները համեմատելով մինչև առաջին
տարբերող իդենտիֆիկատոր գտնելը։ Մինչթողարկումային տարբերակները համեմատվում են
տվյալ եղանակով՝ իդենտիֆիկատորները, որոնք կազմված են միայն թվերից, համեմատվում
են թվայնորեն։ Տառեր և գծիկ պարունակող իդենտիֆիկատորները համեմատվում են
տառացի՝ ASCII աղյուսակի հերթականությամբ։ Թվային իդենտիֆիկատորները միշտ
ունենում են ավելի ցածր կարգավիճակ, քան ոչ թվայինները։ Մինչթողարկումային
սիմվոլների մեծ քանակ ունեցող տարբերակը ունենում է ավելի բարձր կարգավիճակ, երբ
համեմատվող իդենտիֆիկատորները նույնն են․ օրինակ՝ 1.0.0-alpha < 1.0.0-alpha.1 <
1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 <
1.0.0։
  


Բակուս֊Նոյերի սխեման SemVer֊ով ներկայացված տարբերակի համարների համար
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


Ի՞նչու օգտագործել սեմանտիկ տարբերակում

Սա նոր կամ հեղափոխական միտք չէ։ Հավանական է՝ դուք օգտվում եք տարբերակման նման
ինչ֊որ եղանակից։ Խնդիրն այն է, որ «նման» եղանակից օգվելը կարող է բավարար չլինել։
Առանց կոշտ սպեցիֆիկացիայի տարբերակի համարները անօգուտ են դառնում
կախվածությունները կարգավորելու հարցում։ Տալով անուն և որոշակիացնելով վերը
ձևակերպված մտքերը՝ ավելի հեշտ է դառնում հաղորդել ձեր մտքերը այն օգտատերերին,
որոնք օգտվում են ձեր ծրագրային ապահովումից։ Եթե այդ մտքերը հասկանալի են և ճկուն,
կախվածությունների սպեցիֆիկացիան կաշխատի։

Պարզ օրինակի միջոցով կարելի է ցույց տալ, թե ինչպես է Սեմանտիկ Տարբերակումը
«կախվածություննեի դժողքը» թողնում անցյալում։ Պատկերացնենք մի գրադարան (library),
որի անունն է՝ «Firetruck»։ Նրա աշխատանքի համար անհրաժեշ է Սեմանտիկ Տարբերակումով
թողարկվող «Ladder» փեքիջը։ Երբ Firetruck֊ը ստեղծվել էր, Ladder֊ի տարբերակի
համարն էր՝ 3.1.0։ Քանի որ Firetruck֊ը օգտագործում է Ladder֊ի 3.1.0 տարբերակի
ֆունկցիոնալը, դուք հանգիստ կարող եք հայտարարել կախվածությունը Ladder֊ի 3.1.0
տարբերակից, բայց ոչ ավել քան 4.0.0։ Երբ դուրս գա Ladder֊ի 3.2.0 տարբերակը, դուք
հաստատ կիմանաք, որ այն համատեղելի է ձեր ծրագրի հետ և կարող եք հանգիստ ինտեգրել
այն։

Որպես պատասխանատու ծրագրավորող՝ դուք իհարկե կցանկանաք վստահ լինել, որ բոլոր
թարմացումները աշխատում են այնպես ինչպես հայտարարվել է։ Իրական աշխարհում միշտ
խառնաշփոթ է, և ոչինչ չի կարելի անել դրա հետ, բացի ուշադիր լինելուց։ Սեմանտիկ
տարբերակման միջոցով դուք կարող եք թողարկել ձեր ծրագրային ապահովման նոր
տարբերակներ և թարմացումներ չմտածելով կախվածությունների մասին և պահպանել ձեր
ժամանակը և նյարդերը։

Եթե այս ամենը գայթակղիչ է թվում ձեզ, այն ամենը ինչ ձեզ անհրաժեշտ է՝ սկսել
օգտագործել Սեմանտիկ տարբերակումը, հայտարարել դրա մասին և հետևել կանոններին։ Նշեք
այս կայքի հղումը ձեր README֊ում և օգտագործողները կիմանան այս կանոնների մասին։

ՀՏՀ

Ի՞նչ է անհրաժեշտ անել 0.y.z տարբերակում արված փոփոխությունների հետ, ծրագրավորման նախնական փուլում։

Ամենահեշտ լուծումը աշխատանքը 0.1.0 տարբերակի թողարկումով սկսելն է և հետագայում
ամեն հաջորդ թողարկման համար ՄԻՆՈՐ տարբերակի համարը մեծացնելը։

Ի՞նչպես իմանալ, որ 1.0.0 տարբերակը թողարկելու ժամանկն է։

Եթե ձեր ծրագրային ապահովումը արդեն օգտագործվում է պրոդաքշնում, ամենայն
հավանականությամբ արդեն պետք է թողարկել 1.0.0 տարբերակը։ Եթե դուք ունեք ստաբիլ
API, որը ունի օգտագործողներ, տարբերակի համարը պետք է լինի 1.0.0։ Եթե
անհանգստանում եք հետ համատեղելիության մասին, ամենայն հավանականությամբ ձեր
ծրագրային ապահովման տարբերակի համարը արդեն պետք է լինի 1.0.0։

Արդյո՞ք աշխատելու այս ձևը չի խանգարում արագ ծրագրավորմանը (rapid development) և արագ իտերացիաներին (fast iteration)։

Երբ ՄԱԺՈՐ տարբերակի համարը 0 է, դա արդեն իսկ ենթադրում է արագ ծրագրավորում։ Եթե
դուք փոփոխեք API֊ը ամեն օր, ապա պետք է լինեք 0.y.z տարբերակի վրա, կամ առանձին
ճյուղի (branch) վրա աշխատեք հաջորդ ՄԱԺՈՐ տարբերակի թողարկման համար։

Եթե նույնիսկ փոքր փոփոխությունները, որոնք խախտում են հետ համատեղելիությունը, պահանջում են նոր ՄԱԺՈՐ տարբերակի թողարկում, արդյո՞ք դա չի հանգեցնի նրան, որ շուտով տարբերակի համարը դառնա 42.0.0։

Սա ավելի շատ պատասխանատվության և հեռատեսության խնդիր է։ Ծրագրային ապահովման հետ
համատեղելիությունը խախտող փոփոխությունները աննշան չեն, քանի որ դրա արդյունքում
թարմացումները կարող են շատ թանկ արժենալ։ Հետ համատեղելիությունը խախտող
փոփոխությունների թողարկումը տարբերակի ՄԱԺՈՐ համարի ավելացմամբ, նշանակում է՝ դուք
պետք է մտածեք ձեր փոփոխությունների հետևանքների մասին և հաշվի առնեք գին֊օգուտ
հարաբերակցությունը։

Դոկումենտացիայի կազմումը մեծ աշխատանք է պահանջում։

Որպես պրոֆեսիոնալ ծրագրավորող ձեր պատասխանատվությունն է ճիշտ դոկումենտացնել
ծրագրային ապահովումը, որը նախատեսված է ուրիշների օգտագործման համար։ Ծրագրային
ապահովման բարդության կարգավորումը նրա արդյունավետության պահպանման կարևոևագույն
կետերից մեկն է։ Եթե ոչ մեկը չգիտի, թե ինչպես օգտագործել ձեր ծրագրային
ապահովումը, կամ որ մեթոդի կանչն է անվտանգ, ինչպես պետք է նրանք օգտագործեն այն։
Երկարաժամկետ հեռանկարով Սեմանտիկ Տարբերակումը, համառ և կոշտ դիրքը որակով
շարադրված փաբլիք API֊ի նկատմամբ կնպաստեն ամենքի և ամեն ինչի ճիշտ և համակարգված
աշխատելուն։

Ի՞նչ է անհրաժեշտ անել, եթե պատահաբար թողարկվել են հետ համատեղելիությունը խախտող փոփոխություններ ՄԻՆՈՐ տարբերակի տակ։

Հենց որ դուք հասկացաք, որ խախտել եք Սեմանտիկ Տարբերակման սպեցիֆիկացիան, ուղղեք
սխալը և թողարկեք նոր ՄԻՆՈՐ տարբերակ, որը լուծում է խնդիրը և վերականգնում հետ
համատեղելիությունը։ Նույնիսկ նման դեպքերում անընդունելի է արդեն թողարկված
տարբերակներում փոփոխությունների իրականացումը։ Եթե անհրաժեշտ է, նշեք
դոկումենտացիայում և տեղյակ պահեք օգտագործողներին հետ համատեղելիության և
տարբերակման հերթականության խախտման մասին։

Ի՞նչ է անհրաժեշտ անել, եթե փոփոխվել են կախվածությունները առանց փաբլիք API֊ը փոփոխելու։

Դա կարող է դիտարկվել որպես հետ համատեղելի փոփոխություն, քանի որ այն չի ազդում
փաբլիք API֊ի վրա։ Ծրագրային ապահովումը, որը ակնհայտորեն ունի նույն
կախվածությունները, ինչ փեքիջը, պետք է ունենա իր սեփական կախվածությունների
սպեցիֆիկացիան, և հեղինակը տեղյակ կլինի ի հայտ եկած կոնֆլիկտների մասին։ Արդյոք
տվյալ փոփոխությունները ՄԱԺՈՐ, թե ՓԱԹՉ մակարդակի են, կախված է նրանից, թե դուք
փոխել եք ձեր կախվածությունները սխալներ ուղղելու, թե՞ նոր ֆունկցիոնալ ինտեգրելու
համար։ Երկրորդ դեպքում, որպես կանոն ավելանում է որոշակի քանակով կոդ և որպես
հետևանք մեծանում է տարբերակի ՄԻՆՈՐ համարը։

Ի՞նչ անել, եթե պատահաբար փոփոխվել է փաբլիք API֊ը, և այն չի համապատասխանում տարբերակի համարին (այսինքն՝ կոդը սխալմամբ պարունակում է հետ համատեղելիությունը խախտող փոփոխություններ ՓԱԹՉ տարբերակի թողարկման մեջ)։

Որոշումը ձերն է։ Եթե դուք ունեք օգտագործողների մեծ խումբ, որը կկանգնի փաբլիք
API֊ի նախկին ֆունկցիոնալի վերականգման փաստի առաջ, ուրեմն ճիշտ կլինի թողարկել նոր
տարբերակ ՄԱԺՈՐ համարի մեծացումով։ Չնայած նրան, որ այն պարունակում է միայն ՓԱԹՉ
մակարդակի փոփոխություններ, հիշեք՝ ըստ Սեմանտիկ Տարբերակման սպեցիֆիկացիայի
տարբերակի համարները մեծացվում են սպեցիֆիկացիային համաձայն։ Եթե այդ
փոփոխությունները կարևոր են ձեր օգտագործողների համար, օգտագործեք տարբերակի համարը
նրանց տեղյակ պահելու համար։

Ի՞նչ անել հնացած (deprecated) ֆունկցիոնալի հետ։

Որոշ ֆունկցիոնալի հնանալը սովորական երևույթ է և ծրագրային ապահովման
ստեղծման/մշակման ընթացքում հաճախ պարտադիր է առաջընթացի համար։ Երբ դուք հնացած եք
հայտարարում, փաբլիք API֊ի ինչ֊որ հատված, դուք պետք է երկու բան անեք․ նախ
թարմացնեք ձեր դոկումենտացիան և տեղեկացնեք օգտագործողներին փոփոխության մասին (1),
և ապա թողարկեք նոր ՄԻՆՈՐ տարբերակ՝ նշում կատարելով հնացած ֆունկցիոնալի մասին
(2)։ Մինչ դուք ամբողջովին կջնջեք հնացած ֆունկցիոնալը, հաջորդ ՄԱԺՈՐ թողարկման
ժամանակ պետք է լինի առնվազն մեկ ՄԻՆՈՐ թողարկում, որը պարունակում է տեղեկություն
ֆունկցիոնալի հնացած հայտարարվելու մասին, որպեսզի օգտագործողները հեշտությամբ
անցնեն նոր API֊ի։

Արդյոք SemVer֊ը ունի՞ սահմանափակում տարբերակի համարի երկարության վրա։

Ոչ, բայց եղեք խելամիտ։ Եթե տարբերակի համարի երկարությունը 255 սիմվոլ է,
հավանաբար դա չափազանց է։ Բացի դրանից որոշ համակարգեր կարող են ունենալ իրենց
սեփական սահմանափակումները տարբերակի համարի երկարության վրա։

«v1.2.3» ֆորմատը համարվու՞մ է տարբերակի սեմանտիկ համար։

Ոչ, «v1.2.3»֊ը տարբերակի սեմանտիկ համար չի համարվում։ Ամեն դեպքում «v» տառը
սեմանտիկ տարբերակի առջևում դնելը ընդունված երևույթ է (անգլերենում) տարբերակի
համարը ընդգծելու համար։ «v» հապավման օգտագործումը «version» բառի փոխարեն
տարածված պրակտիկա է տարբերակների կարգավորման (version control) մեջ: Օրինակ՝
git tag v1.2.3 -m "Release version 1.2.3"․ այստեղ «v1.2.3»֊ը թեգի անուն է, և
սեմանտիկ տարբերակը «1.2.3» է։

Ինչպիսի՞ ռեգուլյար արտահայտության (RegEx) միջոցով կարելի է ստուգել SemVer տարբերակի համարի ճշտությունը:

Կա երկու եղանակ.


  անվանական խմբերի միջոցով (named groups)։ (PCRE [Perl համատեղելի ռեգուլյար
արտահայտություններ, օրինակ՝ Perl, PHP և R], Python և Go)։


Տես՝ https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$



  թվային խմբերի (numbered capture groups) միջոցով (cg1 = major, cg2 = minor,
cg3 = patch, cg4 = prerelease and cg5 = buildmetadata)։ Այս եղանակը համատեղելի է
ECMA Script֊ի (JavaScript), PCRE֊ի (Perl համատեղելի ռեգուլյար
արտահայտություններ, օրինակ՝ Perl, PHP և R), Python և Go.


Տես՝ https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Հեղինակ

Սեմանտիկ Տարբերակման սպեցիֆիկացիայի հեղինակն է
Թոմ Պրեստոն-Վարները (Gravatar֊ի հիմնադիր և
GitHub֊ի համահիմնադիր)։

Եթե դուք ցանկանում եք որևէ մեկնաբանություն թողնել, խնդրում ենք
GitHub֊ում հարց (issue) բացել։

Լիցենզիա

Creative Commons ― CC BY 3.0\nՍեմանտիկ Տարբերակում 2.0.0\nԱյս ֆորմատով ներկայացված տարբերակի համարի (version number) դեպքում՝
ՄԱԺՈՐ․ՄԻՆՈՐ․ՓԱԹՉ (MAJOR.MINOR.PATCH), պետք է մեծացնել՝\nՄԱԺՈՐ տարբերակի համարը, երբ տեղի են ունեցել API֊ի այնպիսի փոփոխություններ,
որոնց արդյունքում խախտվել է հետ համատեղելիությունը։\nՄԻՆՈՐ տարբերակի համարը, երբ ավելացվել է նոր ֆունկցիոնալ՝ հետ
համատեղելիությունը չխախտելով (backwards-compatible)։\nՓԱԹՉ տարբերակի համարը, երբ տեղի են ունեցել հետ համատեղելի փոփոխություններ։\nԿարելի է անել նաև հավելյալ նշանակումներ՝ որպես հավելում ՄԱԺՈՐ․ՄԻՆՈՐ․ՓԱԹՉ
ֆորմատին․ մինչթողարկումային (pre-release) պիտակ (label) և բիլդ-մետատվյալ
(build metadata)։\nԾրագրային ապահովման մենեջմենթի աշխարհում գոյություն ունի «կախվածությունների
դժոխք» (dependency hell) հասկացություն։ Ձեր համակարգի մեծացման և դրան ինտեգրված
փեքիջների քանակի ավելացման հետ մեծանում է հավանականությունը, որ դուք վաղ թե ուշ
կկանգնեք այս խնդրի առաջ։\nԱյն համակարգերում, որոնք ունեն շատ կախվածություններ, նոր տարբերակի թողարկումը
կարող է արագ վերածվել մղձավանջի։ Եթե կախվածությունների սպեցիֆիկացիան շատ խիստ է,
դուք կարող եք կանգնել նոր տարբերակի թողարկման արգելքի (version lock) առաջ
(անհնար է դառնում թարմացնել ծրագիրը՝ առանց թարմացնելու կախման մեջ գտնվող բոլոր
փեքիջները)։ Մյուս կողմից էլ, եթե կախվածությունների սպեցիֆիկացիան շատ ազատ է,
դուք անխուսափելիորեն կբախվեք տարբերակի անհամապատասխանության (version
promiscuity) խնդրին․ անհիմն է ենթադրությունը, որ ձեր ծրագիրը կմնա համատեղելի
ապագա տարբերակների հետ։ «Կախվածությունների դժոխքը» մի իրավիճակ է, երբ տարբերակի
թողարկման և/կամ տարբերակի անհապատասխանության արգելքը թույլ չի տալիս ձեզ հեշտ և
անվտանգ զարգացնել ձեր նախագիծը։\nՈրպես այս խնդրի լուծում՝ ես առաջարկում եմ պարզ կանոններ և պահանջներ, որոնք
սահմանում են, թե ինչպես են սահմանվում և մեծացվում տարբերակների համարները։ Այս
կանոնները հիմնված են (բայց ոչ անպայման սահմանափակված) բաց (open source) և փակ
(closed source) ծրագրային ապահովման գոյություն ունեցող և լայն տարածում գտած
պրակտիկաների վրա։ Նախևառաջ, որպեսզի այս կանոններն աշխատեն, դուք պետք է սահմանեք
փաբլիք API: Այն կարող է նկարագրված լինել ինչպես դոկումենտացիայի, այնպես էլ կոդի
մեջ։ Կարևոր է, որ API֊ը լինի ճիշտ և հասկանալի։ Ձեր API֊ը հայտարարելուց հետո դուք
փոփոխությունների մասին կտեղեկացնեք տարբերակի համարը մեծացնելու միջոցով։
Դիտարկենք այս ֆորմատով ներկայացված տարբերակ՝ X.Y.Z (ՄԱԺՈՐ․ՄԻՆՈՐ․ՓԱԹՉ)։ Սխալների
ուղղումները (bug fix), որոենք չեն ազդել API-ի վրա, մեծացնում են ՓԱԹՉ֊ը։ Հետ
համատեղելի հավելումները և փոփոխությունները մեծացնում են ՄԻՆՈՐ֊ը, հետ
համատեղելիությունը խախտող փոփոխությունները մեծացնում են ՄԱԺՈՐ֊ը։\nԵս անվանել եմ այս համակարգը «Սեմանտիկ տարբերակում» (Semantic Versioning): Այս
սխեմայի միջոցով տարբերակի համարը և դրա փոխվելը իմաստավորում են կոդի
պարունակությունը և նրանում եղած փոփոխությունները տարբերակից տարբերակ։\nՍեմանտիկ տարբերակման սպեցիֆիկացիա (SemVer)\nՆշված բառերը՝ «ՊԵՏՔ Է» (MUST, SHALL), «ՉՊԵՏՔ Է» (MUST NOT, SHALL NOT),
«ՊԱՐՏԱԴԻՐ Է» (REQUIRED), «ԱՆՀՐԱԺԵՇՏ Է» (SHOULD), «ԱՆՀՐԱԺԵՇՏ ՉԷ» (SHOULD NOT),
«ԽՈՐՀՈՒՐԴ Է ՏՐՎՈՒՄ» (RECOMMENDED), «ԿԱՐՈՂ Է» (MAY) և «ՊԱՐՏԱԴԻՐ ՉԷ» (OPTIONAL)
պետք է ինտերպրիտացվեն RFC 2119 ստանդարտին
համապատասխան։\nԾրագրային ապահովումը, որն օգտագործվում է Սեմանտիկ տարբերակում, ՊԵՏՔ Է (MUST)
հայտարարի հասանելի փաբլիք API: Այդ API֊ը կարող է հայտարարվել ինչպես կոդի մեջ,
այնպես էլ՝ առանձին դոկումենտացիայում։ Երկու դեպքում էլ այն պետք է լինի ճշգրիտ
(precise) և սպառիչ (comprehensive)։\nԾրագրային ապահովումը, որն օգտագործվում է Սեմանտիկ տարբերակում, ՊԵՏՔ Է (MUST)
հայտարարի հասանելի փաբլիք API: Այդ API֊ը կարող է հայտարարվել ինչպես կոդի մեջ,
այնպես էլ՝ առանձին դոկումենտացիայում։ Երկու դեպքում էլ այն պետք է լինի ճշգրիտ
(precise) և սպառիչ (comprehensive)։\nՏարբերակի ՆՈՐՄԱԼ համարը (normal version) ՊԵՏՔ Է (MUST) ունենա այս ֆորմատը՝
X.Y.Z, որտեղ X, Y և Z թվերը ոչ բացասական ամբողջ թվեր են և ՉՊԵՏՔ է (MUST NOT)
սկսվեն զրոյով։ X֊ը տարբերակի ՄԱԺՈՐ համարն է, Y֊ը՝ ՄԻՆՈՐ և Z֊ը՝ ՓԱԹՉ։ Բոլոր
բաղադիրչները պետք է մեծացվեն թվայնորեն․ օրինակ՝ 1.9.0 -> 1.10.0 -> 1.11.0։\nՏարբերակի ՆՈՐՄԱԼ համարը (normal version) ՊԵՏՔ Է (MUST) ունենա այս ֆորմատը՝
X.Y.Z, որտեղ X, Y և Z թվերը ոչ բացասական ամբողջ թվեր են և ՉՊԵՏՔ է (MUST NOT)
սկսվեն զրոյով։ X֊ը տարբերակի ՄԱԺՈՐ համարն է, Y֊ը՝ ՄԻՆՈՐ և Z֊ը՝ ՓԱԹՉ։ Բոլոր
բաղադիրչները պետք է մեծացվեն թվայնորեն․ օրինակ՝ 1.9.0 -> 1.10.0 -> 1.11.0։\nՓեքիջի թողարկումից հետո այդ տարբերակի պարունակությունը ՉՊԵՏՔ է (MUST NOT)
փոփոխության ենթարկվի։ Ցանկացած փոփոխություն ՊԵՏՔ Է (MUST) թողարկվի որպես նոր
տարբերակ։\nՓեքիջի թողարկումից հետո այդ տարբերակի պարունակությունը ՉՊԵՏՔ է (MUST NOT)
փոփոխության ենթարկվի։ Ցանկացած փոփոխություն ՊԵՏՔ Է (MUST) թողարկվի որպես նոր
տարբերակ։\nԶրոյական ՄԱԺՈՐ տարբերակը (0.y.z) նախատեսված է ծրագրային ապահովման
ստեղծման/մշակման նախնական փուլի (initial development) համար։ Ամեն ինչ կարող է
փոխվել՝ կամայական պահի։ Փաբլիք API֊ը չպետք է դիտարկվի որպես ստաբիլ։\nԶրոյական ՄԱԺՈՐ տարբերակը (0.y.z) նախատեսված է ծրագրային ապահովման
ստեղծման/մշակման նախնական փուլի (initial development) համար։ Ամեն ինչ կարող է
փոխվել՝ կամայական պահի։ Փաբլիք API֊ը չպետք է դիտարկվի որպես ստաբիլ։\n1.0.0 տարբերակի թողարկումից հետո API-ը համարվում է ստաբիլ, և տարբերակի համարը
փոխվում է կախված նրանից, թե ինչպես է փոխվում փաբլիք API֊ը։\n1.0.0 տարբերակի թողարկումից հետո API-ը համարվում է ստաբիլ, և տարբերակի համարը
փոխվում է կախված նրանից, թե ինչպես է փոխվում փաբլիք API֊ը։\nՏարբերակի ՓԱԹՉ համարը՝ Z (x.y.Z | x > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե տեղի են
ունեցել միայն հետ համատեղելի սխալների ուղղումներ (bug fix)։ Սխալի ուղղում՝
նշանակում է ներքին փոփոխություն, որը ուղղում է սխալ պահվածքը։\nՏարբերակի ՓԱԹՉ համարը՝ Z (x.y.Z | x > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե տեղի են
ունեցել միայն հետ համատեղելի սխալների ուղղումներ (bug fix)։ Սխալի ուղղում՝
նշանակում է ներքին փոփոխություն, որը ուղղում է սխալ պահվածքը։\nՏարբերակի ՄԻՆՈՐ համարը՝ Y (x.Y.z | x > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե փաբլիք
API֊ում ավելացել է նոր հետ համատեղելի ֆունկցիոնալ։ Տարբերակի համարը ՊԵՏՔ Է
(MUST) մեծացվի, եթե հասանելի փաբլիք API֊ի որևէ ֆունկցիոնալ պիտակավորվել է
որպես հնացած (deprecated)։ Տարբերակի համարը ԿԱՐՈՂ Է (MAY) մեծացվել, եթե տեղի
է ունեցել նոր ֆունկցիոնալի ինտեգրացիա, կամ զգալի բարելավումներ են տեղի
ունեցել փրայվիթ կոդում։ Այն ԿԱՐՈՂ Է (MAY) նաև պարունակել ՓԱԹՉ մակարդակի
փոփոխություններ։ Տարբերակի ՓԱԹՉ համարը ՊԵՏՔ Է (MUST) զրոյացվի, երբ մեծացվում
է ՄԻՆՈՐ համարը։\nՏարբերակի ՄԻՆՈՐ համարը՝ Y (x.Y.z | x > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե փաբլիք
API֊ում ավելացել է նոր հետ համատեղելի ֆունկցիոնալ։ Տարբերակի համարը ՊԵՏՔ Է
(MUST) մեծացվի, եթե հասանելի փաբլիք API֊ի որևէ ֆունկցիոնալ պիտակավորվել է
որպես հնացած (deprecated)։ Տարբերակի համարը ԿԱՐՈՂ Է (MAY) մեծացվել, եթե տեղի
է ունեցել նոր ֆունկցիոնալի ինտեգրացիա, կամ զգալի բարելավումներ են տեղի
ունեցել փրայվիթ կոդում։ Այն ԿԱՐՈՂ Է (MAY) նաև պարունակել ՓԱԹՉ մակարդակի
փոփոխություններ։ Տարբերակի ՓԱԹՉ համարը ՊԵՏՔ Է (MUST) զրոյացվի, երբ մեծացվում
է ՄԻՆՈՐ համարը։\nՏարբերակի ՄԱԺՈՐ համարը՝ X (X.y.z | X > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե փաբլիք
API֊ում ներկայացվել են հետ համատեղելիությունը խախտող կամայական
փոփոխություններ։ Այն ԿԱՐՈՂ Է (MAY) պարունակել նաև ՓԱԹՉ և ՄԻՆՈՐ մակարդակի
փոփոխություններ։ Տարբերակի ՓԱԹՉ և ՄԻՆՈՐ համարները ՊԵՏՔ Է (MUST) զրոյացվեն,
երբ մեծացվում է ՄԱԺՈՐ համարը։\nՏարբերակի ՄԱԺՈՐ համարը՝ X (X.y.z | X > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե փաբլիք
API֊ում ներկայացվել են հետ համատեղելիությունը խախտող կամայական
փոփոխություններ։ Այն ԿԱՐՈՂ Է (MAY) պարունակել նաև ՓԱԹՉ և ՄԻՆՈՐ մակարդակի
փոփոխություններ։ Տարբերակի ՓԱԹՉ և ՄԻՆՈՐ համարները ՊԵՏՔ Է (MUST) զրոյացվեն,
երբ մեծացվում է ՄԱԺՈՐ համարը։\nՄինչթողարկումային (pre-release) տարբերակը ԿԱՐՈՂ Է (MAY) պիտակավորվել
տարբերակի ՓԱԹՉ համարից անմիջապես հետո գծիկ և դրան հետևող կետիկով առանձնացված
տարբեր իդենտիֆիկատորներ ավելացնելու միջոցով։ Իդենտիֆիկատորները ՊԵՏՔ Է (MUST)
պարունակեն միայն ASCII տառա֊թվային սիմվոլներ և գծիկ՝ [0-9A-Za-z-]։
Իդենտիֆիկատորները ՉՊԵՏՔ Է (MUST NOT) լինեն դատարկ։ Թվային իդենտիֆիկատորները
ՉՊԵՏՔ Է (MUST NOT) սկսվեն զրոյով։ Մինչթողարկումային տարբերակները ունեն ավելի
ցածր ԿԱՐԳԱՎԻՃԱԿ, քան համապատասխան ՆՈՐՄԱԼ֊ները։ Մինչթողարկումային տարբերակը
ցույց է տալիս, որ այդ տարբերակը ստաբիլ չէ և կարող է չբավարարել
համատեղելիության պահանջները, որոնք նշված են համապատասխան ՆՈՐՄԱԼ տարբերակում․
օրինակ՝ 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92։\nՄինչթողարկումային (pre-release) տարբերակը ԿԱՐՈՂ Է (MAY) պիտակավորվել
տարբերակի ՓԱԹՉ համարից անմիջապես հետո գծիկ և դրան հետևող կետիկով առանձնացված
տարբեր իդենտիֆիկատորներ ավելացնելու միջոցով։ Իդենտիֆիկատորները ՊԵՏՔ Է (MUST)
պարունակեն միայն ASCII տառա֊թվային սիմվոլներ և գծիկ՝ [0-9A-Za-z-]։
Իդենտիֆիկատորները ՉՊԵՏՔ Է (MUST NOT) լինեն դատարկ։ Թվային իդենտիֆիկատորները
ՉՊԵՏՔ Է (MUST NOT) սկսվեն զրոյով։ Մինչթողարկումային տարբերակները ունեն ավելի
ցածր ԿԱՐԳԱՎԻՃԱԿ, քան համապատասխան ՆՈՐՄԱԼ֊ները։ Մինչթողարկումային տարբերակը
ցույց է տալիս, որ այդ տարբերակը ստաբիլ չէ և կարող է չբավարարել
համատեղելիության պահանջները, որոնք նշված են համապատասխան ՆՈՐՄԱԼ տարբերակում․
օրինակ՝ 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92։\nԲիլդ֊մետատվյալները (build-metadata) ԿԱՐՈՂ ԵՆ (MAY) պիտակավորվել տարբերակի
ՓԱԹՉ համարից կամ մինչթողարկումային տարբերակի իդենտիֆիկատորից անմիջապես հետո
գումարման նշան և դրան հետևող կետիկով առանձնացված տարբեր իդենտիֆիկատորներ
ավելացնելու միջոցով։ Իդենտիֆիկատորները ՊԵՏՔ Է (MUST) պարունակեն միայն ASCII
տառա֊թվային սիմվոլներ և գծիկ՝ [0-9A-Za-z-]։ Իդենտիֆիկատորները ՉՊԵՏՔ Է (MUST
NOT) լինեն դատարկ։ Բիլդ֊մետատվյալները ՊԵՏՔ Է (MUST) անտեսել տարբերակի
ԿԱՐԳԱՎԻՃԱԿԸ որոշելիս այսինքն, եթե նույն ծրագրի երկու տարբերակները տարբերվում
են միայն բիլդ֊մետատվյալներով, ուրեմն դրանք ունեն նույն ԿԱՐԳԱՎԻՃԱԿԸ․ օրինակ՝
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85։\nԲիլդ֊մետատվյալները (build-metadata) ԿԱՐՈՂ ԵՆ (MAY) պիտակավորվել տարբերակի
ՓԱԹՉ համարից կամ մինչթողարկումային տարբերակի իդենտիֆիկատորից անմիջապես հետո
գումարման նշան և դրան հետևող կետիկով առանձնացված տարբեր իդենտիֆիկատորներ
ավելացնելու միջոցով։ Իդենտիֆիկատորները ՊԵՏՔ Է (MUST) պարունակեն միայն ASCII
տառա֊թվային սիմվոլներ և գծիկ՝ [0-9A-Za-z-]։ Իդենտիֆիկատորները ՉՊԵՏՔ Է (MUST
NOT) լինեն դատարկ։ Բիլդ֊մետատվյալները ՊԵՏՔ Է (MUST) անտեսել տարբերակի
ԿԱՐԳԱՎԻՃԱԿԸ որոշելիս այսինքն, եթե նույն ծրագրի երկու տարբերակները տարբերվում
են միայն բիլդ֊մետատվյալներով, ուրեմն դրանք ունեն նույն ԿԱՐԳԱՎԻՃԱԿԸ․ օրինակ՝
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85։\nԿԱՐԳԱՎԻՃԱԿԸ (precedence) որոշում է, թե ինչպես է պետք համեմատել տարբերակները
միմյանց հետ, երբ դրանք դասավորված են։ ԿԱՐԳԱՎԻՃԱԿԸ ՊԵՏՔ Է (MUST) հաշվել
տարբերակի համարը՝ ՄԱԺՈՐ, ՄԻՆՈՐ, ՓԱԹՉ, և մինչթողարկումային իդենտիֆիկատորները
բաժանելու միջոցով։ ԿԱՐԳԱՎԻՃԱԿԸ որոշելիս բիլդ֊մետատվյալները հաշվի չեն առնվում։
ԿԱՐԳԱՎԻՃԱԿԸ որոշվում է ՄԱԺՈՐ, ՄԻՆՈՐ, ՓԱԹՉ տարբերակի համարները ձախից աջ
թվայնորեն համեմատելու միջոցով․ օրինակ՝ 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1։ Երբ
ՄԱԺՈՐ, ՄԻՆՈՐ և ՓԱԹՉ տարբերակի համարները հավասար են, մինչթողարկումային
տարբերակը ունենում է ավելի փոքր ԿԱՐԳԱՎԻՃԱԿ, քան ՆՈՐՄԱԼ տարբերակը․ օրինակ՝
1.0.0-alpha < 1.0.0։ Երբ տարբերակների ՄԱԺՈՐ, ՄԻՆՈՐ և ՓԱԹՉ համարները հավասար
են, ԿԱՐԳԱՎԻՃԱԿԸ ՊԵՏՔ Է (MUST) որոշել մինչթողարկումային տարբերակի միջոցով՝
ձախից աջ կետով առանձնացված իդենտիֆիկատորները համեմատելով մինչև առաջին
տարբերող իդենտիֆիկատոր գտնելը։ Մինչթողարկումային տարբերակները համեմատվում են
տվյալ եղանակով՝ իդենտիֆիկատորները, որոնք կազմված են միայն թվերից, համեմատվում
են թվայնորեն։ Տառեր և գծիկ պարունակող իդենտիֆիկատորները համեմատվում են
տառացի՝ ASCII աղյուսակի հերթականությամբ։ Թվային իդենտիֆիկատորները միշտ
ունենում են ավելի ցածր կարգավիճակ, քան ոչ թվայինները։ Մինչթողարկումային
սիմվոլների մեծ քանակ ունեցող տարբերակը ունենում է ավելի բարձր կարգավիճակ, երբ
համեմատվող իդենտիֆիկատորները նույնն են․ օրինակ՝ 1.0.0-alpha < 1.0.0-alpha.1 <
1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 <
1.0.0։\nԿԱՐԳԱՎԻՃԱԿԸ (precedence) որոշում է, թե ինչպես է պետք համեմատել տարբերակները
միմյանց հետ, երբ դրանք դասավորված են։ ԿԱՐԳԱՎԻՃԱԿԸ ՊԵՏՔ Է (MUST) հաշվել
տարբերակի համարը՝ ՄԱԺՈՐ, ՄԻՆՈՐ, ՓԱԹՉ, և մինչթողարկումային իդենտիֆիկատորները
բաժանելու միջոցով։ ԿԱՐԳԱՎԻՃԱԿԸ որոշելիս բիլդ֊մետատվյալները հաշվի չեն առնվում։
ԿԱՐԳԱՎԻՃԱԿԸ որոշվում է ՄԱԺՈՐ, ՄԻՆՈՐ, ՓԱԹՉ տարբերակի համարները ձախից աջ
թվայնորեն համեմատելու միջոցով․ օրինակ՝ 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1։ Երբ
ՄԱԺՈՐ, ՄԻՆՈՐ և ՓԱԹՉ տարբերակի համարները հավասար են, մինչթողարկումային
տարբերակը ունենում է ավելի փոքր ԿԱՐԳԱՎԻՃԱԿ, քան ՆՈՐՄԱԼ տարբերակը․ օրինակ՝
1.0.0-alpha < 1.0.0։ Երբ տարբերակների ՄԱԺՈՐ, ՄԻՆՈՐ և ՓԱԹՉ համարները հավասար
են, ԿԱՐԳԱՎԻՃԱԿԸ ՊԵՏՔ Է (MUST) որոշել մինչթողարկումային տարբերակի միջոցով՝
ձախից աջ կետով առանձնացված իդենտիֆիկատորները համեմատելով մինչև առաջին
տարբերող իդենտիֆիկատոր գտնելը։ Մինչթողարկումային տարբերակները համեմատվում են
տվյալ եղանակով՝ իդենտիֆիկատորները, որոնք կազմված են միայն թվերից, համեմատվում
են թվայնորեն։ Տառեր և գծիկ պարունակող իդենտիֆիկատորները համեմատվում են
տառացի՝ ASCII աղյուսակի հերթականությամբ։ Թվային իդենտիֆիկատորները միշտ
ունենում են ավելի ցածր կարգավիճակ, քան ոչ թվայինները։ Մինչթողարկումային
սիմվոլների մեծ քանակ ունեցող տարբերակը ունենում է ավելի բարձր կարգավիճակ, երբ
համեմատվող իդենտիֆիկատորները նույնն են․ օրինակ՝ 1.0.0-alpha < 1.0.0-alpha.1 <
1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 <
1.0.0։\nԲակուս֊Նոյերի սխեման SemVer֊ով ներկայացված տարբերակի համարների համար\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nԻ՞նչու օգտագործել սեմանտիկ տարբերակում\nՍա նոր կամ հեղափոխական միտք չէ։ Հավանական է՝ դուք օգտվում եք տարբերակման նման
ինչ֊որ եղանակից։ Խնդիրն այն է, որ «նման» եղանակից օգվելը կարող է բավարար չլինել։
Առանց կոշտ սպեցիֆիկացիայի տարբերակի համարները անօգուտ են դառնում
կախվածությունները կարգավորելու հարցում։ Տալով անուն և որոշակիացնելով վերը
ձևակերպված մտքերը՝ ավելի հեշտ է դառնում հաղորդել ձեր մտքերը այն օգտատերերին,
որոնք օգտվում են ձեր ծրագրային ապահովումից։ Եթե այդ մտքերը հասկանալի են և ճկուն,
կախվածությունների սպեցիֆիկացիան կաշխատի։\nՊարզ օրինակի միջոցով կարելի է ցույց տալ, թե ինչպես է Սեմանտիկ Տարբերակումը
«կախվածություննեի դժողքը» թողնում անցյալում։ Պատկերացնենք մի գրադարան (library),
որի անունն է՝ «Firetruck»։ Նրա աշխատանքի համար անհրաժեշ է Սեմանտիկ Տարբերակումով
թողարկվող «Ladder» փեքիջը։ Երբ Firetruck֊ը ստեղծվել էր, Ladder֊ի տարբերակի
համարն էր՝ 3.1.0։ Քանի որ Firetruck֊ը օգտագործում է Ladder֊ի 3.1.0 տարբերակի
ֆունկցիոնալը, դուք հանգիստ կարող եք հայտարարել կախվածությունը Ladder֊ի 3.1.0
տարբերակից, բայց ոչ ավել քան 4.0.0։ Երբ դուրս գա Ladder֊ի 3.2.0 տարբերակը, դուք
հաստատ կիմանաք, որ այն համատեղելի է ձեր ծրագրի հետ և կարող եք հանգիստ ինտեգրել
այն։\nՈրպես պատասխանատու ծրագրավորող՝ դուք իհարկե կցանկանաք վստահ լինել, որ բոլոր
թարմացումները աշխատում են այնպես ինչպես հայտարարվել է։ Իրական աշխարհում միշտ
խառնաշփոթ է, և ոչինչ չի կարելի անել դրա հետ, բացի ուշադիր լինելուց։ Սեմանտիկ
տարբերակման միջոցով դուք կարող եք թողարկել ձեր ծրագրային ապահովման նոր
տարբերակներ և թարմացումներ չմտածելով կախվածությունների մասին և պահպանել ձեր
ժամանակը և նյարդերը։\nԵթե այս ամենը գայթակղիչ է թվում ձեզ, այն ամենը ինչ ձեզ անհրաժեշտ է՝ սկսել
օգտագործել Սեմանտիկ տարբերակումը, հայտարարել դրա մասին և հետևել կանոններին։ Նշեք
այս կայքի հղումը ձեր README֊ում և օգտագործողները կիմանան այս կանոնների մասին։\nԻ՞նչ է անհրաժեշտ անել 0.y.z տարբերակում արված փոփոխությունների հետ, ծրագրավորման նախնական փուլում։\nԱմենահեշտ լուծումը աշխատանքը 0.1.0 տարբերակի թողարկումով սկսելն է և հետագայում
ամեն հաջորդ թողարկման համար ՄԻՆՈՐ տարբերակի համարը մեծացնելը։\nԻ՞նչպես իմանալ, որ 1.0.0 տարբերակը թողարկելու ժամանկն է։\nԵթե ձեր ծրագրային ապահովումը արդեն օգտագործվում է պրոդաքշնում, ամենայն
հավանականությամբ արդեն պետք է թողարկել 1.0.0 տարբերակը։ Եթե դուք ունեք ստաբիլ
API, որը ունի օգտագործողներ, տարբերակի համարը պետք է լինի 1.0.0։ Եթե
անհանգստանում եք հետ համատեղելիության մասին, ամենայն հավանականությամբ ձեր
ծրագրային ապահովման տարբերակի համարը արդեն պետք է լինի 1.0.0։\nԱրդյո՞ք աշխատելու այս ձևը չի խանգարում արագ ծրագրավորմանը (rapid development) և արագ իտերացիաներին (fast iteration)։\nԵրբ ՄԱԺՈՐ տարբերակի համարը 0 է, դա արդեն իսկ ենթադրում է արագ ծրագրավորում։ Եթե
դուք փոփոխեք API֊ը ամեն օր, ապա պետք է լինեք 0.y.z տարբերակի վրա, կամ առանձին
ճյուղի (branch) վրա աշխատեք հաջորդ ՄԱԺՈՐ տարբերակի թողարկման համար։\nԵթե նույնիսկ փոքր փոփոխությունները, որոնք խախտում են հետ համատեղելիությունը, պահանջում են նոր ՄԱԺՈՐ տարբերակի թողարկում, արդյո՞ք դա չի հանգեցնի նրան, որ շուտով տարբերակի համարը դառնա 42.0.0։\nՍա ավելի շատ պատասխանատվության և հեռատեսության խնդիր է։ Ծրագրային ապահովման հետ
համատեղելիությունը խախտող փոփոխությունները աննշան չեն, քանի որ դրա արդյունքում
թարմացումները կարող են շատ թանկ արժենալ։ Հետ համատեղելիությունը խախտող
փոփոխությունների թողարկումը տարբերակի ՄԱԺՈՐ համարի ավելացմամբ, նշանակում է՝ դուք
պետք է մտածեք ձեր փոփոխությունների հետևանքների մասին և հաշվի առնեք գին֊օգուտ
հարաբերակցությունը։\nԴոկումենտացիայի կազմումը մեծ աշխատանք է պահանջում։\nՈրպես պրոֆեսիոնալ ծրագրավորող ձեր պատասխանատվությունն է ճիշտ դոկումենտացնել
ծրագրային ապահովումը, որը նախատեսված է ուրիշների օգտագործման համար։ Ծրագրային
ապահովման բարդության կարգավորումը նրա արդյունավետության պահպանման կարևոևագույն
կետերից մեկն է։ Եթե ոչ մեկը չգիտի, թե ինչպես օգտագործել ձեր ծրագրային
ապահովումը, կամ որ մեթոդի կանչն է անվտանգ, ինչպես պետք է նրանք օգտագործեն այն։
Երկարաժամկետ հեռանկարով Սեմանտիկ Տարբերակումը, համառ և կոշտ դիրքը որակով
շարադրված փաբլիք API֊ի նկատմամբ կնպաստեն ամենքի և ամեն ինչի ճիշտ և համակարգված
աշխատելուն։\nԻ՞նչ է անհրաժեշտ անել, եթե պատահաբար թողարկվել են հետ համատեղելիությունը խախտող փոփոխություններ ՄԻՆՈՐ տարբերակի տակ։\nՀենց որ դուք հասկացաք, որ խախտել եք Սեմանտիկ Տարբերակման սպեցիֆիկացիան, ուղղեք
սխալը և թողարկեք նոր ՄԻՆՈՐ տարբերակ, որը լուծում է խնդիրը և վերականգնում հետ
համատեղելիությունը։ Նույնիսկ նման դեպքերում անընդունելի է արդեն թողարկված
տարբերակներում փոփոխությունների իրականացումը։ Եթե անհրաժեշտ է, նշեք
դոկումենտացիայում և տեղյակ պահեք օգտագործողներին հետ համատեղելիության և
տարբերակման հերթականության խախտման մասին։\nԻ՞նչ է անհրաժեշտ անել, եթե փոփոխվել են կախվածությունները առանց փաբլիք API֊ը փոփոխելու։\nԴա կարող է դիտարկվել որպես հետ համատեղելի փոփոխություն, քանի որ այն չի ազդում
փաբլիք API֊ի վրա։ Ծրագրային ապահովումը, որը ակնհայտորեն ունի նույն
կախվածությունները, ինչ փեքիջը, պետք է ունենա իր սեփական կախվածությունների
սպեցիֆիկացիան, և հեղինակը տեղյակ կլինի ի հայտ եկած կոնֆլիկտների մասին։ Արդյոք
տվյալ փոփոխությունները ՄԱԺՈՐ, թե ՓԱԹՉ մակարդակի են, կախված է նրանից, թե դուք
փոխել եք ձեր կախվածությունները սխալներ ուղղելու, թե՞ նոր ֆունկցիոնալ ինտեգրելու
համար։ Երկրորդ դեպքում, որպես կանոն ավելանում է որոշակի քանակով կոդ և որպես
հետևանք մեծանում է տարբերակի ՄԻՆՈՐ համարը։\nԻ՞նչ անել, եթե պատահաբար փոփոխվել է փաբլիք API֊ը, և այն չի համապատասխանում տարբերակի համարին (այսինքն՝ կոդը սխալմամբ պարունակում է հետ համատեղելիությունը խախտող փոփոխություններ ՓԱԹՉ տարբերակի թողարկման մեջ)։\nՈրոշումը ձերն է։ Եթե դուք ունեք օգտագործողների մեծ խումբ, որը կկանգնի փաբլիք
API֊ի նախկին ֆունկցիոնալի վերականգման փաստի առաջ, ուրեմն ճիշտ կլինի թողարկել նոր
տարբերակ ՄԱԺՈՐ համարի մեծացումով։ Չնայած նրան, որ այն պարունակում է միայն ՓԱԹՉ
մակարդակի փոփոխություններ, հիշեք՝ ըստ Սեմանտիկ Տարբերակման սպեցիֆիկացիայի
տարբերակի համարները մեծացվում են սպեցիֆիկացիային համաձայն։ Եթե այդ
փոփոխությունները կարևոր են ձեր օգտագործողների համար, օգտագործեք տարբերակի համարը
նրանց տեղյակ պահելու համար։\nԻ՞նչ անել հնացած (deprecated) ֆունկցիոնալի հետ։\nՈրոշ ֆունկցիոնալի հնանալը սովորական երևույթ է և ծրագրային ապահովման
ստեղծման/մշակման ընթացքում հաճախ պարտադիր է առաջընթացի համար։ Երբ դուք հնացած եք
հայտարարում, փաբլիք API֊ի ինչ֊որ հատված, դուք պետք է երկու բան անեք․ նախ
թարմացնեք ձեր դոկումենտացիան և տեղեկացնեք օգտագործողներին փոփոխության մասին (1),
և ապա թողարկեք նոր ՄԻՆՈՐ տարբերակ՝ նշում կատարելով հնացած ֆունկցիոնալի մասին
(2)։ Մինչ դուք ամբողջովին կջնջեք հնացած ֆունկցիոնալը, հաջորդ ՄԱԺՈՐ թողարկման
ժամանակ պետք է լինի առնվազն մեկ ՄԻՆՈՐ թողարկում, որը պարունակում է տեղեկություն
ֆունկցիոնալի հնացած հայտարարվելու մասին, որպեսզի օգտագործողները հեշտությամբ
անցնեն նոր API֊ի։\nԱրդյոք SemVer֊ը ունի՞ սահմանափակում տարբերակի համարի երկարության վրա։\nՈչ, բայց եղեք խելամիտ։ Եթե տարբերակի համարի երկարությունը 255 սիմվոլ է,
հավանաբար դա չափազանց է։ Բացի դրանից որոշ համակարգեր կարող են ունենալ իրենց
սեփական սահմանափակումները տարբերակի համարի երկարության վրա։\n«v1.2.3» ֆորմատը համարվու՞մ է տարբերակի սեմանտիկ համար։\nՈչ, «v1.2.3»֊ը տարբերակի սեմանտիկ համար չի համարվում։ Ամեն դեպքում «v» տառը
սեմանտիկ տարբերակի առջևում դնելը ընդունված երևույթ է (անգլերենում) տարբերակի
համարը ընդգծելու համար։ «v» հապավման օգտագործումը «version» բառի փոխարեն
տարածված պրակտիկա է տարբերակների կարգավորման (version control) մեջ: Օրինակ՝
git tag v1.2.3 -m "Release version 1.2.3"․ այստեղ «v1.2.3»֊ը թեգի անուն է, և
սեմանտիկ տարբերակը «1.2.3» է։\nԻնչպիսի՞ ռեգուլյար արտահայտության (RegEx) միջոցով կարելի է ստուգել SemVer տարբերակի համարի ճշտությունը:\nանվանական խմբերի միջոցով (named groups)։ (PCRE [Perl համատեղելի ռեգուլյար
արտահայտություններ, օրինակ՝ Perl, PHP և R], Python և Go)։\nՏես՝ https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nթվային խմբերի (numbered capture groups) միջոցով (cg1 = major, cg2 = minor,
cg3 = patch, cg4 = prerelease and cg5 = buildmetadata)։ Այս եղանակը համատեղելի է
ECMA Script֊ի (JavaScript), PCRE֊ի (Perl համատեղելի ռեգուլյար
արտահայտություններ, օրինակ՝ Perl, PHP և R), Python և Go.\nՏես՝ https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nՍեմանտիկ Տարբերակման սպեցիֆիկացիայի հեղինակն է
Թոմ Պրեստոն-Վարները (Gravatar֊ի հիմնադիր և
GitHub֊ի համահիմնադիր)։\nԵթե դուք ցանկանում եք որևէ մեկնաբանություն թողնել, խնդրում ենք
GitHub֊ում հարց (issue) բացել։\nGitHub֊ում հարց (issue) բացել\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nPemversian Semantik 2.0.0

Ringkasan

Versi semantik ditulis dalam bentuk MAJOR.MINOR.PATCH, dengan:


  Tambah angka versi MAJOR jika membuat perubahan API yang tidak lagi cocok dengan versi sebelumnya.
  Tambah angka versi MINOR jika menambah fitur tanpa membuat versi lama tidak bisa digunakan.
  Tambah angka versi PATCH jika ada perbaikan bug tanpa membuat versi lama tidak bisa digunakan.


Tambahan label dan versi sebelum rilis atau info tambahan tersedia sebagai ekstensi dari format
MAJOR.MINOR.PATCH.

Pendahuluan

Dalam pengembangan perangkat lunak, sering terjadi permasalahan dependency hell. Semakin besar sistem yang dibuat dan semakin banyak modul yang digunakan sistem kita, semakin sering permasalahan ini akan terjadi.

Dalam sistem yang saling terkait, merilis versi baru bisa menjadi mimpi buruk. Jika spesifikasi dependensi sistem terlalu ketat, bisa jadi sistem kita tidak bisa dikembangkan lagi. Jika spesifikasi dependensi sistem terlalu bebas, semakin sulit untuk berasumsi versi mana yang bisa digunakan dengan versi yang lain. Dependency hell adalah saat Anda berada pada satu atau dua masalah ini, yang menahan Anda untuk bergerak maju dengan aman dan mudah.

Sebagai solusi permasalahan ini, kami mengusulkan seperangkat aturan dan persayaratan sederhana yang menentukan bagaimana nomor versi diberikan dan bertambah. Aturan-aturan ini didasarkan pada, namun tidak terbatas pada, praktik-praktik yang sudah ada pada perangkat lunak sumber terbuka dan tertutup. Agar sistem ini dapat bekerja, Anda harus mengumumkan API publik terlebih dahulu. Ini dapat terdiri dari dokumentasi atau diberlakukan oleh kode itu sendiri. Apapun itu, API ini harus jelas dan tepat. Setelah Anda mengidentifikasi API publik Anda, Anda mengomunikasikan perubahan pada API tersebut dengan penambahan spesifik pada nomor versi Anda. Pertimbangkan format versi X.Y.Z (Major.Minor.Patch). Perbaikan bug yang tidak memengaruhi API tersebut akan menambah versi patch, penambahan/perubahan API yang kompatibel dengan versi sebelumnya akan menambah versi minor, dan perubahan API yang tidak kompatibel dengan versi sebelumnya akan menambah versi major.

Standar ini bernama “Pemversian Semantik”. Dengan skema ini, setiap orang yang melihat angka versi bisa tahu secara umum apa yang berubah dengan sistem tersebut.

Spesifikasi Pemversian Semantik (SemVer)

Kata/frasa “HARUS” (“MUST”), “TIDAK BOLEH” (“MUST NOT”), “DIBUTUHKAN” (“REQUIRED”), “SEHARUSNYA” (“SHALL”), “JANGAN SAMPAI” (“SHALL NOT”), “SEBAIKNYA” (“SHOULD”), “SEBAIKNYA TIDAK” (“SHOULD NOT”), “DIREKOMENDASIKAN” (“RECOMMENDED”), “BISA” (“MAY”) di dokumen ini sesuai dengan RFC 2119.


  
    Perangkat lunak dengan Pemversian Semantik HARUS menentukan API public. Bisa dijelaskan dengan kode, atau ditulis di dokumentasi saja. Apapun itu HARUS ditulis dengan jelas dan akurat.
  
  
    Versi normal HARUS ditulis dalam bentuk X.Y.Z, dengan X, Y, dan Z adalah bilangan bulat nonnegatif, dan TIDAK BOLEH didahului angka 0 (contoh 01.02.03). X adalah versi major, Y adalah minor, dan Z adalah patch. Setiap elemen HARUS bertambah secara numerik dengan kenaikan sebesar satu. Contohnya: 1.9.0 -> 1.10.0 -> 1.11.0
  
  
    Setelah sebuah paket berversi dirilis, isi dari versi tersebut TIDAK BOLEH diubah. Setiap perubahan HARUS dirilis sebagai versi baru.
  
  
    Versi major 0 (0.y.z) adalah untuk pengembangan awal. Apapun BISA bisa berubah kapan saja. API publik SEBAIKNYA
dianggap tidak stabil di versi ini.
  
  
    Versi 1.0.0 adalah titik awal API publik. Cara nomor versi ini dinaikkan setelah rilis ini adalah tergantung dengan API publik ini dan bagaimana ia berubah.
  
  
    Versi patch Z (x.y.Z | x > 0) HARUS dinaikkan jika ada perbaikan bug yang kompatibel dengan versi lama. Sebuah perbaikan bug didefinisikan sebagai perubahan internal yang memperbaiki perilaku yang salah.
  
  
    Versi minor Y (x.Y.z | x > 0) HARUS dinaikkan jika ada fitur baru yang kompatibel dengan versi lama dalam API publik. Ini HARUS dinaikkan jika sebuah fungsionalitas API publik dibuat usang. Ini BISA dinaikkan jika ada tambahan fungsionalitas substansial atau terjadi peningkatan di dalam kode privat. Ini BISA diubah bersama dengan perubahan tingkat patch. Versi patch HARUS dikembalikan ke angka 0 jika versi minor dinaikkan.
  
  
    Versi major X (X.y.z | X > 0) HARUS dinaikkan jika ada perubahan yang membuat versi baru tidak kompatibel dengan versi lama pada API publik. Ini juga BISA diubah bersama dengan perubahan tingkat patch dan minor. Versi minor dan patch HARUS dikembalikan ke angka 0 jika versi major dinaikkan.
  
  
    Versi prarilis BISA ditulis dengan menambahkan tanda hubung dan rangkaian pengenal dengan pemisah titik tepat setelah versi patch. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda hubung [0-9A-Za-z]. Pengenal TIDAK BOLEH kosong. Pengenal numerik TIDAK BOLEH didahului angka 0. Versi prarilis memiliki presendens yang lebih rendah dibandingkan dengan versi normal yang terkait. Versi prarilis dianggap tidak stabil dan mungkin tidak memuaskan persyaratan kompatibilitas yang dimaksudkan seperti yang ditunjukkan oleh versi normal yang terkait. Contoh: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92, 1.0.0-x-y-z.--.
  
  
    Build metadata BISA ditulis didahului dengan tanda tambah dan rangkaian pengenal dengan pemisah titik setelah versi patch atau prarilis. Build metadata HARUS ditulis dengan huruf ASCII alfanumerik dan tanda hubung [0-9A-Za-z]. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda hubung [0-9A-Za-z]. Pengenal TIDAK BOLEH kosong. Build metadata HARUS diabaikan saat menentukan presedens versi. Dengan begitu, dua versi yang berbada hanya di build metadata-nya memiliki preseden yang sama. Contoh: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3----117B344092BD.
  
  
    Presedens mengacu pada bagaimana versi-versi dibandingkan satu sama lain ketika diurutkan.

    
      
        Presedens HARUS dihitung dengan memisahkan versi menjadi pengenal major, minor, patch, dan prarilis dalam urutan tersebut (Build metadata tidak diperhitungkan dalam pengurutan).
      
      
        Presedens ditentukan oleh perbedaan pertama saat membandingkan masing-masing pengenal ini dari kiri ke kanan sebagai berikut: Major, minor, dan patch selalu dibandingkan secara numerik.

        Contoh: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Saat versi major, minor, dan patch sama, versi prarilis lebih rendah memiliki presedens lebih rendah dibandingkan dengan versi normal:

        Contoh: 1.0.0-alpha < 1.0.0.
      
      
        Prioritas untuk dua versi prarilis dengan versi major, minor, dan patch HARUS ditentukan dengan membandingkan setiap pengenal yang dipisahkan titik dari kiri ke kanan hingga ditemukan perbedaan sebagai berikut:

        
          
            Pengenal yang hanya terdiri dari angka dibandingkan secara numerik.
          
          
            Pengenal dengan huruf atau tanda hubung dibandingkan secara leksikal dalam urutan pengurutan ASCII.
          
          
            Pengenal numerik selalu memiliki presedens yang lebih rendah daripada pengenal non-numerik pengenal non-numerik.
          
          
            Suatu set yang lebih besar dari bidang prarilis memiliki presedens yang lebih tinggi daripada yang set yang lebih kecil, jika semua pengenal sebelumnya sama.
          
        

        Contoh: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
      
    
  


Grammar Bentuk Backus–Naur untuk Versi SemVer Valid
<semver valid> ::= <inti versi>
                 | <inti versi> "-" <prarilis>
                 | <inti versi> "+" <build>
                 | <inti versi> "-" <prarilis> "+" <build>

<inti versi> ::= <major> "." <minor> "." <patch>

<major> ::= <pengenal numerik>

<minor> ::= <pengenal numerik>

<patch> ::= <pengenal numerik>

<prarilis> ::= <pengenal prarilis dengan pemisah titik>

<pengenal prarilis dengan pemisah titik> ::= <pengenal prarilis>
                                           | <pengenal prarilis> "." <pengenal prarilis dengan pemisah titik>

<build> ::= <pengenal buld dengan pemisah titik>

<pengenal buld dengan pemisah titik> ::= <pengenal build>
                                       | <pengenal build> "." <pengenal buld dengan pemisah titik>

<pengenal prarilis> ::= <pengenal alfanumerik>
                      | <pengenal numerik>

<pengenal build> ::= <pengenal alfanumerik>
                   | <angka-angka>

<pengenal alfanumerik> ::= <nonangka>
                         | <nonangka> <karakter-karakter pengenal>
                         | <karakter-karakter pengenal> <nonangka>
                         | <karakter-karakter pengenal> <nonangka> <karakter-karakter pengenal>

<pengenal numerik> ::= "0"
                     | <angka positif>
                     | <angka positif> <angka-angka>

<karakter-karakter pengenal> ::= <karakter pengenal>
                               | <karakter pengenal> <karakter-karakter pengenal>

<karakter pengenal> ::= <angka>
                      | <nonangka>

<nonangka> ::= <huruf>
             | "-"

<angka-angka> ::= <angka>
                | <angka> <angka-angka>

<angka> ::= "0"
          | <angka positif>

<angka positif> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<huruf> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
          | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
          | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
          | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
          | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
          | "y" | "z"


Kenapa Menggunakan Pemversian Semantik?

Ini bukanlah ide baru yang revolusioner. Faktanya, kalian mungkin sudah menggunakan standar ini, hanya saja tidak terlalu ketat. Masalahnya, “tidak teralu ketat” saja tidak cukup bagus. Tanpa kepatuhan terhadap beberapa jenis spesifikasi formal, nomor versi adalah pada dasarnya tidak berguna untuk manajemen dependensi. Dengan memberikan nama dan definisi yang jelas definisi yang jelas untuk ide-ide tersebut, mengkomunikasikan maksud Anda kepada pengguna perangkat lunak Anda menjadi lebih mudah. Setelah maksud ini jelas, spesifikasi ketergantungan yang fleksibel (tetapi tidak terlalu fleksibel) akhirnya dapat dibuat.

Contoh sederhana ini menunjukkan manfaat Pemversian Semantik untuk menghilangkan “dependency hell.” Misalkan ada sebuah modul bernama “MobilPemadamKebakaran”. Modul “MobilPemadamKebakaran” membutuhkan modul lain bernama “Tangga”. Pada waktu “MobilPemadamKebakaran” dibuat, “Tangga” memiliki versi 3.1.0. Dengan menggunakan Pemversian Semantik, “MobilPemadamKebakaran” bisa dengan yakin menggunakan modul “Tangga” selama modul tersebut mempunyai versi antara 3.1.0 sampai dengan sebelum versi 4.0.0.

Sebagai pengembang yang bertanggung jawab, tentu saja Anda ingin memverifikasi bahwa peningkatan paket berfungsi seperti yang diiklankan. Dunia nyata tidaklah pasti; tidak ada yang bisa kita lakukan selain waspada. Yang bisa Anda lakukan adalah membiarkan Pemversian Semantik memberi Anda cara yang masuk akal untuk merilis dan memutakhirkan paket tanpa harus menggulirkan versi baru dari paket dependen, membuat Anda menghemat waktu dan kerumitan.

Jika menurut kalian aturan ini bagus, cara untuk memulai menggunakan pemversian semantik adalah dengan menautkan situs ini dalam README kalian supaya orang lain bisa tahu mengenai aturan ini dan mulai menggunakannya juga.

Pertanyaan Yang Sering Diajukan

Bagaimana cara menangani revisi dalam fase pengembangan awal 0.y.z?

Hal yang paling sederhana untuk dilakukan adalah memulai rilis pengembangan awal Anda pada 0.1.0 dan kemudian meningkatkan versi minor untuk setiap rilis berikutnya.

Bagaimana saya tahu kapan merilis 1.0.0?

Jika perangkat lunak Anda digunakan dalam produksi, mungkin perangkat lunak Anda sudah versi 1.0.0. Jika Anda memiliki API yang stabil yang menjadi andalan pengguna, Anda harusnya sudah pada 1.0.0. Jika Anda sangat mengkhawatirkan kompatibilitas versi lama, Anda mungkin sudah pada 1.0.0.

Bukankah standar ini mencegah perkembangan yang cepat?

Versi major nol adalah tentang pengembangan yang cepat. Jika Anda mengubah API setiap hari, Anda harus tetap berada di versi 0.y.z atau di pengembangan terpisah yang bekerja pada versi major berikutnya.

Jika perubahan terkecil yang tidak kompatibel dengan API publik memerlukan kenaikkan versi major, bukankah saya akan berakhir di versi 42.0.0 dengan sangat cepat?

Ini adalah pertanyaan tentang pengembangan yang bertanggung jawab dan pandangan ke depan. Perubahan yang tidak kompatibel tidak boleh diperkenalkan dengan mudah ke perangkat lunak yang memiliki banyak kode dependen. Biaya yang harus dikeluarkan untuk meng-upgrade bisa sangat besar. Kewajiban mengganti versi major untuk merilis perubahan yang tidak kompatibel seharusnya membuat Anda memikirkan dampak dari perubahan Anda, dan mengevaluasi perbandingan biaya dan manfaat yang terkait.

Mendokumentasikan seluruh API publik sangatlah merepotkan!

Sudah tanggung jawab Anda sebagai pengembang profesional untuk mendokumentasikan perangkat lunak untuk digunakan oleh orang lain dengan benar. Mengelola kompleksitas perangkat lunak adalah bagian yang sangat penting dalam menjaga proyek tetap efisien, dan itu sulit dilakukan jika tidak ada yang tahu cara menggunakan perangkat lunak Anda, atau metode apa yang aman untuk dihubungi. Dalam jangka panjang, Pemversian Semantik, dan desakan pada API publik yang terdefinisi dengan baik dapat membuat semua orang dan segala sesuatu berjalan dengan lancar.

Bagaimana jika secara tidak sengaja membuat perubahan yang menjadikan versi lama tidak bisa dipakai?

Setelah Anda menyadari bahwa Anda telah melanggar spesifikasi Pemversian Semantik, perbaiki dan rilis versi minor baru yang memperbaiki masalah dan mengembalikan kompatibilitas versi lama. Bahkan dalam kondisi ini, memodifikasi rilis yang telah diberi versi adalah dilarang. Jika mau, dokumentasikan versi yang bermasalah dan memberi tahu pengguna Anda tentang masalah tersebut sehingga mereka mengetahui versi yang bermasalah.

Apa yang harus saya lakukan jika saya memperbarui dependensi saya sendiri tanpa mengubah API publik?

Hal tersebut dianggap kompatibel karena tidak mempengaruhi API publik. Perangkat lunak yang secara eksplisit bergantung pada dependensi yang sama dengan paket Anda harus memiliki spesifikasi dependensi mereka sendiri dan pembuatnya akan memberi tahu konflik yang ada. Menentukan apakah perubahan tersebut merupakan tingkat patch atau tingkat minor  tergantung pada apakah Anda memperbarui dependensi untuk memperbaiki bug atau memperkenalkan fungsionalitas baru. Kami biasanya mengharapkan kode tambahan untuk contoh yang kedua, yang dalam hal ini jelas merupakan kenaikan tingkat minor.

Bagaimana jika saya secara tidak sengaja mengubah API publik dengan cara yang tidak sesuai dengan perubahan nomor versi (misalnya, kode secara tidak benar memperkenalkan perubahan besar dalam rilis patch)?

Gunakan kebijakan terbaik Anda. Jika Anda memiliki audiens yang sangat besar yang akan terpengaruh secara drastis dengan apa yang dimaksudkan oleh API publik, maka lebih baik melakukan rilis versi major, meskipun perbaikannya dapat sangat dianggap sebagai rilis patch. Ingat, Pemversian Semantik adalah segalanya tentang menyampaikan makna melalui perubahan nomor versi. Jika perubahan ini perubahan ini penting bagi pengguna Anda, gunakan nomor versi itu untuk memberi tahu mereka.

Bagaimana cara menangani fungsionalitas yang sudah diusangkan?

Mengusangkan fungsionalitas yang ada adalah hal yang lumrah dalam pengembangan perangkat lunak dan sering kali diperlukan untuk membuat suatu kemajuan. Ketika Anda mengusangkan bagian  dari API publik Anda, Anda harus melakukan dua hal: (1) memperbarui dokumentasi Anda untuk memberi tahu pengguna tahu tentang perubahan tersebut, dan (2) mengeluarkan rilis minor baru dengan penghentian yang baru dengan pengusangan itu dibuat. Sebelum Anda benar-benar menghapus fungsionalitas dalam rilis major yang baru harus ada setidaknya satu rilis minor yang berisi pengusangan itu sehingga pengguna dapat beralih dengan lancar ke API yang baru.

Apakah Versi Semantik punya batasan jumlah karakter dalam versi?

Tidak, tetapi gunakan kebijakan yang baik. Misalnya, versi dengan panjang 255 karakter mungkin teralu banyak. Selain itu, sistem tertentu mungkin memiliki batasan mereka sendiri pada ukuran string.

Apakah ada regular expression (RegEx) yang disarankan untuk memeriksa string SemVer?

Ada dua. Satu dengan grup bernama untuk sistem yang didukung (PCRE [Perl Compatible Regular Expressions, yaitu Perl, PHP dan R], Python dan Go).

Lihat: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Dan satu lagi dengan kelompok tangkapan bernomor (jadi cg1 = major, cg2 = minor, cg3 = patch, cg4 = prarilis dan cg5 = build metadata) yang kompatibel dengan ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
yaitu Perl, PHP dan R), Python dan Go.

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Tentang

Spesifikasi Pemversian Semantik awalnya dibuat oleh Tom Preston-Werner, pembuat Gravatar dan cofounder dari GitHub.

Terjemahan Bahasa Indonesia ditulis oleh Aditya Purwa, Christian B. Wibowo, dan Hans5958.

Untuk saran dan kritik, silahkan buka issue di GitHub.

Lisensi

Creative Commons ― CC BY 3.0\nPemversian Semantik 2.0.0\nVersi semantik ditulis dalam bentuk MAJOR.MINOR.PATCH, dengan:\nTambah angka versi MAJOR jika membuat perubahan API yang tidak lagi cocok dengan versi sebelumnya.\nTambah angka versi MINOR jika menambah fitur tanpa membuat versi lama tidak bisa digunakan.\nTambah angka versi PATCH jika ada perbaikan bug tanpa membuat versi lama tidak bisa digunakan.\nTambahan label dan versi sebelum rilis atau info tambahan tersedia sebagai ekstensi dari format
MAJOR.MINOR.PATCH.\nDalam pengembangan perangkat lunak, sering terjadi permasalahan dependency hell. Semakin besar sistem yang dibuat dan semakin banyak modul yang digunakan sistem kita, semakin sering permasalahan ini akan terjadi.\nDalam sistem yang saling terkait, merilis versi baru bisa menjadi mimpi buruk. Jika spesifikasi dependensi sistem terlalu ketat, bisa jadi sistem kita tidak bisa dikembangkan lagi. Jika spesifikasi dependensi sistem terlalu bebas, semakin sulit untuk berasumsi versi mana yang bisa digunakan dengan versi yang lain. Dependency hell adalah saat Anda berada pada satu atau dua masalah ini, yang menahan Anda untuk bergerak maju dengan aman dan mudah.\nSebagai solusi permasalahan ini, kami mengusulkan seperangkat aturan dan persayaratan sederhana yang menentukan bagaimana nomor versi diberikan dan bertambah. Aturan-aturan ini didasarkan pada, namun tidak terbatas pada, praktik-praktik yang sudah ada pada perangkat lunak sumber terbuka dan tertutup. Agar sistem ini dapat bekerja, Anda harus mengumumkan API publik terlebih dahulu. Ini dapat terdiri dari dokumentasi atau diberlakukan oleh kode itu sendiri. Apapun itu, API ini harus jelas dan tepat. Setelah Anda mengidentifikasi API publik Anda, Anda mengomunikasikan perubahan pada API tersebut dengan penambahan spesifik pada nomor versi Anda. Pertimbangkan format versi X.Y.Z (Major.Minor.Patch). Perbaikan bug yang tidak memengaruhi API tersebut akan menambah versi patch, penambahan/perubahan API yang kompatibel dengan versi sebelumnya akan menambah versi minor, dan perubahan API yang tidak kompatibel dengan versi sebelumnya akan menambah versi major.\nStandar ini bernama “Pemversian Semantik”. Dengan skema ini, setiap orang yang melihat angka versi bisa tahu secara umum apa yang berubah dengan sistem tersebut.\nSpesifikasi Pemversian Semantik (SemVer)\nKata/frasa “HARUS” (“MUST”), “TIDAK BOLEH” (“MUST NOT”), “DIBUTUHKAN” (“REQUIRED”), “SEHARUSNYA” (“SHALL”), “JANGAN SAMPAI” (“SHALL NOT”), “SEBAIKNYA” (“SHOULD”), “SEBAIKNYA TIDAK” (“SHOULD NOT”), “DIREKOMENDASIKAN” (“RECOMMENDED”), “BISA” (“MAY”) di dokumen ini sesuai dengan RFC 2119.\nPerangkat lunak dengan Pemversian Semantik HARUS menentukan API public. Bisa dijelaskan dengan kode, atau ditulis di dokumentasi saja. Apapun itu HARUS ditulis dengan jelas dan akurat.\nPerangkat lunak dengan Pemversian Semantik HARUS menentukan API public. Bisa dijelaskan dengan kode, atau ditulis di dokumentasi saja. Apapun itu HARUS ditulis dengan jelas dan akurat.\nVersi normal HARUS ditulis dalam bentuk X.Y.Z, dengan X, Y, dan Z adalah bilangan bulat nonnegatif, dan TIDAK BOLEH didahului angka 0 (contoh 01.02.03). X adalah versi major, Y adalah minor, dan Z adalah patch. Setiap elemen HARUS bertambah secara numerik dengan kenaikan sebesar satu. Contohnya: 1.9.0 -> 1.10.0 -> 1.11.0\nVersi normal HARUS ditulis dalam bentuk X.Y.Z, dengan X, Y, dan Z adalah bilangan bulat nonnegatif, dan TIDAK BOLEH didahului angka 0 (contoh 01.02.03). X adalah versi major, Y adalah minor, dan Z adalah patch. Setiap elemen HARUS bertambah secara numerik dengan kenaikan sebesar satu. Contohnya: 1.9.0 -> 1.10.0 -> 1.11.0\nSetelah sebuah paket berversi dirilis, isi dari versi tersebut TIDAK BOLEH diubah. Setiap perubahan HARUS dirilis sebagai versi baru.\nSetelah sebuah paket berversi dirilis, isi dari versi tersebut TIDAK BOLEH diubah. Setiap perubahan HARUS dirilis sebagai versi baru.\nVersi major 0 (0.y.z) adalah untuk pengembangan awal. Apapun BISA bisa berubah kapan saja. API publik SEBAIKNYA
dianggap tidak stabil di versi ini.\nVersi major 0 (0.y.z) adalah untuk pengembangan awal. Apapun BISA bisa berubah kapan saja. API publik SEBAIKNYA
dianggap tidak stabil di versi ini.\nVersi 1.0.0 adalah titik awal API publik. Cara nomor versi ini dinaikkan setelah rilis ini adalah tergantung dengan API publik ini dan bagaimana ia berubah.\nVersi 1.0.0 adalah titik awal API publik. Cara nomor versi ini dinaikkan setelah rilis ini adalah tergantung dengan API publik ini dan bagaimana ia berubah.\nVersi patch Z (x.y.Z | x > 0) HARUS dinaikkan jika ada perbaikan bug yang kompatibel dengan versi lama. Sebuah perbaikan bug didefinisikan sebagai perubahan internal yang memperbaiki perilaku yang salah.\nVersi patch Z (x.y.Z | x > 0) HARUS dinaikkan jika ada perbaikan bug yang kompatibel dengan versi lama. Sebuah perbaikan bug didefinisikan sebagai perubahan internal yang memperbaiki perilaku yang salah.\nVersi minor Y (x.Y.z | x > 0) HARUS dinaikkan jika ada fitur baru yang kompatibel dengan versi lama dalam API publik. Ini HARUS dinaikkan jika sebuah fungsionalitas API publik dibuat usang. Ini BISA dinaikkan jika ada tambahan fungsionalitas substansial atau terjadi peningkatan di dalam kode privat. Ini BISA diubah bersama dengan perubahan tingkat patch. Versi patch HARUS dikembalikan ke angka 0 jika versi minor dinaikkan.\nVersi minor Y (x.Y.z | x > 0) HARUS dinaikkan jika ada fitur baru yang kompatibel dengan versi lama dalam API publik. Ini HARUS dinaikkan jika sebuah fungsionalitas API publik dibuat usang. Ini BISA dinaikkan jika ada tambahan fungsionalitas substansial atau terjadi peningkatan di dalam kode privat. Ini BISA diubah bersama dengan perubahan tingkat patch. Versi patch HARUS dikembalikan ke angka 0 jika versi minor dinaikkan.\nVersi major X (X.y.z | X > 0) HARUS dinaikkan jika ada perubahan yang membuat versi baru tidak kompatibel dengan versi lama pada API publik. Ini juga BISA diubah bersama dengan perubahan tingkat patch dan minor. Versi minor dan patch HARUS dikembalikan ke angka 0 jika versi major dinaikkan.\nVersi major X (X.y.z | X > 0) HARUS dinaikkan jika ada perubahan yang membuat versi baru tidak kompatibel dengan versi lama pada API publik. Ini juga BISA diubah bersama dengan perubahan tingkat patch dan minor. Versi minor dan patch HARUS dikembalikan ke angka 0 jika versi major dinaikkan.\nVersi prarilis BISA ditulis dengan menambahkan tanda hubung dan rangkaian pengenal dengan pemisah titik tepat setelah versi patch. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda hubung [0-9A-Za-z]. Pengenal TIDAK BOLEH kosong. Pengenal numerik TIDAK BOLEH didahului angka 0. Versi prarilis memiliki presendens yang lebih rendah dibandingkan dengan versi normal yang terkait. Versi prarilis dianggap tidak stabil dan mungkin tidak memuaskan persyaratan kompatibilitas yang dimaksudkan seperti yang ditunjukkan oleh versi normal yang terkait. Contoh: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92, 1.0.0-x-y-z.--.\nVersi prarilis BISA ditulis dengan menambahkan tanda hubung dan rangkaian pengenal dengan pemisah titik tepat setelah versi patch. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda hubung [0-9A-Za-z]. Pengenal TIDAK BOLEH kosong. Pengenal numerik TIDAK BOLEH didahului angka 0. Versi prarilis memiliki presendens yang lebih rendah dibandingkan dengan versi normal yang terkait. Versi prarilis dianggap tidak stabil dan mungkin tidak memuaskan persyaratan kompatibilitas yang dimaksudkan seperti yang ditunjukkan oleh versi normal yang terkait. Contoh: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92, 1.0.0-x-y-z.--.\nBuild metadata BISA ditulis didahului dengan tanda tambah dan rangkaian pengenal dengan pemisah titik setelah versi patch atau prarilis. Build metadata HARUS ditulis dengan huruf ASCII alfanumerik dan tanda hubung [0-9A-Za-z]. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda hubung [0-9A-Za-z]. Pengenal TIDAK BOLEH kosong. Build metadata HARUS diabaikan saat menentukan presedens versi. Dengan begitu, dua versi yang berbada hanya di build metadata-nya memiliki preseden yang sama. Contoh: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3----117B344092BD.\nBuild metadata BISA ditulis didahului dengan tanda tambah dan rangkaian pengenal dengan pemisah titik setelah versi patch atau prarilis. Build metadata HARUS ditulis dengan huruf ASCII alfanumerik dan tanda hubung [0-9A-Za-z]. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda hubung [0-9A-Za-z]. Pengenal TIDAK BOLEH kosong. Build metadata HARUS diabaikan saat menentukan presedens versi. Dengan begitu, dua versi yang berbada hanya di build metadata-nya memiliki preseden yang sama. Contoh: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3----117B344092BD.\nPresedens mengacu pada bagaimana versi-versi dibandingkan satu sama lain ketika diurutkan.

    
      
        Presedens HARUS dihitung dengan memisahkan versi menjadi pengenal major, minor, patch, dan prarilis dalam urutan tersebut (Build metadata tidak diperhitungkan dalam pengurutan).
      
      
        Presedens ditentukan oleh perbedaan pertama saat membandingkan masing-masing pengenal ini dari kiri ke kanan sebagai berikut: Major, minor, dan patch selalu dibandingkan secara numerik.

        Contoh: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Saat versi major, minor, dan patch sama, versi prarilis lebih rendah memiliki presedens lebih rendah dibandingkan dengan versi normal:

        Contoh: 1.0.0-alpha < 1.0.0.
      
      
        Prioritas untuk dua versi prarilis dengan versi major, minor, dan patch HARUS ditentukan dengan membandingkan setiap pengenal yang dipisahkan titik dari kiri ke kanan hingga ditemukan perbedaan sebagai berikut:

        
          
            Pengenal yang hanya terdiri dari angka dibandingkan secara numerik.
          
          
            Pengenal dengan huruf atau tanda hubung dibandingkan secara leksikal dalam urutan pengurutan ASCII.
          
          
            Pengenal numerik selalu memiliki presedens yang lebih rendah daripada pengenal non-numerik pengenal non-numerik.
          
          
            Suatu set yang lebih besar dari bidang prarilis memiliki presedens yang lebih tinggi daripada yang set yang lebih kecil, jika semua pengenal sebelumnya sama.
          
        

        Contoh: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPresedens mengacu pada bagaimana versi-versi dibandingkan satu sama lain ketika diurutkan.\nPresedens HARUS dihitung dengan memisahkan versi menjadi pengenal major, minor, patch, dan prarilis dalam urutan tersebut (Build metadata tidak diperhitungkan dalam pengurutan).\nPresedens HARUS dihitung dengan memisahkan versi menjadi pengenal major, minor, patch, dan prarilis dalam urutan tersebut (Build metadata tidak diperhitungkan dalam pengurutan).\nPresedens ditentukan oleh perbedaan pertama saat membandingkan masing-masing pengenal ini dari kiri ke kanan sebagai berikut: Major, minor, dan patch selalu dibandingkan secara numerik.

        Contoh: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nPresedens ditentukan oleh perbedaan pertama saat membandingkan masing-masing pengenal ini dari kiri ke kanan sebagai berikut: Major, minor, dan patch selalu dibandingkan secara numerik.\nContoh: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nSaat versi major, minor, dan patch sama, versi prarilis lebih rendah memiliki presedens lebih rendah dibandingkan dengan versi normal:

        Contoh: 1.0.0-alpha < 1.0.0.\nSaat versi major, minor, dan patch sama, versi prarilis lebih rendah memiliki presedens lebih rendah dibandingkan dengan versi normal:\nContoh: 1.0.0-alpha < 1.0.0.\nPrioritas untuk dua versi prarilis dengan versi major, minor, dan patch HARUS ditentukan dengan membandingkan setiap pengenal yang dipisahkan titik dari kiri ke kanan hingga ditemukan perbedaan sebagai berikut:

        
          
            Pengenal yang hanya terdiri dari angka dibandingkan secara numerik.
          
          
            Pengenal dengan huruf atau tanda hubung dibandingkan secara leksikal dalam urutan pengurutan ASCII.
          
          
            Pengenal numerik selalu memiliki presedens yang lebih rendah daripada pengenal non-numerik pengenal non-numerik.
          
          
            Suatu set yang lebih besar dari bidang prarilis memiliki presedens yang lebih tinggi daripada yang set yang lebih kecil, jika semua pengenal sebelumnya sama.
          
        

        Contoh: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPrioritas untuk dua versi prarilis dengan versi major, minor, dan patch HARUS ditentukan dengan membandingkan setiap pengenal yang dipisahkan titik dari kiri ke kanan hingga ditemukan perbedaan sebagai berikut:\nPengenal yang hanya terdiri dari angka dibandingkan secara numerik.\nPengenal yang hanya terdiri dari angka dibandingkan secara numerik.\nPengenal dengan huruf atau tanda hubung dibandingkan secara leksikal dalam urutan pengurutan ASCII.\nPengenal dengan huruf atau tanda hubung dibandingkan secara leksikal dalam urutan pengurutan ASCII.\nPengenal numerik selalu memiliki presedens yang lebih rendah daripada pengenal non-numerik pengenal non-numerik.\nPengenal numerik selalu memiliki presedens yang lebih rendah daripada pengenal non-numerik pengenal non-numerik.\nSuatu set yang lebih besar dari bidang prarilis memiliki presedens yang lebih tinggi daripada yang set yang lebih kecil, jika semua pengenal sebelumnya sama.\nSuatu set yang lebih besar dari bidang prarilis memiliki presedens yang lebih tinggi daripada yang set yang lebih kecil, jika semua pengenal sebelumnya sama.\nContoh: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nGrammar Bentuk Backus–Naur untuk Versi SemVer Valid\n<semver valid> ::= <inti versi>
                 | <inti versi> "-" <prarilis>
                 | <inti versi> "+" <build>
                 | <inti versi> "-" <prarilis> "+" <build>

<inti versi> ::= <major> "." <minor> "." <patch>

<major> ::= <pengenal numerik>

<minor> ::= <pengenal numerik>

<patch> ::= <pengenal numerik>

<prarilis> ::= <pengenal prarilis dengan pemisah titik>

<pengenal prarilis dengan pemisah titik> ::= <pengenal prarilis>
                                           | <pengenal prarilis> "." <pengenal prarilis dengan pemisah titik>

<build> ::= <pengenal buld dengan pemisah titik>

<pengenal buld dengan pemisah titik> ::= <pengenal build>
                                       | <pengenal build> "." <pengenal buld dengan pemisah titik>

<pengenal prarilis> ::= <pengenal alfanumerik>
                      | <pengenal numerik>

<pengenal build> ::= <pengenal alfanumerik>
                   | <angka-angka>

<pengenal alfanumerik> ::= <nonangka>
                         | <nonangka> <karakter-karakter pengenal>
                         | <karakter-karakter pengenal> <nonangka>
                         | <karakter-karakter pengenal> <nonangka> <karakter-karakter pengenal>

<pengenal numerik> ::= "0"
                     | <angka positif>
                     | <angka positif> <angka-angka>

<karakter-karakter pengenal> ::= <karakter pengenal>
                               | <karakter pengenal> <karakter-karakter pengenal>

<karakter pengenal> ::= <angka>
                      | <nonangka>

<nonangka> ::= <huruf>
             | "-"

<angka-angka> ::= <angka>
                | <angka> <angka-angka>

<angka> ::= "0"
          | <angka positif>

<angka positif> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<huruf> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
          | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
          | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
          | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
          | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
          | "y" | "z"\n<semver valid> ::= <inti versi>
                 | <inti versi> "-" <prarilis>
                 | <inti versi> "+" <build>
                 | <inti versi> "-" <prarilis> "+" <build>

<inti versi> ::= <major> "." <minor> "." <patch>

<major> ::= <pengenal numerik>

<minor> ::= <pengenal numerik>

<patch> ::= <pengenal numerik>

<prarilis> ::= <pengenal prarilis dengan pemisah titik>

<pengenal prarilis dengan pemisah titik> ::= <pengenal prarilis>
                                           | <pengenal prarilis> "." <pengenal prarilis dengan pemisah titik>

<build> ::= <pengenal buld dengan pemisah titik>

<pengenal buld dengan pemisah titik> ::= <pengenal build>
                                       | <pengenal build> "." <pengenal buld dengan pemisah titik>

<pengenal prarilis> ::= <pengenal alfanumerik>
                      | <pengenal numerik>

<pengenal build> ::= <pengenal alfanumerik>
                   | <angka-angka>

<pengenal alfanumerik> ::= <nonangka>
                         | <nonangka> <karakter-karakter pengenal>
                         | <karakter-karakter pengenal> <nonangka>
                         | <karakter-karakter pengenal> <nonangka> <karakter-karakter pengenal>

<pengenal numerik> ::= "0"
                     | <angka positif>
                     | <angka positif> <angka-angka>

<karakter-karakter pengenal> ::= <karakter pengenal>
                               | <karakter pengenal> <karakter-karakter pengenal>

<karakter pengenal> ::= <angka>
                      | <nonangka>

<nonangka> ::= <huruf>
             | "-"

<angka-angka> ::= <angka>
                | <angka> <angka-angka>

<angka> ::= "0"
          | <angka positif>

<angka positif> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<huruf> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
          | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
          | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
          | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
          | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
          | "y" | "z"\nKenapa Menggunakan Pemversian Semantik?\nIni bukanlah ide baru yang revolusioner. Faktanya, kalian mungkin sudah menggunakan standar ini, hanya saja tidak terlalu ketat. Masalahnya, “tidak teralu ketat” saja tidak cukup bagus. Tanpa kepatuhan terhadap beberapa jenis spesifikasi formal, nomor versi adalah pada dasarnya tidak berguna untuk manajemen dependensi. Dengan memberikan nama dan definisi yang jelas definisi yang jelas untuk ide-ide tersebut, mengkomunikasikan maksud Anda kepada pengguna perangkat lunak Anda menjadi lebih mudah. Setelah maksud ini jelas, spesifikasi ketergantungan yang fleksibel (tetapi tidak terlalu fleksibel) akhirnya dapat dibuat.\nContoh sederhana ini menunjukkan manfaat Pemversian Semantik untuk menghilangkan “dependency hell.” Misalkan ada sebuah modul bernama “MobilPemadamKebakaran”. Modul “MobilPemadamKebakaran” membutuhkan modul lain bernama “Tangga”. Pada waktu “MobilPemadamKebakaran” dibuat, “Tangga” memiliki versi 3.1.0. Dengan menggunakan Pemversian Semantik, “MobilPemadamKebakaran” bisa dengan yakin menggunakan modul “Tangga” selama modul tersebut mempunyai versi antara 3.1.0 sampai dengan sebelum versi 4.0.0.\nSebagai pengembang yang bertanggung jawab, tentu saja Anda ingin memverifikasi bahwa peningkatan paket berfungsi seperti yang diiklankan. Dunia nyata tidaklah pasti; tidak ada yang bisa kita lakukan selain waspada. Yang bisa Anda lakukan adalah membiarkan Pemversian Semantik memberi Anda cara yang masuk akal untuk merilis dan memutakhirkan paket tanpa harus menggulirkan versi baru dari paket dependen, membuat Anda menghemat waktu dan kerumitan.\nJika menurut kalian aturan ini bagus, cara untuk memulai menggunakan pemversian semantik adalah dengan menautkan situs ini dalam README kalian supaya orang lain bisa tahu mengenai aturan ini dan mulai menggunakannya juga.\nPertanyaan Yang Sering Diajukan\nBagaimana cara menangani revisi dalam fase pengembangan awal 0.y.z?\nHal yang paling sederhana untuk dilakukan adalah memulai rilis pengembangan awal Anda pada 0.1.0 dan kemudian meningkatkan versi minor untuk setiap rilis berikutnya.\nBagaimana saya tahu kapan merilis 1.0.0?\nJika perangkat lunak Anda digunakan dalam produksi, mungkin perangkat lunak Anda sudah versi 1.0.0. Jika Anda memiliki API yang stabil yang menjadi andalan pengguna, Anda harusnya sudah pada 1.0.0. Jika Anda sangat mengkhawatirkan kompatibilitas versi lama, Anda mungkin sudah pada 1.0.0.\nBukankah standar ini mencegah perkembangan yang cepat?\nVersi major nol adalah tentang pengembangan yang cepat. Jika Anda mengubah API setiap hari, Anda harus tetap berada di versi 0.y.z atau di pengembangan terpisah yang bekerja pada versi major berikutnya.\nJika perubahan terkecil yang tidak kompatibel dengan API publik memerlukan kenaikkan versi major, bukankah saya akan berakhir di versi 42.0.0 dengan sangat cepat?\nIni adalah pertanyaan tentang pengembangan yang bertanggung jawab dan pandangan ke depan. Perubahan yang tidak kompatibel tidak boleh diperkenalkan dengan mudah ke perangkat lunak yang memiliki banyak kode dependen. Biaya yang harus dikeluarkan untuk meng-upgrade bisa sangat besar. Kewajiban mengganti versi major untuk merilis perubahan yang tidak kompatibel seharusnya membuat Anda memikirkan dampak dari perubahan Anda, dan mengevaluasi perbandingan biaya dan manfaat yang terkait.\nMendokumentasikan seluruh API publik sangatlah merepotkan!\nSudah tanggung jawab Anda sebagai pengembang profesional untuk mendokumentasikan perangkat lunak untuk digunakan oleh orang lain dengan benar. Mengelola kompleksitas perangkat lunak adalah bagian yang sangat penting dalam menjaga proyek tetap efisien, dan itu sulit dilakukan jika tidak ada yang tahu cara menggunakan perangkat lunak Anda, atau metode apa yang aman untuk dihubungi. Dalam jangka panjang, Pemversian Semantik, dan desakan pada API publik yang terdefinisi dengan baik dapat membuat semua orang dan segala sesuatu berjalan dengan lancar.\nBagaimana jika secara tidak sengaja membuat perubahan yang menjadikan versi lama tidak bisa dipakai?\nSetelah Anda menyadari bahwa Anda telah melanggar spesifikasi Pemversian Semantik, perbaiki dan rilis versi minor baru yang memperbaiki masalah dan mengembalikan kompatibilitas versi lama. Bahkan dalam kondisi ini, memodifikasi rilis yang telah diberi versi adalah dilarang. Jika mau, dokumentasikan versi yang bermasalah dan memberi tahu pengguna Anda tentang masalah tersebut sehingga mereka mengetahui versi yang bermasalah.\nApa yang harus saya lakukan jika saya memperbarui dependensi saya sendiri tanpa mengubah API publik?\nHal tersebut dianggap kompatibel karena tidak mempengaruhi API publik. Perangkat lunak yang secara eksplisit bergantung pada dependensi yang sama dengan paket Anda harus memiliki spesifikasi dependensi mereka sendiri dan pembuatnya akan memberi tahu konflik yang ada. Menentukan apakah perubahan tersebut merupakan tingkat patch atau tingkat minor  tergantung pada apakah Anda memperbarui dependensi untuk memperbaiki bug atau memperkenalkan fungsionalitas baru. Kami biasanya mengharapkan kode tambahan untuk contoh yang kedua, yang dalam hal ini jelas merupakan kenaikan tingkat minor.\nBagaimana jika saya secara tidak sengaja mengubah API publik dengan cara yang tidak sesuai dengan perubahan nomor versi (misalnya, kode secara tidak benar memperkenalkan perubahan besar dalam rilis patch)?\nGunakan kebijakan terbaik Anda. Jika Anda memiliki audiens yang sangat besar yang akan terpengaruh secara drastis dengan apa yang dimaksudkan oleh API publik, maka lebih baik melakukan rilis versi major, meskipun perbaikannya dapat sangat dianggap sebagai rilis patch. Ingat, Pemversian Semantik adalah segalanya tentang menyampaikan makna melalui perubahan nomor versi. Jika perubahan ini perubahan ini penting bagi pengguna Anda, gunakan nomor versi itu untuk memberi tahu mereka.\nBagaimana cara menangani fungsionalitas yang sudah diusangkan?\nMengusangkan fungsionalitas yang ada adalah hal yang lumrah dalam pengembangan perangkat lunak dan sering kali diperlukan untuk membuat suatu kemajuan. Ketika Anda mengusangkan bagian  dari API publik Anda, Anda harus melakukan dua hal: (1) memperbarui dokumentasi Anda untuk memberi tahu pengguna tahu tentang perubahan tersebut, dan (2) mengeluarkan rilis minor baru dengan penghentian yang baru dengan pengusangan itu dibuat. Sebelum Anda benar-benar menghapus fungsionalitas dalam rilis major yang baru harus ada setidaknya satu rilis minor yang berisi pengusangan itu sehingga pengguna dapat beralih dengan lancar ke API yang baru.\nApakah Versi Semantik punya batasan jumlah karakter dalam versi?\nTidak, tetapi gunakan kebijakan yang baik. Misalnya, versi dengan panjang 255 karakter mungkin teralu banyak. Selain itu, sistem tertentu mungkin memiliki batasan mereka sendiri pada ukuran string.\nApakah ada regular expression (RegEx) yang disarankan untuk memeriksa string SemVer?\nAda dua. Satu dengan grup bernama untuk sistem yang didukung (PCRE [Perl Compatible Regular Expressions, yaitu Perl, PHP dan R], Python dan Go).\nLihat: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nDan satu lagi dengan kelompok tangkapan bernomor (jadi cg1 = major, cg2 = minor, cg3 = patch, cg4 = prarilis dan cg5 = build metadata) yang kompatibel dengan ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
yaitu Perl, PHP dan R), Python dan Go.\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nSpesifikasi Pemversian Semantik awalnya dibuat oleh Tom Preston-Werner, pembuat Gravatar dan cofounder dari GitHub.\nTerjemahan Bahasa Indonesia ditulis oleh Aditya Purwa, Christian B. Wibowo, dan Hans5958.\nUntuk saran dan kritik, silahkan buka issue di GitHub.\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nVersionamento Semantico 2.0.0

Sommario

Dato un numero di versione MAJOR.MINOR.PATCH, incrementate la:


  versione MAJOR quando modificate l’API in modo non retrocompatibile
  versione MINOR quando aggiungete funzionalità in modo retrocompatibile
  versione PATCH quando correggete bug in modo retrocompatibile


Sono disponibili etichette aggiuntive per il pre-release e i metadati di build come
estensioni al formato MAJOR.MINOR.PATCH.

Introduzione

Nel mondo della gestione del software esiste un luogo terrificante chiamato
“inferno della dipendenza”. Quanto più cresce il vostro sistema e quanti più 
pacchetti integrate nel vostro software, tanto più facilmente vi ritroverete, un 
giorno, in questa valle di lacrime.

Nei sistemi con molte dipendenze, rilasciare nuove versioni di pacchetti può 
diventare rapidamente un incubo. Se le specifiche di dipendenza sono troppo 
stringenti, siete a rischio di blocco di versione (l’impossibilità di aggiornare
un pacchetto senza dover rilasciare nuove versioni di ogni pacchetto 
dipendente). Se le dipendenze sono specificate in modo troppo permissivo, sarete
inevitabilmente afflitti da promiscuità di versione (l’ipotizzare compatibilità 
con versioni future più di quanto sia ragionevole). L’inferno della dipendenza 
è dove siete quando blocco di versione e/o promiscuità di versione vi impediscono 
di far avanzare il vostro progetto in modo facile e sicuro.

Come soluzione a questo problema, propongo un semplice insieme di regole e 
requisiti che stabiliscono come i numeri di versione siano assegnati ed 
incrementati.
Queste regole sono basate su, ma non necessariamente limitate a, diffuse
pratiche comuni adottate sia in software proprietario che open source.
Affinché questo sistema funzioni, avete prima bisogno di dichiarare un’API 
pubblica. Quest’ultima può consistere di documentazione o essere imposta tramite
il codice stesso. In ogni caso, è importante che tale API sia chiara e precisa. 
Una volta identificata la vostra API pubblica, comunicatene le modifiche con 
incrementi specifici del numero di versione. Considerate un formato di 
versione X.Y.Z (Major.Minor.Patch). La correzione di bug, non influenzando
l’API, incrementa la versione Patch, aggiunte/modifiche retrocompatibili all’API
incrementano la versione Minor, e modifiche non retrocompatibili all’API
incrementano la versione Major.

Chiamo questo sistema “Versionamento Semantico”. Con queste convenzioni i numeri di 
versione, ed il modo in cui essi cambiano, comunicano significato relativamente
al codice sottostante e a cosa è stato modificato da una versione all’altra.

Specifica di Versionamento Semantico (SemVer)

Le parole chiave “DEVE” (“MUST”), “NON DEVE” (“MUST NOT”), “REQUIRED”, “SHALL”, 
“SHALL NOT”, “DOVREBBE” (“SHOULD”), “SHOULD NOT”, “RECOMMENDED”, “PUO’” (“MAY”), 
e “OPTIONAL” in questo documento sono da interpretarsi come descritto nella 
RFC 2119.


  
    Software che usa Versionamento Semantico DEVE dichiarare un’API pubblica. 
Questa API potrebbe essere dichiarata nel codice stesso oppure essere definita 
rigorosamente nella documentazione. Indipendentemente da come è dichiarata, dovrebbe
essere precisa a completa.
  
  
    Un numero di versione normale DEVE essere nella forma X.Y.Z, dove X, Y, e Z 
sono interi non negativi, e NON DEVONO contenere zeri iniziali. X è la versione
major, Y è la versione minor, e Z è la versione patch.
Ogni elemento DEVE incrementare come numero a sé. Per esempio: 
1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Una volta che un pacchetto versionato è stato rilasciato, i contenuti di
quella versione NON DEVONO essere modificati. Qualsiasi modifica DEVE essere
rilasciata come una nuova versione.
  
  
    La versione Major zero (0.y.z) è per lo sviluppo iniziale. Qualunque cosa
può cambiare in qualsiasi istante. L’API pubblica non dovrebbe essere 
considerata stabile.
  
  
    La versione 1.0.0 definisce l’API pubblica. Il modo in cui il numero di 
versione è incrementato dopo questo rilascio dipende da questa API pubblica
e da come quest’ultima cambia.
  
  
    La versione Patch Z (x.y.Z | x > 0) DEVE essere incrementata solo se sono
introdotte correzioni retrocompatibili di bug. Una correzione di un bug è
definita come una modifica interna che corregge un comportamento errato.
  
  
    La versione Minor Y (x.Y.z | x > 0) DEVE essere incrementata se nell’API 
pubblica è introdotta una nuova funzionalità retrocompatibile. Essa DEVE essere
incrementata se qualsiasi funzionalità dell’API pubblica è marcata come 
deprecata. Essa PUO’ essere incrementata se sono introdotti all’interno del 
codice privato nuove funzionalità o miglioramenti sostanziali. Essa PUO’ 
includere modifiche di livello patch. La versione Patch DEVE essere
reimpostata a 0 quando la versione Minor è incrementata.
  
  
    La versione Major X (X.y.z | X > 0) DEVE essere incrementata se nell’API 
pubblica è introdotta qualsiasi modifica non retrocompatibile. Essa PUO’ 
includere modifiche di livello minor e patch. Le versioni patch e minor DEVONO
essere reimpostate a 0 quando la versione major è incrementata.
  
  
    Una versione di pre-rilascio PUO’ essere indicata aggiungendo immediatamente 
dopo la versione patch un trattino e una serie di identificatori separati dal 
punto. Gli identificatori DEVONO essere composti solo da alfanumerici ASCII e 
trattini [0-9A-Za-z-]. Gli identificatori NON DEVONO essere vuoti. Gli
identificatori numerici NON DEVONO includere zeri iniziali. Le versioni di
pre-rilascio hanno una precedenza inferiore rispetto alla versione normale
associata. Una versione di pre-rilascio indica che la versione è instabile
e potrebbe non soddisfare i requisiti di compatibilità intesi come indicato 
dalla versione normale ad essa associata. Esempi: 1.0.0-alpha, 1.0.0-alpha.1, 
1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Metadati di build POSSONO essere indicati aggiungendo immediatamente dopo la
versione patch o pre-rilascio un segno di addizione e una serie di 
identificatori separati dal punto. Gli identificatori DEVONO essere composti 
solo da alfanumerici ASCII e trattini [0-9A-Za-z-]. Gli identificatori NON 
DEVONO essere vuoti. I metadati di build dovrebbero essere ignorati nella 
determinazione della precedenza delle versione. Perciò due versioni che 
differiscono solo per i metadati di build, hanno la stessa precedenza. Esempi: 
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    La precedenza si riferisce a come le versioni sono confrontate l’una con
l’altra quando poste in relazione d’ordine. La precedenza DEVE essere calcolata 
separando gli identificatori nell’ordine seguente: major, minor, patch e 
pre-release (i metadati di build non compaiono nella precedenza). La precedenza 
è determinata dalla prima discrepanza quando si confrontano ognuno di tali 
identificatori da sinistra a destra come segue: le versioni major, minor e 
patch sono sempre confrontate numericamente. Esempio: 1.0.0 < 2.0.0 < 2.1.0 < 
2.1.1. 
Quando major, minor, e patch sono uguali, una versione di pre-rilascio ha una 
precedenza inferiore rispetto alla versione normale. Esempio: 1.0.0-alpha < 
1.0.0. 
La precedenza per due versioni di pre-rilascio con la stessa versione major, 
minor, e patch DEVE essere determinata confrontando ognuno degli identificatori
separati dal punto da sinistra a destra finché si trova una discrepanza come 
segue: gli identificatori costituiti da sole cifre sono confrontati 
numericamente e gli identificatori con lettere o trattini sono confrontati
lessicalmente secondo l’ordinamento ASCII. Gli identificatori numerici hanno
sempre una precedenza più bassa rispetto agli identificatori non numerici. 
Un insieme più grande di identificatori ha una precedenza superiore rispetto
ad un insieme più piccolo, se tutti quanti i precedenti identificatori sono 
uguali. Esempio: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Perché usare Versionamento Semantico?

Questa non è un’idea rivoluzionaria. Infatti, probabilmente fate già qualcosa di
simile a questo. Il problema è che quel “simile” non è abbastanza buono.
Senza la conformità a qualche tipo di specifica formale, i numeri di versione
sono essenzialmente inutili per una gestione delle dipendenze. Dando un nome
ed una chiara definizione alle idee sopra, diventa semplice comunicare le vostre
intenzioni agli utenti del vostro software. Quando queste intenzioni sono chiare,
flessibili (ma non troppo flessibili) le specifiche di dipendenza possono
finalmente essere realizzate.

Un semplice esempio dimostrerà come Versionamento Semantico può rendere 
l’inferno della dipendenza una cosa del passato. Considerate una libreria
chiamata “CamionDeiPompieri”. Essa richiede un pacchetto semanticamente 
versionato di nome “Scala”. All’istante in cui è creato, Scala è alla versione 
3.1.0. Poiché CamionDeiPompieri utilizza alcune funzionalità che furono 
inizialmente introdotte in 3.1.0, potete specificare con sicurezza la dipendenza 
da Scala come maggiore o uguale a 3.1.0 ma minore di 4.0.0. Ora, quando Scala 
versione 3.1.1 e 3.2.0 diventano disponibili, potete rilasciarle al vostro sistema 
di gestione dei pacchetti e sapere che esse saranno compatibili con software 
dipendente esistente.

In qualità di sviluppatori responsabili vorrete, naturalmente, verificare che
qualsiasi aggiornamento di pacchetto funzioni come descritto. Il mondo reale è
un luogo caotico; non possiamo farci nulla se non essere vigili. Ciò che potete
fare è consentire a Versionamento Semantico di fornirvi un modo sano di 
rilasciare ed aggiornare i pacchetti senza dover propagare le nuove versioni
ai pacchetti dipendenti, facendovi risparmiare tempo e fastidio.

Se tutto questo vi suona desiderabile, tutto ciò che vi serve fare per iniziare 
ad usare Versionamento Semantico è dichiarare che state facendo così e poi 
seguire le regole. Rimandate a questo sito web dal vostro LEGGIMI (README) così altri
conosceranno le regole e potranno beneficiarne.

FAQ

Come dovrei gestire revisioni nella fase iniziale 0.y.z di sviluppo?

La cosa più semplice da fare è cominciare da 0.1.0 con il rilascio di sviluppo 
iniziale e poi incrementare la versione minor per ogni successivo rilascio.

Come faccio a sapere quando rilasciare la 1.0.0?

Se il vostro software è usato in produzione, dovrebbe probabilmente già essere
alla 1.0.0. Se avete un’API stabile dalla quale gli utenti sono diventati 
dipendenti, dovreste essere alla 1.0.0. Se vi state preoccupando molto 
relativamente alla retrocompatibilità, dovreste probabilmente già essere alla 
1.0.0.

Questo non scoraggia lo sviluppo rapido e le iterazioni veloci?

La versione Major zero riguarda completamente lo sviluppo rapido. Se state 
modificando l’API ogni giorno dovreste o essere già nella versione 0.y.z oppure 
essere su un ramo di sviluppo separato lavorando alla prossima
versione major.

Se perfino la più piccola modifica non retrocompatibile all’API pubblica comporta un colpo alla versione major, non finirei alla versione 42.0.0 molto rapidamente?

Questa è una questione di sviluppo responsabile e lungimiranza. Modifiche
incompatibili non dovrebbero essere introdotte con leggerezza a software che
ha molto codice dipendente. Il costo in cui si potrebbe incorrere per aggiornare
potrebbe essere significativo. Dover dar colpi alla versione major per 
rilasciare modifiche incompatibili significa che penserete all’impatto delle vostre 
modifiche, e valuterete il rapporto costi/benefici coinvolto.

Documentare l’intera API pubblica è troppo lavoro!

E’ vostra responsabilità come sviluppatori professionisti documentare 
appropriatamente software il cui uso è destinato ad altri. Gestire la
complessità del software è una parte enormemente importante per mantenere
un progetto efficiente, e ciò è difficile da fare se nessuno sa come usare il
vostro software, o nessuno sa con sicurezza quali metodi sono invocabili. Nel lungo 
periodo Versionamento Semantico, ed il perseverare su un’API pubblica ben 
documentata, è in grado di far andare tutto liscio.

Cosa faccio se rilascio accidentalmente una modifica non retrocompatibile come versione minor?

Non appena realizzate di aver infranto le specifiche di Versionamento Semantico,
correggete il problema e rilasciate una nuova versione minor che corregga il 
problema e ripristini la retrocompatibilità. Perfino in tali circostanze,
non è accettabile modificare una versione rilasciata. Se è appropriato,
documentate la versione illecita ed informate i vostri utenti del problema cosicché
siano consapevoli della versione illecita.

Cosa dovrei fare se aggiorno le mie dipendenze senza modificare l’API pubblica?

Ciò sarebbe considerato compatibile poiché non interessa l’API pubblica.
Software che dipendono esplicitamente dalle stesse dipendenze del vostro 
pacchetto dovrebbero avere le loro proprie specifiche di dipendenza e l’autore 
noterà qualsiasi conflitto. Determinare se la modifica sia di livello patch o
minor dipende se avete aggiornato le vostre dipendenze per correggere un bug o
per introdurre una nuova funzionalità. In quest’ultimo caso solitamente mi 
aspetto del codice aggiuntivo, ed ovviamente un incremento della versione
minor.

Cosa faccio se inavvertitamente altero l’API pubblica in un modo non conforme con la modifica al numero di versione (per esempio il codice introduce erroneamente una modifica che rompe la major in un rilascio di una patch).

Utilizzate il buon senso. Se avete una platea immensa che sarebbe drasticamente
impattata dal ripristinio del comportamento atteso dell’API pubblica, allora
potrebbe essere meglio eseguire un rilascio di una versione major, perfino se
la correzione potrebbe strettamente essere considerata il rilascio di una patch.
Ricordate, Versionamento Semantico, è finalizzato alla comunicazione di 
significato attraverso il cambiamento del numero di versione. Se tali 
modifiche sono importanti per i vostri utenti, usate il numero di versione
per informarli.

Come dovrei gestire la deprecazione di funzionalità?

Deprecare funzionalità esistenti fa parte del normale sviluppo di software ed è
spesso necessario per fare progressi in avanti. Quando deprecate parte della
vostra API pubblica, dovreste fare due cose: (1) aggiornare la vostra documentazione
per consentire agli utenti di essere consapevoli della modifica, (2) distribuire
un nuovo rilascio minor con la deprecazione all’interno. Prima di rimuovere
completamente la funzionalità nel rilascio di una nuova major dovrebbe esserci 
al minimo un rilascio minor che contenga la deprecazione cosicché gli utenti 
siano in grado di migrare tranquillamente alla nuova API.

Versionamento Semantico ha un limite alla dimensione della stringa della versione?

No, ma usate il buon senso. Per esempio, una stringa di versione di 255 caratteri 
è eccessiva. Inoltre, sistemi specifici possono imporre i loro limiti sulla 
dimensione.

“v1.2.3” è una versione semantica?

No, “v1.2.3” non è una versione semantica. Tuttavia, prefissare una versione semantica
con una “v” è un modo comune (in inglese) di indicare che si tratta di un numero di versione.
L’abbreviazione “v” per “version” si incontra spesso nel controllo di versione. Esempio:
git tag v1.2.3 -m "Release version 1.2.3", ove “v1.2.3” è un nome di tag
e la versione semantica è “1.2.3”.

Esiste una espressione regolare (RegEx) suggerita per controllare la stringa SemVer?

Ne esistono due. Una con i gruppi nominati per quei sistemi che li supportano
(PCRE [Perl Compatible Regular Expressions, i.e. Perl, PHP ed R], Python
e Go).

Vedi: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


…ed una con invece i gruppi di cattura numerati (quindi cg1 = major, cg2 = minor,
cg3 = patch, cg4 = prerelease and cg5 = buildmetadata) che è compatibile
con ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
i.e. Perl, PHP ed R), Python e Go.

Vedi: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


A riguardo

La specifica di Versionamento Semantico è scritta da Tom
Preston-Werner, inventore di Gravatars e
cofondatore di GitHub.

Traduzione a cura del Java User Group Padova:

  Tarin Gamberini (autore)
  Enrico Mezzato (revisore)
  Emanuele Gesuato (revisore)
  Anicet Foba Togue (revisore)


…e di Lorenzo L. Ancora (autore)

Per lasciare il vostro feedback per favore aprite una segnalazione su 
GitHub.

Licenza

Creative Commons ― CC BY 3.0\nVersionamento Semantico 2.0.0\nDato un numero di versione MAJOR.MINOR.PATCH, incrementate la:\nversione MAJOR quando modificate l’API in modo non retrocompatibile\nversione MINOR quando aggiungete funzionalità in modo retrocompatibile\nversione PATCH quando correggete bug in modo retrocompatibile\nSono disponibili etichette aggiuntive per il pre-release e i metadati di build come
estensioni al formato MAJOR.MINOR.PATCH.\nNel mondo della gestione del software esiste un luogo terrificante chiamato
“inferno della dipendenza”. Quanto più cresce il vostro sistema e quanti più 
pacchetti integrate nel vostro software, tanto più facilmente vi ritroverete, un 
giorno, in questa valle di lacrime.\nNei sistemi con molte dipendenze, rilasciare nuove versioni di pacchetti può 
diventare rapidamente un incubo. Se le specifiche di dipendenza sono troppo 
stringenti, siete a rischio di blocco di versione (l’impossibilità di aggiornare
un pacchetto senza dover rilasciare nuove versioni di ogni pacchetto 
dipendente). Se le dipendenze sono specificate in modo troppo permissivo, sarete
inevitabilmente afflitti da promiscuità di versione (l’ipotizzare compatibilità 
con versioni future più di quanto sia ragionevole). L’inferno della dipendenza 
è dove siete quando blocco di versione e/o promiscuità di versione vi impediscono 
di far avanzare il vostro progetto in modo facile e sicuro.\nCome soluzione a questo problema, propongo un semplice insieme di regole e 
requisiti che stabiliscono come i numeri di versione siano assegnati ed 
incrementati.
Queste regole sono basate su, ma non necessariamente limitate a, diffuse
pratiche comuni adottate sia in software proprietario che open source.
Affinché questo sistema funzioni, avete prima bisogno di dichiarare un’API 
pubblica. Quest’ultima può consistere di documentazione o essere imposta tramite
il codice stesso. In ogni caso, è importante che tale API sia chiara e precisa. 
Una volta identificata la vostra API pubblica, comunicatene le modifiche con 
incrementi specifici del numero di versione. Considerate un formato di 
versione X.Y.Z (Major.Minor.Patch). La correzione di bug, non influenzando
l’API, incrementa la versione Patch, aggiunte/modifiche retrocompatibili all’API
incrementano la versione Minor, e modifiche non retrocompatibili all’API
incrementano la versione Major.\nChiamo questo sistema “Versionamento Semantico”. Con queste convenzioni i numeri di 
versione, ed il modo in cui essi cambiano, comunicano significato relativamente
al codice sottostante e a cosa è stato modificato da una versione all’altra.\nSpecifica di Versionamento Semantico (SemVer)\nLe parole chiave “DEVE” (“MUST”), “NON DEVE” (“MUST NOT”), “REQUIRED”, “SHALL”, 
“SHALL NOT”, “DOVREBBE” (“SHOULD”), “SHOULD NOT”, “RECOMMENDED”, “PUO’” (“MAY”), 
e “OPTIONAL” in questo documento sono da interpretarsi come descritto nella 
RFC 2119.\nSoftware che usa Versionamento Semantico DEVE dichiarare un’API pubblica. 
Questa API potrebbe essere dichiarata nel codice stesso oppure essere definita 
rigorosamente nella documentazione. Indipendentemente da come è dichiarata, dovrebbe
essere precisa a completa.\nSoftware che usa Versionamento Semantico DEVE dichiarare un’API pubblica. 
Questa API potrebbe essere dichiarata nel codice stesso oppure essere definita 
rigorosamente nella documentazione. Indipendentemente da come è dichiarata, dovrebbe
essere precisa a completa.\nUn numero di versione normale DEVE essere nella forma X.Y.Z, dove X, Y, e Z 
sono interi non negativi, e NON DEVONO contenere zeri iniziali. X è la versione
major, Y è la versione minor, e Z è la versione patch.
Ogni elemento DEVE incrementare come numero a sé. Per esempio: 
1.9.0 -> 1.10.0 -> 1.11.0.\nUn numero di versione normale DEVE essere nella forma X.Y.Z, dove X, Y, e Z 
sono interi non negativi, e NON DEVONO contenere zeri iniziali. X è la versione
major, Y è la versione minor, e Z è la versione patch.
Ogni elemento DEVE incrementare come numero a sé. Per esempio: 
1.9.0 -> 1.10.0 -> 1.11.0.\nUna volta che un pacchetto versionato è stato rilasciato, i contenuti di
quella versione NON DEVONO essere modificati. Qualsiasi modifica DEVE essere
rilasciata come una nuova versione.\nUna volta che un pacchetto versionato è stato rilasciato, i contenuti di
quella versione NON DEVONO essere modificati. Qualsiasi modifica DEVE essere
rilasciata come una nuova versione.\nLa versione Major zero (0.y.z) è per lo sviluppo iniziale. Qualunque cosa
può cambiare in qualsiasi istante. L’API pubblica non dovrebbe essere 
considerata stabile.\nLa versione Major zero (0.y.z) è per lo sviluppo iniziale. Qualunque cosa
può cambiare in qualsiasi istante. L’API pubblica non dovrebbe essere 
considerata stabile.\nLa versione 1.0.0 definisce l’API pubblica. Il modo in cui il numero di 
versione è incrementato dopo questo rilascio dipende da questa API pubblica
e da come quest’ultima cambia.\nLa versione 1.0.0 definisce l’API pubblica. Il modo in cui il numero di 
versione è incrementato dopo questo rilascio dipende da questa API pubblica
e da come quest’ultima cambia.\nLa versione Patch Z (x.y.Z | x > 0) DEVE essere incrementata solo se sono
introdotte correzioni retrocompatibili di bug. Una correzione di un bug è
definita come una modifica interna che corregge un comportamento errato.\nLa versione Patch Z (x.y.Z | x > 0) DEVE essere incrementata solo se sono
introdotte correzioni retrocompatibili di bug. Una correzione di un bug è
definita come una modifica interna che corregge un comportamento errato.\nLa versione Minor Y (x.Y.z | x > 0) DEVE essere incrementata se nell’API 
pubblica è introdotta una nuova funzionalità retrocompatibile. Essa DEVE essere
incrementata se qualsiasi funzionalità dell’API pubblica è marcata come 
deprecata. Essa PUO’ essere incrementata se sono introdotti all’interno del 
codice privato nuove funzionalità o miglioramenti sostanziali. Essa PUO’ 
includere modifiche di livello patch. La versione Patch DEVE essere
reimpostata a 0 quando la versione Minor è incrementata.\nLa versione Minor Y (x.Y.z | x > 0) DEVE essere incrementata se nell’API 
pubblica è introdotta una nuova funzionalità retrocompatibile. Essa DEVE essere
incrementata se qualsiasi funzionalità dell’API pubblica è marcata come 
deprecata. Essa PUO’ essere incrementata se sono introdotti all’interno del 
codice privato nuove funzionalità o miglioramenti sostanziali. Essa PUO’ 
includere modifiche di livello patch. La versione Patch DEVE essere
reimpostata a 0 quando la versione Minor è incrementata.\nLa versione Major X (X.y.z | X > 0) DEVE essere incrementata se nell’API 
pubblica è introdotta qualsiasi modifica non retrocompatibile. Essa PUO’ 
includere modifiche di livello minor e patch. Le versioni patch e minor DEVONO
essere reimpostate a 0 quando la versione major è incrementata.\nLa versione Major X (X.y.z | X > 0) DEVE essere incrementata se nell’API 
pubblica è introdotta qualsiasi modifica non retrocompatibile. Essa PUO’ 
includere modifiche di livello minor e patch. Le versioni patch e minor DEVONO
essere reimpostate a 0 quando la versione major è incrementata.\nUna versione di pre-rilascio PUO’ essere indicata aggiungendo immediatamente 
dopo la versione patch un trattino e una serie di identificatori separati dal 
punto. Gli identificatori DEVONO essere composti solo da alfanumerici ASCII e 
trattini [0-9A-Za-z-]. Gli identificatori NON DEVONO essere vuoti. Gli
identificatori numerici NON DEVONO includere zeri iniziali. Le versioni di
pre-rilascio hanno una precedenza inferiore rispetto alla versione normale
associata. Una versione di pre-rilascio indica che la versione è instabile
e potrebbe non soddisfare i requisiti di compatibilità intesi come indicato 
dalla versione normale ad essa associata. Esempi: 1.0.0-alpha, 1.0.0-alpha.1, 
1.0.0-0.3.7, 1.0.0-x.7.z.92.\nUna versione di pre-rilascio PUO’ essere indicata aggiungendo immediatamente 
dopo la versione patch un trattino e una serie di identificatori separati dal 
punto. Gli identificatori DEVONO essere composti solo da alfanumerici ASCII e 
trattini [0-9A-Za-z-]. Gli identificatori NON DEVONO essere vuoti. Gli
identificatori numerici NON DEVONO includere zeri iniziali. Le versioni di
pre-rilascio hanno una precedenza inferiore rispetto alla versione normale
associata. Una versione di pre-rilascio indica che la versione è instabile
e potrebbe non soddisfare i requisiti di compatibilità intesi come indicato 
dalla versione normale ad essa associata. Esempi: 1.0.0-alpha, 1.0.0-alpha.1, 
1.0.0-0.3.7, 1.0.0-x.7.z.92.\nMetadati di build POSSONO essere indicati aggiungendo immediatamente dopo la
versione patch o pre-rilascio un segno di addizione e una serie di 
identificatori separati dal punto. Gli identificatori DEVONO essere composti 
solo da alfanumerici ASCII e trattini [0-9A-Za-z-]. Gli identificatori NON 
DEVONO essere vuoti. I metadati di build dovrebbero essere ignorati nella 
determinazione della precedenza delle versione. Perciò due versioni che 
differiscono solo per i metadati di build, hanno la stessa precedenza. Esempi: 
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nMetadati di build POSSONO essere indicati aggiungendo immediatamente dopo la
versione patch o pre-rilascio un segno di addizione e una serie di 
identificatori separati dal punto. Gli identificatori DEVONO essere composti 
solo da alfanumerici ASCII e trattini [0-9A-Za-z-]. Gli identificatori NON 
DEVONO essere vuoti. I metadati di build dovrebbero essere ignorati nella 
determinazione della precedenza delle versione. Perciò due versioni che 
differiscono solo per i metadati di build, hanno la stessa precedenza. Esempi: 
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nLa precedenza si riferisce a come le versioni sono confrontate l’una con
l’altra quando poste in relazione d’ordine. La precedenza DEVE essere calcolata 
separando gli identificatori nell’ordine seguente: major, minor, patch e 
pre-release (i metadati di build non compaiono nella precedenza). La precedenza 
è determinata dalla prima discrepanza quando si confrontano ognuno di tali 
identificatori da sinistra a destra come segue: le versioni major, minor e 
patch sono sempre confrontate numericamente. Esempio: 1.0.0 < 2.0.0 < 2.1.0 < 
2.1.1. 
Quando major, minor, e patch sono uguali, una versione di pre-rilascio ha una 
precedenza inferiore rispetto alla versione normale. Esempio: 1.0.0-alpha < 
1.0.0. 
La precedenza per due versioni di pre-rilascio con la stessa versione major, 
minor, e patch DEVE essere determinata confrontando ognuno degli identificatori
separati dal punto da sinistra a destra finché si trova una discrepanza come 
segue: gli identificatori costituiti da sole cifre sono confrontati 
numericamente e gli identificatori con lettere o trattini sono confrontati
lessicalmente secondo l’ordinamento ASCII. Gli identificatori numerici hanno
sempre una precedenza più bassa rispetto agli identificatori non numerici. 
Un insieme più grande di identificatori ha una precedenza superiore rispetto
ad un insieme più piccolo, se tutti quanti i precedenti identificatori sono 
uguali. Esempio: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nLa precedenza si riferisce a come le versioni sono confrontate l’una con
l’altra quando poste in relazione d’ordine. La precedenza DEVE essere calcolata 
separando gli identificatori nell’ordine seguente: major, minor, patch e 
pre-release (i metadati di build non compaiono nella precedenza). La precedenza 
è determinata dalla prima discrepanza quando si confrontano ognuno di tali 
identificatori da sinistra a destra come segue: le versioni major, minor e 
patch sono sempre confrontate numericamente. Esempio: 1.0.0 < 2.0.0 < 2.1.0 < 
2.1.1. 
Quando major, minor, e patch sono uguali, una versione di pre-rilascio ha una 
precedenza inferiore rispetto alla versione normale. Esempio: 1.0.0-alpha < 
1.0.0. 
La precedenza per due versioni di pre-rilascio con la stessa versione major, 
minor, e patch DEVE essere determinata confrontando ognuno degli identificatori
separati dal punto da sinistra a destra finché si trova una discrepanza come 
segue: gli identificatori costituiti da sole cifre sono confrontati 
numericamente e gli identificatori con lettere o trattini sono confrontati
lessicalmente secondo l’ordinamento ASCII. Gli identificatori numerici hanno
sempre una precedenza più bassa rispetto agli identificatori non numerici. 
Un insieme più grande di identificatori ha una precedenza superiore rispetto
ad un insieme più piccolo, se tutti quanti i precedenti identificatori sono 
uguali. Esempio: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPerché usare Versionamento Semantico?\nQuesta non è un’idea rivoluzionaria. Infatti, probabilmente fate già qualcosa di
simile a questo. Il problema è che quel “simile” non è abbastanza buono.
Senza la conformità a qualche tipo di specifica formale, i numeri di versione
sono essenzialmente inutili per una gestione delle dipendenze. Dando un nome
ed una chiara definizione alle idee sopra, diventa semplice comunicare le vostre
intenzioni agli utenti del vostro software. Quando queste intenzioni sono chiare,
flessibili (ma non troppo flessibili) le specifiche di dipendenza possono
finalmente essere realizzate.\nUn semplice esempio dimostrerà come Versionamento Semantico può rendere 
l’inferno della dipendenza una cosa del passato. Considerate una libreria
chiamata “CamionDeiPompieri”. Essa richiede un pacchetto semanticamente 
versionato di nome “Scala”. All’istante in cui è creato, Scala è alla versione 
3.1.0. Poiché CamionDeiPompieri utilizza alcune funzionalità che furono 
inizialmente introdotte in 3.1.0, potete specificare con sicurezza la dipendenza 
da Scala come maggiore o uguale a 3.1.0 ma minore di 4.0.0. Ora, quando Scala 
versione 3.1.1 e 3.2.0 diventano disponibili, potete rilasciarle al vostro sistema 
di gestione dei pacchetti e sapere che esse saranno compatibili con software 
dipendente esistente.\nIn qualità di sviluppatori responsabili vorrete, naturalmente, verificare che
qualsiasi aggiornamento di pacchetto funzioni come descritto. Il mondo reale è
un luogo caotico; non possiamo farci nulla se non essere vigili. Ciò che potete
fare è consentire a Versionamento Semantico di fornirvi un modo sano di 
rilasciare ed aggiornare i pacchetti senza dover propagare le nuove versioni
ai pacchetti dipendenti, facendovi risparmiare tempo e fastidio.\nSe tutto questo vi suona desiderabile, tutto ciò che vi serve fare per iniziare 
ad usare Versionamento Semantico è dichiarare che state facendo così e poi 
seguire le regole. Rimandate a questo sito web dal vostro LEGGIMI (README) così altri
conosceranno le regole e potranno beneficiarne.\nCome dovrei gestire revisioni nella fase iniziale 0.y.z di sviluppo?\nLa cosa più semplice da fare è cominciare da 0.1.0 con il rilascio di sviluppo 
iniziale e poi incrementare la versione minor per ogni successivo rilascio.\nCome faccio a sapere quando rilasciare la 1.0.0?\nSe il vostro software è usato in produzione, dovrebbe probabilmente già essere
alla 1.0.0. Se avete un’API stabile dalla quale gli utenti sono diventati 
dipendenti, dovreste essere alla 1.0.0. Se vi state preoccupando molto 
relativamente alla retrocompatibilità, dovreste probabilmente già essere alla 
1.0.0.\nQuesto non scoraggia lo sviluppo rapido e le iterazioni veloci?\nLa versione Major zero riguarda completamente lo sviluppo rapido. Se state 
modificando l’API ogni giorno dovreste o essere già nella versione 0.y.z oppure 
essere su un ramo di sviluppo separato lavorando alla prossima
versione major.\nSe perfino la più piccola modifica non retrocompatibile all’API pubblica comporta un colpo alla versione major, non finirei alla versione 42.0.0 molto rapidamente?\nQuesta è una questione di sviluppo responsabile e lungimiranza. Modifiche
incompatibili non dovrebbero essere introdotte con leggerezza a software che
ha molto codice dipendente. Il costo in cui si potrebbe incorrere per aggiornare
potrebbe essere significativo. Dover dar colpi alla versione major per 
rilasciare modifiche incompatibili significa che penserete all’impatto delle vostre 
modifiche, e valuterete il rapporto costi/benefici coinvolto.\nDocumentare l’intera API pubblica è troppo lavoro!\nE’ vostra responsabilità come sviluppatori professionisti documentare 
appropriatamente software il cui uso è destinato ad altri. Gestire la
complessità del software è una parte enormemente importante per mantenere
un progetto efficiente, e ciò è difficile da fare se nessuno sa come usare il
vostro software, o nessuno sa con sicurezza quali metodi sono invocabili. Nel lungo 
periodo Versionamento Semantico, ed il perseverare su un’API pubblica ben 
documentata, è in grado di far andare tutto liscio.\nCosa faccio se rilascio accidentalmente una modifica non retrocompatibile come versione minor?\nNon appena realizzate di aver infranto le specifiche di Versionamento Semantico,
correggete il problema e rilasciate una nuova versione minor che corregga il 
problema e ripristini la retrocompatibilità. Perfino in tali circostanze,
non è accettabile modificare una versione rilasciata. Se è appropriato,
documentate la versione illecita ed informate i vostri utenti del problema cosicché
siano consapevoli della versione illecita.\nCosa dovrei fare se aggiorno le mie dipendenze senza modificare l’API pubblica?\nCiò sarebbe considerato compatibile poiché non interessa l’API pubblica.
Software che dipendono esplicitamente dalle stesse dipendenze del vostro 
pacchetto dovrebbero avere le loro proprie specifiche di dipendenza e l’autore 
noterà qualsiasi conflitto. Determinare se la modifica sia di livello patch o
minor dipende se avete aggiornato le vostre dipendenze per correggere un bug o
per introdurre una nuova funzionalità. In quest’ultimo caso solitamente mi 
aspetto del codice aggiuntivo, ed ovviamente un incremento della versione
minor.\nCosa faccio se inavvertitamente altero l’API pubblica in un modo non conforme con la modifica al numero di versione (per esempio il codice introduce erroneamente una modifica che rompe la major in un rilascio di una patch).\nUtilizzate il buon senso. Se avete una platea immensa che sarebbe drasticamente
impattata dal ripristinio del comportamento atteso dell’API pubblica, allora
potrebbe essere meglio eseguire un rilascio di una versione major, perfino se
la correzione potrebbe strettamente essere considerata il rilascio di una patch.
Ricordate, Versionamento Semantico, è finalizzato alla comunicazione di 
significato attraverso il cambiamento del numero di versione. Se tali 
modifiche sono importanti per i vostri utenti, usate il numero di versione
per informarli.\nCome dovrei gestire la deprecazione di funzionalità?\nDeprecare funzionalità esistenti fa parte del normale sviluppo di software ed è
spesso necessario per fare progressi in avanti. Quando deprecate parte della
vostra API pubblica, dovreste fare due cose: (1) aggiornare la vostra documentazione
per consentire agli utenti di essere consapevoli della modifica, (2) distribuire
un nuovo rilascio minor con la deprecazione all’interno. Prima di rimuovere
completamente la funzionalità nel rilascio di una nuova major dovrebbe esserci 
al minimo un rilascio minor che contenga la deprecazione cosicché gli utenti 
siano in grado di migrare tranquillamente alla nuova API.\nVersionamento Semantico ha un limite alla dimensione della stringa della versione?\nNo, ma usate il buon senso. Per esempio, una stringa di versione di 255 caratteri 
è eccessiva. Inoltre, sistemi specifici possono imporre i loro limiti sulla 
dimensione.\n“v1.2.3” è una versione semantica?\nNo, “v1.2.3” non è una versione semantica. Tuttavia, prefissare una versione semantica
con una “v” è un modo comune (in inglese) di indicare che si tratta di un numero di versione.
L’abbreviazione “v” per “version” si incontra spesso nel controllo di versione. Esempio:
git tag v1.2.3 -m "Release version 1.2.3", ove “v1.2.3” è un nome di tag
e la versione semantica è “1.2.3”.\nEsiste una espressione regolare (RegEx) suggerita per controllare la stringa SemVer?\nNe esistono due. Una con i gruppi nominati per quei sistemi che li supportano
(PCRE [Perl Compatible Regular Expressions, i.e. Perl, PHP ed R], Python
e Go).\nVedi: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n…ed una con invece i gruppi di cattura numerati (quindi cg1 = major, cg2 = minor,
cg3 = patch, cg4 = prerelease and cg5 = buildmetadata) che è compatibile
con ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
i.e. Perl, PHP ed R), Python e Go.\nVedi: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nLa specifica di Versionamento Semantico è scritta da Tom
Preston-Werner, inventore di Gravatars e
cofondatore di GitHub.\nTraduzione a cura del Java User Group Padova:\nJava User Group Padova\nTarin Gamberini (autore)\nEnrico Mezzato (revisore)\nEmanuele Gesuato (revisore)\nAnicet Foba Togue (revisore)\n…e di Lorenzo L. Ancora (autore)\nPer lasciare il vostro feedback per favore aprite una segnalazione su 
GitHub.\naprite una segnalazione su 
GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nセマンティック バージョニング 2.0.0

概要

　バージョンナンバーは、メジャー.マイナー.パッチ とし、バージョンを上げるには、


  APIの変更に互換性のない場合はメジャーバージョンを、
  後方互換性があり機能性を追加した場合はマイナーバージョンを、
  後方互換性を伴うバグ修正をした場合はパッチバージョンを上げます。


　プレリリースやビルドナンバーなどのラベルに関しては、メジャー.マイナー.パッチ の形式を拡張する形で利用することができます。

導入

　ソフトウェア・マネージメントの世界には、「依存性地獄」と呼ばれる恐ろしいものがあります。あなたのシステムが大きく成長すればするほど、さまざまなパッケージを組み込めば組み込むほど、自分が地獄の底にいることにいつか気づくでしょう。

　多くの依存性を有しているシステムにとって、新しいバージョンがリリースされることは悪夢でしかありません。厳密に依存関係を指定してしまうと、システムはバージョン・ロック（すべての依存パッケージを新しくしない限り、アップグレードできないこと）の危機にさらされてしまいます。反対に、依存指定を緩く管理しすぎると、バージョンが複雑に絡まり合い、痛い目にあうことは避けられないでしょう（合理性よりも将来のバージョンとの互換性を気にすることになる）。依存性地獄とは、あなたのプロジェクトでバージョン・ロックまたはバージョン混乱に陥ることで、プロジェクトに支障をきたすことを指します。

　この問題の解決策として、私はシンプルなルールセットとバージョン・ナンバーをどのように割り当て、バージョンを上げていくのかについての要件を提案します。これらのルールは既存のクローズドまたはオープンソースプロジェクトで普及している一般的な（必ずしもそうであるとは限りませんが）プラクティスをもとに作られています。このシステムを利用するために、まずはパブリックなAPIを宣言する必要があります。これはドキュメントに記載しても、コード自体で表現しても構いません。とにかく、APIが明確かつ正確であることは非常に重要です。パブリックなAPIを宣言したら、それを変更する際にはルールに従ってバージョン番号を上げなければなりません。つまり、X.Y.Z（メジャー.マイナー.パッチ）のバージョン形式を遵守しなければなりません。APIに影響を及ぼさないバグ修正はパッチバージョンを、後方互換性を保ちつつAPIを変更・追加した場合はマイナーバージョンを、後方互換性のないAPIの変更はメジャーバージョンを上げます。

　私はこのシステムを『セマンティック バージョニング』と呼び、このスキームに従えば、あるバージョンのコードが次のバージョンへの変更された際に何が変更されたのかユーザーに伝えることができます。

セマンティック バージョニング仕様書 (SemVer)

　この文書における各キーワード「しなければならない（MUST）」、「してはならない（MUST NOT）」、「要求されている（REQUIRED）」、「することになる（SHALL）」、「することはない（SHALL NOT）」、「する必要がある（SHOULD）」、「しないほうがよい（SHOULD NOT）」、「推奨される（RECOMMENDED）」、「してもよい（MAY）」、「選択できる（OPTIONAL）」は、RFC 2119に記載されている内容に従い解釈してください。


  
    セマンティック バージョニングを適用するソフトウェアはパブリックAPIを宣言しなければなりません（MUST）。このAPIはコード自体で表現されているかもしれませんし、明確に文書として存在してるかもしれません。どちらにせよ、正確かつ漏れがないようにするべきです（SHOULD）。
  
  
    通常のバージョンナンバーは、X.Y.Zの形式にしなければなりません（MUST）。このときX、Y、Zは非負の整数であり（MUST）、各数値の先頭にゼロを配置してはなりません（MUST NOT）。Xはメジャーバージョン、Yはマイナーバージョン、Zはパッチバージョンを表します。各バージョンは数値的にバージョンアップしなければなりません（MUST）。例：1.9.0 -> 1.10.0 -> 1.11.0。
  
  
    一度パッケージをリリースしたのなら、そのバージョンのパッケージのコンテンツは修正してはなりません（MUST NOT）。いかなる修正も新しいバージョンとしてリリースしなければなりません（MUST）。
  
  
    メジャーバージョンのゼロ（0.y.z）は初期段階の開発用です。いつでも、いかなる変更も起こりえます（MAY）。この時のパブリックAPIは安定していると考えるべきではありません（SHOULD NOT）。
  
  
    バージョン1.0.0はパブリックAPIを定義します。このリリース後のバージョンナンバーの上げ方に関しては、パブリックAPIがどのくらい変更されるのかによって決まります。
  
  
    パッチバージョン Z （x.y.Z | x > 0）は、後方互換性を保ったバグ修正を取り込んだ場合のみ、上げなければなりません（MUST）。バグ修正とは間違った振る舞いを修正する内部の変更のことを指します。
  
  
    マイナーバージョン Y （x.Y.z | x > 0）は、後方互換性を保ちつつ機能性をパブリックAPIに追加した場合、上げなければなりません（MUST）。また、いかなるパブリックAPIも廃止予定としたのなら、上げなければなりません（MUST）。プライベートコード内での新しい機能の追加や改善を取り込んだ場合は、上げてもよいです（MAY）。その際にパッチレベルの変更も含めてもよいです（MAY）。マイナーバージョンを上げた際にはパッチバージョンを0にリセットしなければなりません（MUST）。
  
  
    メジャーバージョン X （X.y.z | X > 0）は、パブリックAPIに対して後方互換性を持たない変更が取り込まれた場合、上げなければなりません（MUST）。その際にマイナーおよびパッチレベルの変更も含めてもよいです（MAY）。メジャーバージョンを上げた際には、パッチおよびマイナーバージョンを0にリセットしなければなりません（MUST）。
  
  
    プレリリースバージョンは、パッチバージョンの直後にハイフンとドットで区切られた識別子を追加することで表現してもよいです（MAY）。識別子は必ずASCII英数字とハイフン [0-9A-Za-z-] でなければなりません（MUST）。識別子は空であってはなりません（MUST NOT）。数値の識別子はゼロから始めてはなりません（MUST NOT）。プレリリースバージョンは関連する通常のバージョンよりも低い優先度です。プレリリースバージョンは、不安定であり、関連する通常のバージョンが示す要件と互換性を満たさない可能性があります。例：1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92。
  
  
    ビルドメタデータはパッチまたはプレリリースバージョンの直後にプラス記号とドットで区切られた識別子を追加することで表現してもよいです（MAY）。識別子は必ずASCII英数字とハイフン [0-9A-Za-z-] でなければなりません（MUST）。識別子は空であってはなりません（MUST NOT）。バージョンの優先度を決める際にはビルドメタデータは無視されなければなりません（MUST）。つまり、2つのビルドメタデータだけが違うバージョンは、同じ優先度ということです。例：1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85。
  
  
    バージョン同士をどのように比較するのかは優先度によって決まります。優先度はメジャー、マイナー、パッチ、プレリリース識別子の順番（ビルドメタデータは優先度に関して考慮しない）で分けて評価されなければなりません（MUST）。優先度は、各識別子を左から右に比較して最初の違いによって評価します。以下のように、メジャー、マイナー、パッチバージョンと常に数値的に比較します。例：1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。メジャー、マイナー、パッチが同じ場合、プレリリースバージョンを持っている方が通常のバージョンよりも低い優先度です。例：1.0.0-alpha < 1.0.0。同じ、メジャー、マイナー、パッチを持つプレリリースバージョンの優先度の決定は、ドットで区切れた識別子を左から右に、異なるところが見つかるまで比較し決定しなければなりません（MUST）。数値のみで構成される識別子は数値的に比較され、文字列やハイフンを含む識別子はASCIIソート順に辞書的に比較されます。数値的な識別子は常に数値的でない識別子よりも低い優先度です。もし先行する識別子が同じ場合、プレリリースのフィールドが小さいセットよりも大きいセットのほうが高い優先度です。例：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。
  


SemVerバージョンを表すバッカス・ナウア記法
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


なぜセマンティック バージョニングを使用するのか？

　このアイデアは新しいものでもなければ、革新的なものでもありません。実際、みなさんも似たような取り組みを既におこなっているかもしれません。問題は「似ている」のでは不十分だということです。正式な仕様書による取り決めがなければ、バージョンナンバーは依存性の管理において基本的には無意味です。上記のアイデアに対して名前と正確な定義を与えることよって、あなたの開発するソフトウェアにおいて、あなたの意図がユーザーに対して伝わりやすくなることでしょう。一度、これらの意図を正確にしてしまえば、柔軟な（しかし、柔軟すぎてはいけない）依存性の仕様を作ることができます。

　単純な例として、セマンティック バージョニングがどのように依存性地獄を過去のものとするかについて説明します。「Firetruck」と呼ばれるライブラリについて考えてみましょう。それはセマンティック バージョニングされた「Ladder」というパッケージを必要とします。Firetruckを作成した時、Ladderはバージョン3.1.0でした。Firetruckは、バージョン3.1.0時に導入されたいくつかの機能を使用しているので、Ladderが3.1.0以上4.0.0未満の範囲で安全に依存性を指定できます。Ladderのバージョン3.1.1と3.2.0が利用可能になった時、それらをパッケージ管理に取り込んでリリースすることができ、それらが既存の依存するソフトウェアと互換性があるということは明確です。

　賢明な開発者であれば、もちろんパッケージがアップグレードされたのならその機能を使ってみたいと思うはずでしょう。ただ、現実は混沌としていて、我々ができることといったら、慎重になることくらいです。セマンティック バージョニングを実践することで、新しい依存パッケージを巻き込むことなく、まともな方法でリリース、アップグレードすることができ、手間と時間を節約してくれることでしょう。

　もし全面的に同意できると感じたのなら、セマンティック バージョニングを実践していることを宣言し、ルールを守って下さい。それからあなたのREADMEからこのWebサイトにリンクしてください、そうすれば、他の人がこのルールを知り、役立てることができるでしょう。

FAQ

0.y.zのような初期の開発フェーズにおけるバージョンの取り扱いはどのようにすべきでしょうか？

　一番簡単な方法は0.1.0からで開発版をリリースし、その後のリリースのたびにマイナーバージョンを上げていけばよいでしょう。

1.0.0のリリースはいつすべきでしょうか？

　もし既にプロダクション用途であなたのソフトウェアが利用されているのなら、それは1.0.0であるべきでしょう。またもし安定したAPIを持ち、それに依存しているユーザーが複数いるのなら、それは1.0.0であるべきでしょう。もし後方互換性について多大な心配をしているのなら、それは1.0.0であるべきでしょう。

高速開発や高速イテレーションに悪影響を与えませんか？

　メジャーバージョンがゼロの場合、それは高速開発を意味しています。もし、毎日APIを変更しているのなら、0.y.zのバージョンのままにすべきか、開発ブランチとして切り分け、次のメジャーバージョンアップのために開発すべきです。

パブリックAPIに対して後方互換性を保たない、ほんの些細な変更があった際もメジャーバージョンアップをしなければならないのなら、42.0.0のようなバージョンにすぐになってしまわないですか？

　これは責任ある開発と深い洞察のある質問です。多くの依存されているコードを持つソフトウェアにおいて、非互換な変更を気軽に取り込むべきではありません。アップグレードする度にかかるコストは無視できないものでしょう。非互換な変更をリリースするためにメジャーバージョンを上げることは、変更における悪影響を思い知ることになるでしょう。加えて、費用対効果を評価して判断すべきでしょう。

すべてのパブリックAPIに関してドキュメントを書くのは重労働です。

　ユーザーに使用されることを前提としたソフトウェアに適切なドキュメントを用意することはプロフェッショナルな開発者としての当然の責任です。ソフトウェアの複雑性を管理することはプロジェクトをスムーズに続けていくために非常に重要なことで、もしあなたのソフトウェアの使い方や、どのメソッドが安全に呼び出せるのかを誰も知らないのは望ましい状況とは言えません。セマンティック バージョニングと適切に定義されたパブリックAPIを宣言することは長期的に見ればメリットが大きいでしょう。

もし誤って後方互換性のない変更をマイナーバージョンとしてリリースした場合、どうすればよいでしょうか？

　セマンティック バージョニングの仕様に違反したのならすぐに問題を修正してください。つまり後方互換性を復元し、新しくマイナーバージョンをリリースして下さい。このような状況下においてもリリースされたバージョンナンバーを修正してはなりません。適切な対応が完了したのなら、次は違反したバージョンを記録し、それをユーザーに知らせましょう。

もし、パブリックAPIの変更なしに自分のパッケージの依存性をアップデートしてしまったら、どうすべきでしょうか？

　それ自体はパブリックAPIに影響しませんので安心してください。パッケージとして明らかに同じ依存性を持つソフトウェアは自身の依存仕様を定義すべきですし、作成者はいかなるコンフリクトも見逃さないでしょう。その変更がパッチレベルなのかマイナーレベルなのかどうかは、パッケージの依存性をアップデートした理由がバグを修正するためか新しい機能を実装するためかどうかに依存します。後者のケースの場合は明らかにマイナーレベルの変更でしょう。

もしうっかりパブリックAPIをセマンティック バージョニングに対応していない形で変更したらどうなるでしょうか？（例：パッチリリースで主要なバグが発生した場合）

　最善の判断をしてください。もしパブリックAPIの動作が変わることで大いに影響するユーザーがいる場合、厳密にはパッチリリースであると考慮されるかもしれませんが、その後にメジャーバージョンをリリースするのがベストかもしれません。セマンティック バージョニングはバージョンがどのように変更されるのかということを伝えるためのものであるということを注意して下さい。

どのように非推奨機能を扱えばよいでしょうか？

　既存機能を廃止予定にするのはソフトウェア開発においては普通の事であり、開発を進める上で頻繁に必要となります。パブリックAPIの一部を非推奨にしたい場合、2つのことをすべきです。第一にユーザーに知らせるためにドキュメントを更新して下さい。次に非推奨機能を残したまま新しいマイナーバージョンをリリースして下さい。完全に非推奨機能を削除しメジャーバージョンをリリースする前に、ユーザーがスムーズに新しいAPIに移行できるように少なくとも1回のマイナーバージョン（非推奨機能を含んだ）をリリースして下さい。

SemVerのバージョン文字列に限度はありますか？

　いいえ、ありませんが良識ある判断をしてください。例えば255文字のバージョン文字列は過剰と言えるでしょうし、特定のシステムではそれ独自の文字列の限界値があることでしょう。

『v1.2.3』はセマンティック バージョンでしょうか？

　いいえ、『v1.2.3』はセマンティック バージョンではありません。しかしながら、セマンティック バージョンに接頭辞の『v』を付けるのは英語ではバージョン番号であることを示す一般的な方法です。バージョン管理では、『バージョン』を『v』と略すことがよくあります。たとえば git tag v1.2.3 -m" Release version 1.2.3 " では『v1.2.3』はタグ名であり、セマンティック バージョンは『1.2.3』です。

SemVer文字列をチェックするために推奨される正規表現（RegEx）はありますか？

　二つあります。一つは名前付きグループをサポートするシステム（PCRE [Perl Compatible Regular Expressions, 例: Perl, PHP and R]、Python、Go）のための正規表現です。

参考: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


　もう一つは番号付きキャプチャグループを使った正規表現です（したがって、cg1 = メジャー、cg2 = マイナー、cg3 = パッチ、cg4 = プレリリース、cg5 = ビルドメタデータを意味します）。これはECMA Script（JavaScript）、PCRE（Perl Compatible Regular Expressions, 例: Perl, PHP and R）、Python、Goにおいて互換性があります。

参考: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


著者について

セマンティック バージョニング仕様書の著者はTom Preston-Werner氏です。彼はGravatarの考案者であり、GitHubの共同創設者でもあります。

もしフィードバックがある場合は、GitHub上でissueを立てて下さい。

ライセンス

Creative Commons ― CC BY 3.0\nセマンティック バージョニング 2.0.0\nバージョンナンバーは、メジャー.マイナー.パッチ とし、バージョンを上げるには、\nAPIの変更に互換性のない場合はメジャーバージョンを、\n後方互換性があり機能性を追加した場合はマイナーバージョンを、\n後方互換性を伴うバグ修正をした場合はパッチバージョンを上げます。\nプレリリースやビルドナンバーなどのラベルに関しては、メジャー.マイナー.パッチ の形式を拡張する形で利用することができます。\nソフトウェア・マネージメントの世界には、「依存性地獄」と呼ばれる恐ろしいものがあります。あなたのシステムが大きく成長すればするほど、さまざまなパッケージを組み込めば組み込むほど、自分が地獄の底にいることにいつか気づくでしょう。\n多くの依存性を有しているシステムにとって、新しいバージョンがリリースされることは悪夢でしかありません。厳密に依存関係を指定してしまうと、システムはバージョン・ロック（すべての依存パッケージを新しくしない限り、アップグレードできないこと）の危機にさらされてしまいます。反対に、依存指定を緩く管理しすぎると、バージョンが複雑に絡まり合い、痛い目にあうことは避けられないでしょう（合理性よりも将来のバージョンとの互換性を気にすることになる）。依存性地獄とは、あなたのプロジェクトでバージョン・ロックまたはバージョン混乱に陥ることで、プロジェクトに支障をきたすことを指します。\nこの問題の解決策として、私はシンプルなルールセットとバージョン・ナンバーをどのように割り当て、バージョンを上げていくのかについての要件を提案します。これらのルールは既存のクローズドまたはオープンソースプロジェクトで普及している一般的な（必ずしもそうであるとは限りませんが）プラクティスをもとに作られています。このシステムを利用するために、まずはパブリックなAPIを宣言する必要があります。これはドキュメントに記載しても、コード自体で表現しても構いません。とにかく、APIが明確かつ正確であることは非常に重要です。パブリックなAPIを宣言したら、それを変更する際にはルールに従ってバージョン番号を上げなければなりません。つまり、X.Y.Z（メジャー.マイナー.パッチ）のバージョン形式を遵守しなければなりません。APIに影響を及ぼさないバグ修正はパッチバージョンを、後方互換性を保ちつつAPIを変更・追加した場合はマイナーバージョンを、後方互換性のないAPIの変更はメジャーバージョンを上げます。\n私はこのシステムを『セマンティック バージョニング』と呼び、このスキームに従えば、あるバージョンのコードが次のバージョンへの変更された際に何が変更されたのかユーザーに伝えることができます。\nセマンティック バージョニング仕様書 (SemVer)\nこの文書における各キーワード「しなければならない（MUST）」、「してはならない（MUST NOT）」、「要求されている（REQUIRED）」、「することになる（SHALL）」、「することはない（SHALL NOT）」、「する必要がある（SHOULD）」、「しないほうがよい（SHOULD NOT）」、「推奨される（RECOMMENDED）」、「してもよい（MAY）」、「選択できる（OPTIONAL）」は、RFC 2119に記載されている内容に従い解釈してください。\nセマンティック バージョニングを適用するソフトウェアはパブリックAPIを宣言しなければなりません（MUST）。このAPIはコード自体で表現されているかもしれませんし、明確に文書として存在してるかもしれません。どちらにせよ、正確かつ漏れがないようにするべきです（SHOULD）。\nセマンティック バージョニングを適用するソフトウェアはパブリックAPIを宣言しなければなりません（MUST）。このAPIはコード自体で表現されているかもしれませんし、明確に文書として存在してるかもしれません。どちらにせよ、正確かつ漏れがないようにするべきです（SHOULD）。\n通常のバージョンナンバーは、X.Y.Zの形式にしなければなりません（MUST）。このときX、Y、Zは非負の整数であり（MUST）、各数値の先頭にゼロを配置してはなりません（MUST NOT）。Xはメジャーバージョン、Yはマイナーバージョン、Zはパッチバージョンを表します。各バージョンは数値的にバージョンアップしなければなりません（MUST）。例：1.9.0 -> 1.10.0 -> 1.11.0。\n通常のバージョンナンバーは、X.Y.Zの形式にしなければなりません（MUST）。このときX、Y、Zは非負の整数であり（MUST）、各数値の先頭にゼロを配置してはなりません（MUST NOT）。Xはメジャーバージョン、Yはマイナーバージョン、Zはパッチバージョンを表します。各バージョンは数値的にバージョンアップしなければなりません（MUST）。例：1.9.0 -> 1.10.0 -> 1.11.0。\n一度パッケージをリリースしたのなら、そのバージョンのパッケージのコンテンツは修正してはなりません（MUST NOT）。いかなる修正も新しいバージョンとしてリリースしなければなりません（MUST）。\n一度パッケージをリリースしたのなら、そのバージョンのパッケージのコンテンツは修正してはなりません（MUST NOT）。いかなる修正も新しいバージョンとしてリリースしなければなりません（MUST）。\nメジャーバージョンのゼロ（0.y.z）は初期段階の開発用です。いつでも、いかなる変更も起こりえます（MAY）。この時のパブリックAPIは安定していると考えるべきではありません（SHOULD NOT）。\nメジャーバージョンのゼロ（0.y.z）は初期段階の開発用です。いつでも、いかなる変更も起こりえます（MAY）。この時のパブリックAPIは安定していると考えるべきではありません（SHOULD NOT）。\nバージョン1.0.0はパブリックAPIを定義します。このリリース後のバージョンナンバーの上げ方に関しては、パブリックAPIがどのくらい変更されるのかによって決まります。\nバージョン1.0.0はパブリックAPIを定義します。このリリース後のバージョンナンバーの上げ方に関しては、パブリックAPIがどのくらい変更されるのかによって決まります。\nパッチバージョン Z （x.y.Z | x > 0）は、後方互換性を保ったバグ修正を取り込んだ場合のみ、上げなければなりません（MUST）。バグ修正とは間違った振る舞いを修正する内部の変更のことを指します。\nパッチバージョン Z （x.y.Z | x > 0）は、後方互換性を保ったバグ修正を取り込んだ場合のみ、上げなければなりません（MUST）。バグ修正とは間違った振る舞いを修正する内部の変更のことを指します。\nマイナーバージョン Y （x.Y.z | x > 0）は、後方互換性を保ちつつ機能性をパブリックAPIに追加した場合、上げなければなりません（MUST）。また、いかなるパブリックAPIも廃止予定としたのなら、上げなければなりません（MUST）。プライベートコード内での新しい機能の追加や改善を取り込んだ場合は、上げてもよいです（MAY）。その際にパッチレベルの変更も含めてもよいです（MAY）。マイナーバージョンを上げた際にはパッチバージョンを0にリセットしなければなりません（MUST）。\nマイナーバージョン Y （x.Y.z | x > 0）は、後方互換性を保ちつつ機能性をパブリックAPIに追加した場合、上げなければなりません（MUST）。また、いかなるパブリックAPIも廃止予定としたのなら、上げなければなりません（MUST）。プライベートコード内での新しい機能の追加や改善を取り込んだ場合は、上げてもよいです（MAY）。その際にパッチレベルの変更も含めてもよいです（MAY）。マイナーバージョンを上げた際にはパッチバージョンを0にリセットしなければなりません（MUST）。\nメジャーバージョン X （X.y.z | X > 0）は、パブリックAPIに対して後方互換性を持たない変更が取り込まれた場合、上げなければなりません（MUST）。その際にマイナーおよびパッチレベルの変更も含めてもよいです（MAY）。メジャーバージョンを上げた際には、パッチおよびマイナーバージョンを0にリセットしなければなりません（MUST）。\nメジャーバージョン X （X.y.z | X > 0）は、パブリックAPIに対して後方互換性を持たない変更が取り込まれた場合、上げなければなりません（MUST）。その際にマイナーおよびパッチレベルの変更も含めてもよいです（MAY）。メジャーバージョンを上げた際には、パッチおよびマイナーバージョンを0にリセットしなければなりません（MUST）。\nプレリリースバージョンは、パッチバージョンの直後にハイフンとドットで区切られた識別子を追加することで表現してもよいです（MAY）。識別子は必ずASCII英数字とハイフン [0-9A-Za-z-] でなければなりません（MUST）。識別子は空であってはなりません（MUST NOT）。数値の識別子はゼロから始めてはなりません（MUST NOT）。プレリリースバージョンは関連する通常のバージョンよりも低い優先度です。プレリリースバージョンは、不安定であり、関連する通常のバージョンが示す要件と互換性を満たさない可能性があります。例：1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92。\nプレリリースバージョンは、パッチバージョンの直後にハイフンとドットで区切られた識別子を追加することで表現してもよいです（MAY）。識別子は必ずASCII英数字とハイフン [0-9A-Za-z-] でなければなりません（MUST）。識別子は空であってはなりません（MUST NOT）。数値の識別子はゼロから始めてはなりません（MUST NOT）。プレリリースバージョンは関連する通常のバージョンよりも低い優先度です。プレリリースバージョンは、不安定であり、関連する通常のバージョンが示す要件と互換性を満たさない可能性があります。例：1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92。\nビルドメタデータはパッチまたはプレリリースバージョンの直後にプラス記号とドットで区切られた識別子を追加することで表現してもよいです（MAY）。識別子は必ずASCII英数字とハイフン [0-9A-Za-z-] でなければなりません（MUST）。識別子は空であってはなりません（MUST NOT）。バージョンの優先度を決める際にはビルドメタデータは無視されなければなりません（MUST）。つまり、2つのビルドメタデータだけが違うバージョンは、同じ優先度ということです。例：1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85。\nビルドメタデータはパッチまたはプレリリースバージョンの直後にプラス記号とドットで区切られた識別子を追加することで表現してもよいです（MAY）。識別子は必ずASCII英数字とハイフン [0-9A-Za-z-] でなければなりません（MUST）。識別子は空であってはなりません（MUST NOT）。バージョンの優先度を決める際にはビルドメタデータは無視されなければなりません（MUST）。つまり、2つのビルドメタデータだけが違うバージョンは、同じ優先度ということです。例：1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85。\nバージョン同士をどのように比較するのかは優先度によって決まります。優先度はメジャー、マイナー、パッチ、プレリリース識別子の順番（ビルドメタデータは優先度に関して考慮しない）で分けて評価されなければなりません（MUST）。優先度は、各識別子を左から右に比較して最初の違いによって評価します。以下のように、メジャー、マイナー、パッチバージョンと常に数値的に比較します。例：1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。メジャー、マイナー、パッチが同じ場合、プレリリースバージョンを持っている方が通常のバージョンよりも低い優先度です。例：1.0.0-alpha < 1.0.0。同じ、メジャー、マイナー、パッチを持つプレリリースバージョンの優先度の決定は、ドットで区切れた識別子を左から右に、異なるところが見つかるまで比較し決定しなければなりません（MUST）。数値のみで構成される識別子は数値的に比較され、文字列やハイフンを含む識別子はASCIIソート順に辞書的に比較されます。数値的な識別子は常に数値的でない識別子よりも低い優先度です。もし先行する識別子が同じ場合、プレリリースのフィールドが小さいセットよりも大きいセットのほうが高い優先度です。例：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。\nバージョン同士をどのように比較するのかは優先度によって決まります。優先度はメジャー、マイナー、パッチ、プレリリース識別子の順番（ビルドメタデータは優先度に関して考慮しない）で分けて評価されなければなりません（MUST）。優先度は、各識別子を左から右に比較して最初の違いによって評価します。以下のように、メジャー、マイナー、パッチバージョンと常に数値的に比較します。例：1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。メジャー、マイナー、パッチが同じ場合、プレリリースバージョンを持っている方が通常のバージョンよりも低い優先度です。例：1.0.0-alpha < 1.0.0。同じ、メジャー、マイナー、パッチを持つプレリリースバージョンの優先度の決定は、ドットで区切れた識別子を左から右に、異なるところが見つかるまで比較し決定しなければなりません（MUST）。数値のみで構成される識別子は数値的に比較され、文字列やハイフンを含む識別子はASCIIソート順に辞書的に比較されます。数値的な識別子は常に数値的でない識別子よりも低い優先度です。もし先行する識別子が同じ場合、プレリリースのフィールドが小さいセットよりも大きいセットのほうが高い優先度です。例：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。\nSemVerバージョンを表すバッカス・ナウア記法\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nなぜセマンティック バージョニングを使用するのか？\nこのアイデアは新しいものでもなければ、革新的なものでもありません。実際、みなさんも似たような取り組みを既におこなっているかもしれません。問題は「似ている」のでは不十分だということです。正式な仕様書による取り決めがなければ、バージョンナンバーは依存性の管理において基本的には無意味です。上記のアイデアに対して名前と正確な定義を与えることよって、あなたの開発するソフトウェアにおいて、あなたの意図がユーザーに対して伝わりやすくなることでしょう。一度、これらの意図を正確にしてしまえば、柔軟な（しかし、柔軟すぎてはいけない）依存性の仕様を作ることができます。\n単純な例として、セマンティック バージョニングがどのように依存性地獄を過去のものとするかについて説明します。「Firetruck」と呼ばれるライブラリについて考えてみましょう。それはセマンティック バージョニングされた「Ladder」というパッケージを必要とします。Firetruckを作成した時、Ladderはバージョン3.1.0でした。Firetruckは、バージョン3.1.0時に導入されたいくつかの機能を使用しているので、Ladderが3.1.0以上4.0.0未満の範囲で安全に依存性を指定できます。Ladderのバージョン3.1.1と3.2.0が利用可能になった時、それらをパッケージ管理に取り込んでリリースすることができ、それらが既存の依存するソフトウェアと互換性があるということは明確です。\n賢明な開発者であれば、もちろんパッケージがアップグレードされたのならその機能を使ってみたいと思うはずでしょう。ただ、現実は混沌としていて、我々ができることといったら、慎重になることくらいです。セマンティック バージョニングを実践することで、新しい依存パッケージを巻き込むことなく、まともな方法でリリース、アップグレードすることができ、手間と時間を節約してくれることでしょう。\nもし全面的に同意できると感じたのなら、セマンティック バージョニングを実践していることを宣言し、ルールを守って下さい。それからあなたのREADMEからこのWebサイトにリンクしてください、そうすれば、他の人がこのルールを知り、役立てることができるでしょう。\n0.y.zのような初期の開発フェーズにおけるバージョンの取り扱いはどのようにすべきでしょうか？\n一番簡単な方法は0.1.0からで開発版をリリースし、その後のリリースのたびにマイナーバージョンを上げていけばよいでしょう。\n1.0.0のリリースはいつすべきでしょうか？\nもし既にプロダクション用途であなたのソフトウェアが利用されているのなら、それは1.0.0であるべきでしょう。またもし安定したAPIを持ち、それに依存しているユーザーが複数いるのなら、それは1.0.0であるべきでしょう。もし後方互換性について多大な心配をしているのなら、それは1.0.0であるべきでしょう。\n高速開発や高速イテレーションに悪影響を与えませんか？\nメジャーバージョンがゼロの場合、それは高速開発を意味しています。もし、毎日APIを変更しているのなら、0.y.zのバージョンのままにすべきか、開発ブランチとして切り分け、次のメジャーバージョンアップのために開発すべきです。\nパブリックAPIに対して後方互換性を保たない、ほんの些細な変更があった際もメジャーバージョンアップをしなければならないのなら、42.0.0のようなバージョンにすぐになってしまわないですか？\nこれは責任ある開発と深い洞察のある質問です。多くの依存されているコードを持つソフトウェアにおいて、非互換な変更を気軽に取り込むべきではありません。アップグレードする度にかかるコストは無視できないものでしょう。非互換な変更をリリースするためにメジャーバージョンを上げることは、変更における悪影響を思い知ることになるでしょう。加えて、費用対効果を評価して判断すべきでしょう。\nすべてのパブリックAPIに関してドキュメントを書くのは重労働です。\nユーザーに使用されることを前提としたソフトウェアに適切なドキュメントを用意することはプロフェッショナルな開発者としての当然の責任です。ソフトウェアの複雑性を管理することはプロジェクトをスムーズに続けていくために非常に重要なことで、もしあなたのソフトウェアの使い方や、どのメソッドが安全に呼び出せるのかを誰も知らないのは望ましい状況とは言えません。セマンティック バージョニングと適切に定義されたパブリックAPIを宣言することは長期的に見ればメリットが大きいでしょう。\nもし誤って後方互換性のない変更をマイナーバージョンとしてリリースした場合、どうすればよいでしょうか？\nセマンティック バージョニングの仕様に違反したのならすぐに問題を修正してください。つまり後方互換性を復元し、新しくマイナーバージョンをリリースして下さい。このような状況下においてもリリースされたバージョンナンバーを修正してはなりません。適切な対応が完了したのなら、次は違反したバージョンを記録し、それをユーザーに知らせましょう。\nもし、パブリックAPIの変更なしに自分のパッケージの依存性をアップデートしてしまったら、どうすべきでしょうか？\nそれ自体はパブリックAPIに影響しませんので安心してください。パッケージとして明らかに同じ依存性を持つソフトウェアは自身の依存仕様を定義すべきですし、作成者はいかなるコンフリクトも見逃さないでしょう。その変更がパッチレベルなのかマイナーレベルなのかどうかは、パッケージの依存性をアップデートした理由がバグを修正するためか新しい機能を実装するためかどうかに依存します。後者のケースの場合は明らかにマイナーレベルの変更でしょう。\nもしうっかりパブリックAPIをセマンティック バージョニングに対応していない形で変更したらどうなるでしょうか？（例：パッチリリースで主要なバグが発生した場合）\n最善の判断をしてください。もしパブリックAPIの動作が変わることで大いに影響するユーザーがいる場合、厳密にはパッチリリースであると考慮されるかもしれませんが、その後にメジャーバージョンをリリースするのがベストかもしれません。セマンティック バージョニングはバージョンがどのように変更されるのかということを伝えるためのものであるということを注意して下さい。\nどのように非推奨機能を扱えばよいでしょうか？\n既存機能を廃止予定にするのはソフトウェア開発においては普通の事であり、開発を進める上で頻繁に必要となります。パブリックAPIの一部を非推奨にしたい場合、2つのことをすべきです。第一にユーザーに知らせるためにドキュメントを更新して下さい。次に非推奨機能を残したまま新しいマイナーバージョンをリリースして下さい。完全に非推奨機能を削除しメジャーバージョンをリリースする前に、ユーザーがスムーズに新しいAPIに移行できるように少なくとも1回のマイナーバージョン（非推奨機能を含んだ）をリリースして下さい。\nSemVerのバージョン文字列に限度はありますか？\nいいえ、ありませんが良識ある判断をしてください。例えば255文字のバージョン文字列は過剰と言えるでしょうし、特定のシステムではそれ独自の文字列の限界値があることでしょう。\n『v1.2.3』はセマンティック バージョンでしょうか？\nいいえ、『v1.2.3』はセマンティック バージョンではありません。しかしながら、セマンティック バージョンに接頭辞の『v』を付けるのは英語ではバージョン番号であることを示す一般的な方法です。バージョン管理では、『バージョン』を『v』と略すことがよくあります。たとえば git tag v1.2.3 -m" Release version 1.2.3 " では『v1.2.3』はタグ名であり、セマンティック バージョンは『1.2.3』です。\nSemVer文字列をチェックするために推奨される正規表現（RegEx）はありますか？\n二つあります。一つは名前付きグループをサポートするシステム（PCRE [Perl Compatible Regular Expressions, 例: Perl, PHP and R]、Python、Go）のための正規表現です。\n参考: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nもう一つは番号付きキャプチャグループを使った正規表現です（したがって、cg1 = メジャー、cg2 = マイナー、cg3 = パッチ、cg4 = プレリリース、cg5 = ビルドメタデータを意味します）。これはECMA Script（JavaScript）、PCRE（Perl Compatible Regular Expressions, 例: Perl, PHP and R）、Python、Goにおいて互換性があります。\n参考: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nセマンティック バージョニング仕様書の著者はTom Preston-Werner氏です。彼はGravatarの考案者であり、GitHubの共同創設者でもあります。\nもしフィードバックがある場合は、GitHub上でissueを立てて下さい。\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nსემანტიკური ვერსიონირება 2.0.0

მოკლედ

როდესაც გვაქვს ვერსიის ნომერი მაჟორული.მინორული.პატჩი, უნდა გაიზარდოს:


  მაჟორული ვერსია, როდესაც შეტანილია არა უკუთავსებადი ცვლილებები API-ში.
  მინორული ვერსია, როდესაც ემატება ახალი ფუნქციონალი, უკუთავსებადობის დაურღვევლად.
  პატჩ-ვერსია, როდესაც ემატება უკუთავსებადი ჩასწორებები.


პრე-რელიზის და ბილდის მეტა-მონაცემების დამატებითი აღნიშვნები შესაძლებელია მიემატოს 
ფორმატს მაჟორული.მინორული.პატჩი

შესავალი

პროგრამული უზრუნველყოფის შემუშავების მართვის პროცესში არსებობს ცნება 
“დამოკიდებულებათა ჯოჯოხეთი” (dependency hell). რაც უფრო იზრდება სისტემა და 
რაც უფრო მეტი ბიბლიოთეკის ინტეგრირება ხდება პროექტში, მით უფრო იზრდება ამ 
სიტუაციაში მოხვედრის ალბათობა.

სისტემაში სადაც ბევრი დამოკიდებულებაა, ახალი ვერსიის გამოშვება შეიძლება 
გადაიქცეს დიდ თავის ტკივილად. თუ დამოკიდებულებების სპეციფიკაცია ზედმეტად მკაცრია, 
არსებობს ახალი ვერსიის გამოშვების ბლოკირების საფრთხე (შეუძლებელია პაკეტის განახლება 
თითოეული დამოკიდებული ბიბლიოთეკის განახლების გარეშე). თუ დამოკიდებულებების სპეციფიკაცია 
ზედმეტად თავისუფალია, ადრე თუ გვიან აუცილებლად დადგება ვერსიების შეუსაბამობის 
პრობლემა (უსაფუძვლო იმედი მომავალ ვერსიებთან თავსებადობისა).
“დამოკიდებულებათა ჯოჯოხეთი” არის მდგომარეობა როდესაც დამოკიდებულებების არსებობა 
ხელს უშლის პროექტის წინსვლას და განვითარებას.

ამ პრობლემის მოგვარებისთვის გთავაზობთ უბრალო წესების და მოთხოვნების კრებულს, 
რომელიც განსაზღვრავს როგორ ენიჭება და იცვლება ვერსიის ნომრები.
იმისათვის რომ ამ სისტემამ იმუშაოს, თქვენ უნდა განსაზღვროთ გარე (public) API.
ის შეიძლება აღიწეროს როგორც დოკუმენტაციაში, ასევე თავად კოდის მეშვეობით. მთავარია, 
რომ ეს API იყოს გასაგები და ზუსტი. მას შემდეგ რაც ერთხელ აღწერთ გარე API-ს, 
მასში ცვლილებების შესახებ მის მომხმარებლებს თქვენ ამცნობთ სპეციალური ვერსიის 
ნომრის გაზრდის მეშვეობით. განვიხილოთ ვერსიის ფორმატი X.Y.Z (მაჟორული, მინორული, პატჩი). 
ბაგ-ფიქსები რომელთაც არ აქვთ გავლენა API-ზე, ზრდის პატჩ-ვერსიას, უკუთავსებადი 
დამატებები და ცვლილებები ზრდის მინორულ ვერსიას, ხოლო არა უკუთავსებადი ცვლილებები 
ზრდის მაჟორულ ვერსიას.

ამას ვუწოდებ “სემანტიკურ ვერსიონირებას” (Semantic Versioning). ამ სქემის მიხედვით
ვერსიის ნომრები და მათი ცვლილება აღწერს იმას, თუ როგორ შეიცვალა და რა შეიცვალა 
კოდში ერთი ვერსიიდან მეორემდე.

სემანტიკური ვერსიონირების სპეციფიკაცია (SemVer)
სიტყვები “უნდა” (MUST), “არ უნდა” (MUST NOT), “აუცილებელია” (REQUIRED),
“სასურველია” (SHOULD), “არ არის სასურველი” (SHOULD NOT), “რეკომენდირებულია” (RECOMMENDED),
“შეიძლება” (MAY) და “არასავალდებულოა” (OPTIONAL) ამ დოკუმენტში უნდა იქნეს 
ინტერპრეტირებული შესაბამისად RFC 2119 სპეციფიკაციისა.


  
    პროგრამული უზრუნველყოფა რომელიც იყენებს სემანტიკურ ვერსიონირებას, 
“უნდა” აღწერდეს გარე API-ს. ეს API შეიძლება იყოს აღწერილი თვითონ კოდში, 
ან მკაცრად იყოს განსაზღვრული დოკუმენტაციაში. API როგორც არ უნდა იყოს აღწერილი, 
იგი უნდა იყოს ზუსტი და ამომწურავი.
  
  
    ვერსიის ჩვეულებრივი ნომერი “უნდა” იყოს ფორმატში X.Y.Z, სადაც X, Y და Z — 
არის არაუარყოფითი მთელი რიცხვები და “არ უნდა” იწყებოდეს ნულით. X არის მაჟორული ვერსია, 
Y — მინორული ვერსია და Z — პატჩ-ვერსია. თითოეული ელემენტი “უნდა” იზრდებოდეს რიცხვობრივად.
მაგალითად: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    პაკეტის ახალი ვერსიის რელიზის შემდეგ ამ ვერსიის შემადგენლობა “არ უნდა” შეიცვალოს.
ნებისმიერი ცვლილების გამოშვება “უნდა” მოხდეს ახალი ვერსიით.
  
  
    მაჟორული ვერსია ნული (0.y.z) განკუთვნილია საწყისი სამუშაოებისთვის.
ყველაფერი შეიძლება შეიცვალოს ნებისმიერ მომენტში. გარე API არ შეიძლება 
განიხილოს როგორც სტაბილური.
  
  
    ვერსია 1.0.0 განსაზღვრავს გარე API-ს. ამ რელიზის შემდეგ ვერსიის ნომრები იზრდება
იმის მიხედვით თუ როგორ იცვლება გარე API.
  
  
    პატჩ-ვერსია Z (x.y.Z | x > 0) “უნდა” გაიზარდოს მხოლოდ იმ შემთხვევაში, 
თუ შეიცავს უკუთავსებად ბაგ-ფიქსებს. განსაზღვრება ბაგ-ფიქსი ნიშნავს
შიდა ცვლილებებს, რომელიც აღმოფხვრის კოდის არაკორექტულად მუშაობას.
  
  
    მინორული ვერსია (x.Y.z | x > 0) “უნდა” გაიზარდოს იმ შემთხვევაში,
თუ გარე API-ში წარმოდგენილია ახალი უკუთავსებადი ფუნქციონალი. “უნდა” გაიზარდოს 
იმ შემთხვევაში, თუ გარე API-ს რომელიმე ფუნქციონალი მოინიშნა როგორც მოძველებული 
(deprecated). “შეიძლება” გაიზარდოს ახალი ფუნქციონალის რეალიზაციისას ან
მნიშვნელოვანი ცვლილებებისას პრივატულ კოდში. ასევე იგი “შეიძლება” შეიცავდეს 
ცვლილებებს რომელიც დამახასიათებელია პატჩებისთვის. პატჩ-ვერსია “უნდა” განულდეს,
როდესაც იზრდება მინორული ვერსია.
  
  
    მაჟორული ვერსია X (X.y.z | X > 0) “უნდა” გაიზარდოს იმ შემთხვევაში, 
თუ გარე API-ში წარმოდგენილია რაიმე არა უკუთავსებადი ცვლილებები.
იგი “შეიძლება” შეიცავდეს ასევე ცვლილებებს, რომელიც დამახასიათებელია 
მინორული ვერსიებისთვის და პატჩებისთვის. როდესაც იზრდება მაჟორული ვერსია,
მინორული ვერსია და პატჩ-ვერსია “უნდა” განულდეს.
  
  
    წინა სარელიზო ვერსია “შეიძლება” იყოს აღნიშნული დეფისის და წერტილებით 
გამოყოფილი იდენტიფიკატორების სერიის დამატებით, რომელიც მოსდევს პატჩ-ვერსიას.
იდენტიფიკატორები “უნდა” შეიცავდეს მხოლოდ ASCII ასობგერით-ციფრულ სიმბოლოებს 
და დეფისს [0-9A-Za-z-]. იდენტიფიკატორები “არ უნდა” იყოს ცარიელი. ციფრული
იდენტიფიკატორები “არ უნდა” იწყებოდეს ნულით. წინა სარელიზო ვერსია მიანიშნებს
იმაზე, რომ ეს ვერსია არ არის სტაბილური და შეიძლება არ აკმაყოფილებდეს 
თავსებადობის მოთხოვნებს, რომელიც აღნიშნულია შესაბამისი ნორმალური ვერსიებით. 
მაგალითები: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    ბილდის მეტა-მონაცემები “შეიძლება” იყოს აღნიშნული პლუს ნიშნის და 
წერტილით გამოყოფილი იდენტიფიკატორების დამატებით პატჩ-ვერსიის ან წინა 
სარელიზო ვერსიის შემდეგ. იდენტიფიკატორები “უნდა” შეიცავდეს მხოლოდ ASCII 
ასობგერით-ციფრულ სიმბოლოებს და დეფისს [0-9A-Za-z-]. იდენტიფიკატორები “არ უნდა” 
იყოს ცარიელი. “რეკომენდირებულია” ბილდის მეტა-მონაცემების დაიგნორება, როდესაც
ძირითადი ვერსიები ერთი და იგივეა და ხდება ვერსიის პრიორიტეტის განსაზღვრა.
მაგალითები: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    პრიორიტეტი განსაზღვრავს თუ როგორ შეესაბამება ვერსიები ერთმანეთს სორტირების დროს.
ვერსიის პრიორიტეტი “უნდა” გამოითვალოს ვერსიის ნომრების მაჟორულ, მინორულ, 
პატჩ და წინა სარელიზო ვერსიებად დაყოფით (ბილდის მეტა-მონაცემები ამ გათვლაში არ ფიგურირებს).
პრიორიტეტი განისაზღვრება თითოეული იდენტიფიკატორის შედარებისას მარცხნიდან მარჯვნივ:
მაჟორული, მინორული და პატჩ ვერსია დარდება რიცხვობრივად. მაგალითად: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
როდესაც მაჟორული, მინორული და პატჩ-ვერსია ექვივალენტურია, წინა სარელიზო ვერსიას გაჩნია
ნორმალურ ვერსიაზე ნაკლები პრიორიტეტი. მაგალითად: 1.0.0-alpha < 1.0.0.
როდესაც ორ წინა სარელიზო ვერსიას გააჩნია ერთნაირი მაჟორული, მინორული და
პატჩ-ვერსია, მათ შორის პრიორიტეტი “უნდა” განისაზღვროს თითოეული წერტილით გამოყოფილი 
იდენტიფიკატორის მარცხნიდან მარჯვნივ შედარებით მანამდე, სანამ არ იქნება ნაპოვნი 
შემდეგი სახის განსხვავებები: იდენტიფიკატორები რომლებიც შედგება მხოლოდ ციფრებით, 
დარდება რიცხვობრივად; ასო-ბგერითი იდენტიფიკატორები ან დეფისები დარდება ლექსიკურად
ASCII სტანდარტის მიხედვით. რიცხვობრივ იდენტიფიკატორებს ყოველთვის გააჩნია დაბალი 
პრიორიტეტი ასო-ბგერით იდენტიფიკატორებთან მიმართებაში. როდესაც შესადარებელი 
იდენტიფიკატორები ტოლია, სიმბოლოების მეტ რაოდენობას გააჩნია უფრო მაღალი პრიორიტეტი. 
მაგალითი: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


რატომ უნდა გამოვიყენოთ სემანტიკური ვერსიონირება?

ეს არ გახლავთ ახალი ან რევოლუციური იდეა. ალბათ თქვენ უკვე იყენებთ რაიმე მსგავსს.
პრობლემა გახლავთ ის, რომ “მსგავსი” არ ნიშნავს საკმარისად კარგს. ფორმალური სპეციფიკაციის 
გარეშე ვერსიის ნომრები ფაქტიურად გამოუსადეგარია დამოკიდებულებების სამართავად.
ვერსიონირების იდეის ნათლად ფორმულირების და განსაზღვრის შემდეგ გაცილებით იოლი 
ხდება თქვენი პროგრამული უზრუნველყოფის მომხმარებლებს ამცნოთ გეგმების შესახებ.
როდესაც ეს გეგმები ნათელია და მოქნილი (არა ზედმეტად), შესაძლებელი ხდება 
დამოკიდებულებების სპეციფიკაციის შექმნა.

უბრალო მაგალითზე მოვახდინოთ დემონსტრირება თუ როგორ შეუძლია სემანტიკურ ვერსიონირებას 
“დამოკიდებულებათა ჯოჯოხეთი” აქციოს წარსულად. წარმოვიდგინოთ ბიბლიოთეკა სახელად 
“Firetruck”. მას ჭირდება სემანტიკურად ვერსიონირებული პაკეტი სახელად “Ladder”.
როდესაც შეიქმნა Firetruck, პაკეტი Ladder იყო 3.1.0 ვერსია. იქიდან გამომდინარე, რომ
Firetruck იყენებს ფუნქციონალს, რომელიც პირველად გაჩნდა 3.1.0 ვერსიაში, თქვენ მშვიდად 
შეგიძლიათ გამოაცხადოთ დამოკიდებულება Ladder პაკეტზე ვერსიით მინიმუმ 3.1.0 მაგრამ 
ნაკლები ვიდრე 4.0.0.
შემდეგ, როდესაც Ladder ხელმისაწვდომი გახდება ვერსიებით 3.1.1 და 3.2.0, თქვენ შეგეძლებათ 
მისი ინტეგრირება თქვენ სისტემაში და თან გეცოდინებათ, რომ იგი თავსებადია მიმდინარე 
ფუნქციონალთან.

როგორც პასუხისმგებლიან დეველოპერს, თქვენ რა თქმა უნდა გინდათ იყოთ დარწმუნებული 
იმაში, რომ ყველა განახლება ფუნქციონირებს ისე, როგორც გამოცხადებულია. რეალურ სამყაროში 
სრული ქაოსია და ამას ვერაფერს ვუზავთ. თქვენ რაც შეგიძლიათ გააკეთოთ, ეს არის სემანტიკურ 
ვერსიონირებას მიცეთ საშუალება დაგეხმაროთ რელიზების გამოშვებაში, მათზე დამოკიდებული 
პაკეტების განახლების გარეშე. ეს დაგიზოგავთ ბევრ დროს და ნერვებს.

თუ ეს მიმზიდველად ჟღერს, მაშინ ყველაფერი რაც გჭირდებათ, არის სემანტიკური 
ვერსიონირების გამოყენების დაწყება, გამოცხადება რომ იყენებთ მას, და მასში აღწერილი წესების დაცვა.
დაამატეთ ამ საიტის ბმული თქვენ README ფაილში, რათა მომხმარებლებმა იცოდნენ წესები 
და მიიღონ სრული სარგებელი აქედან.

ხშირად დასმული კითხვები (FAQ)

როგორ უნდა ვიმუშაო რევიზიებთან 0.y.z დეველოპმენტის საწყის ეტაპზე?

ყველაზე მარტივი — დაიწყოთ დეველოპმენტი 0.1.0 ვერსიიდან და შემდეგ გაზარდოთ მინორული 
ვერსია ყოველი შემდეგი რელიზის დროს.

როგორ უნდა მივხვდე რომ 1.0.0 რელიზის გამოშვების დროა?

თუ თქვენი პროგრამული უზრუნველყოფა გამოიყენება პროდაქშენზე, დიდი ალბათობით იგი 
უნდა იყოს 1.0.0 ვერსია. თუ თქვენ გაქვთ სტაბილური API, რომელზეც დამოკიდებული არიან 
მომხმარებლები, მაშინ ვერსია უნდა იყოს 1.0.0. თუ თქვენ იწყებთ შიშს უკუთავსებადობაზე, მაშინ დიდი 
ალბათობით თქვენი პროგრამული უზრუნველყოფის ვერსია უკვე არის 1.0.0.

ხელს ხომ არ უშლის სწრაფ დეველოპმენტს (Rapid Development) და მოკლე იტერაციებს (Fast Iteration)?

მაჟორული ვერსია 0 ზუსტადაც რომ ნიშნავს სწრაფ დეველოპმენტს. თუ თქვენ ცვლით API-ს ყოველ დღე,
უნდა გაჩერდეთ ვერსიაზე 0.y.z ან უნდა იმუშაოთ განსხვავებულ ტოტზე (branch) შემდეგი 
მაჟორული ვერსიის რელიზისთვის.

გარე API-ში ძალიან უმნიშვნელო არა უკუთავსებადი ცვლილებებიც საჭიროებს ახალი მაჟორული ვერსიის გამოშვებას? ეს ხომ არ გამოიწვევს იმას, რომ ძალიან მალე ვერსიის ნომერი გახდება 42.0.0?

წინდახედული და პასუხისმგებლიანი კითხვაა. არა უკუთავსებადი ცვლილებები არ შეიძლება რომ 
წარმოდგენილი იყოს როგორც უმნიშვნელო ცვლილებები, მითუმეტეს როდესაც ამ API-ზე დამოკიდებულია 
კიდევ სხვა კოდი. განახლების ღირებულება შეიძლება დიდი აღმოჩნდეს. არა უკუთავსებადი ცვლილებების 
შემთხვევაში, მაჟორული ვერსიის გაზრდის პრაქტიკა ნიშნავს, რომ თქვენ მოგიწევთ ფიქრი ცვლილებების 
შესახებ და ღირებულება/სარგებელის შეფარდების გათვალისწინება.

სრული API-ს დოკუმენტირება ძალიან დიდი სამუშაოა!

პროგრამული უზრუნველყოფის სწორი დოკუმენტირება არის თქვენი პასუხისმგებლობა, როგორც 
პროფესიონალი დეველოპერის. მითუმეტეს, როდესაც ეს პროგრამული უზრუნველყოფა გათვლილია ფართო 
აუდიტორიაზე. პროგრამული უზრუნველყოფის კომპლექსურობის მართვა არის მნიშვნელოვანი ნაწილი 
პროექტის მაღალი ეფექტურობის შენარჩუნებისთვის. და ეს ძალიან რთულია, როდესაც მომხმარებელმა 
არ იცის როგორ გამოიყენოს თქვენი პროგრამული უზრუნველყოფა ან რომელი მეთოდის გამოძახება 
შეუძლია უსაფრთხოდ. ხანგრძლივ პერსპექტივაში სემანტიკური ვერსიონირება და გარე API-ს ხარისხიანი 
დოკუმენტირებისადმი დაჟინებული სწრაფვა დაგეხმარებათ შეუფერხებლად მუშაობაში.

როგორ მოვიქცე თუ შემთხვევით არა უკუთავსებადი ცვლილებები დავარელიზე როგორც მინორული ვერსია?

როგორც კი აღმოაჩენთ, რომ დაარღვიეთ სემანტიკური ვერსიონირების სპეციფიკაცია, გაასწორეთ 
პრობლემა და გამოუშვით ახალი მინორული ვერსია, რომელიც აღადგენს უკუთავსებადობას. ასეთ 
ვითარებაშიც კი დაუშვებელია უკვე გამოშვებული რელიზის მოდიფიცირება. თუ საჭიროდ ჩათვლით, 
სასურველია ასევე დოკუმენტაციაში უკუთავსებადობის დარღვევის მითითება იმ კონკრეტული ვერსიისთვის 
და მომხმარებლების ინფორმირება იმის თაობაზე რომ ვერსიების მიმდევრობა დარღვეულია.

რა უნდა გავაკეთო, თუ ვანახლებ საკუთარ დამოკიდებულებებს გარე API-ს ცვლილების გარეშე?

ეს შეიძლება განიხილოს როგორც თავსებადი ცვლილებები, რაკი მას გავლენა არ აქვს გარე API-ზე.
პროგრამულ უზრუნველყოფას რომელიც თავისმხრივ დამოკიდებულია იმავე დამოკიდებულებებზე, 
უნდა გააჩნდეს საკუთარი დამოკიდებულებების სპეციფიკაციები და შესაბამისად ავტორი შეიტყობს შესაძლო 
კონფლიქტების შესახებ. ცვლილებები უნდა აღიწეროს როგორც პატჩ-ვერსია თუ მინორული, ეს
განისაზღვრება იმით, დამოკიდებულებები განახლდა ხარვეზის გასწორების გამო თუ დაემატა ახალი 
ფუნქციონალი. უკანასკნელის შემთხვევაში, როგორც წესი ემატება ახალი კოდი და შესაბამისად 
ახლდება მინორული ვერსია.

რა უნდა გავაკეთო, თუ შემთხვევით შევცვალე გარე API და არასწორად გავზარდე ვერსიის ნომერი (მაგალითად კოდი შეიცავს არა უკუთავსებად ცვლილებებს პატჩ-ვერსიაში)?

მოიქეცით თქვენი შეხედულებისამებრ. თუ თქვენი აუდიტორია საკმაოდ დიდია და გახდა საჭირო API-ს 
ძველი ფუნქციონალის დაბრუნება, მაშინ სასურველია ახალი მაჟორული ვერსიის გამოშვება, მიუხედავად 
იმისა, რომ ცვლილებები შეიცავს პატჩ-რელიზის შესაბამის ჩასწორებებს. დაიხსომეთ, სემანტიკურ 
ვერსიონირებაში ვერსიის ნომრები იცვლება სპეციფიკაციის მკაცრი დაცვით. თუ ცვლილებები 
მნიშვნელოვანია თქვენი მომხმარებლებისთვის, გამოიყენეთ ვერსიის ნომერი მათი ინფორმირებისთვის.

როგორ მოვიქცე მოძველებულ ფუნქციონალთან მიმართებაში?

ფუნქციონალის მოძველებულად გამოცხადება — ეს ჩვეულებრივი ამბავია დეველოპმენტის პროცესში
და ხშირად აუცილებელიც კია პროდუქტის განსავითარებლად. როდესაც გარე API-ს რაიმე ნაწილს 
აცხადებთ მოძველებულად, თქვენ უნდა გააკეთოთ ორი რამ: (1) განაახლოთ თქვენი დოკუმენტაცია, 
რათა მომხმარებლებმა შეიტყონ ამ ცვლილების შესახებ; (2) გამოუშვათ ახალი რელიზი მინორული 
ვერსიის გაზრდით. მანამ, სანამ მთლიანად ამოიღებთ კოდიდან მოძველებულ ფუნქციონალს და 
დაარელიზებთ მაჟორულ ვერსიას, უნდა არსებობდეს მინიმუმ ერთი მინორული რელიზი, რომელიც 
შეიცავს ფუნქციონალის მოძველებულად გამოცხადებას. ეს აუცილებელია იმისათვის, რომ 
მომხმარებლებმა უმტკივნეულოდ შეძლონ ახალ API-ზე გადასვლა.

სემანტიკურ ვერსიონირებას თუ გააჩნია ვერსიაში შესაძლო სიმბოლოების ლიმიტი?

არა, თუმცა იხელმძღვანელეთ საღი აზრით. ალბათ დამეთანხმებით 255 სიმბოლო ვერსიის აღწერაში ზედმეტია.
ასევე, ზოგიერთ სისტემას შეიძლება გააჩნდეს საკუთარი შეზღუდვები ხაზის დასაშვები სიგრძის მიმართ.

ავტორის შესახებ

სემანტიკური ვერსიონირების სპეციფიკაციის ავტორია
ტომ პრესტონ-ვერნერი, Gravatar-ის დამფუძნებელი
და GitHub-ის თანადამფუძნებელი.

თუ გსურთ დატოვოთ თქვენი გამოხმაურება, გთხოვთ შექმნათ
დაამატოთ თემა GitHub-ზე.

ქართული თარგმანი


  Avtandil Kikabidze aka LONGMAN (author)


ლიცენზია

Creative Commons — CC BY 3.0\nსემანტიკური ვერსიონირება 2.0.0\nროდესაც გვაქვს ვერსიის ნომერი მაჟორული.მინორული.პატჩი, უნდა გაიზარდოს:\nმაჟორული ვერსია, როდესაც შეტანილია არა უკუთავსებადი ცვლილებები API-ში.\nმინორული ვერსია, როდესაც ემატება ახალი ფუნქციონალი, უკუთავსებადობის დაურღვევლად.\nპატჩ-ვერსია, როდესაც ემატება უკუთავსებადი ჩასწორებები.\nპრე-რელიზის და ბილდის მეტა-მონაცემების დამატებითი აღნიშვნები შესაძლებელია მიემატოს 
ფორმატს მაჟორული.მინორული.პატჩი\nპროგრამული უზრუნველყოფის შემუშავების მართვის პროცესში არსებობს ცნება 
“დამოკიდებულებათა ჯოჯოხეთი” (dependency hell). რაც უფრო იზრდება სისტემა და 
რაც უფრო მეტი ბიბლიოთეკის ინტეგრირება ხდება პროექტში, მით უფრო იზრდება ამ 
სიტუაციაში მოხვედრის ალბათობა.\nსისტემაში სადაც ბევრი დამოკიდებულებაა, ახალი ვერსიის გამოშვება შეიძლება 
გადაიქცეს დიდ თავის ტკივილად. თუ დამოკიდებულებების სპეციფიკაცია ზედმეტად მკაცრია, 
არსებობს ახალი ვერსიის გამოშვების ბლოკირების საფრთხე (შეუძლებელია პაკეტის განახლება 
თითოეული დამოკიდებული ბიბლიოთეკის განახლების გარეშე). თუ დამოკიდებულებების სპეციფიკაცია 
ზედმეტად თავისუფალია, ადრე თუ გვიან აუცილებლად დადგება ვერსიების შეუსაბამობის 
პრობლემა (უსაფუძვლო იმედი მომავალ ვერსიებთან თავსებადობისა).
“დამოკიდებულებათა ჯოჯოხეთი” არის მდგომარეობა როდესაც დამოკიდებულებების არსებობა 
ხელს უშლის პროექტის წინსვლას და განვითარებას.\nამ პრობლემის მოგვარებისთვის გთავაზობთ უბრალო წესების და მოთხოვნების კრებულს, 
რომელიც განსაზღვრავს როგორ ენიჭება და იცვლება ვერსიის ნომრები.
იმისათვის რომ ამ სისტემამ იმუშაოს, თქვენ უნდა განსაზღვროთ გარე (public) API.
ის შეიძლება აღიწეროს როგორც დოკუმენტაციაში, ასევე თავად კოდის მეშვეობით. მთავარია, 
რომ ეს API იყოს გასაგები და ზუსტი. მას შემდეგ რაც ერთხელ აღწერთ გარე API-ს, 
მასში ცვლილებების შესახებ მის მომხმარებლებს თქვენ ამცნობთ სპეციალური ვერსიის 
ნომრის გაზრდის მეშვეობით. განვიხილოთ ვერსიის ფორმატი X.Y.Z (მაჟორული, მინორული, პატჩი). 
ბაგ-ფიქსები რომელთაც არ აქვთ გავლენა API-ზე, ზრდის პატჩ-ვერსიას, უკუთავსებადი 
დამატებები და ცვლილებები ზრდის მინორულ ვერსიას, ხოლო არა უკუთავსებადი ცვლილებები 
ზრდის მაჟორულ ვერსიას.\nამას ვუწოდებ “სემანტიკურ ვერსიონირებას” (Semantic Versioning). ამ სქემის მიხედვით
ვერსიის ნომრები და მათი ცვლილება აღწერს იმას, თუ როგორ შეიცვალა და რა შეიცვალა 
კოდში ერთი ვერსიიდან მეორემდე.\nსემანტიკური ვერსიონირების სპეციფიკაცია (SemVer)\nსიტყვები “უნდა” (MUST), “არ უნდა” (MUST NOT), “აუცილებელია” (REQUIRED),
“სასურველია” (SHOULD), “არ არის სასურველი” (SHOULD NOT), “რეკომენდირებულია” (RECOMMENDED),
“შეიძლება” (MAY) და “არასავალდებულოა” (OPTIONAL) ამ დოკუმენტში უნდა იქნეს 
ინტერპრეტირებული შესაბამისად RFC 2119 სპეციფიკაციისა.\nპროგრამული უზრუნველყოფა რომელიც იყენებს სემანტიკურ ვერსიონირებას, 
“უნდა” აღწერდეს გარე API-ს. ეს API შეიძლება იყოს აღწერილი თვითონ კოდში, 
ან მკაცრად იყოს განსაზღვრული დოკუმენტაციაში. API როგორც არ უნდა იყოს აღწერილი, 
იგი უნდა იყოს ზუსტი და ამომწურავი.\nპროგრამული უზრუნველყოფა რომელიც იყენებს სემანტიკურ ვერსიონირებას, 
“უნდა” აღწერდეს გარე API-ს. ეს API შეიძლება იყოს აღწერილი თვითონ კოდში, 
ან მკაცრად იყოს განსაზღვრული დოკუმენტაციაში. API როგორც არ უნდა იყოს აღწერილი, 
იგი უნდა იყოს ზუსტი და ამომწურავი.\nვერსიის ჩვეულებრივი ნომერი “უნდა” იყოს ფორმატში X.Y.Z, სადაც X, Y და Z — 
არის არაუარყოფითი მთელი რიცხვები და “არ უნდა” იწყებოდეს ნულით. X არის მაჟორული ვერსია, 
Y — მინორული ვერსია და Z — პატჩ-ვერსია. თითოეული ელემენტი “უნდა” იზრდებოდეს რიცხვობრივად.
მაგალითად: 1.9.0 -> 1.10.0 -> 1.11.0.\nვერსიის ჩვეულებრივი ნომერი “უნდა” იყოს ფორმატში X.Y.Z, სადაც X, Y და Z — 
არის არაუარყოფითი მთელი რიცხვები და “არ უნდა” იწყებოდეს ნულით. X არის მაჟორული ვერსია, 
Y — მინორული ვერსია და Z — პატჩ-ვერსია. თითოეული ელემენტი “უნდა” იზრდებოდეს რიცხვობრივად.
მაგალითად: 1.9.0 -> 1.10.0 -> 1.11.0.\nპაკეტის ახალი ვერსიის რელიზის შემდეგ ამ ვერსიის შემადგენლობა “არ უნდა” შეიცვალოს.
ნებისმიერი ცვლილების გამოშვება “უნდა” მოხდეს ახალი ვერსიით.\nპაკეტის ახალი ვერსიის რელიზის შემდეგ ამ ვერსიის შემადგენლობა “არ უნდა” შეიცვალოს.
ნებისმიერი ცვლილების გამოშვება “უნდა” მოხდეს ახალი ვერსიით.\nმაჟორული ვერსია ნული (0.y.z) განკუთვნილია საწყისი სამუშაოებისთვის.
ყველაფერი შეიძლება შეიცვალოს ნებისმიერ მომენტში. გარე API არ შეიძლება 
განიხილოს როგორც სტაბილური.\nმაჟორული ვერსია ნული (0.y.z) განკუთვნილია საწყისი სამუშაოებისთვის.
ყველაფერი შეიძლება შეიცვალოს ნებისმიერ მომენტში. გარე API არ შეიძლება 
განიხილოს როგორც სტაბილური.\nვერსია 1.0.0 განსაზღვრავს გარე API-ს. ამ რელიზის შემდეგ ვერსიის ნომრები იზრდება
იმის მიხედვით თუ როგორ იცვლება გარე API.\nვერსია 1.0.0 განსაზღვრავს გარე API-ს. ამ რელიზის შემდეგ ვერსიის ნომრები იზრდება
იმის მიხედვით თუ როგორ იცვლება გარე API.\nპატჩ-ვერსია Z (x.y.Z | x > 0) “უნდა” გაიზარდოს მხოლოდ იმ შემთხვევაში, 
თუ შეიცავს უკუთავსებად ბაგ-ფიქსებს. განსაზღვრება ბაგ-ფიქსი ნიშნავს
შიდა ცვლილებებს, რომელიც აღმოფხვრის კოდის არაკორექტულად მუშაობას.\nპატჩ-ვერსია Z (x.y.Z | x > 0) “უნდა” გაიზარდოს მხოლოდ იმ შემთხვევაში, 
თუ შეიცავს უკუთავსებად ბაგ-ფიქსებს. განსაზღვრება ბაგ-ფიქსი ნიშნავს
შიდა ცვლილებებს, რომელიც აღმოფხვრის კოდის არაკორექტულად მუშაობას.\nმინორული ვერსია (x.Y.z | x > 0) “უნდა” გაიზარდოს იმ შემთხვევაში,
თუ გარე API-ში წარმოდგენილია ახალი უკუთავსებადი ფუნქციონალი. “უნდა” გაიზარდოს 
იმ შემთხვევაში, თუ გარე API-ს რომელიმე ფუნქციონალი მოინიშნა როგორც მოძველებული 
(deprecated). “შეიძლება” გაიზარდოს ახალი ფუნქციონალის რეალიზაციისას ან
მნიშვნელოვანი ცვლილებებისას პრივატულ კოდში. ასევე იგი “შეიძლება” შეიცავდეს 
ცვლილებებს რომელიც დამახასიათებელია პატჩებისთვის. პატჩ-ვერსია “უნდა” განულდეს,
როდესაც იზრდება მინორული ვერსია.\nმინორული ვერსია (x.Y.z | x > 0) “უნდა” გაიზარდოს იმ შემთხვევაში,
თუ გარე API-ში წარმოდგენილია ახალი უკუთავსებადი ფუნქციონალი. “უნდა” გაიზარდოს 
იმ შემთხვევაში, თუ გარე API-ს რომელიმე ფუნქციონალი მოინიშნა როგორც მოძველებული 
(deprecated). “შეიძლება” გაიზარდოს ახალი ფუნქციონალის რეალიზაციისას ან
მნიშვნელოვანი ცვლილებებისას პრივატულ კოდში. ასევე იგი “შეიძლება” შეიცავდეს 
ცვლილებებს რომელიც დამახასიათებელია პატჩებისთვის. პატჩ-ვერსია “უნდა” განულდეს,
როდესაც იზრდება მინორული ვერსია.\nმაჟორული ვერსია X (X.y.z | X > 0) “უნდა” გაიზარდოს იმ შემთხვევაში, 
თუ გარე API-ში წარმოდგენილია რაიმე არა უკუთავსებადი ცვლილებები.
იგი “შეიძლება” შეიცავდეს ასევე ცვლილებებს, რომელიც დამახასიათებელია 
მინორული ვერსიებისთვის და პატჩებისთვის. როდესაც იზრდება მაჟორული ვერსია,
მინორული ვერსია და პატჩ-ვერსია “უნდა” განულდეს.\nმაჟორული ვერსია X (X.y.z | X > 0) “უნდა” გაიზარდოს იმ შემთხვევაში, 
თუ გარე API-ში წარმოდგენილია რაიმე არა უკუთავსებადი ცვლილებები.
იგი “შეიძლება” შეიცავდეს ასევე ცვლილებებს, რომელიც დამახასიათებელია 
მინორული ვერსიებისთვის და პატჩებისთვის. როდესაც იზრდება მაჟორული ვერსია,
მინორული ვერსია და პატჩ-ვერსია “უნდა” განულდეს.\nწინა სარელიზო ვერსია “შეიძლება” იყოს აღნიშნული დეფისის და წერტილებით 
გამოყოფილი იდენტიფიკატორების სერიის დამატებით, რომელიც მოსდევს პატჩ-ვერსიას.
იდენტიფიკატორები “უნდა” შეიცავდეს მხოლოდ ASCII ასობგერით-ციფრულ სიმბოლოებს 
და დეფისს [0-9A-Za-z-]. იდენტიფიკატორები “არ უნდა” იყოს ცარიელი. ციფრული
იდენტიფიკატორები “არ უნდა” იწყებოდეს ნულით. წინა სარელიზო ვერსია მიანიშნებს
იმაზე, რომ ეს ვერსია არ არის სტაბილური და შეიძლება არ აკმაყოფილებდეს 
თავსებადობის მოთხოვნებს, რომელიც აღნიშნულია შესაბამისი ნორმალური ვერსიებით. 
მაგალითები: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nწინა სარელიზო ვერსია “შეიძლება” იყოს აღნიშნული დეფისის და წერტილებით 
გამოყოფილი იდენტიფიკატორების სერიის დამატებით, რომელიც მოსდევს პატჩ-ვერსიას.
იდენტიფიკატორები “უნდა” შეიცავდეს მხოლოდ ASCII ასობგერით-ციფრულ სიმბოლოებს 
და დეფისს [0-9A-Za-z-]. იდენტიფიკატორები “არ უნდა” იყოს ცარიელი. ციფრული
იდენტიფიკატორები “არ უნდა” იწყებოდეს ნულით. წინა სარელიზო ვერსია მიანიშნებს
იმაზე, რომ ეს ვერსია არ არის სტაბილური და შეიძლება არ აკმაყოფილებდეს 
თავსებადობის მოთხოვნებს, რომელიც აღნიშნულია შესაბამისი ნორმალური ვერსიებით. 
მაგალითები: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nბილდის მეტა-მონაცემები “შეიძლება” იყოს აღნიშნული პლუს ნიშნის და 
წერტილით გამოყოფილი იდენტიფიკატორების დამატებით პატჩ-ვერსიის ან წინა 
სარელიზო ვერსიის შემდეგ. იდენტიფიკატორები “უნდა” შეიცავდეს მხოლოდ ASCII 
ასობგერით-ციფრულ სიმბოლოებს და დეფისს [0-9A-Za-z-]. იდენტიფიკატორები “არ უნდა” 
იყოს ცარიელი. “რეკომენდირებულია” ბილდის მეტა-მონაცემების დაიგნორება, როდესაც
ძირითადი ვერსიები ერთი და იგივეა და ხდება ვერსიის პრიორიტეტის განსაზღვრა.
მაგალითები: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nბილდის მეტა-მონაცემები “შეიძლება” იყოს აღნიშნული პლუს ნიშნის და 
წერტილით გამოყოფილი იდენტიფიკატორების დამატებით პატჩ-ვერსიის ან წინა 
სარელიზო ვერსიის შემდეგ. იდენტიფიკატორები “უნდა” შეიცავდეს მხოლოდ ASCII 
ასობგერით-ციფრულ სიმბოლოებს და დეფისს [0-9A-Za-z-]. იდენტიფიკატორები “არ უნდა” 
იყოს ცარიელი. “რეკომენდირებულია” ბილდის მეტა-მონაცემების დაიგნორება, როდესაც
ძირითადი ვერსიები ერთი და იგივეა და ხდება ვერსიის პრიორიტეტის განსაზღვრა.
მაგალითები: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nპრიორიტეტი განსაზღვრავს თუ როგორ შეესაბამება ვერსიები ერთმანეთს სორტირების დროს.
ვერსიის პრიორიტეტი “უნდა” გამოითვალოს ვერსიის ნომრების მაჟორულ, მინორულ, 
პატჩ და წინა სარელიზო ვერსიებად დაყოფით (ბილდის მეტა-მონაცემები ამ გათვლაში არ ფიგურირებს).
პრიორიტეტი განისაზღვრება თითოეული იდენტიფიკატორის შედარებისას მარცხნიდან მარჯვნივ:
მაჟორული, მინორული და პატჩ ვერსია დარდება რიცხვობრივად. მაგალითად: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
როდესაც მაჟორული, მინორული და პატჩ-ვერსია ექვივალენტურია, წინა სარელიზო ვერსიას გაჩნია
ნორმალურ ვერსიაზე ნაკლები პრიორიტეტი. მაგალითად: 1.0.0-alpha < 1.0.0.
როდესაც ორ წინა სარელიზო ვერსიას გააჩნია ერთნაირი მაჟორული, მინორული და
პატჩ-ვერსია, მათ შორის პრიორიტეტი “უნდა” განისაზღვროს თითოეული წერტილით გამოყოფილი 
იდენტიფიკატორის მარცხნიდან მარჯვნივ შედარებით მანამდე, სანამ არ იქნება ნაპოვნი 
შემდეგი სახის განსხვავებები: იდენტიფიკატორები რომლებიც შედგება მხოლოდ ციფრებით, 
დარდება რიცხვობრივად; ასო-ბგერითი იდენტიფიკატორები ან დეფისები დარდება ლექსიკურად
ASCII სტანდარტის მიხედვით. რიცხვობრივ იდენტიფიკატორებს ყოველთვის გააჩნია დაბალი 
პრიორიტეტი ასო-ბგერით იდენტიფიკატორებთან მიმართებაში. როდესაც შესადარებელი 
იდენტიფიკატორები ტოლია, სიმბოლოების მეტ რაოდენობას გააჩნია უფრო მაღალი პრიორიტეტი. 
მაგალითი: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nპრიორიტეტი განსაზღვრავს თუ როგორ შეესაბამება ვერსიები ერთმანეთს სორტირების დროს.
ვერსიის პრიორიტეტი “უნდა” გამოითვალოს ვერსიის ნომრების მაჟორულ, მინორულ, 
პატჩ და წინა სარელიზო ვერსიებად დაყოფით (ბილდის მეტა-მონაცემები ამ გათვლაში არ ფიგურირებს).
პრიორიტეტი განისაზღვრება თითოეული იდენტიფიკატორის შედარებისას მარცხნიდან მარჯვნივ:
მაჟორული, მინორული და პატჩ ვერსია დარდება რიცხვობრივად. მაგალითად: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
როდესაც მაჟორული, მინორული და პატჩ-ვერსია ექვივალენტურია, წინა სარელიზო ვერსიას გაჩნია
ნორმალურ ვერსიაზე ნაკლები პრიორიტეტი. მაგალითად: 1.0.0-alpha < 1.0.0.
როდესაც ორ წინა სარელიზო ვერსიას გააჩნია ერთნაირი მაჟორული, მინორული და
პატჩ-ვერსია, მათ შორის პრიორიტეტი “უნდა” განისაზღვროს თითოეული წერტილით გამოყოფილი 
იდენტიფიკატორის მარცხნიდან მარჯვნივ შედარებით მანამდე, სანამ არ იქნება ნაპოვნი 
შემდეგი სახის განსხვავებები: იდენტიფიკატორები რომლებიც შედგება მხოლოდ ციფრებით, 
დარდება რიცხვობრივად; ასო-ბგერითი იდენტიფიკატორები ან დეფისები დარდება ლექსიკურად
ASCII სტანდარტის მიხედვით. რიცხვობრივ იდენტიფიკატორებს ყოველთვის გააჩნია დაბალი 
პრიორიტეტი ასო-ბგერით იდენტიფიკატორებთან მიმართებაში. როდესაც შესადარებელი 
იდენტიფიკატორები ტოლია, სიმბოლოების მეტ რაოდენობას გააჩნია უფრო მაღალი პრიორიტეტი. 
მაგალითი: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nრატომ უნდა გამოვიყენოთ სემანტიკური ვერსიონირება?\nეს არ გახლავთ ახალი ან რევოლუციური იდეა. ალბათ თქვენ უკვე იყენებთ რაიმე მსგავსს.
პრობლემა გახლავთ ის, რომ “მსგავსი” არ ნიშნავს საკმარისად კარგს. ფორმალური სპეციფიკაციის 
გარეშე ვერსიის ნომრები ფაქტიურად გამოუსადეგარია დამოკიდებულებების სამართავად.
ვერსიონირების იდეის ნათლად ფორმულირების და განსაზღვრის შემდეგ გაცილებით იოლი 
ხდება თქვენი პროგრამული უზრუნველყოფის მომხმარებლებს ამცნოთ გეგმების შესახებ.
როდესაც ეს გეგმები ნათელია და მოქნილი (არა ზედმეტად), შესაძლებელი ხდება 
დამოკიდებულებების სპეციფიკაციის შექმნა.\nუბრალო მაგალითზე მოვახდინოთ დემონსტრირება თუ როგორ შეუძლია სემანტიკურ ვერსიონირებას 
“დამოკიდებულებათა ჯოჯოხეთი” აქციოს წარსულად. წარმოვიდგინოთ ბიბლიოთეკა სახელად 
“Firetruck”. მას ჭირდება სემანტიკურად ვერსიონირებული პაკეტი სახელად “Ladder”.
როდესაც შეიქმნა Firetruck, პაკეტი Ladder იყო 3.1.0 ვერსია. იქიდან გამომდინარე, რომ
Firetruck იყენებს ფუნქციონალს, რომელიც პირველად გაჩნდა 3.1.0 ვერსიაში, თქვენ მშვიდად 
შეგიძლიათ გამოაცხადოთ დამოკიდებულება Ladder პაკეტზე ვერსიით მინიმუმ 3.1.0 მაგრამ 
ნაკლები ვიდრე 4.0.0.
შემდეგ, როდესაც Ladder ხელმისაწვდომი გახდება ვერსიებით 3.1.1 და 3.2.0, თქვენ შეგეძლებათ 
მისი ინტეგრირება თქვენ სისტემაში და თან გეცოდინებათ, რომ იგი თავსებადია მიმდინარე 
ფუნქციონალთან.\nროგორც პასუხისმგებლიან დეველოპერს, თქვენ რა თქმა უნდა გინდათ იყოთ დარწმუნებული 
იმაში, რომ ყველა განახლება ფუნქციონირებს ისე, როგორც გამოცხადებულია. რეალურ სამყაროში 
სრული ქაოსია და ამას ვერაფერს ვუზავთ. თქვენ რაც შეგიძლიათ გააკეთოთ, ეს არის სემანტიკურ 
ვერსიონირებას მიცეთ საშუალება დაგეხმაროთ რელიზების გამოშვებაში, მათზე დამოკიდებული 
პაკეტების განახლების გარეშე. ეს დაგიზოგავთ ბევრ დროს და ნერვებს.\nთუ ეს მიმზიდველად ჟღერს, მაშინ ყველაფერი რაც გჭირდებათ, არის სემანტიკური 
ვერსიონირების გამოყენების დაწყება, გამოცხადება რომ იყენებთ მას, და მასში აღწერილი წესების დაცვა.
დაამატეთ ამ საიტის ბმული თქვენ README ფაილში, რათა მომხმარებლებმა იცოდნენ წესები 
და მიიღონ სრული სარგებელი აქედან.\nხშირად დასმული კითხვები (FAQ)\nროგორ უნდა ვიმუშაო რევიზიებთან 0.y.z დეველოპმენტის საწყის ეტაპზე?\nყველაზე მარტივი — დაიწყოთ დეველოპმენტი 0.1.0 ვერსიიდან და შემდეგ გაზარდოთ მინორული 
ვერსია ყოველი შემდეგი რელიზის დროს.\nროგორ უნდა მივხვდე რომ 1.0.0 რელიზის გამოშვების დროა?\nთუ თქვენი პროგრამული უზრუნველყოფა გამოიყენება პროდაქშენზე, დიდი ალბათობით იგი 
უნდა იყოს 1.0.0 ვერსია. თუ თქვენ გაქვთ სტაბილური API, რომელზეც დამოკიდებული არიან 
მომხმარებლები, მაშინ ვერსია უნდა იყოს 1.0.0. თუ თქვენ იწყებთ შიშს უკუთავსებადობაზე, მაშინ დიდი 
ალბათობით თქვენი პროგრამული უზრუნველყოფის ვერსია უკვე არის 1.0.0.\nხელს ხომ არ უშლის სწრაფ დეველოპმენტს (Rapid Development) და მოკლე იტერაციებს (Fast Iteration)?\nმაჟორული ვერსია 0 ზუსტადაც რომ ნიშნავს სწრაფ დეველოპმენტს. თუ თქვენ ცვლით API-ს ყოველ დღე,
უნდა გაჩერდეთ ვერსიაზე 0.y.z ან უნდა იმუშაოთ განსხვავებულ ტოტზე (branch) შემდეგი 
მაჟორული ვერსიის რელიზისთვის.\nგარე API-ში ძალიან უმნიშვნელო არა უკუთავსებადი ცვლილებებიც საჭიროებს ახალი მაჟორული ვერსიის გამოშვებას? ეს ხომ არ გამოიწვევს იმას, რომ ძალიან მალე ვერსიის ნომერი გახდება 42.0.0?\nწინდახედული და პასუხისმგებლიანი კითხვაა. არა უკუთავსებადი ცვლილებები არ შეიძლება რომ 
წარმოდგენილი იყოს როგორც უმნიშვნელო ცვლილებები, მითუმეტეს როდესაც ამ API-ზე დამოკიდებულია 
კიდევ სხვა კოდი. განახლების ღირებულება შეიძლება დიდი აღმოჩნდეს. არა უკუთავსებადი ცვლილებების 
შემთხვევაში, მაჟორული ვერსიის გაზრდის პრაქტიკა ნიშნავს, რომ თქვენ მოგიწევთ ფიქრი ცვლილებების 
შესახებ და ღირებულება/სარგებელის შეფარდების გათვალისწინება.\nსრული API-ს დოკუმენტირება ძალიან დიდი სამუშაოა!\nპროგრამული უზრუნველყოფის სწორი დოკუმენტირება არის თქვენი პასუხისმგებლობა, როგორც 
პროფესიონალი დეველოპერის. მითუმეტეს, როდესაც ეს პროგრამული უზრუნველყოფა გათვლილია ფართო 
აუდიტორიაზე. პროგრამული უზრუნველყოფის კომპლექსურობის მართვა არის მნიშვნელოვანი ნაწილი 
პროექტის მაღალი ეფექტურობის შენარჩუნებისთვის. და ეს ძალიან რთულია, როდესაც მომხმარებელმა 
არ იცის როგორ გამოიყენოს თქვენი პროგრამული უზრუნველყოფა ან რომელი მეთოდის გამოძახება 
შეუძლია უსაფრთხოდ. ხანგრძლივ პერსპექტივაში სემანტიკური ვერსიონირება და გარე API-ს ხარისხიანი 
დოკუმენტირებისადმი დაჟინებული სწრაფვა დაგეხმარებათ შეუფერხებლად მუშაობაში.\nროგორ მოვიქცე თუ შემთხვევით არა უკუთავსებადი ცვლილებები დავარელიზე როგორც მინორული ვერსია?\nროგორც კი აღმოაჩენთ, რომ დაარღვიეთ სემანტიკური ვერსიონირების სპეციფიკაცია, გაასწორეთ 
პრობლემა და გამოუშვით ახალი მინორული ვერსია, რომელიც აღადგენს უკუთავსებადობას. ასეთ 
ვითარებაშიც კი დაუშვებელია უკვე გამოშვებული რელიზის მოდიფიცირება. თუ საჭიროდ ჩათვლით, 
სასურველია ასევე დოკუმენტაციაში უკუთავსებადობის დარღვევის მითითება იმ კონკრეტული ვერსიისთვის 
და მომხმარებლების ინფორმირება იმის თაობაზე რომ ვერსიების მიმდევრობა დარღვეულია.\nრა უნდა გავაკეთო, თუ ვანახლებ საკუთარ დამოკიდებულებებს გარე API-ს ცვლილების გარეშე?\nეს შეიძლება განიხილოს როგორც თავსებადი ცვლილებები, რაკი მას გავლენა არ აქვს გარე API-ზე.
პროგრამულ უზრუნველყოფას რომელიც თავისმხრივ დამოკიდებულია იმავე დამოკიდებულებებზე, 
უნდა გააჩნდეს საკუთარი დამოკიდებულებების სპეციფიკაციები და შესაბამისად ავტორი შეიტყობს შესაძლო 
კონფლიქტების შესახებ. ცვლილებები უნდა აღიწეროს როგორც პატჩ-ვერსია თუ მინორული, ეს
განისაზღვრება იმით, დამოკიდებულებები განახლდა ხარვეზის გასწორების გამო თუ დაემატა ახალი 
ფუნქციონალი. უკანასკნელის შემთხვევაში, როგორც წესი ემატება ახალი კოდი და შესაბამისად 
ახლდება მინორული ვერსია.\nრა უნდა გავაკეთო, თუ შემთხვევით შევცვალე გარე API და არასწორად გავზარდე ვერსიის ნომერი (მაგალითად კოდი შეიცავს არა უკუთავსებად ცვლილებებს პატჩ-ვერსიაში)?\nმოიქეცით თქვენი შეხედულებისამებრ. თუ თქვენი აუდიტორია საკმაოდ დიდია და გახდა საჭირო API-ს 
ძველი ფუნქციონალის დაბრუნება, მაშინ სასურველია ახალი მაჟორული ვერსიის გამოშვება, მიუხედავად 
იმისა, რომ ცვლილებები შეიცავს პატჩ-რელიზის შესაბამის ჩასწორებებს. დაიხსომეთ, სემანტიკურ 
ვერსიონირებაში ვერსიის ნომრები იცვლება სპეციფიკაციის მკაცრი დაცვით. თუ ცვლილებები 
მნიშვნელოვანია თქვენი მომხმარებლებისთვის, გამოიყენეთ ვერსიის ნომერი მათი ინფორმირებისთვის.\nროგორ მოვიქცე მოძველებულ ფუნქციონალთან მიმართებაში?\nფუნქციონალის მოძველებულად გამოცხადება — ეს ჩვეულებრივი ამბავია დეველოპმენტის პროცესში
და ხშირად აუცილებელიც კია პროდუქტის განსავითარებლად. როდესაც გარე API-ს რაიმე ნაწილს 
აცხადებთ მოძველებულად, თქვენ უნდა გააკეთოთ ორი რამ: (1) განაახლოთ თქვენი დოკუმენტაცია, 
რათა მომხმარებლებმა შეიტყონ ამ ცვლილების შესახებ; (2) გამოუშვათ ახალი რელიზი მინორული 
ვერსიის გაზრდით. მანამ, სანამ მთლიანად ამოიღებთ კოდიდან მოძველებულ ფუნქციონალს და 
დაარელიზებთ მაჟორულ ვერსიას, უნდა არსებობდეს მინიმუმ ერთი მინორული რელიზი, რომელიც 
შეიცავს ფუნქციონალის მოძველებულად გამოცხადებას. ეს აუცილებელია იმისათვის, რომ 
მომხმარებლებმა უმტკივნეულოდ შეძლონ ახალ API-ზე გადასვლა.\nსემანტიკურ ვერსიონირებას თუ გააჩნია ვერსიაში შესაძლო სიმბოლოების ლიმიტი?\nარა, თუმცა იხელმძღვანელეთ საღი აზრით. ალბათ დამეთანხმებით 255 სიმბოლო ვერსიის აღწერაში ზედმეტია.
ასევე, ზოგიერთ სისტემას შეიძლება გააჩნდეს საკუთარი შეზღუდვები ხაზის დასაშვები სიგრძის მიმართ.\nსემანტიკური ვერსიონირების სპეციფიკაციის ავტორია
ტომ პრესტონ-ვერნერი, Gravatar-ის დამფუძნებელი
და GitHub-ის თანადამფუძნებელი.\nთუ გსურთ დატოვოთ თქვენი გამოხმაურება, გთხოვთ შექმნათ
დაამატოთ თემა GitHub-ზე.\nდაამატოთ თემა GitHub-ზე\nAvtandil Kikabidze aka LONGMAN (author)\nAvtandil Kikabidze aka LONGMAN\nCreative Commons — CC BY 3.0\nCreative Commons — CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nAsefrek anamkan n yileqman 2.0.0

Agzul

Mi ara tesɛum uṭṭun n ulqem s talɣa MAJOR.MINOR.PATCH, ilaq ad tesnernim:


  alqem MAJOR mi ara tgem abeddel n API yemyagin d wayen yezrin,
  alqem MINOR mi ara ternum timahilin yemɛaban d wayen yezrin,
  alqem PATCH mi ara tgem iseɣtiyen n tuccḍiwin yemɛaban d wayen yezrin.


Llant tecraḍ nniḍen i yileqman send tuffɣa (pre-release) d yidfersefka n usali
(build metadata) i irennun d isiɣzaf i talɣa MAJOR.MINOR.PATCH.

Tazwart

Deg umaḍal n usnefli n yiseɣẓanen, tella yiwet n tegnit ttkukrun-tt medden
ssawalen-as “times n teglin” (seg Teglizit “dependency hell”). Simal yettimɣur
unagraw-nwen, simal trennum iwemmusen i useɣẓan-nwen, simal yettaẓ-d wass deg
ur as-tettafem ara akk ixef-is deg wanu-a yesbelɛen asirem.

Deg unagraw deg i caḍent teglin, asufeɣ n yileqman imaynuten n kra yisger yezmer
ad yuɣal awal sin am yir targit. Ma yella ilugan n tigelt bezzaf ḥersen, tzemrem
ad tesweḥlem ileqman-nwen (ur tettizmirem ara ad tleqmem isger war ma
tessufɣem-d ileqman imaynuten n yal isger uɣur yurez). Ma yella tiglin bezzaf
serrḥent, iban ad d-teɣlim deg uceṛṛeɛ n ulqem (aqbal s tmara n umɛabi d
yileqman i d-itteddun nnig wayen ilaqen). Ma ur ken-yeǧǧi ara usewḥel n
yileqman neɣ aceṛṛeɛ n yileqman ad tseddum asenfar-nwen ar zdat s tefses
d tɣellist, ad d-tafem iman-nwen deg “tmes n teglin”.

Akken ad yefru wugur-a, summreɣ-d kra n yilugan d tmariwin ara awen-d-yinin amek
ara tesbeddem neɣ ad tesnernim uṭṭunen n yileqman. Ilugan-a bnan ― ɣas akken
mačči ala ɣef waya ― ɣef tsemras i nennum, yellan yakan ttwaseqdacent s waṭas
ama deg useɣẓan uslig ama deg win yeldin. Akken ad yeddu unagraw-a, ilaq ad
tesbeddem API tazayezt (agrudem n usihel n yesnasen). Aya yezmer ad yili s
usedles neɣ ad yettwaseyyef deg tengalt yakan. Akken yebɣu yili, API-a ilaq ad
tettwafham yerna ad temqet. Mi dayen tesbeddem-tt, ad tessawalem ɣef
ubeddel-is s usnerni n wuṭṭun-nwen n ulqem. Ma nesɛa alqem s talɣa X.Y.Z
(Major.Minor.Patch), iseɣtiyen ur nettbeddil ara API ad snernin alqem patch,
abeddel d usegmu n API yemɛaban d wayen yezrin ad snernin minor, abeddel n API
yemyagin d wayen yezrin ad yesnerni alqem major.

Semmaɣ-as i unagraw-a “aleqqem anamkan”. S unagraw-a, uṭṭunen n ulqem d wamek s
i ttnernin ttaken anamek i tengalt uɣur cudden d wayen yettbeddilen seg ulqem
ar wayeḍ.

Asefru n uleqqem anamkan (SemVer)

Awalen yufraren “ILAQ” (MUST/SHALL), “UR ILAQ ARA” (MUST NOT/SHALL NOT),
“YETTUḤETTMEM” (REQUIRED), “YEWWI-D” (SHOULD), “UR D-YEWWI ARA” (SHOULD NOT),
“YELHA” (RECOMMENDED), “YEZMER” (MAY), “AXETRAN” (OPTIONAL) i d-yeddan deg
wezmam-a, yewwi-d ad ttwafehmen akken i ten-id-mlan deg
RFC 2119.


  
    Aseɣẓan yesseqdacen aleqqem anamkan ILAQ ad yesbedd API tazayezt. API-a
tezmer ad tili deg tengalt yakan neɣ ad d-tettwasefhem akken iwata deg
yiseftar. Akken tebɣu tili, ILAQ ad tettwafham yerna ad temqet.
  
  
    Uṭṭun amagnu n ulqem ILAQ ad yili s talɣa X.Y.Z anda X, Y d Z d ummiden ur
nelli d uzdiren, UR ILAQ ARA ad gebren ilmawen ur nesɛi anamek. X d alqem
ameqran (major), Y d alqem ameẓyan (minor), ma d Z d alqem n useɣti (patch). Yal
aferdis ILAQ ad yettnerni s wudem umḍin. Amedya: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Ma dayen yeffeɣ-d yisger s kra ulqem, ayen yellan deg ulqem-a UR ILAQ ARA ad
ibeddel. Ma yella-d kra ubeddel, ILAQ ad d-yeffeɣ deg ulqem amaynut.
  
  
    Ilem deg ulqem ameqran (0.y.z) yemmug i usnefli amezwaru. Kullec YEZMER ad
ibeddel seg teswiɛt ar tayeḍ. API tazayezt UR D-YEWWI ARA ad tettwaḥsab terked.
  
  
    D alqem 1.0.0 i yesbeddayen API tazayezt. Abrid ara yaɣ usnerni n wuṭṭun n
ulqem segmi ara d-yeffeɣ, yeqqen ɣer API-nni tazayezt d wamek i tettbeddil.
  
  
    Alqem n useɣti Z (x.y.Z | x > 0) ILAQ ad yennerni ma yella d iseɣtiyen kan
yemɛaban d wayen yezrin i d-ikecmen. Aseɣti n ubug d abeddel agensas i
yettseggimen tikli yeccḍen.
  
  
    Alqem ameẓyan Y (x.Y.z | x > 0) ILAQ ad yennerni ma yella tekcem-d tmahilt
tamaynut yemɛaban d wayen yezrin ɣer API tazayezt. ILAQ daɣen ad yennerni ma
yella kra n tmahilt n API tazayezt tettwacreḍ d tin ara yettwakksen. YEZMER ad
yennerni ma tekcem-d tmahilt tamynut neɣ aseggem meqqren i yerzan tanglat
tusligt kan. YEZMER ad d-yeglu s ubeddel deg uswir n useɣti. Mi ara yennerni
ulqem ameẓyan, alqem n useɣti ILAQ ad yuɣal ar 0.
  
  
    Alqem ameqran X (X.y.z | X > 0) ILAQ ad yennerni ma nessekcem kra ubeddel
yemyagin d wayen yezrin ar API tazayezt. YEZMER daɣen ad d-yeglu s ubeddel deg
uswir ameẓyan neɣ n useɣti. Alqem n useɣti d ulqem ameẓyan ILAQ ad uɣalen ar 0
mi ara yennerni ulqem ameqran.
  
  
    Alqem send tuffɣa YEZMER ad d-iban s tmerna n ujerrid d umazrar n yiferdisen
yebḍan s tenqiḍt deffir kan ulqem n useɣti. Iferdisen-a UR ILAQ ad gebren ala
isekkilen igmumḍinen ASCII d ujerrid [0-9A-Za-z-]. Iferdisen-a UR ILAQ ARA ad
ilin d ilmawen. Iferdisen umḍinen UR ILAQ ARA ad gebren ilmawen ur nesɛi anamek.
Alqem send tuffɣa yettas-d ddaw ulqem amagnu i icudden ɣur-s. Alqem send tuffɣa
d alqem ur nerkid ara yerna yezmer ur yettqadar ara tiwtilin n umɛabi i yeɛnan
alqem amagnu i icudden ɣur-s. Imedyaten: 1.0.0-alpha, 1.0.0-alpha.1,
1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Idfersefka n usali ZEMREN ad d-binen s tmerna n uzmul “+” d umazrar n
yiferdisen yebḍan s tenqiḍt, deffir kan ulqem n useɣti neɣ n ulqem send
tuffɣa. Iferdisen-a UR ILAQ ad gebren ala isekkilen igmumḍinen ASCII d ujerrid
[0-9A-Za-z-]. Iferdisen-a UR ILAQ ARA ad ilin d ilmawen. Idfersefka n usali
ILAQ ad ttwazeglen deg umyizwer n yileqman. Ɣef waya, ma llan sin n yileqman
mgaraden kan deg yidfersefka n usali, atenan kifkif-iten deg umyizwer.
Imedyaten:  1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    Amyizwer ger yileqman yemmal-d amek ara ttwasettfen wa deffir wa. Amyizwer
ILAQ ad yettwaḥsab s beṭṭu n ulqem aferdis aferdis: ameqran, ameẓyan, n useɣti
d send tuffɣa s umyizwer-a (idfersefka ur ttekkin ara deg umyizwer). Amyizwer
yettili-d akken kan ara d-naf amgirred amenzu mi ara nesmenyif ger yiferdisen-a
yiwen yiwen seg uzelmaḍ ar uyeffus akka: alqem ameqran, alqem ameẓyan d ulqem
n useɣti nesmenyif-iten dima s wudem umḍin. Amedya: 1.0.0 < 2.0.0 < 2.1.0 <
2.1.1. Mi ara yilin yiferdisen imeqranen d yimeẓyanen d wid n useɣti d imegduya,
alqem send tuffɣa ad d-yezg ddaw ulqem amagnu. Amedya: 1.0.0-alpha < 1.0.0.
Amyizwer ger sin n yileqman send tuffɣa i iɛedlen aferdis ameqran d umeẓyan
d win n useɣti ILAQ ad yili s usmenyif n yal aferdis iḥazen s tenqiḍt seg
uzelmaḍ ar uyeffus alamma nufa-d amgirred akka: asmenyif n yiferdisen igebren
ala uṭṭunen ad d-yili s wudem umḍin, ma d asmenyif n yiferdisen yesɛan
isekkilen d yijerriden ad yili s umyizwer ASCII deg ugemmay. Alqem send tuffɣa
i umi ggten yiferdisen ad d-yezg ddaw n win yesɛan ciṭṭuḥ, ma ɛedlen akk
iferdisen-nni yezwaren. Amedya: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta
< 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Iwacu ad nseqdec aleqqem anamkan?

Aya mačči d takti tamaynut neɣ d tin ara ibeddlen tudert. Tidet kan, yezmer
txeddmem yakan ayen iqerben ar waya. Ugur d wa: “iqreben” ur icaḍ ara. War
amtawi d kra n ulugen unṣib, ad uɣalen wuṭṭunen n yileqman ur nfiɛen ara i
usefrek n teglin. S usbeddi n yisem d unamek ibanen i tikta i d-nefka da, ad
yishil ad tesfehmem ayen i tgemnem i widak yesseqdacen aseɣẓan-nwen. Mi ara ibin
wayen tgemnem, tzemrem ad d-txedmem aslugen iserḥen (d acu mačči bezzaf)
n tiglin.

Atan umedya ameẓyan ara d-iseknen amek ara yerr uleqqem anamkan “times n teglin”
d tamsalt yefran. Ad d-nini nesɛa tamkarḍit isem-is “AkamyunUsexsi”. Tettuḥwaǧ
isger iteddun s uleqqem anamkan semman-as “Tasellumt”. Ass deg i d-yennulfa
AkamyunUsexsi, Tasellumt tella deg ulqem 3.1.0. Ma yesseqdac AkamyunUsexsi kra
n tmahilt i d-ikecmmen deg 3.1.0, tzemrem ad d-tinim war aɣbel belli alqem
n tagelt Tasellumt ilaq ad yili nnig n 3.1.0 maca ddaw n 4.0.0. Imir, asmi
ara d-ffɣen yileqman 3.1.1 d 3.2.0 n Tasellumt, tzemrem ad ten-ternum ar
unagraw-nwen n usefrek n yisegran yerna teẓram ad mɛaban d useɣẓan-nni i
ten-yuḥwaǧen.

Win yellan d aneflay amasay, iban ad yebɣu ad isefqed kra ubeddel i d-yellan
deg yisger ma itteddu akken iwata. Deg tilawt, timsal mačči d iger iberzen;
ulac ayen i nezmer ad nexdem mgal aya nnig uḥader. Ayen i tzemrem ad txedmem,
d aseqdec n uleqqem anamkan ara awen-d-yefken abrid yelhan i usufeɣ d uleqqem
n yisegran war ma tcelɛem-d deg usufeɣ n teglin, s wakka ad d-trebḥem akud
yerna ad tekksem aɣbel.

Ma yella yeffeɣ fell-awen akk waya, tuḥwaǧem kan ad d-tinim belli tseqdacem-t
yerna ad tḍefrem ilugan akken ad tebdum aseqdec n uleqqem anamkan. Rnut aseɣwen
ar usmel-a deg README-nwen akken ad walin wiyaḍ ilugan yerna ad d-sfaydin
seg-sen.

Isteqsiyen imezga

Amek i ilaq ad sferkeɣ abeddel deg uḥric amenzu n usnefli 0.y.z?

Abrid isehlen akk d beddu n usnefli amenzu seg ulqem 0.1.0, syin akkin ad
tesnernayem alqem ameẓyan i yal asufeɣ amaynut.

Amek ara nẓer melmi ara d-nessufeɣ alqem 1.0.0?

Ma yella useɣẓan-nwen yettwaseqdec deg ufares, ahat yewwi-d ad yili s ulqem
1.0.0. Ma yella tesɛam API irekden uɣur bdan ttwarzen iseqdacen, ilaq ad tilim
s ulqem 1.0.0. Ma tebdam tcelɛem-d deg umɛabi d wayen yezrin, ilaq ad tilim
yakan deg ulqem 1.0.0.

Wissen aya ma ur yettekkes ara afud i usnefli arurad d wallusen wezzilen?

Alqem ameqran ilem (0) yemmug i usnefli arurad. Ma tettbeddilem API yal ass,
ilaq ad teqqimem deg ulqem 0.y.z neɣ deg ufurek iḥazen i usnefli ad tqeddcem
ɣef ulqem ameqran i d-iteddun.

Ma kra n ubeddel meẓẓiyen yemyagin d wayen yezrin deg API tazayezt yuḥwaǧ anserni n ulqem, ur nettaweḍ ara awal sin ar ulqem 42.0.0?

Aya d tamsalt n usnefli s tmasit d uwali ar zdat. Abeddel ara yerẓen amɛabi ur
ilaq ara ad d-yekcem kan akka ar useɣẓan uɣur teqqen aṭas n tengalt. Asali ar
ulqem amaynut yezmer ad d-yekker ɣlay. Ma tesnernam alqem ameqran akken ad
d-tessufɣem abeddel ur nemɛaba ara, aql-iken tettmeyyizem ɣef wayen ara d-yeglu
ubeddel-nwen, yerna tettakem azal i wassaɣ yellan ger tseglut d wayen i d-tesqam.

Asefter n API tazayezt akken ma tella d axeddim meqqren mliḥ!

Yewwi-d fell-awen s yisem-nwen d ineflayen imsaduren ad tesdelsem aseɣẓan-nwen
yemmugen akken ad tesqedcen wiyaḍ. Asefrek n umcubbak n useɣẓan d ayen yesɛan
azal meqqren akken ad yeqqim usenfar ifaz. Yuɛer ad naweḍ ar waya ma yella yiwen
ur yeẓri amek ara iseqdec aseɣẓan, neɣ anti tarrayin i umi yezmer ad isiwel.
Syin akkin, aleqqem anamkan d usbeddi igerrzen n API tazayezt ad ǧǧen yal yiwen
ad yeddu ɣer zdat war uguren.

Dacu i ilaq ad nexedem ma yella nessufeɣ-d s tuccḍa abeddel ur nemɛaba ara d wayen yezrin deg ulqem ameẓyan?

Akken kan ara d-takim belli terẓam asefru n uleqqem anamkan, ilaq ad tesseɣtim
ugur yerna ad d-tessufɣem alqem ameẓyan amaynut ara d-yerren amɛabi d wayen
yezrin. Ula deg tegnit am ta, ur ilaq ara ad tbeddlem ileqman i d-yeffɣen. Ma
twalam ilaq, sdelset alqem-nni yeccḍen, tesɛelmem iseqdacen-nwen s wugur-a i
d-yellan.

Dacu i ilaq ad nexdem mi ara nelqem tiglin-nneɣ war ma nbeddel API tazayezt?

Aya yezmer ad yettusemma d abddel yemɛaban imi ur yettnal ara API tazayezt.
Iseɣẓanen yurzen ɣer teglin yecban tid n uwemmus-nwen ahat ad sɛun asefru-nsen
n teglin, ihi amsekar-nsent ad ifiq ma yella kra n wugur. Akken ad teẓrem ma
ad yili ubeddel deg uswir n useɣti neɣ deg uswir ameẓyan, ilaq ad twalim ma
tessulim tiglin-nwen akken ad tesseɣtim abug neɣ akken ad d-teskecmem tamahilt
tamynut. Tezga tettili-d tmerna n tengalt deg tegnit-nni tis snat, d ayen i
yuḥwaǧen bla ccekk asnerni n ulqem ameẓyan.

Amek ara nexdem ma nbeddel s tuccḍa API tazayezt s wudem ur nemɛaba ara d ubeddel n wuṭṭun n ulqem (md. tessekcem-d tengalt abeddel meqqren yerẓan amɛabi deg ulqem n useɣti)?

D kunwi i yeẓran. Ma llan aṭas i ken-yeṭṭafaren, ara tḥazem mliḥ s tuɣalin ar
deffir ma terram API tazayezt akken tella, ahat yif-it ma tessufɣem-d alqem
ameqran, ɣas akken abeddel-nwen icaḍ-as uleqqem n useɣti. Ur tettut ara belli
aleqqem anamkan yemmug akken ad yefk anamek i usnerni n wuṭṭunen n yileqman.
Ma yella ubeddel i d-yellan yesɛa azal meqqren i yiseqdacen-nwen, sbinet-asen
-t-id s wuṭṭun n ulqem.

Amek ara nsefrek acraḍ n tukksa n tmahilin?

Acraḍ n tmahilin send ad ttwakksent d tigawt yuzzlen deg usnefli n useɣẓan yerna
d ayen i as-ilaqen tikwal akken ad yaẓ ɣer zdat. Mi ara tcerḍeḍ aḥric deg
API-nwen tazayezt ad yettwakkes, ɣur-wen snat n tɣawsiwin ad tent-txedmem: (1)
ad tleqmem iseftar-nwen akken ad ẓren iseqdacen-nwen, (2) ad d-tessufɣem alqem
ameẓyan amaynut deg ara d-tseddum acraḍ n tukksa. Send ad tekksem akk kra
tamahilt deg ulqem ameqran amaynut, ilaq ad d-tessufɣem ma drus yiwen ulqem
ameẓyan i d-immalen tukksa-a akken iseqdacen ad ɛeddin dac dac ɣer API tamaynut.

Yesɛa uleqqem anamkan kra n tilist ɣef teɣzi n wuṭṭun n ulqem?

Ala, dacu meyyez akken i iwata. Ahat uṭṭun n ulqem n 255 n yisekkilen (d amedya
kan) bezzaf ɣezzif. Yerna, kra n yinagrawen ttseyyifen tilisa ɣef teɣzi n uzrar
n wuṭṭun n ulqem.

“v1.2.3” d alqem anamkan?

Ala, “v1.2.3” mačči d alqem anamkan. Maca, timerna n “v” (seg Teglizit) deg
tazwara n ulqem anamkan akken ad d-ibin belli d uṭṭun n ulqem, d ayen yuzzlen
s waṭas. Nettmagar-d aṭas asemẓi n “version” s “v” deg usefrek n yileqman.
Amedya: git tag v1.2.3 -m "Asufeɣ n ulqem 1.2.3", anda “v1.2.3” d isem
n tecreḍt, ma yella d alqem anamkan d “1.2.3”.

Tella kra n tenfalit talugant (RegEx) i usentem n uzrar n ulqem anamkan?

Llant snat. Yiwet s yigrawen yettusemman tetteddu deg yinagrawen i asen-izemren
(PCRE [Perl Compatible Regular Expressions, am Perl, PHP d R], Python akked Go).

Wali: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Tella tayeḍ s yigrawen n tuṭṭfiwin s wuṭṭunen (agraw1 = major, agraw2 = minor,
agraw3 = patch, agraw4 = prerelease ma d agraw5 = buildmetadata) temɛaba d ECMA
Script (JavaScript), PCRE (Perl Compatible Regular Expressions, am Perl, PHP
d R), Python akked Go.

Wali: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Ayen yerzan

Asefru n uleqqem anamkan yura-t Tom Preston-Werner,
win i d-yesnulfan Gravatar yerna yettekki deg usufeɣ n GitHub.

Ma tebɣam ad d-teǧǧem iwenniten, ldit atiki deg GitHub
ma ulac aɣilif.

Turagt

Creative Commons ― CC BY 3.0\nAsefrek anamkan n yileqman 2.0.0\nMi ara tesɛum uṭṭun n ulqem s talɣa MAJOR.MINOR.PATCH, ilaq ad tesnernim:\nalqem MAJOR mi ara tgem abeddel n API yemyagin d wayen yezrin,\nalqem MINOR mi ara ternum timahilin yemɛaban d wayen yezrin,\nalqem PATCH mi ara tgem iseɣtiyen n tuccḍiwin yemɛaban d wayen yezrin.\nLlant tecraḍ nniḍen i yileqman send tuffɣa (pre-release) d yidfersefka n usali
(build metadata) i irennun d isiɣzaf i talɣa MAJOR.MINOR.PATCH.\nDeg umaḍal n usnefli n yiseɣẓanen, tella yiwet n tegnit ttkukrun-tt medden
ssawalen-as “times n teglin” (seg Teglizit “dependency hell”). Simal yettimɣur
unagraw-nwen, simal trennum iwemmusen i useɣẓan-nwen, simal yettaẓ-d wass deg
ur as-tettafem ara akk ixef-is deg wanu-a yesbelɛen asirem.\nDeg unagraw deg i caḍent teglin, asufeɣ n yileqman imaynuten n kra yisger yezmer
ad yuɣal awal sin am yir targit. Ma yella ilugan n tigelt bezzaf ḥersen, tzemrem
ad tesweḥlem ileqman-nwen (ur tettizmirem ara ad tleqmem isger war ma
tessufɣem-d ileqman imaynuten n yal isger uɣur yurez). Ma yella tiglin bezzaf
serrḥent, iban ad d-teɣlim deg uceṛṛeɛ n ulqem (aqbal s tmara n umɛabi d
yileqman i d-itteddun nnig wayen ilaqen). Ma ur ken-yeǧǧi ara usewḥel n
yileqman neɣ aceṛṛeɛ n yileqman ad tseddum asenfar-nwen ar zdat s tefses
d tɣellist, ad d-tafem iman-nwen deg “tmes n teglin”.\nAkken ad yefru wugur-a, summreɣ-d kra n yilugan d tmariwin ara awen-d-yinin amek
ara tesbeddem neɣ ad tesnernim uṭṭunen n yileqman. Ilugan-a bnan ― ɣas akken
mačči ala ɣef waya ― ɣef tsemras i nennum, yellan yakan ttwaseqdacent s waṭas
ama deg useɣẓan uslig ama deg win yeldin. Akken ad yeddu unagraw-a, ilaq ad
tesbeddem API tazayezt (agrudem n usihel n yesnasen). Aya yezmer ad yili s
usedles neɣ ad yettwaseyyef deg tengalt yakan. Akken yebɣu yili, API-a ilaq ad
tettwafham yerna ad temqet. Mi dayen tesbeddem-tt, ad tessawalem ɣef
ubeddel-is s usnerni n wuṭṭun-nwen n ulqem. Ma nesɛa alqem s talɣa X.Y.Z
(Major.Minor.Patch), iseɣtiyen ur nettbeddil ara API ad snernin alqem patch,
abeddel d usegmu n API yemɛaban d wayen yezrin ad snernin minor, abeddel n API
yemyagin d wayen yezrin ad yesnerni alqem major.\nSemmaɣ-as i unagraw-a “aleqqem anamkan”. S unagraw-a, uṭṭunen n ulqem d wamek s
i ttnernin ttaken anamek i tengalt uɣur cudden d wayen yettbeddilen seg ulqem
ar wayeḍ.\nAsefru n uleqqem anamkan (SemVer)\nAwalen yufraren “ILAQ” (MUST/SHALL), “UR ILAQ ARA” (MUST NOT/SHALL NOT),
“YETTUḤETTMEM” (REQUIRED), “YEWWI-D” (SHOULD), “UR D-YEWWI ARA” (SHOULD NOT),
“YELHA” (RECOMMENDED), “YEZMER” (MAY), “AXETRAN” (OPTIONAL) i d-yeddan deg
wezmam-a, yewwi-d ad ttwafehmen akken i ten-id-mlan deg
RFC 2119.\nAseɣẓan yesseqdacen aleqqem anamkan ILAQ ad yesbedd API tazayezt. API-a
tezmer ad tili deg tengalt yakan neɣ ad d-tettwasefhem akken iwata deg
yiseftar. Akken tebɣu tili, ILAQ ad tettwafham yerna ad temqet.\nAseɣẓan yesseqdacen aleqqem anamkan ILAQ ad yesbedd API tazayezt. API-a
tezmer ad tili deg tengalt yakan neɣ ad d-tettwasefhem akken iwata deg
yiseftar. Akken tebɣu tili, ILAQ ad tettwafham yerna ad temqet.\nUṭṭun amagnu n ulqem ILAQ ad yili s talɣa X.Y.Z anda X, Y d Z d ummiden ur
nelli d uzdiren, UR ILAQ ARA ad gebren ilmawen ur nesɛi anamek. X d alqem
ameqran (major), Y d alqem ameẓyan (minor), ma d Z d alqem n useɣti (patch). Yal
aferdis ILAQ ad yettnerni s wudem umḍin. Amedya: 1.9.0 -> 1.10.0 -> 1.11.0.\nUṭṭun amagnu n ulqem ILAQ ad yili s talɣa X.Y.Z anda X, Y d Z d ummiden ur
nelli d uzdiren, UR ILAQ ARA ad gebren ilmawen ur nesɛi anamek. X d alqem
ameqran (major), Y d alqem ameẓyan (minor), ma d Z d alqem n useɣti (patch). Yal
aferdis ILAQ ad yettnerni s wudem umḍin. Amedya: 1.9.0 -> 1.10.0 -> 1.11.0.\nMa dayen yeffeɣ-d yisger s kra ulqem, ayen yellan deg ulqem-a UR ILAQ ARA ad
ibeddel. Ma yella-d kra ubeddel, ILAQ ad d-yeffeɣ deg ulqem amaynut.\nMa dayen yeffeɣ-d yisger s kra ulqem, ayen yellan deg ulqem-a UR ILAQ ARA ad
ibeddel. Ma yella-d kra ubeddel, ILAQ ad d-yeffeɣ deg ulqem amaynut.\nIlem deg ulqem ameqran (0.y.z) yemmug i usnefli amezwaru. Kullec YEZMER ad
ibeddel seg teswiɛt ar tayeḍ. API tazayezt UR D-YEWWI ARA ad tettwaḥsab terked.\nIlem deg ulqem ameqran (0.y.z) yemmug i usnefli amezwaru. Kullec YEZMER ad
ibeddel seg teswiɛt ar tayeḍ. API tazayezt UR D-YEWWI ARA ad tettwaḥsab terked.\nD alqem 1.0.0 i yesbeddayen API tazayezt. Abrid ara yaɣ usnerni n wuṭṭun n
ulqem segmi ara d-yeffeɣ, yeqqen ɣer API-nni tazayezt d wamek i tettbeddil.\nD alqem 1.0.0 i yesbeddayen API tazayezt. Abrid ara yaɣ usnerni n wuṭṭun n
ulqem segmi ara d-yeffeɣ, yeqqen ɣer API-nni tazayezt d wamek i tettbeddil.\nAlqem n useɣti Z (x.y.Z | x > 0) ILAQ ad yennerni ma yella d iseɣtiyen kan
yemɛaban d wayen yezrin i d-ikecmen. Aseɣti n ubug d abeddel agensas i
yettseggimen tikli yeccḍen.\nAlqem n useɣti Z (x.y.Z | x > 0) ILAQ ad yennerni ma yella d iseɣtiyen kan
yemɛaban d wayen yezrin i d-ikecmen. Aseɣti n ubug d abeddel agensas i
yettseggimen tikli yeccḍen.\nAlqem ameẓyan Y (x.Y.z | x > 0) ILAQ ad yennerni ma yella tekcem-d tmahilt
tamaynut yemɛaban d wayen yezrin ɣer API tazayezt. ILAQ daɣen ad yennerni ma
yella kra n tmahilt n API tazayezt tettwacreḍ d tin ara yettwakksen. YEZMER ad
yennerni ma tekcem-d tmahilt tamynut neɣ aseggem meqqren i yerzan tanglat
tusligt kan. YEZMER ad d-yeglu s ubeddel deg uswir n useɣti. Mi ara yennerni
ulqem ameẓyan, alqem n useɣti ILAQ ad yuɣal ar 0.\nAlqem ameẓyan Y (x.Y.z | x > 0) ILAQ ad yennerni ma yella tekcem-d tmahilt
tamaynut yemɛaban d wayen yezrin ɣer API tazayezt. ILAQ daɣen ad yennerni ma
yella kra n tmahilt n API tazayezt tettwacreḍ d tin ara yettwakksen. YEZMER ad
yennerni ma tekcem-d tmahilt tamynut neɣ aseggem meqqren i yerzan tanglat
tusligt kan. YEZMER ad d-yeglu s ubeddel deg uswir n useɣti. Mi ara yennerni
ulqem ameẓyan, alqem n useɣti ILAQ ad yuɣal ar 0.\nAlqem ameqran X (X.y.z | X > 0) ILAQ ad yennerni ma nessekcem kra ubeddel
yemyagin d wayen yezrin ar API tazayezt. YEZMER daɣen ad d-yeglu s ubeddel deg
uswir ameẓyan neɣ n useɣti. Alqem n useɣti d ulqem ameẓyan ILAQ ad uɣalen ar 0
mi ara yennerni ulqem ameqran.\nAlqem ameqran X (X.y.z | X > 0) ILAQ ad yennerni ma nessekcem kra ubeddel
yemyagin d wayen yezrin ar API tazayezt. YEZMER daɣen ad d-yeglu s ubeddel deg
uswir ameẓyan neɣ n useɣti. Alqem n useɣti d ulqem ameẓyan ILAQ ad uɣalen ar 0
mi ara yennerni ulqem ameqran.\nAlqem send tuffɣa YEZMER ad d-iban s tmerna n ujerrid d umazrar n yiferdisen
yebḍan s tenqiḍt deffir kan ulqem n useɣti. Iferdisen-a UR ILAQ ad gebren ala
isekkilen igmumḍinen ASCII d ujerrid [0-9A-Za-z-]. Iferdisen-a UR ILAQ ARA ad
ilin d ilmawen. Iferdisen umḍinen UR ILAQ ARA ad gebren ilmawen ur nesɛi anamek.
Alqem send tuffɣa yettas-d ddaw ulqem amagnu i icudden ɣur-s. Alqem send tuffɣa
d alqem ur nerkid ara yerna yezmer ur yettqadar ara tiwtilin n umɛabi i yeɛnan
alqem amagnu i icudden ɣur-s. Imedyaten: 1.0.0-alpha, 1.0.0-alpha.1,
1.0.0-0.3.7, 1.0.0-x.7.z.92.\nAlqem send tuffɣa YEZMER ad d-iban s tmerna n ujerrid d umazrar n yiferdisen
yebḍan s tenqiḍt deffir kan ulqem n useɣti. Iferdisen-a UR ILAQ ad gebren ala
isekkilen igmumḍinen ASCII d ujerrid [0-9A-Za-z-]. Iferdisen-a UR ILAQ ARA ad
ilin d ilmawen. Iferdisen umḍinen UR ILAQ ARA ad gebren ilmawen ur nesɛi anamek.
Alqem send tuffɣa yettas-d ddaw ulqem amagnu i icudden ɣur-s. Alqem send tuffɣa
d alqem ur nerkid ara yerna yezmer ur yettqadar ara tiwtilin n umɛabi i yeɛnan
alqem amagnu i icudden ɣur-s. Imedyaten: 1.0.0-alpha, 1.0.0-alpha.1,
1.0.0-0.3.7, 1.0.0-x.7.z.92.\nIdfersefka n usali ZEMREN ad d-binen s tmerna n uzmul “+” d umazrar n
yiferdisen yebḍan s tenqiḍt, deffir kan ulqem n useɣti neɣ n ulqem send
tuffɣa. Iferdisen-a UR ILAQ ad gebren ala isekkilen igmumḍinen ASCII d ujerrid
[0-9A-Za-z-]. Iferdisen-a UR ILAQ ARA ad ilin d ilmawen. Idfersefka n usali
ILAQ ad ttwazeglen deg umyizwer n yileqman. Ɣef waya, ma llan sin n yileqman
mgaraden kan deg yidfersefka n usali, atenan kifkif-iten deg umyizwer.
Imedyaten:  1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nIdfersefka n usali ZEMREN ad d-binen s tmerna n uzmul “+” d umazrar n
yiferdisen yebḍan s tenqiḍt, deffir kan ulqem n useɣti neɣ n ulqem send
tuffɣa. Iferdisen-a UR ILAQ ad gebren ala isekkilen igmumḍinen ASCII d ujerrid
[0-9A-Za-z-]. Iferdisen-a UR ILAQ ARA ad ilin d ilmawen. Idfersefka n usali
ILAQ ad ttwazeglen deg umyizwer n yileqman. Ɣef waya, ma llan sin n yileqman
mgaraden kan deg yidfersefka n usali, atenan kifkif-iten deg umyizwer.
Imedyaten:  1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nAmyizwer ger yileqman yemmal-d amek ara ttwasettfen wa deffir wa. Amyizwer
ILAQ ad yettwaḥsab s beṭṭu n ulqem aferdis aferdis: ameqran, ameẓyan, n useɣti
d send tuffɣa s umyizwer-a (idfersefka ur ttekkin ara deg umyizwer). Amyizwer
yettili-d akken kan ara d-naf amgirred amenzu mi ara nesmenyif ger yiferdisen-a
yiwen yiwen seg uzelmaḍ ar uyeffus akka: alqem ameqran, alqem ameẓyan d ulqem
n useɣti nesmenyif-iten dima s wudem umḍin. Amedya: 1.0.0 < 2.0.0 < 2.1.0 <
2.1.1. Mi ara yilin yiferdisen imeqranen d yimeẓyanen d wid n useɣti d imegduya,
alqem send tuffɣa ad d-yezg ddaw ulqem amagnu. Amedya: 1.0.0-alpha < 1.0.0.
Amyizwer ger sin n yileqman send tuffɣa i iɛedlen aferdis ameqran d umeẓyan
d win n useɣti ILAQ ad yili s usmenyif n yal aferdis iḥazen s tenqiḍt seg
uzelmaḍ ar uyeffus alamma nufa-d amgirred akka: asmenyif n yiferdisen igebren
ala uṭṭunen ad d-yili s wudem umḍin, ma d asmenyif n yiferdisen yesɛan
isekkilen d yijerriden ad yili s umyizwer ASCII deg ugemmay. Alqem send tuffɣa
i umi ggten yiferdisen ad d-yezg ddaw n win yesɛan ciṭṭuḥ, ma ɛedlen akk
iferdisen-nni yezwaren. Amedya: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta
< 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nAmyizwer ger yileqman yemmal-d amek ara ttwasettfen wa deffir wa. Amyizwer
ILAQ ad yettwaḥsab s beṭṭu n ulqem aferdis aferdis: ameqran, ameẓyan, n useɣti
d send tuffɣa s umyizwer-a (idfersefka ur ttekkin ara deg umyizwer). Amyizwer
yettili-d akken kan ara d-naf amgirred amenzu mi ara nesmenyif ger yiferdisen-a
yiwen yiwen seg uzelmaḍ ar uyeffus akka: alqem ameqran, alqem ameẓyan d ulqem
n useɣti nesmenyif-iten dima s wudem umḍin. Amedya: 1.0.0 < 2.0.0 < 2.1.0 <
2.1.1. Mi ara yilin yiferdisen imeqranen d yimeẓyanen d wid n useɣti d imegduya,
alqem send tuffɣa ad d-yezg ddaw ulqem amagnu. Amedya: 1.0.0-alpha < 1.0.0.
Amyizwer ger sin n yileqman send tuffɣa i iɛedlen aferdis ameqran d umeẓyan
d win n useɣti ILAQ ad yili s usmenyif n yal aferdis iḥazen s tenqiḍt seg
uzelmaḍ ar uyeffus alamma nufa-d amgirred akka: asmenyif n yiferdisen igebren
ala uṭṭunen ad d-yili s wudem umḍin, ma d asmenyif n yiferdisen yesɛan
isekkilen d yijerriden ad yili s umyizwer ASCII deg ugemmay. Alqem send tuffɣa
i umi ggten yiferdisen ad d-yezg ddaw n win yesɛan ciṭṭuḥ, ma ɛedlen akk
iferdisen-nni yezwaren. Amedya: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta
< 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nIwacu ad nseqdec aleqqem anamkan?\nAya mačči d takti tamaynut neɣ d tin ara ibeddlen tudert. Tidet kan, yezmer
txeddmem yakan ayen iqerben ar waya. Ugur d wa: “iqreben” ur icaḍ ara. War
amtawi d kra n ulugen unṣib, ad uɣalen wuṭṭunen n yileqman ur nfiɛen ara i
usefrek n teglin. S usbeddi n yisem d unamek ibanen i tikta i d-nefka da, ad
yishil ad tesfehmem ayen i tgemnem i widak yesseqdacen aseɣẓan-nwen. Mi ara ibin
wayen tgemnem, tzemrem ad d-txedmem aslugen iserḥen (d acu mačči bezzaf)
n tiglin.\nAtan umedya ameẓyan ara d-iseknen amek ara yerr uleqqem anamkan “times n teglin”
d tamsalt yefran. Ad d-nini nesɛa tamkarḍit isem-is “AkamyunUsexsi”. Tettuḥwaǧ
isger iteddun s uleqqem anamkan semman-as “Tasellumt”. Ass deg i d-yennulfa
AkamyunUsexsi, Tasellumt tella deg ulqem 3.1.0. Ma yesseqdac AkamyunUsexsi kra
n tmahilt i d-ikecmmen deg 3.1.0, tzemrem ad d-tinim war aɣbel belli alqem
n tagelt Tasellumt ilaq ad yili nnig n 3.1.0 maca ddaw n 4.0.0. Imir, asmi
ara d-ffɣen yileqman 3.1.1 d 3.2.0 n Tasellumt, tzemrem ad ten-ternum ar
unagraw-nwen n usefrek n yisegran yerna teẓram ad mɛaban d useɣẓan-nni i
ten-yuḥwaǧen.\nWin yellan d aneflay amasay, iban ad yebɣu ad isefqed kra ubeddel i d-yellan
deg yisger ma itteddu akken iwata. Deg tilawt, timsal mačči d iger iberzen;
ulac ayen i nezmer ad nexdem mgal aya nnig uḥader. Ayen i tzemrem ad txedmem,
d aseqdec n uleqqem anamkan ara awen-d-yefken abrid yelhan i usufeɣ d uleqqem
n yisegran war ma tcelɛem-d deg usufeɣ n teglin, s wakka ad d-trebḥem akud
yerna ad tekksem aɣbel.\nMa yella yeffeɣ fell-awen akk waya, tuḥwaǧem kan ad d-tinim belli tseqdacem-t
yerna ad tḍefrem ilugan akken ad tebdum aseqdec n uleqqem anamkan. Rnut aseɣwen
ar usmel-a deg README-nwen akken ad walin wiyaḍ ilugan yerna ad d-sfaydin
seg-sen.\nAmek i ilaq ad sferkeɣ abeddel deg uḥric amenzu n usnefli 0.y.z?\nAbrid isehlen akk d beddu n usnefli amenzu seg ulqem 0.1.0, syin akkin ad
tesnernayem alqem ameẓyan i yal asufeɣ amaynut.\nAmek ara nẓer melmi ara d-nessufeɣ alqem 1.0.0?\nMa yella useɣẓan-nwen yettwaseqdec deg ufares, ahat yewwi-d ad yili s ulqem
1.0.0. Ma yella tesɛam API irekden uɣur bdan ttwarzen iseqdacen, ilaq ad tilim
s ulqem 1.0.0. Ma tebdam tcelɛem-d deg umɛabi d wayen yezrin, ilaq ad tilim
yakan deg ulqem 1.0.0.\nWissen aya ma ur yettekkes ara afud i usnefli arurad d wallusen wezzilen?\nAlqem ameqran ilem (0) yemmug i usnefli arurad. Ma tettbeddilem API yal ass,
ilaq ad teqqimem deg ulqem 0.y.z neɣ deg ufurek iḥazen i usnefli ad tqeddcem
ɣef ulqem ameqran i d-iteddun.\nMa kra n ubeddel meẓẓiyen yemyagin d wayen yezrin deg API tazayezt yuḥwaǧ anserni n ulqem, ur nettaweḍ ara awal sin ar ulqem 42.0.0?\nAya d tamsalt n usnefli s tmasit d uwali ar zdat. Abeddel ara yerẓen amɛabi ur
ilaq ara ad d-yekcem kan akka ar useɣẓan uɣur teqqen aṭas n tengalt. Asali ar
ulqem amaynut yezmer ad d-yekker ɣlay. Ma tesnernam alqem ameqran akken ad
d-tessufɣem abeddel ur nemɛaba ara, aql-iken tettmeyyizem ɣef wayen ara d-yeglu
ubeddel-nwen, yerna tettakem azal i wassaɣ yellan ger tseglut d wayen i d-tesqam.\nAsefter n API tazayezt akken ma tella d axeddim meqqren mliḥ!\nYewwi-d fell-awen s yisem-nwen d ineflayen imsaduren ad tesdelsem aseɣẓan-nwen
yemmugen akken ad tesqedcen wiyaḍ. Asefrek n umcubbak n useɣẓan d ayen yesɛan
azal meqqren akken ad yeqqim usenfar ifaz. Yuɛer ad naweḍ ar waya ma yella yiwen
ur yeẓri amek ara iseqdec aseɣẓan, neɣ anti tarrayin i umi yezmer ad isiwel.
Syin akkin, aleqqem anamkan d usbeddi igerrzen n API tazayezt ad ǧǧen yal yiwen
ad yeddu ɣer zdat war uguren.\nDacu i ilaq ad nexedem ma yella nessufeɣ-d s tuccḍa abeddel ur nemɛaba ara d wayen yezrin deg ulqem ameẓyan?\nAkken kan ara d-takim belli terẓam asefru n uleqqem anamkan, ilaq ad tesseɣtim
ugur yerna ad d-tessufɣem alqem ameẓyan amaynut ara d-yerren amɛabi d wayen
yezrin. Ula deg tegnit am ta, ur ilaq ara ad tbeddlem ileqman i d-yeffɣen. Ma
twalam ilaq, sdelset alqem-nni yeccḍen, tesɛelmem iseqdacen-nwen s wugur-a i
d-yellan.\nDacu i ilaq ad nexdem mi ara nelqem tiglin-nneɣ war ma nbeddel API tazayezt?\nAya yezmer ad yettusemma d abddel yemɛaban imi ur yettnal ara API tazayezt.
Iseɣẓanen yurzen ɣer teglin yecban tid n uwemmus-nwen ahat ad sɛun asefru-nsen
n teglin, ihi amsekar-nsent ad ifiq ma yella kra n wugur. Akken ad teẓrem ma
ad yili ubeddel deg uswir n useɣti neɣ deg uswir ameẓyan, ilaq ad twalim ma
tessulim tiglin-nwen akken ad tesseɣtim abug neɣ akken ad d-teskecmem tamahilt
tamynut. Tezga tettili-d tmerna n tengalt deg tegnit-nni tis snat, d ayen i
yuḥwaǧen bla ccekk asnerni n ulqem ameẓyan.\nAmek ara nexdem ma nbeddel s tuccḍa API tazayezt s wudem ur nemɛaba ara d ubeddel n wuṭṭun n ulqem (md. tessekcem-d tengalt abeddel meqqren yerẓan amɛabi deg ulqem n useɣti)?\nD kunwi i yeẓran. Ma llan aṭas i ken-yeṭṭafaren, ara tḥazem mliḥ s tuɣalin ar
deffir ma terram API tazayezt akken tella, ahat yif-it ma tessufɣem-d alqem
ameqran, ɣas akken abeddel-nwen icaḍ-as uleqqem n useɣti. Ur tettut ara belli
aleqqem anamkan yemmug akken ad yefk anamek i usnerni n wuṭṭunen n yileqman.
Ma yella ubeddel i d-yellan yesɛa azal meqqren i yiseqdacen-nwen, sbinet-asen
-t-id s wuṭṭun n ulqem.\nAmek ara nsefrek acraḍ n tukksa n tmahilin?\nAcraḍ n tmahilin send ad ttwakksent d tigawt yuzzlen deg usnefli n useɣẓan yerna
d ayen i as-ilaqen tikwal akken ad yaẓ ɣer zdat. Mi ara tcerḍeḍ aḥric deg
API-nwen tazayezt ad yettwakkes, ɣur-wen snat n tɣawsiwin ad tent-txedmem: (1)
ad tleqmem iseftar-nwen akken ad ẓren iseqdacen-nwen, (2) ad d-tessufɣem alqem
ameẓyan amaynut deg ara d-tseddum acraḍ n tukksa. Send ad tekksem akk kra
tamahilt deg ulqem ameqran amaynut, ilaq ad d-tessufɣem ma drus yiwen ulqem
ameẓyan i d-immalen tukksa-a akken iseqdacen ad ɛeddin dac dac ɣer API tamaynut.\nYesɛa uleqqem anamkan kra n tilist ɣef teɣzi n wuṭṭun n ulqem?\nAla, dacu meyyez akken i iwata. Ahat uṭṭun n ulqem n 255 n yisekkilen (d amedya
kan) bezzaf ɣezzif. Yerna, kra n yinagrawen ttseyyifen tilisa ɣef teɣzi n uzrar
n wuṭṭun n ulqem.\n“v1.2.3” d alqem anamkan?\nAla, “v1.2.3” mačči d alqem anamkan. Maca, timerna n “v” (seg Teglizit) deg
tazwara n ulqem anamkan akken ad d-ibin belli d uṭṭun n ulqem, d ayen yuzzlen
s waṭas. Nettmagar-d aṭas asemẓi n “version” s “v” deg usefrek n yileqman.
Amedya: git tag v1.2.3 -m "Asufeɣ n ulqem 1.2.3", anda “v1.2.3” d isem
n tecreḍt, ma yella d alqem anamkan d “1.2.3”.\nTella kra n tenfalit talugant (RegEx) i usentem n uzrar n ulqem anamkan?\nLlant snat. Yiwet s yigrawen yettusemman tetteddu deg yinagrawen i asen-izemren
(PCRE [Perl Compatible Regular Expressions, am Perl, PHP d R], Python akked Go).\nWali: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nTella tayeḍ s yigrawen n tuṭṭfiwin s wuṭṭunen (agraw1 = major, agraw2 = minor,
agraw3 = patch, agraw4 = prerelease ma d agraw5 = buildmetadata) temɛaba d ECMA
Script (JavaScript), PCRE (Perl Compatible Regular Expressions, am Perl, PHP
d R), Python akked Go.\nWali: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nAsefru n uleqqem anamkan yura-t Tom Preston-Werner,
win i d-yesnulfan Gravatar yerna yettekki deg usufeɣ n GitHub.\nMa tebɣam ad d-teǧǧem iwenniten, ldit atiki deg GitHub
ma ulac aɣilif.\nldit atiki deg GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\n유의적 버전 2.0.0-ko2

요약

버전을 주.부.수 숫자로 하고:


  기존 버전과 호환되지 않게 API가 바뀌면 “주(主) 버전”을 올리고,
  기존 버전과 호환되면서 새로운 기능을 추가할 때는 “부(部) 버전”을 올리고,
  기존 버전과 호환되면서 버그를 수정한 것이라면 “수(修) 버전”을 올린다.


주.부.수 형식에 정식배포 전 버전이나 빌드 메타데이터를 위한 라벨을 덧붙이는 방법도 있다.

머리말

소프트웨어 관리의 세계에는 “의존성 지옥”이라 불리는 성가신 문제가 있다. 시스템 규모가 커질수록, 그리고 더 많은 패키지를 가져다 쓸수록, 언젠가, 이 절망의 늪에 빠진 자신을 발견하기 쉽다.

의존성이 높은 시스템에서는, 새 패키지 버전을 배포하는 일이 금방 끔찍해지곤 한다. 의존성 명세를 너무 엄격하게 관리하면, 버전에 갇히게 될 위험이 있다(의존하는 모든 패키지의 새 버전을 배포하지 않고는 업그레이드할 수 없게 된다). 의존성을 너무 느슨하게 관리하면, 버전이 엉켜서 괴롭게 될 것이다(지나치게 나중 버전까지 호환될 거라 가정한 경우). 버전에 갇히거나 엉켜서 쉽고 안전하게 프로젝트를 계속 진행할 수 없다면 의존성 지옥에 빠진 것이다.

이 문제의 해결책으로, 버전 번호를 어떻게 정하고 올려야 하는지를 명시하는 규칙과 요구사항을 제안한다. 이 규칙들은 기존 오픈 소스/비공개 소스 소프트웨어에 널리 활용되는 규칙을 바탕으로 했으나, 반드시 따르고자 제약을 받지는 않았다. 이 시스템이 동작하려면, 먼저 공개(public) API를 선언해야 한다. 문서와 소스 코드 자체로 드러낼 수 있다. 어떤 방식이든 API가 명확해야 한다. 한번 공개 API를 정의하고 나면, 버전 번호를 올리는 방식을 통해 API가 어떻게 바뀌는지 표현한다. 버전을 X.Y.Z (주.부.수) 형식으로 정한다. API에 영향이 없는 버그 수정은 수(修)버전을 올리고, API가 호환되면서 바꾸거나 추가하는 경우에는 부(部)버전을 올리고, API가 호환되지 않는 변경이라면 주(主)버전을 올린다.

이 체계를 “유의적 버전”이라고 부르고자 한다. 이 체계를 따르면, 버전 번호와 그 번호를 바꾸는 방법을 통해 특정 버전에서 다음 버전으로 넘어가면서 코드가 어떻게 바뀌는지를 드러낸다.

유의적 버전 명세 (SemVer)

이하 “반드시(MUST, REQUIRED, SHALL) ~한다”, “절대 ~해서는 안 된다(MUST NOT, SHALL NOT)”, “될 수 있으면(SHOULD, RECOMMENDED) ~한다”, “~하지 않는 게 좋다(SHOULD NOT)”, “할 수 있다(MAY, OPTIONAL)”의 표현은 RFC 2119에 기술한 대로 해석한다.


  
    유의적 버전을 쓰는 소프트웨어는 반드시 공개 API를 선언한다. 이 API는 코드 자체로 선언하거나 문서로 엄격히 명시해야 한다. 어떤 방식으로든, 정확하고 이해하기 쉬워야 한다.
  
  
    보통 버전 번호는 반드시 X.Y.Z의 형태로 하고, X, Y, Z는 각각 자연수(음이 아닌 정수)이고, 절대로 0이 앞에 붙어서는 안 된다. X는 주(主)버전 번호이고, Y는 부(部)버전 번호이며, Z는 수(修)버전 번호이다. 각각은 반드시 증가하는 수여야 한다. 예: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    특정 버전으로 패키지를 배포하고 나면, 그 버전의 내용은 절대 변경하지 말아야 한다. 변경분이 있다면 반드시 새로운 버전으로 배포하도록 한다.
  
  
    주버전 0(0.y.z)은 초기 개발을 위해서 쓴다. 아무 때나 마음대로 바꿀 수 있다. 이 공개 API는 안정판으로 보지 않는 게 좋다.
  
  
    1.0.0 버전은 공개 API를 정의한다. 이후의 버전 번호는 이때 배포한 공개 API에서 어떻게 바뀌는지에 따라 올린다.
  
  
    수버전 Z (x.y.Z | x > 0)는 반드시 그전 버전 API와 호환되는 버그 수정의 경우에만 올린다. 버그 수정은 잘못된 내부 기능을 고치는 것이라 정의한다.
  
  
    공개 API에 기존과 호환되는 새로운 기능을 추가할 때는 반드시 부버전 Y(x.Y.z | x > 0)를 올린다. 공개 API의 일부를 앞으로 제거할 것(deprecate)으로 표시한 경우에도 반드시 올리도록 한다. 내부 비공개 코드에 새로운 기능이 대폭 추가되거나 개선사항이 있을 때도 올릴 수 있다. 부버전을 올릴 때 수버전을 올릴 때만큼의 변화를 포함할 수도 있다. 부버전이 올라가면 수버전은 반드시 0에서 다시 시작한다.
  
  
    공개 API에 기존과 호환되지 않는 변화가 있을 때는 반드시 주버전 X(X.y.z | X > 0)를 올린다. 부버전이나 수버전급 변화를 포함할 수 있다. 주버전 번호를 올릴 때는 반드시 부버전과 수버전을 0으로 초기화 한다.
  
  
    수버전 바로 뒤에 붙임표(-)를 붙이고 마침표(.)로 구분된 식별자를 더해서 정식 배포를 앞둔 (pre-release) 버전을 표기할 수 있다. 식별자는 반드시 아스키(ASCII) 문자, 숫자, 붙임표로만 구성한다[0-9A-Za-z-]. 식별자는 반드시 한 글자 이상으로 한다. 숫자 식별자의 경우 절대 앞에 0을 붙인 숫자로 표기하지 않는다. 정식배포 전 버전은 관련한 보통 버전보다 우선순위가 낮다. 정식배포 전 버전은 아직 불안정하며 연관된 일반 버전에 대해 호환성 요구사항이 충족되지 않을 수도 있다. 예: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    빌드 메타데이터는 수버전이나 정식배포 전 식별자 뒤에 더하기(+) 기호를 붙인 뒤에 마침표로 구분된 식별자를 덧붙여서 표현할 수 있다. 식별자는 반드시 아스키 문자와 숫자와 붙임표로만 구성한다 [0-9A-Za-z-]. 식별자는 반드시 한 글자 이상으로 한다. 빌드 메타데이터는 버전 간의 우선순위를 판단하고자 할 때 반드시 무시해야 한다. 그러므로, 빌드 메타데이터만 다른 두 버전의 우선순위는 같다. 예: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    우선순위는 버전의 순서를 정렬할 때 서로를 어떻게 비교할지를 나타낸다. 우선순위는 반드시 주, 부, 수 버전, 그리고 정식배포 전 버전의 식별자를 나누어 계산하도록 한다 (빌드 메타데이터는 우선순위에 영향을 주지 않는다). 우선순위는 다음의 순서로 차례로 비교하면서, 차이가 나는 부분이 나타나면 결정된다: 주, 부, 수는 숫자로 비교한다. 예: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. 주, 부, 수버전이 같을 경우, 정식배포 전 버전이 표기된 경우의 우선순위가 더 낮다. 예: 1.0.0-alpha < 1.0.0. 주, 부, 수버전이 같은 두 배포 전 버전 간의 우선순위는 반드시 마침표로 구분된 식별자를 각각 차례로 비교하면서 차이점을 찾는다: 숫자로만 구성된 식별자는 수의 크기로 비교하고 알파벳이나 붙임표가 포함된 경우에는 아스키 문자열 정렬을 하도록 한다. 숫자로만 구성된 식별자는 어떤 경우에도 문자와 붙임표가 있는 식별자보다 낮은 우선순위로 여긴다. 앞선 식별자가 모두 같은 배포 전 버전의 경우에는 필드 수가 많은 쪽이 더 높은 우선순위를 가진다. 예: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


유효한 유의적 버전의 BNF(Backus-Naur Form) 문법
<유의적 버전> ::= <버전 몸통>
             | <버전 몸통> "-" <배포 전 버전>
             | <버전 몸통> "+" <빌드>
             | <버전 몸통> "-" <배포 전 버전> "+" <빌드>

<버전 몸통> ::= <주> "." <부> "." <수>

<주> ::= <숫자 식별자>

<부> ::= <숫자 식별자>

<수> ::= <숫자 식별자>

<배포 전 버전> ::= <마침표로 구분된 배포 전 식별자들>

<마침표로 구분된 배포 전 식별자들> ::= <배포 전 식별자>
                              | <배포 전 식별자> "." <마침표로 구분된 배포 전 식별자들>

<빌드> ::= <마침표로 구분된 빌드 식별자들>

<마침표로 구분된 빌드 식별자들> ::= <빌드 식별자>
                            | <빌드 식별자> "." <마침표로 구분된 빌드 식별자들>

<배포 전 식별자> ::= <숫자와 알파벳으로 구성된 식별자>
                | <숫자 식별자>

<빌드 식별자> ::= <숫자와 알파벳으로 구성된 식별자>
             | <숫자들>

<숫자와 알파벳으로 구성된 식별자> ::= <숫자 아닌 것>
                             | <숫자 아닌 것> <식별자 문자들>
                             | <식별자 문자들> <숫자 아닌 것>
                             | <식별자 문자들> <숫자 아닌 것> <식별자 문자들>

<숫자 식별자> ::= "0"
             | <양의 숫자>
             | <양의 숫자> <숫자들>

<식별자 문자들> ::= <식별자 문자>
               | <식별자 문자> <식별자 문자들>

<식별자 문자> ::= <숫자>
             | <숫자 아닌 것>

<숫자 아닌 것> ::= <문자>
              | "-"

<숫자들> ::= <숫자>
         | <숫자> <숫자들>

<숫자> ::= "0"
        | <양의 숫자>

<양의 숫자> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<문자> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
        | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
        | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
        | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
        | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
        | "y" | "z"


유의적 버전을 써야 하는 이유

유의적 버전은 혁신적인 아이디어가 아니다. 사실, 이미 이와 비슷한 방식으로 버전을 정해서 쓰고 있었을 수 있다. 문제는 이와 “비슷한” 방식으로는 충분치 않다는 점이다. 어떠한 형태로 정식 명세를 정해서 따르지 않는다면, 버전 번호는 의존성 관리에서 무의미하다. 이상의 아이디어에 이름을 정하고 명시적인 정의를 내림으로써, 소프트웨어 사용자에게 제작자의 의도를 전달하기 쉬워진다. 의도가 명확해야만, (너무 지나치지는 않은) 융통성 있는 의존성 명세를 만들 수 있다.

유의적 버전으로 어떻게 의존성 지옥을 벗어날 수 있는지 간단한 예를 들어보자. “Firetruck”이라는 라이브러리가 있다고 하자. 이 라이브러리는 유의적 버전이 붙은 “Ladder”라는 패키지에 의존한다. Firetruck을 만들었을 때, Ladder는 버전 3.1.0이었다. Firetruck이 3.1.0에 처음으로 추가된 기능을 사용했기 때문에, Ladder의 의존성을 3.1.0 이상, 4.0.0 미만으로 지정할 수 있다. 이제, Ladder의 3.1.1 버전과 3.2.0 버전이 공개된다면, 패키지 관리 시스템에 그 버전을 넣을 수 있고 기존 소프트웨어와 호환될 것이라고 알 수 있다.

물론, 책임감 있는 개발자로서 패키지가 업그레이드된 부분이 홍보된 대로 잘 동작하는지 검증하고자 할 것이다. 실상은 지저분하다; 조심해서 관리하는 것 외에는 달리 도리가 없다. 유의적 버전을 사용함으로써 의존하는 패키지들의 새 버전들과 씨름하지 않고, 시간 낭비와 소란 없이 패키지를 공개하고 업그레이드할 수 있다.

만약 이상의 내용이 그럴싸하다면, 유의적 버전을 쓰기 시작하기 위해서 할 일은, 그렇게 하고자 마음먹고 규칙을 따르기만 하면 된다. 여러분의 README 파일에 이 웹사이트의 링크를 추가해서 다른 사람들도 유용하게 쓸 수 있게 하자.

FAQ

초기 개발 단계에 0.y.z 버전 관리는 어떻게 할까?

가장 간단한 방법은 최초 개발 배포를 0.1.0으로 하고, 이후 배포마다 부버전을 올리는 것이다.

언제 1.0.0을 배포해야 할지 어떻게 알 수 있나?

소프트웨어가 실 서비스에 쓰이기 시작했다면 이미 1.0.0이라고 여길 수 있다. 사용자들이 믿고 쓸 수 있는 안정한 API가 있다면 1.0.0일 것이다. 하위 버전 호환성에 대해 우려하기 시작했다면 이미 1.0.0일 수 있다.

유의적 버전 짓기가 신속한 개발과 빠른 이터레이션에 방해가 되지는 않을까?

주버전 0이 신속한 개발을 위한 것이다. 만약 API를 매일같이 바꾸고 있다면 0.y.z 버전을 쓰거나 별도의 다음번 주버전 배포를 앞둔 개발 브랜치를 써야 한다.

공개 API의 아주 사소한 부분이 하위호환이 되지 않는다고 주버전을 매번 올려야 한다면, 어느새 버전 42.0.0이 되어버리지는 않나?

책임감 있고 선견지명이 있는 질문이다. 의존하는 코드가 많은 소프트웨어에, 호환되지 않는 변화를 가볍게 도입해서는 안 된다. 관련해서 업그레이드하는 데 필요한 비용이 어마어마해질 수 있다. 호환되지 않는 변경분을 배포하기 위해 주버전을 올리려면, 바뀌는 부분에 인한 여파와 그 비용과 혜택을 충분히 평가해야 한다.

공개 API 전체를 문서로 만드는 것은 일이 너무 많다!

프로 개발자로서 다른 사람들이 쓰게 하려고 만든 소프트웨어를 적절히 문서로 만드는 것은 책임이다. 프로젝트를 효율적으로 유지하기 위해 소프트웨어의 복잡성을 관리하는 일은 매우 중요한 일이고, 남이 소프트웨어를 어떻게 쓰는지 모르거나 어떤 메소드들을 안전하게 호출할 수 있는 건지 모른다면 어려울 것이다. 장기적으로 볼 때, 유의적 버전과 잘 정의한 공개 API는 관련된 모든 사람과 모든 것이 순조롭게 지낼 수 있게 한다.

부버전을 올리는데 실수로 호환되지 않는 변경이 들어갔다면 어떻게 해야 하나?

유의적 버전 명세를 어겼다는 사실을 알게 되면, 즉시 문제를 해결하고 호환성이 깨진 부분을 복구해서 새 부버전을 배포한다. 이 경우라도 이미 배포된 버전을 변경해서는 안 된다. 필요한 경우라면 문제가 되는 버전을 문서로 표시해서 사용자들로 하여금 주의하도록 한다.

공개 API는 유지한 채 내부의 의존성을 바꾼다면 어떻게 할까?

공개 API에 영향을 주지 않으므로 호환된다고 여긴다. 당신의 패키지와 똑같은 의존성을 명시한 소프트웨어는 별도로 의존성 명세가 있어야 하고 작성자는 충돌을 눈치챌 것이다. 변화가 수버전 수준인지 부버전 수준인지 결정하는 것은 버그를 수정하고자 한 작업인지, 새로운 기능을 추가하기 위해서인지에 달려있다. 후자의 경우, 추가적인 코드를 예상할 것이며, 그렇다면 당연히 부버전을 증가해야 할 것이다.

실수로 버전 증가와 맞지 않게 공개 API 변경을 했다면 어떻게 하나? (수버전 배포에서 잘못된 코드가 들어가서 깨지게 된 경우)

스스로 최선의 판단을 하자. 공개 API가 원래 의도했던 대로 사용될 수 있게 바꾸는 작업에 영향을 받는 대규모 사용자층이 있다면, 수정사항이 엄밀히 따지자면 수버전 배포로 여겨져야 한다 하더라도, 주버전 배포를 하는 것이 최선일 것이다. 유의적 버전은 어떻게 버전 번호가 바뀌는지 의미를 전달하는 것이 전부임을 잊지 말자. 변경이 사용자에게 중요한 의미가 있다면, 버전 번호로 잘 알릴 수 있도록 한다.

제거하는 기능들에 대해서는 어떻게 할까?

기존의 기능들을 사용하지 못하게 없애는 것은 소프트웨어 개발과정의 자연스러운 일부분이며, 때로는 앞으로 나아가기 위해 필수적인 일이기도 하다. 공개 API의 일부를 제거하고자 하다면 다음의 두 가지 일을 해야 한다: (1) 문서를 업데이트해서 사용자들에게 변화를 알리도록 한다. (2) 해당 기능이 제거될 거라 표시된 새 부버전을 적절한 시기에 배포한다. 새 주버전에서 완전히 기능을 제거하기 전에, 제거될 것이라 표시한 부버전 배포를 최소한 한 번은 진행해서 사용자들이 원활하게 새로운 API를 사용할 수 있도록 해야 한다.

유의적 버전의 버전 문자열 길이에 제한이 있나?

없지만, 잘 판단 하자. 예를 들어, 255자 버전 문자열은 아마도 지나치게 긴 것일 것이다. 또, 몇몇 시스템은 문자열 길이에 대해 나름의 제한이 있을 것이다.

“v1.2.3”은 유의적 버전 인가?

“v1.2.3”은 유의적 버전이 아니다. 그러나, 버전 숫자를 나타내기 위해 유의적 버전의 접두어로 “v”를 붙이기도 한다. 버전 관리 도구에서 “version”의 축약어로 “v”로 사용하는 것을 흔하게 볼 수 있다. 예: git tag v1.2.3 -m "Release version 1.2.3" 에서 “v1.2.3”은 tag name이고 유의적 버전은 “1.2.3” 이다.

유의적 버전을 확인할 수 있는 정규식(RegEx)이 있나?

두가지 방법이 있다. 첫번째는 캡처 그룹 이름 지정 방식의 정규식이다(PCRE [Perl Compatible Regular Expressions, i.e. Perl, PHP and R], Python, Go 지원).

See: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


두번째는 캡처 그룹 이름 지정 방식을 지원하지 않는 경우의 정규식이다.

See: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


작성자

유의적 버전 명세는 그라바타(Gravatars)의 창시자이자 깃헙(GitHub)의 공동창업자인 톰 프레스턴-베르너(Tom
Preston-Werner)가 작성했다.

원문에 대한 의견을 남기고자 한다면, 원문 깃헙에 이슈를 작성해 주기 바란다.

한국어 번역은 김대현이 했고, 관련한 의견은 한국어판 깃헙에 이슈로 남겨주기 바란다.

라이선스

Creative Commons ― CC BY 3.0
http://creativecommons.org/licenses/by/3.0/\n기존 버전과 호환되지 않게 API가 바뀌면 “주(主) 버전”을 올리고,\n기존 버전과 호환되면서 새로운 기능을 추가할 때는 “부(部) 버전”을 올리고,\n기존 버전과 호환되면서 버그를 수정한 것이라면 “수(修) 버전”을 올린다.\n주.부.수 형식에 정식배포 전 버전이나 빌드 메타데이터를 위한 라벨을 덧붙이는 방법도 있다.\n소프트웨어 관리의 세계에는 “의존성 지옥”이라 불리는 성가신 문제가 있다. 시스템 규모가 커질수록, 그리고 더 많은 패키지를 가져다 쓸수록, 언젠가, 이 절망의 늪에 빠진 자신을 발견하기 쉽다.\n의존성이 높은 시스템에서는, 새 패키지 버전을 배포하는 일이 금방 끔찍해지곤 한다. 의존성 명세를 너무 엄격하게 관리하면, 버전에 갇히게 될 위험이 있다(의존하는 모든 패키지의 새 버전을 배포하지 않고는 업그레이드할 수 없게 된다). 의존성을 너무 느슨하게 관리하면, 버전이 엉켜서 괴롭게 될 것이다(지나치게 나중 버전까지 호환될 거라 가정한 경우). 버전에 갇히거나 엉켜서 쉽고 안전하게 프로젝트를 계속 진행할 수 없다면 의존성 지옥에 빠진 것이다.\n이 문제의 해결책으로, 버전 번호를 어떻게 정하고 올려야 하는지를 명시하는 규칙과 요구사항을 제안한다. 이 규칙들은 기존 오픈 소스/비공개 소스 소프트웨어에 널리 활용되는 규칙을 바탕으로 했으나, 반드시 따르고자 제약을 받지는 않았다. 이 시스템이 동작하려면, 먼저 공개(public) API를 선언해야 한다. 문서와 소스 코드 자체로 드러낼 수 있다. 어떤 방식이든 API가 명확해야 한다. 한번 공개 API를 정의하고 나면, 버전 번호를 올리는 방식을 통해 API가 어떻게 바뀌는지 표현한다. 버전을 X.Y.Z (주.부.수) 형식으로 정한다. API에 영향이 없는 버그 수정은 수(修)버전을 올리고, API가 호환되면서 바꾸거나 추가하는 경우에는 부(部)버전을 올리고, API가 호환되지 않는 변경이라면 주(主)버전을 올린다.\n이 체계를 “유의적 버전”이라고 부르고자 한다. 이 체계를 따르면, 버전 번호와 그 번호를 바꾸는 방법을 통해 특정 버전에서 다음 버전으로 넘어가면서 코드가 어떻게 바뀌는지를 드러낸다.\n이하 “반드시(MUST, REQUIRED, SHALL) ~한다”, “절대 ~해서는 안 된다(MUST NOT, SHALL NOT)”, “될 수 있으면(SHOULD, RECOMMENDED) ~한다”, “~하지 않는 게 좋다(SHOULD NOT)”, “할 수 있다(MAY, OPTIONAL)”의 표현은 RFC 2119에 기술한 대로 해석한다.\n유의적 버전을 쓰는 소프트웨어는 반드시 공개 API를 선언한다. 이 API는 코드 자체로 선언하거나 문서로 엄격히 명시해야 한다. 어떤 방식으로든, 정확하고 이해하기 쉬워야 한다.\n유의적 버전을 쓰는 소프트웨어는 반드시 공개 API를 선언한다. 이 API는 코드 자체로 선언하거나 문서로 엄격히 명시해야 한다. 어떤 방식으로든, 정확하고 이해하기 쉬워야 한다.\n보통 버전 번호는 반드시 X.Y.Z의 형태로 하고, X, Y, Z는 각각 자연수(음이 아닌 정수)이고, 절대로 0이 앞에 붙어서는 안 된다. X는 주(主)버전 번호이고, Y는 부(部)버전 번호이며, Z는 수(修)버전 번호이다. 각각은 반드시 증가하는 수여야 한다. 예: 1.9.0 -> 1.10.0 -> 1.11.0.\n보통 버전 번호는 반드시 X.Y.Z의 형태로 하고, X, Y, Z는 각각 자연수(음이 아닌 정수)이고, 절대로 0이 앞에 붙어서는 안 된다. X는 주(主)버전 번호이고, Y는 부(部)버전 번호이며, Z는 수(修)버전 번호이다. 각각은 반드시 증가하는 수여야 한다. 예: 1.9.0 -> 1.10.0 -> 1.11.0.\n특정 버전으로 패키지를 배포하고 나면, 그 버전의 내용은 절대 변경하지 말아야 한다. 변경분이 있다면 반드시 새로운 버전으로 배포하도록 한다.\n특정 버전으로 패키지를 배포하고 나면, 그 버전의 내용은 절대 변경하지 말아야 한다. 변경분이 있다면 반드시 새로운 버전으로 배포하도록 한다.\n주버전 0(0.y.z)은 초기 개발을 위해서 쓴다. 아무 때나 마음대로 바꿀 수 있다. 이 공개 API는 안정판으로 보지 않는 게 좋다.\n주버전 0(0.y.z)은 초기 개발을 위해서 쓴다. 아무 때나 마음대로 바꿀 수 있다. 이 공개 API는 안정판으로 보지 않는 게 좋다.\n1.0.0 버전은 공개 API를 정의한다. 이후의 버전 번호는 이때 배포한 공개 API에서 어떻게 바뀌는지에 따라 올린다.\n1.0.0 버전은 공개 API를 정의한다. 이후의 버전 번호는 이때 배포한 공개 API에서 어떻게 바뀌는지에 따라 올린다.\n수버전 Z (x.y.Z | x > 0)는 반드시 그전 버전 API와 호환되는 버그 수정의 경우에만 올린다. 버그 수정은 잘못된 내부 기능을 고치는 것이라 정의한다.\n수버전 Z (x.y.Z | x > 0)는 반드시 그전 버전 API와 호환되는 버그 수정의 경우에만 올린다. 버그 수정은 잘못된 내부 기능을 고치는 것이라 정의한다.\n공개 API에 기존과 호환되는 새로운 기능을 추가할 때는 반드시 부버전 Y(x.Y.z | x > 0)를 올린다. 공개 API의 일부를 앞으로 제거할 것(deprecate)으로 표시한 경우에도 반드시 올리도록 한다. 내부 비공개 코드에 새로운 기능이 대폭 추가되거나 개선사항이 있을 때도 올릴 수 있다. 부버전을 올릴 때 수버전을 올릴 때만큼의 변화를 포함할 수도 있다. 부버전이 올라가면 수버전은 반드시 0에서 다시 시작한다.\n공개 API에 기존과 호환되는 새로운 기능을 추가할 때는 반드시 부버전 Y(x.Y.z | x > 0)를 올린다. 공개 API의 일부를 앞으로 제거할 것(deprecate)으로 표시한 경우에도 반드시 올리도록 한다. 내부 비공개 코드에 새로운 기능이 대폭 추가되거나 개선사항이 있을 때도 올릴 수 있다. 부버전을 올릴 때 수버전을 올릴 때만큼의 변화를 포함할 수도 있다. 부버전이 올라가면 수버전은 반드시 0에서 다시 시작한다.\n공개 API에 기존과 호환되지 않는 변화가 있을 때는 반드시 주버전 X(X.y.z | X > 0)를 올린다. 부버전이나 수버전급 변화를 포함할 수 있다. 주버전 번호를 올릴 때는 반드시 부버전과 수버전을 0으로 초기화 한다.\n공개 API에 기존과 호환되지 않는 변화가 있을 때는 반드시 주버전 X(X.y.z | X > 0)를 올린다. 부버전이나 수버전급 변화를 포함할 수 있다. 주버전 번호를 올릴 때는 반드시 부버전과 수버전을 0으로 초기화 한다.\n수버전 바로 뒤에 붙임표(-)를 붙이고 마침표(.)로 구분된 식별자를 더해서 정식 배포를 앞둔 (pre-release) 버전을 표기할 수 있다. 식별자는 반드시 아스키(ASCII) 문자, 숫자, 붙임표로만 구성한다[0-9A-Za-z-]. 식별자는 반드시 한 글자 이상으로 한다. 숫자 식별자의 경우 절대 앞에 0을 붙인 숫자로 표기하지 않는다. 정식배포 전 버전은 관련한 보통 버전보다 우선순위가 낮다. 정식배포 전 버전은 아직 불안정하며 연관된 일반 버전에 대해 호환성 요구사항이 충족되지 않을 수도 있다. 예: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\n수버전 바로 뒤에 붙임표(-)를 붙이고 마침표(.)로 구분된 식별자를 더해서 정식 배포를 앞둔 (pre-release) 버전을 표기할 수 있다. 식별자는 반드시 아스키(ASCII) 문자, 숫자, 붙임표로만 구성한다[0-9A-Za-z-]. 식별자는 반드시 한 글자 이상으로 한다. 숫자 식별자의 경우 절대 앞에 0을 붙인 숫자로 표기하지 않는다. 정식배포 전 버전은 관련한 보통 버전보다 우선순위가 낮다. 정식배포 전 버전은 아직 불안정하며 연관된 일반 버전에 대해 호환성 요구사항이 충족되지 않을 수도 있다. 예: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\n빌드 메타데이터는 수버전이나 정식배포 전 식별자 뒤에 더하기(+) 기호를 붙인 뒤에 마침표로 구분된 식별자를 덧붙여서 표현할 수 있다. 식별자는 반드시 아스키 문자와 숫자와 붙임표로만 구성한다 [0-9A-Za-z-]. 식별자는 반드시 한 글자 이상으로 한다. 빌드 메타데이터는 버전 간의 우선순위를 판단하고자 할 때 반드시 무시해야 한다. 그러므로, 빌드 메타데이터만 다른 두 버전의 우선순위는 같다. 예: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\n빌드 메타데이터는 수버전이나 정식배포 전 식별자 뒤에 더하기(+) 기호를 붙인 뒤에 마침표로 구분된 식별자를 덧붙여서 표현할 수 있다. 식별자는 반드시 아스키 문자와 숫자와 붙임표로만 구성한다 [0-9A-Za-z-]. 식별자는 반드시 한 글자 이상으로 한다. 빌드 메타데이터는 버전 간의 우선순위를 판단하고자 할 때 반드시 무시해야 한다. 그러므로, 빌드 메타데이터만 다른 두 버전의 우선순위는 같다. 예: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\n우선순위는 버전의 순서를 정렬할 때 서로를 어떻게 비교할지를 나타낸다. 우선순위는 반드시 주, 부, 수 버전, 그리고 정식배포 전 버전의 식별자를 나누어 계산하도록 한다 (빌드 메타데이터는 우선순위에 영향을 주지 않는다). 우선순위는 다음의 순서로 차례로 비교하면서, 차이가 나는 부분이 나타나면 결정된다: 주, 부, 수는 숫자로 비교한다. 예: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. 주, 부, 수버전이 같을 경우, 정식배포 전 버전이 표기된 경우의 우선순위가 더 낮다. 예: 1.0.0-alpha < 1.0.0. 주, 부, 수버전이 같은 두 배포 전 버전 간의 우선순위는 반드시 마침표로 구분된 식별자를 각각 차례로 비교하면서 차이점을 찾는다: 숫자로만 구성된 식별자는 수의 크기로 비교하고 알파벳이나 붙임표가 포함된 경우에는 아스키 문자열 정렬을 하도록 한다. 숫자로만 구성된 식별자는 어떤 경우에도 문자와 붙임표가 있는 식별자보다 낮은 우선순위로 여긴다. 앞선 식별자가 모두 같은 배포 전 버전의 경우에는 필드 수가 많은 쪽이 더 높은 우선순위를 가진다. 예: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\n우선순위는 버전의 순서를 정렬할 때 서로를 어떻게 비교할지를 나타낸다. 우선순위는 반드시 주, 부, 수 버전, 그리고 정식배포 전 버전의 식별자를 나누어 계산하도록 한다 (빌드 메타데이터는 우선순위에 영향을 주지 않는다). 우선순위는 다음의 순서로 차례로 비교하면서, 차이가 나는 부분이 나타나면 결정된다: 주, 부, 수는 숫자로 비교한다. 예: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. 주, 부, 수버전이 같을 경우, 정식배포 전 버전이 표기된 경우의 우선순위가 더 낮다. 예: 1.0.0-alpha < 1.0.0. 주, 부, 수버전이 같은 두 배포 전 버전 간의 우선순위는 반드시 마침표로 구분된 식별자를 각각 차례로 비교하면서 차이점을 찾는다: 숫자로만 구성된 식별자는 수의 크기로 비교하고 알파벳이나 붙임표가 포함된 경우에는 아스키 문자열 정렬을 하도록 한다. 숫자로만 구성된 식별자는 어떤 경우에도 문자와 붙임표가 있는 식별자보다 낮은 우선순위로 여긴다. 앞선 식별자가 모두 같은 배포 전 버전의 경우에는 필드 수가 많은 쪽이 더 높은 우선순위를 가진다. 예: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\n유효한 유의적 버전의 BNF(Backus-Naur Form) 문법\n<유의적 버전> ::= <버전 몸통>
             | <버전 몸통> "-" <배포 전 버전>
             | <버전 몸통> "+" <빌드>
             | <버전 몸통> "-" <배포 전 버전> "+" <빌드>

<버전 몸통> ::= <주> "." <부> "." <수>

<주> ::= <숫자 식별자>

<부> ::= <숫자 식별자>

<수> ::= <숫자 식별자>

<배포 전 버전> ::= <마침표로 구분된 배포 전 식별자들>

<마침표로 구분된 배포 전 식별자들> ::= <배포 전 식별자>
                              | <배포 전 식별자> "." <마침표로 구분된 배포 전 식별자들>

<빌드> ::= <마침표로 구분된 빌드 식별자들>

<마침표로 구분된 빌드 식별자들> ::= <빌드 식별자>
                            | <빌드 식별자> "." <마침표로 구분된 빌드 식별자들>

<배포 전 식별자> ::= <숫자와 알파벳으로 구성된 식별자>
                | <숫자 식별자>

<빌드 식별자> ::= <숫자와 알파벳으로 구성된 식별자>
             | <숫자들>

<숫자와 알파벳으로 구성된 식별자> ::= <숫자 아닌 것>
                             | <숫자 아닌 것> <식별자 문자들>
                             | <식별자 문자들> <숫자 아닌 것>
                             | <식별자 문자들> <숫자 아닌 것> <식별자 문자들>

<숫자 식별자> ::= "0"
             | <양의 숫자>
             | <양의 숫자> <숫자들>

<식별자 문자들> ::= <식별자 문자>
               | <식별자 문자> <식별자 문자들>

<식별자 문자> ::= <숫자>
             | <숫자 아닌 것>

<숫자 아닌 것> ::= <문자>
              | "-"

<숫자들> ::= <숫자>
         | <숫자> <숫자들>

<숫자> ::= "0"
        | <양의 숫자>

<양의 숫자> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<문자> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
        | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
        | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
        | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
        | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
        | "y" | "z"\n<유의적 버전> ::= <버전 몸통>
             | <버전 몸통> "-" <배포 전 버전>
             | <버전 몸통> "+" <빌드>
             | <버전 몸통> "-" <배포 전 버전> "+" <빌드>

<버전 몸통> ::= <주> "." <부> "." <수>

<주> ::= <숫자 식별자>

<부> ::= <숫자 식별자>

<수> ::= <숫자 식별자>

<배포 전 버전> ::= <마침표로 구분된 배포 전 식별자들>

<마침표로 구분된 배포 전 식별자들> ::= <배포 전 식별자>
                              | <배포 전 식별자> "." <마침표로 구분된 배포 전 식별자들>

<빌드> ::= <마침표로 구분된 빌드 식별자들>

<마침표로 구분된 빌드 식별자들> ::= <빌드 식별자>
                            | <빌드 식별자> "." <마침표로 구분된 빌드 식별자들>

<배포 전 식별자> ::= <숫자와 알파벳으로 구성된 식별자>
                | <숫자 식별자>

<빌드 식별자> ::= <숫자와 알파벳으로 구성된 식별자>
             | <숫자들>

<숫자와 알파벳으로 구성된 식별자> ::= <숫자 아닌 것>
                             | <숫자 아닌 것> <식별자 문자들>
                             | <식별자 문자들> <숫자 아닌 것>
                             | <식별자 문자들> <숫자 아닌 것> <식별자 문자들>

<숫자 식별자> ::= "0"
             | <양의 숫자>
             | <양의 숫자> <숫자들>

<식별자 문자들> ::= <식별자 문자>
               | <식별자 문자> <식별자 문자들>

<식별자 문자> ::= <숫자>
             | <숫자 아닌 것>

<숫자 아닌 것> ::= <문자>
              | "-"

<숫자들> ::= <숫자>
         | <숫자> <숫자들>

<숫자> ::= "0"
        | <양의 숫자>

<양의 숫자> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<문자> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
        | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
        | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
        | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
        | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
        | "y" | "z"\n유의적 버전은 혁신적인 아이디어가 아니다. 사실, 이미 이와 비슷한 방식으로 버전을 정해서 쓰고 있었을 수 있다. 문제는 이와 “비슷한” 방식으로는 충분치 않다는 점이다. 어떠한 형태로 정식 명세를 정해서 따르지 않는다면, 버전 번호는 의존성 관리에서 무의미하다. 이상의 아이디어에 이름을 정하고 명시적인 정의를 내림으로써, 소프트웨어 사용자에게 제작자의 의도를 전달하기 쉬워진다. 의도가 명확해야만, (너무 지나치지는 않은) 융통성 있는 의존성 명세를 만들 수 있다.\n유의적 버전으로 어떻게 의존성 지옥을 벗어날 수 있는지 간단한 예를 들어보자. “Firetruck”이라는 라이브러리가 있다고 하자. 이 라이브러리는 유의적 버전이 붙은 “Ladder”라는 패키지에 의존한다. Firetruck을 만들었을 때, Ladder는 버전 3.1.0이었다. Firetruck이 3.1.0에 처음으로 추가된 기능을 사용했기 때문에, Ladder의 의존성을 3.1.0 이상, 4.0.0 미만으로 지정할 수 있다. 이제, Ladder의 3.1.1 버전과 3.2.0 버전이 공개된다면, 패키지 관리 시스템에 그 버전을 넣을 수 있고 기존 소프트웨어와 호환될 것이라고 알 수 있다.\n물론, 책임감 있는 개발자로서 패키지가 업그레이드된 부분이 홍보된 대로 잘 동작하는지 검증하고자 할 것이다. 실상은 지저분하다; 조심해서 관리하는 것 외에는 달리 도리가 없다. 유의적 버전을 사용함으로써 의존하는 패키지들의 새 버전들과 씨름하지 않고, 시간 낭비와 소란 없이 패키지를 공개하고 업그레이드할 수 있다.\n만약 이상의 내용이 그럴싸하다면, 유의적 버전을 쓰기 시작하기 위해서 할 일은, 그렇게 하고자 마음먹고 규칙을 따르기만 하면 된다. 여러분의 README 파일에 이 웹사이트의 링크를 추가해서 다른 사람들도 유용하게 쓸 수 있게 하자.\n초기 개발 단계에 0.y.z 버전 관리는 어떻게 할까?\n가장 간단한 방법은 최초 개발 배포를 0.1.0으로 하고, 이후 배포마다 부버전을 올리는 것이다.\n언제 1.0.0을 배포해야 할지 어떻게 알 수 있나?\n소프트웨어가 실 서비스에 쓰이기 시작했다면 이미 1.0.0이라고 여길 수 있다. 사용자들이 믿고 쓸 수 있는 안정한 API가 있다면 1.0.0일 것이다. 하위 버전 호환성에 대해 우려하기 시작했다면 이미 1.0.0일 수 있다.\n유의적 버전 짓기가 신속한 개발과 빠른 이터레이션에 방해가 되지는 않을까?\n주버전 0이 신속한 개발을 위한 것이다. 만약 API를 매일같이 바꾸고 있다면 0.y.z 버전을 쓰거나 별도의 다음번 주버전 배포를 앞둔 개발 브랜치를 써야 한다.\n공개 API의 아주 사소한 부분이 하위호환이 되지 않는다고 주버전을 매번 올려야 한다면, 어느새 버전 42.0.0이 되어버리지는 않나?\n책임감 있고 선견지명이 있는 질문이다. 의존하는 코드가 많은 소프트웨어에, 호환되지 않는 변화를 가볍게 도입해서는 안 된다. 관련해서 업그레이드하는 데 필요한 비용이 어마어마해질 수 있다. 호환되지 않는 변경분을 배포하기 위해 주버전을 올리려면, 바뀌는 부분에 인한 여파와 그 비용과 혜택을 충분히 평가해야 한다.\n공개 API 전체를 문서로 만드는 것은 일이 너무 많다!\n프로 개발자로서 다른 사람들이 쓰게 하려고 만든 소프트웨어를 적절히 문서로 만드는 것은 책임이다. 프로젝트를 효율적으로 유지하기 위해 소프트웨어의 복잡성을 관리하는 일은 매우 중요한 일이고, 남이 소프트웨어를 어떻게 쓰는지 모르거나 어떤 메소드들을 안전하게 호출할 수 있는 건지 모른다면 어려울 것이다. 장기적으로 볼 때, 유의적 버전과 잘 정의한 공개 API는 관련된 모든 사람과 모든 것이 순조롭게 지낼 수 있게 한다.\n부버전을 올리는데 실수로 호환되지 않는 변경이 들어갔다면 어떻게 해야 하나?\n유의적 버전 명세를 어겼다는 사실을 알게 되면, 즉시 문제를 해결하고 호환성이 깨진 부분을 복구해서 새 부버전을 배포한다. 이 경우라도 이미 배포된 버전을 변경해서는 안 된다. 필요한 경우라면 문제가 되는 버전을 문서로 표시해서 사용자들로 하여금 주의하도록 한다.\n공개 API는 유지한 채 내부의 의존성을 바꾼다면 어떻게 할까?\n공개 API에 영향을 주지 않으므로 호환된다고 여긴다. 당신의 패키지와 똑같은 의존성을 명시한 소프트웨어는 별도로 의존성 명세가 있어야 하고 작성자는 충돌을 눈치챌 것이다. 변화가 수버전 수준인지 부버전 수준인지 결정하는 것은 버그를 수정하고자 한 작업인지, 새로운 기능을 추가하기 위해서인지에 달려있다. 후자의 경우, 추가적인 코드를 예상할 것이며, 그렇다면 당연히 부버전을 증가해야 할 것이다.\n실수로 버전 증가와 맞지 않게 공개 API 변경을 했다면 어떻게 하나? (수버전 배포에서 잘못된 코드가 들어가서 깨지게 된 경우)\n스스로 최선의 판단을 하자. 공개 API가 원래 의도했던 대로 사용될 수 있게 바꾸는 작업에 영향을 받는 대규모 사용자층이 있다면, 수정사항이 엄밀히 따지자면 수버전 배포로 여겨져야 한다 하더라도, 주버전 배포를 하는 것이 최선일 것이다. 유의적 버전은 어떻게 버전 번호가 바뀌는지 의미를 전달하는 것이 전부임을 잊지 말자. 변경이 사용자에게 중요한 의미가 있다면, 버전 번호로 잘 알릴 수 있도록 한다.\n제거하는 기능들에 대해서는 어떻게 할까?\n기존의 기능들을 사용하지 못하게 없애는 것은 소프트웨어 개발과정의 자연스러운 일부분이며, 때로는 앞으로 나아가기 위해 필수적인 일이기도 하다. 공개 API의 일부를 제거하고자 하다면 다음의 두 가지 일을 해야 한다: (1) 문서를 업데이트해서 사용자들에게 변화를 알리도록 한다. (2) 해당 기능이 제거될 거라 표시된 새 부버전을 적절한 시기에 배포한다. 새 주버전에서 완전히 기능을 제거하기 전에, 제거될 것이라 표시한 부버전 배포를 최소한 한 번은 진행해서 사용자들이 원활하게 새로운 API를 사용할 수 있도록 해야 한다.\n유의적 버전의 버전 문자열 길이에 제한이 있나?\n없지만, 잘 판단 하자. 예를 들어, 255자 버전 문자열은 아마도 지나치게 긴 것일 것이다. 또, 몇몇 시스템은 문자열 길이에 대해 나름의 제한이 있을 것이다.\n“v1.2.3”은 유의적 버전이 아니다. 그러나, 버전 숫자를 나타내기 위해 유의적 버전의 접두어로 “v”를 붙이기도 한다. 버전 관리 도구에서 “version”의 축약어로 “v”로 사용하는 것을 흔하게 볼 수 있다. 예: git tag v1.2.3 -m "Release version 1.2.3" 에서 “v1.2.3”은 tag name이고 유의적 버전은 “1.2.3” 이다.\n유의적 버전을 확인할 수 있는 정규식(RegEx)이 있나?\n두가지 방법이 있다. 첫번째는 캡처 그룹 이름 지정 방식의 정규식이다(PCRE [Perl Compatible Regular Expressions, i.e. Perl, PHP and R], Python, Go 지원).\nSee: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n두번째는 캡처 그룹 이름 지정 방식을 지원하지 않는 경우의 정규식이다.\nSee: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n유의적 버전 명세는 그라바타(Gravatars)의 창시자이자 깃헙(GitHub)의 공동창업자인 톰 프레스턴-베르너(Tom
Preston-Werner)가 작성했다.\n톰 프레스턴-베르너(Tom
Preston-Werner)\n원문에 대한 의견을 남기고자 한다면, 원문 깃헙에 이슈를 작성해 주기 바란다.\n한국어 번역은 김대현이 했고, 관련한 의견은 한국어판 깃헙에 이슈로 남겨주기 바란다.\nCreative Commons ― CC BY 3.0
http://creativecommons.org/licenses/by/3.0/\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSemantisch Versioneren 2.0.0

Samenvatting

Gegeven een versienummer in de vorm MAJEUR.MINEUR.PATCH, worden de individuele elementen als volgt verhoogd:


  MAJEUR wordt verhoogd bij incompatibele API-wijzigingen,
  MINEUR wordt verhoogd bij het toevoegen van functionaliteit die compatibel is met de vorige versie, en
  PATCH wordt verhoogd bij compatibele bugfixes.


Er zijn aanvullende labels beschikbaar voor pre-release en build-metadata om toe te voegen aan het MAJEUR.MINEUR.PATCH-formaat.

Introductie

In de wereld van softwarebeheer bestaat er een gevreesde plek genaamd “dependency hell” oftewel de “hel van afhankelijkheden”. Hoe groter een systeem wordt en hoe meer packages er worden geïntegreerd in de software, des te aannemelijker is het dat je op een zekere dag belandt op deze mistroostige plek.

Het uitbrengen van een nieuwe packageversie kan al snel een nachtmerrie worden als systemen te maken hebben met een hoop afhankelijkheden. Als de afhankelijkheden te strikt gespecificeerd zijn, ontstaat het gevaar op “version lock”: het is dan niet meer mogelijk om een package te upgraden zonder dat alle afhankelijke packages ook een versie verhoogd moeten worden. Als de afhankelijkheden te losjes zijn gespecificeerd, zul je onvermijdelijk worden gebeten door het fenomeen versievermenging: de verwachting dat er meer compatibiliteit is met toekomstige versies dan je redelijkerwijs mag verwachten. Je bevindt je in de hel van afhankelijkheden wanneer “version lock” en/of versievermenging zodanig in de weg zitten dat je project niet makkelijk en veilig kan worden voortgezet.

Als oplossing voor dit probleem stel ik een simpele set van regels en voorwaarden voor die beschrijven hoe versienummers toegewezen en verhoogd worden. Deze regels zijn gebaseerd op, maar niet noodzakelijk beperkt tot reeds bestaande en wijdverspreide gebruiken in zowel gesloten als opensource-software. Om dit systeem succesvol te laten zijn, is het als eerste nodig om je API publiek te declareren. Of deze nu bestaat uit documentatie of wordt afgedwongen door de code zelf maakt niet uit: het belangrijkste is dat de API duidelijk en exact is. Zodra je je publieke API geïdentificeerd hebt, worden wijzigingen gecommuniceerd met specifieke verhogingen in het versienummer. Gebruik een versieformaat van X.Y.Z (Majeur.Mineur.Patch). Bugfixes zonder effect op de API verhogen de patchversie, toevoegingen en wijzigingen aan de API die compatibel zijn met de vorige versie verhogen de mineurversie en wijzigingen aan de API die niet compatibel zijn met de vorige versie verhogen de majeurversie.

Ik noem dit systeem “Semantisch Versioneren”, waarmee versienummers en de manier waarop ze veranderen en verhoogd worden duiding geven over de onderliggende code en wat er is aangepast tussen de verschillende versies.

Specificatie Semantisch Versioneren (SemVer)

De termen “MOET” (“MUST”), “MAG NIET” (“MUST NOT”), “VERPLICHT” (“REQUIRED”), “ZAL” (“SHALL”), “ZAL NIET” (“SHALL NOT”), “ZOU MOETEN” (“SHOULD”), “ZOU NIET MOETEN” (“SHOULD NOT”), “AANBEVOLEN” (“RECOMMENDED”), “MAG” (“MAY”), “OPTIONEEL” (“OPTIONAL”) in dit document dienen te worden geïnterpreteerd zoals beschreven in RFC 2119.


  
    Software die gebruikmaakt van Semantisch Versioneren MOET een publieke API declareren. Deze API kan worden gepubliceerd in de code of strikt uit documentatie bestaan. Ongeacht de vorm is het de bedoeling dat deze nauwkeurig en uitgebreid ZOU MOETEN zijn.
  
  
    Een normaal versienummer MOET de structuur X.Y.Z. hebben, waar X, Y en Z een niet-negatief geheel getal zijn. Voorloopnullen MOGEN NIET aanwezig zijn. X is de majeurversie, Y is de mineurversie en Z is de patchversie. Elk element MOET numeriek ophogen. Bijvoorbeeld: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Wanneer een geversioneerd package is gepubliceerd, MAG de inhoud NIET worden aangepast. Alle wijzigingen MOETEN worden gepubliceerd als een nieuwe versie.
  
  
    Majeurversie nul (0.y.z) is voor de eerste ontwikkelfase. Alles MAG op ieder moment veranderen. De publieke API ZOU NIET als stabiel MOETEN worden beschouwd.
  
  
    Versie 1.0.0 definieert de publieke API. De manier waarop het versienummer wordt verhoogd na deze release is afhankelijk van de publieke API en hoe deze verandert.
  
  
    
      
        
          Patchversie Z (x.y.Z
          x > 0) MOET worden verhoogd als wijzigingen zijn doorgevoerd die compatibel zijn met de vorige versie. De definitie van een bugfix is een interne wijziging welke foutief gedrag corrigeert.
        
      
    
  
  
    
      
        
          Mineurversie Y (x.Y.z
          x > 0) MOET worden verhoogd als nieuwe, met de vorige versie compatibele wijzigingen worden gedaan aan de publieke API. Het MOET worden verhoogd op het moment dat publieke-API-functionaliteit wordt uitgefaseerd. Het MAG worden verhoogd als substantiële nieuwe functionaliteit of verbeteringen worden doorgevoerd in de afgeschermde code. Het MAG ook wijzigingen van niveau patch bevatten. De patchversie MOET op 0 worden teruggezet wanneer een mineurversie is verhoogd.
        
      
    
  
  
    
      
        
          Majeurversie X (X.y.z
          X > 0) MOET worden verhoogd als wijzigingen worden doorgevoerd niet compatibel zijn met de publieke API. Het MAG ook wijzigingen van niveau mineur en patch bevatten. De patch- en mineurversie MOETEN op 0 worden teruggezet wanneer majeurversie is verhoogd.
        
      
    
  
  
    Een prerelease-versie MAG worden aangeduid met de toevoeging van een koppelteken en een serie van puntgescheiden id’s direct volgend op de patchversie. Id’s MOETEN slechts bestaan uit alfanumerieke ASCII karakters en koppeltekens [0-9A-Za-z-]. Id’s MOGEN NIET leeg zijn. Voorloopnullen MOGEN NIET aanwezig zijn in numerieke id’s. Prerelease-versies hebben een lagere prioriteit dan de bijbehorende reguliere versie. Een prerelease-versie impliceert instabiel te zijn en voldoet mogelijk niet aan de voorgenomen compatibiliteitseisen zoals aangeduid bij de bijbehorende reguliere versie. Voorbeelden: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92, 1.0.0-x-y-z.–.
  
  
    Build-metadata MAG worden aangeduid door het toevoegen van een plusteken en een serie van puntgescheiden id’s direct volgend op de patch- of prereleaseversie. Id’s MOETEN slechts bestaan uit alfanumerieke ASCII-karakters en koppeltekens [0-9A-Za-z-]. Id’s MOGEN NIET leeg zijn. Build-metadata MOET genegeerd worden wanneer versieprioriteit wordt bepaald. Kortom, twee verschillende versies welke alleen verschillen in build-metadata hebben dezelfde prioriteit. Voorbeelden: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3—-117B344092BD.
  
  
    Prioriteit refereert naar hoe versies in relatie tot elkaar staan wanneer ze zijn gesorteerd.

    
      
        Prioriteit MOET worden berekend door de versie te scheiden in de majeur-, mineur-, patch- en prerelease-id’s, in die volgorde. (Build-metadata wordt niet meegenomen in het bepalen van prioriteit).
      
      
        De prioriteit wordt bepaald door het eerste gevonden verschil wanneer elk van de id’s van links naar rechts onderling vergeleken worden, op de volgende manier: majeur, mineur en patchversies worden altijd numeriek vergeleken. Voorbeeld: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Wanneer majeur, mineur en patch gelijk zijn, heeft een prerelease-versie lagere prioriteit dan een normale versie. Voorbeeld: 1.0.0-alpha < 1.0.0.
      
      
        Prioriteit voor twee prerelease-versies met dezelfde majeur-, mineur- en patchversie MOET worden bepaald door vergelijking van elk puntgescheiden id van links naar rechts tot een verschil is gevonden, en wel zo:

        
          
            Id’s alleen bestaand uit cijfers worden numeriek vergeleken.
          
          
            Id’s met letters of koppeltekens worden lexicaal vergeleken in de ASCII-volgorde.
          
          
            Numerieke id’s hebben altijd een lagere prioriteit dan niet-numerieke id’s.
          
          
            Een grote reeks met prerelease-velden heeft een hogere prioriteit dan een kleinere als alle voorafgaande id’s gelijk zijn. Voorbeeld:: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
          
        
      
    
  


Backus–Naur Form grammatica voor geldige SemVer-versies
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


Waarom semantisch versioneren?

Dit is geen nieuw of revolutionair idee, waarschijnlijk gebruik je al iets wat hier erg op lijkt. En daar gaat het nu juist om: dat is niet goed genoeg. Zonder je aan een formele specificatie te houden zijn versienummers in essentie nutteloos voor afhankelijkheidsbeheer. Door de bovenstaande ideeën een naam te geven en ze helder te definiëren, is het makkelijker om je bedoelingen over te brengen aan de gebruikers van je software. Pas als deze bedoelingen helder en flexibel (maar niet te flexibel) zijn, kunnen eindelijk specificaties over afhankelijkheid worden gemaakt.

Een eenvoudig voorbeeld toont aan hoe Semantisch Versioneren voorgoed afrekent met de hel van afhankelijkheden. Denk aan een softwarebibliotheek genaamd “Brandweerwagen”. Deze heeft een SemVer-package genaamd “Ladder” nodig. Op het moment dat Brandweerwagen uitgebracht wordt, zit Ladder op versie 3.1.0. Omdat Brandweerwagen functionaliteit gebruikt die is geïntroduceerd in versie 3.1.0, kun je veilig vastleggen dat de afhankelijkheid van Ladder groter dan of gelijk is aan 3.1.0 maar kleiner dan 4.0.0. Als Ladder-versie 3.1.1 en 3.2.0 beschikbaar komen, kunnen deze worden gepubliceerd naar het package-beheersysteem wetend dat ze compatibel zijn met huidige, afhankelijke software.

Als een verantwoordelijke ontwikkelaar wil je natuurlijk nagaan dat alle package-upgrades functioneren zoals beschreven. De echte wereld is turbulent; daar kunnen we niets aan doen anders dan waakzaam zijn. Je kunt Semantisch Versioneren gebruiken als een verstandige en logische manier om packages uit te brengen en bij te werken, zonder nieuwe versies van afhankelijke packages uit te moeten brengen. Dat bespaart tijd en gedoe.

Als bovenstaande aantrekkelijk klinkt, is het enige wat je hoeft te doen verklaren dat je Semantisch Versioneert en dan de regels volgen. Verwijs naar deze website vanuit je README zodat anderen deze regels ook kennen en er profijt van kunnen hebben.

FAQ

Hoe kan ik omgaan met correcties in de 0.y.z eerste ontwikkelfase?

Het makkelijkst is om de release van de eerste ontwikkelfase te starten met 0.1.0 en vervolgens met een mineurversie ophogen voor elke volgende release.

Hoe weet ik wanneer ik versie 1.0.0 kan uitbrengen?

Als de software reeds in productie gebruikt wordt, is hij waarschijnlijk al versie 1.0.0. Als je een stabiele API hebt waar gebruikers van afhankelijk zijn, dan dien je op versie 1.0.0 te zitten. Bij zorgen over compatibiliteit met vorige versies is het ook hoog tijd voor versie 1.0.0.

Werkt dit niet ontmoedigend voor snel ontwikkelen en snelle iteraties?

Bij majeurversie nul draait het om snelle ontwikkeling. Als je de API dagelijks wijzigt zou je nog op versie 0.y.z moeten zitten of op een aparte ontwikkelbranch voor de volgende majeurversie.

Als zelfs kleine niet-compatibele wijzigingen aan de publieke API zorgen voor een verhoging van de majeurversie, zit ik dan niet binnen afzienbare tijd op versie 42.0.0?

Het gaat hier om verantwoordelijk ontwikkelen en voortschrijdend inzicht. Niet-compatibele wijzigingen dienen niet licht opgevat te worden als het om software gaat waar veel van afhankelijk is. De ontwikkelkosten voor een upgrade kunnen significant zijn. Een majeurversie verhogen voor het uitbrengen van niet-compatibele wijzigingen betekent dat je moet nadenken over de impact van de wijzigingen en daarbij de kosten en baten in overweging moet nemen.

Het is veel te veel werk om de volledige publieke API te documenteren!

Het is je verantwoordelijkheid als professioneel ontwikkelaar om software die door anderen gebruikt wordt adequaat te documenteren. Een essentieel onderdeel van een efficiënt softwareproject is om de complexiteit beheersbaar te houden, wat bijzonder lastig wordt als niemand weet hoe je software gebruikt moet worden en welke methoden veilig zijn aan te roepen. Op de lange duur zorgen Semantisch Versioneren en het hameren op een goed gedocumenteerde API ervoor dat de zaken soepel lopen.

Wat als ik per ongeluk een niet-compatibele wijziging uitbreng als een mineurversie?

Als je je realiseert dat je de regels van Semantisch Versioneren overtreden hebt, breng dan zo snel mogelijk een nieuwe mineurversie uit die het probleem oplost en de incompatibiliteit met de vorige versie repareert. Zelfs onder deze omstandigheden is het onacceptabel dat reeds uitgebrachte versies gewijzigd worden. Indien toepasselijk, documenteer de foute versie en informeer je gebruikers over het probleem zodat ze er rekening mee kunnen houden.

Wat moet ik doen als ik mijn eigen afhankelijkheden bijwerk zonder wijzigingen aan de publieke API?

Dit wordt beschouwd als compatibel omdat het geen effect heeft op de publieke API. Software die expliciet afhankelijk is van dezelfde afhankelijkheden als jouw package, dient eigen specificaties over deze afhankelijkheden te hebben waarbij de maker conflicten zal opmerken. Bepalen of de wijziging van het niveau patch of mineur is hangt af van het feit of je afhankelijkheden zijn bijgewerkt om een bug op te lossen of om nieuwe functionaliteit uit te brengen. Voor het tweede is er meestal nieuwe code toegevoegd, wat het zonder twijfel een mineure wijziging maakt.

Wat als ik per ongeluk de publieke API aanpas op een manier die niet strookt met de wijziging in het versienummer (bijvoorbeeld: de code introduceert een majeure niet-compatibele wijziging in een patchrelease)?

Gebruik je gezond verstand. Bij een groot publiek dat veel hinder ondervindt als het gedrag van de publieke API weer wordt aangepast, kan het de beste keus zijn om een majeure versie uit te brengen ook al is de wijziging eigenlijk een patch. Onthoud dat Semantisch Versioneren vooral gaat over het geven van betekenis aan de manier waarop het versienummer verandert. Als deze wijzigingen belangrijk zijn voor je gebruikers, zet dan het versienummer in om ze hierover te informeren.

Hoe moet ik omgaan met uitgefaseerde functionaliteit?

Het uitfaseren van bestaande functionaliteit is een normaal onderdeel van softwareontwikkeling en is vaak vereist om voortgang te maken. Als een deel van je publieke API uitgefaseerd wordt, dienen er twee dingen te veranderen: (1) werk documentatie bij zodat gebruikers op de hoogte zijn van de wijziging, (2) breng een nieuwe mineurversie uit waaruit duidelijk wordt dat de functionaliteit wordt uitgefaseerd. Voordat je met een majeure versie de functionaliteit helemaal verwijdert, dient er tenminste één mineurversie uitgebracht te zijn die duidelijk maakt dat de functionaliteit wordt uitgefaseerd, zodat gebruikers een soepele overgang hebben naar de nieuwe API.

Is er binnen SemVer een limiet op het aantal tekens van de versienaam?

Nee, maar hou het realistisch. Een versie die 255 karakters bevat is waarschijnlijk overdreven. Bepaalde systemen kunnen ook eigen limieten stellen aan de lengte van de versienaam.

Is “v1.2.3” een semantische versie?

Nee, “v.1.2.3” is geen semantische versie. Echter, het prefixen van een semantische versie met de letter “v” is een veel voorkomende manier (in het Engels) om aan te geven dat het een versienummer betreft. Het afkorten van “versie” met “v” wordt vaak gezien bij versiebeheer. Voorbeeld: git tag v1.2.3 -m "Release version 1.2.3", in dit geval is “v.1.2.3” een naamtag en de semantische versie is “1.2.3”.

Bestaat er een reguliere expressie (RegEx) om een SemVer-tekenreeks te controleren?

Er zijn er twee. De ene bevat named groups voor systemen die dit ondersteunen (PCRE [Perl Compatible Regular Expressions, zoals Perl, PHP and R], Python
en Go).

Zie ook: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


En een met numbered capture groups (dus cg1 = majeur, cg2 = mineur, cg3 = patch, cg4 = prerelease and cg5 = buildmetadata) die compatibel is met ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,zoals Perl, PHP and R), Python and Go.

Zie ook: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Over

De specificatie van Semantisch Versioneren is oorspronkelijk geschreven door Tom Preston-Werner, uitvinder van Gravatar en medeoprichter van GitHub.

Feedback kan achtergelaten worden door een issue op GitHub te openen.

Vertaling door: Niek van Galen (auteur), Pieter Edelman (redacteur), Alexander Henket (redacteur)

Licentie

Creative Commons ― CC BY 3.0\nSemantisch Versioneren 2.0.0\nGegeven een versienummer in de vorm MAJEUR.MINEUR.PATCH, worden de individuele elementen als volgt verhoogd:\nMAJEUR wordt verhoogd bij incompatibele API-wijzigingen,\nMINEUR wordt verhoogd bij het toevoegen van functionaliteit die compatibel is met de vorige versie, en\nPATCH wordt verhoogd bij compatibele bugfixes.\nEr zijn aanvullende labels beschikbaar voor pre-release en build-metadata om toe te voegen aan het MAJEUR.MINEUR.PATCH-formaat.\nIn de wereld van softwarebeheer bestaat er een gevreesde plek genaamd “dependency hell” oftewel de “hel van afhankelijkheden”. Hoe groter een systeem wordt en hoe meer packages er worden geïntegreerd in de software, des te aannemelijker is het dat je op een zekere dag belandt op deze mistroostige plek.\nHet uitbrengen van een nieuwe packageversie kan al snel een nachtmerrie worden als systemen te maken hebben met een hoop afhankelijkheden. Als de afhankelijkheden te strikt gespecificeerd zijn, ontstaat het gevaar op “version lock”: het is dan niet meer mogelijk om een package te upgraden zonder dat alle afhankelijke packages ook een versie verhoogd moeten worden. Als de afhankelijkheden te losjes zijn gespecificeerd, zul je onvermijdelijk worden gebeten door het fenomeen versievermenging: de verwachting dat er meer compatibiliteit is met toekomstige versies dan je redelijkerwijs mag verwachten. Je bevindt je in de hel van afhankelijkheden wanneer “version lock” en/of versievermenging zodanig in de weg zitten dat je project niet makkelijk en veilig kan worden voortgezet.\nAls oplossing voor dit probleem stel ik een simpele set van regels en voorwaarden voor die beschrijven hoe versienummers toegewezen en verhoogd worden. Deze regels zijn gebaseerd op, maar niet noodzakelijk beperkt tot reeds bestaande en wijdverspreide gebruiken in zowel gesloten als opensource-software. Om dit systeem succesvol te laten zijn, is het als eerste nodig om je API publiek te declareren. Of deze nu bestaat uit documentatie of wordt afgedwongen door de code zelf maakt niet uit: het belangrijkste is dat de API duidelijk en exact is. Zodra je je publieke API geïdentificeerd hebt, worden wijzigingen gecommuniceerd met specifieke verhogingen in het versienummer. Gebruik een versieformaat van X.Y.Z (Majeur.Mineur.Patch). Bugfixes zonder effect op de API verhogen de patchversie, toevoegingen en wijzigingen aan de API die compatibel zijn met de vorige versie verhogen de mineurversie en wijzigingen aan de API die niet compatibel zijn met de vorige versie verhogen de majeurversie.\nIk noem dit systeem “Semantisch Versioneren”, waarmee versienummers en de manier waarop ze veranderen en verhoogd worden duiding geven over de onderliggende code en wat er is aangepast tussen de verschillende versies.\nSpecificatie Semantisch Versioneren (SemVer)\nDe termen “MOET” (“MUST”), “MAG NIET” (“MUST NOT”), “VERPLICHT” (“REQUIRED”), “ZAL” (“SHALL”), “ZAL NIET” (“SHALL NOT”), “ZOU MOETEN” (“SHOULD”), “ZOU NIET MOETEN” (“SHOULD NOT”), “AANBEVOLEN” (“RECOMMENDED”), “MAG” (“MAY”), “OPTIONEEL” (“OPTIONAL”) in dit document dienen te worden geïnterpreteerd zoals beschreven in RFC 2119.\nSoftware die gebruikmaakt van Semantisch Versioneren MOET een publieke API declareren. Deze API kan worden gepubliceerd in de code of strikt uit documentatie bestaan. Ongeacht de vorm is het de bedoeling dat deze nauwkeurig en uitgebreid ZOU MOETEN zijn.\nSoftware die gebruikmaakt van Semantisch Versioneren MOET een publieke API declareren. Deze API kan worden gepubliceerd in de code of strikt uit documentatie bestaan. Ongeacht de vorm is het de bedoeling dat deze nauwkeurig en uitgebreid ZOU MOETEN zijn.\nEen normaal versienummer MOET de structuur X.Y.Z. hebben, waar X, Y en Z een niet-negatief geheel getal zijn. Voorloopnullen MOGEN NIET aanwezig zijn. X is de majeurversie, Y is de mineurversie en Z is de patchversie. Elk element MOET numeriek ophogen. Bijvoorbeeld: 1.9.0 -> 1.10.0 -> 1.11.0.\nEen normaal versienummer MOET de structuur X.Y.Z. hebben, waar X, Y en Z een niet-negatief geheel getal zijn. Voorloopnullen MOGEN NIET aanwezig zijn. X is de majeurversie, Y is de mineurversie en Z is de patchversie. Elk element MOET numeriek ophogen. Bijvoorbeeld: 1.9.0 -> 1.10.0 -> 1.11.0.\nWanneer een geversioneerd package is gepubliceerd, MAG de inhoud NIET worden aangepast. Alle wijzigingen MOETEN worden gepubliceerd als een nieuwe versie.\nWanneer een geversioneerd package is gepubliceerd, MAG de inhoud NIET worden aangepast. Alle wijzigingen MOETEN worden gepubliceerd als een nieuwe versie.\nMajeurversie nul (0.y.z) is voor de eerste ontwikkelfase. Alles MAG op ieder moment veranderen. De publieke API ZOU NIET als stabiel MOETEN worden beschouwd.\nMajeurversie nul (0.y.z) is voor de eerste ontwikkelfase. Alles MAG op ieder moment veranderen. De publieke API ZOU NIET als stabiel MOETEN worden beschouwd.\nVersie 1.0.0 definieert de publieke API. De manier waarop het versienummer wordt verhoogd na deze release is afhankelijk van de publieke API en hoe deze verandert.\nVersie 1.0.0 definieert de publieke API. De manier waarop het versienummer wordt verhoogd na deze release is afhankelijk van de publieke API en hoe deze verandert.\nPatchversie Z (x.y.Z
          x > 0) MOET worden verhoogd als wijzigingen zijn doorgevoerd die compatibel zijn met de vorige versie. De definitie van een bugfix is een interne wijziging welke foutief gedrag corrigeert.\nx > 0) MOET worden verhoogd als wijzigingen zijn doorgevoerd die compatibel zijn met de vorige versie. De definitie van een bugfix is een interne wijziging welke foutief gedrag corrigeert.\nMineurversie Y (x.Y.z
          x > 0) MOET worden verhoogd als nieuwe, met de vorige versie compatibele wijzigingen worden gedaan aan de publieke API. Het MOET worden verhoogd op het moment dat publieke-API-functionaliteit wordt uitgefaseerd. Het MAG worden verhoogd als substantiële nieuwe functionaliteit of verbeteringen worden doorgevoerd in de afgeschermde code. Het MAG ook wijzigingen van niveau patch bevatten. De patchversie MOET op 0 worden teruggezet wanneer een mineurversie is verhoogd.\nMineurversie Y (x.Y.z\nx > 0) MOET worden verhoogd als nieuwe, met de vorige versie compatibele wijzigingen worden gedaan aan de publieke API. Het MOET worden verhoogd op het moment dat publieke-API-functionaliteit wordt uitgefaseerd. Het MAG worden verhoogd als substantiële nieuwe functionaliteit of verbeteringen worden doorgevoerd in de afgeschermde code. Het MAG ook wijzigingen van niveau patch bevatten. De patchversie MOET op 0 worden teruggezet wanneer een mineurversie is verhoogd.\nMajeurversie X (X.y.z
          X > 0) MOET worden verhoogd als wijzigingen worden doorgevoerd niet compatibel zijn met de publieke API. Het MAG ook wijzigingen van niveau mineur en patch bevatten. De patch- en mineurversie MOETEN op 0 worden teruggezet wanneer majeurversie is verhoogd.\nMajeurversie X (X.y.z\nX > 0) MOET worden verhoogd als wijzigingen worden doorgevoerd niet compatibel zijn met de publieke API. Het MAG ook wijzigingen van niveau mineur en patch bevatten. De patch- en mineurversie MOETEN op 0 worden teruggezet wanneer majeurversie is verhoogd.\nEen prerelease-versie MAG worden aangeduid met de toevoeging van een koppelteken en een serie van puntgescheiden id’s direct volgend op de patchversie. Id’s MOETEN slechts bestaan uit alfanumerieke ASCII karakters en koppeltekens [0-9A-Za-z-]. Id’s MOGEN NIET leeg zijn. Voorloopnullen MOGEN NIET aanwezig zijn in numerieke id’s. Prerelease-versies hebben een lagere prioriteit dan de bijbehorende reguliere versie. Een prerelease-versie impliceert instabiel te zijn en voldoet mogelijk niet aan de voorgenomen compatibiliteitseisen zoals aangeduid bij de bijbehorende reguliere versie. Voorbeelden: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92, 1.0.0-x-y-z.–.\nEen prerelease-versie MAG worden aangeduid met de toevoeging van een koppelteken en een serie van puntgescheiden id’s direct volgend op de patchversie. Id’s MOETEN slechts bestaan uit alfanumerieke ASCII karakters en koppeltekens [0-9A-Za-z-]. Id’s MOGEN NIET leeg zijn. Voorloopnullen MOGEN NIET aanwezig zijn in numerieke id’s. Prerelease-versies hebben een lagere prioriteit dan de bijbehorende reguliere versie. Een prerelease-versie impliceert instabiel te zijn en voldoet mogelijk niet aan de voorgenomen compatibiliteitseisen zoals aangeduid bij de bijbehorende reguliere versie. Voorbeelden: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92, 1.0.0-x-y-z.–.\nBuild-metadata MAG worden aangeduid door het toevoegen van een plusteken en een serie van puntgescheiden id’s direct volgend op de patch- of prereleaseversie. Id’s MOETEN slechts bestaan uit alfanumerieke ASCII-karakters en koppeltekens [0-9A-Za-z-]. Id’s MOGEN NIET leeg zijn. Build-metadata MOET genegeerd worden wanneer versieprioriteit wordt bepaald. Kortom, twee verschillende versies welke alleen verschillen in build-metadata hebben dezelfde prioriteit. Voorbeelden: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3—-117B344092BD.\nBuild-metadata MAG worden aangeduid door het toevoegen van een plusteken en een serie van puntgescheiden id’s direct volgend op de patch- of prereleaseversie. Id’s MOETEN slechts bestaan uit alfanumerieke ASCII-karakters en koppeltekens [0-9A-Za-z-]. Id’s MOGEN NIET leeg zijn. Build-metadata MOET genegeerd worden wanneer versieprioriteit wordt bepaald. Kortom, twee verschillende versies welke alleen verschillen in build-metadata hebben dezelfde prioriteit. Voorbeelden: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3—-117B344092BD.\nPrioriteit refereert naar hoe versies in relatie tot elkaar staan wanneer ze zijn gesorteerd.

    
      
        Prioriteit MOET worden berekend door de versie te scheiden in de majeur-, mineur-, patch- en prerelease-id’s, in die volgorde. (Build-metadata wordt niet meegenomen in het bepalen van prioriteit).
      
      
        De prioriteit wordt bepaald door het eerste gevonden verschil wanneer elk van de id’s van links naar rechts onderling vergeleken worden, op de volgende manier: majeur, mineur en patchversies worden altijd numeriek vergeleken. Voorbeeld: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Wanneer majeur, mineur en patch gelijk zijn, heeft een prerelease-versie lagere prioriteit dan een normale versie. Voorbeeld: 1.0.0-alpha < 1.0.0.
      
      
        Prioriteit voor twee prerelease-versies met dezelfde majeur-, mineur- en patchversie MOET worden bepaald door vergelijking van elk puntgescheiden id van links naar rechts tot een verschil is gevonden, en wel zo:

        
          
            Id’s alleen bestaand uit cijfers worden numeriek vergeleken.
          
          
            Id’s met letters of koppeltekens worden lexicaal vergeleken in de ASCII-volgorde.
          
          
            Numerieke id’s hebben altijd een lagere prioriteit dan niet-numerieke id’s.
          
          
            Een grote reeks met prerelease-velden heeft een hogere prioriteit dan een kleinere als alle voorafgaande id’s gelijk zijn. Voorbeeld:: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPrioriteit refereert naar hoe versies in relatie tot elkaar staan wanneer ze zijn gesorteerd.\nPrioriteit MOET worden berekend door de versie te scheiden in de majeur-, mineur-, patch- en prerelease-id’s, in die volgorde. (Build-metadata wordt niet meegenomen in het bepalen van prioriteit).\nPrioriteit MOET worden berekend door de versie te scheiden in de majeur-, mineur-, patch- en prerelease-id’s, in die volgorde. (Build-metadata wordt niet meegenomen in het bepalen van prioriteit).\nDe prioriteit wordt bepaald door het eerste gevonden verschil wanneer elk van de id’s van links naar rechts onderling vergeleken worden, op de volgende manier: majeur, mineur en patchversies worden altijd numeriek vergeleken. Voorbeeld: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nDe prioriteit wordt bepaald door het eerste gevonden verschil wanneer elk van de id’s van links naar rechts onderling vergeleken worden, op de volgende manier: majeur, mineur en patchversies worden altijd numeriek vergeleken. Voorbeeld: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nWanneer majeur, mineur en patch gelijk zijn, heeft een prerelease-versie lagere prioriteit dan een normale versie. Voorbeeld: 1.0.0-alpha < 1.0.0.\nWanneer majeur, mineur en patch gelijk zijn, heeft een prerelease-versie lagere prioriteit dan een normale versie. Voorbeeld: 1.0.0-alpha < 1.0.0.\nPrioriteit voor twee prerelease-versies met dezelfde majeur-, mineur- en patchversie MOET worden bepaald door vergelijking van elk puntgescheiden id van links naar rechts tot een verschil is gevonden, en wel zo:

        
          
            Id’s alleen bestaand uit cijfers worden numeriek vergeleken.
          
          
            Id’s met letters of koppeltekens worden lexicaal vergeleken in de ASCII-volgorde.
          
          
            Numerieke id’s hebben altijd een lagere prioriteit dan niet-numerieke id’s.
          
          
            Een grote reeks met prerelease-velden heeft een hogere prioriteit dan een kleinere als alle voorafgaande id’s gelijk zijn. Voorbeeld:: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPrioriteit voor twee prerelease-versies met dezelfde majeur-, mineur- en patchversie MOET worden bepaald door vergelijking van elk puntgescheiden id van links naar rechts tot een verschil is gevonden, en wel zo:\nId’s alleen bestaand uit cijfers worden numeriek vergeleken.\nId’s alleen bestaand uit cijfers worden numeriek vergeleken.\nId’s met letters of koppeltekens worden lexicaal vergeleken in de ASCII-volgorde.\nId’s met letters of koppeltekens worden lexicaal vergeleken in de ASCII-volgorde.\nNumerieke id’s hebben altijd een lagere prioriteit dan niet-numerieke id’s.\nNumerieke id’s hebben altijd een lagere prioriteit dan niet-numerieke id’s.\nEen grote reeks met prerelease-velden heeft een hogere prioriteit dan een kleinere als alle voorafgaande id’s gelijk zijn. Voorbeeld:: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nEen grote reeks met prerelease-velden heeft een hogere prioriteit dan een kleinere als alle voorafgaande id’s gelijk zijn. Voorbeeld:: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nBackus–Naur Form grammatica voor geldige SemVer-versies\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nWaarom semantisch versioneren?\nDit is geen nieuw of revolutionair idee, waarschijnlijk gebruik je al iets wat hier erg op lijkt. En daar gaat het nu juist om: dat is niet goed genoeg. Zonder je aan een formele specificatie te houden zijn versienummers in essentie nutteloos voor afhankelijkheidsbeheer. Door de bovenstaande ideeën een naam te geven en ze helder te definiëren, is het makkelijker om je bedoelingen over te brengen aan de gebruikers van je software. Pas als deze bedoelingen helder en flexibel (maar niet te flexibel) zijn, kunnen eindelijk specificaties over afhankelijkheid worden gemaakt.\nEen eenvoudig voorbeeld toont aan hoe Semantisch Versioneren voorgoed afrekent met de hel van afhankelijkheden. Denk aan een softwarebibliotheek genaamd “Brandweerwagen”. Deze heeft een SemVer-package genaamd “Ladder” nodig. Op het moment dat Brandweerwagen uitgebracht wordt, zit Ladder op versie 3.1.0. Omdat Brandweerwagen functionaliteit gebruikt die is geïntroduceerd in versie 3.1.0, kun je veilig vastleggen dat de afhankelijkheid van Ladder groter dan of gelijk is aan 3.1.0 maar kleiner dan 4.0.0. Als Ladder-versie 3.1.1 en 3.2.0 beschikbaar komen, kunnen deze worden gepubliceerd naar het package-beheersysteem wetend dat ze compatibel zijn met huidige, afhankelijke software.\nAls een verantwoordelijke ontwikkelaar wil je natuurlijk nagaan dat alle package-upgrades functioneren zoals beschreven. De echte wereld is turbulent; daar kunnen we niets aan doen anders dan waakzaam zijn. Je kunt Semantisch Versioneren gebruiken als een verstandige en logische manier om packages uit te brengen en bij te werken, zonder nieuwe versies van afhankelijke packages uit te moeten brengen. Dat bespaart tijd en gedoe.\nAls bovenstaande aantrekkelijk klinkt, is het enige wat je hoeft te doen verklaren dat je Semantisch Versioneert en dan de regels volgen. Verwijs naar deze website vanuit je README zodat anderen deze regels ook kennen en er profijt van kunnen hebben.\nHoe kan ik omgaan met correcties in de 0.y.z eerste ontwikkelfase?\nHet makkelijkst is om de release van de eerste ontwikkelfase te starten met 0.1.0 en vervolgens met een mineurversie ophogen voor elke volgende release.\nHoe weet ik wanneer ik versie 1.0.0 kan uitbrengen?\nAls de software reeds in productie gebruikt wordt, is hij waarschijnlijk al versie 1.0.0. Als je een stabiele API hebt waar gebruikers van afhankelijk zijn, dan dien je op versie 1.0.0 te zitten. Bij zorgen over compatibiliteit met vorige versies is het ook hoog tijd voor versie 1.0.0.\nWerkt dit niet ontmoedigend voor snel ontwikkelen en snelle iteraties?\nBij majeurversie nul draait het om snelle ontwikkeling. Als je de API dagelijks wijzigt zou je nog op versie 0.y.z moeten zitten of op een aparte ontwikkelbranch voor de volgende majeurversie.\nAls zelfs kleine niet-compatibele wijzigingen aan de publieke API zorgen voor een verhoging van de majeurversie, zit ik dan niet binnen afzienbare tijd op versie 42.0.0?\nHet gaat hier om verantwoordelijk ontwikkelen en voortschrijdend inzicht. Niet-compatibele wijzigingen dienen niet licht opgevat te worden als het om software gaat waar veel van afhankelijk is. De ontwikkelkosten voor een upgrade kunnen significant zijn. Een majeurversie verhogen voor het uitbrengen van niet-compatibele wijzigingen betekent dat je moet nadenken over de impact van de wijzigingen en daarbij de kosten en baten in overweging moet nemen.\nHet is veel te veel werk om de volledige publieke API te documenteren!\nHet is je verantwoordelijkheid als professioneel ontwikkelaar om software die door anderen gebruikt wordt adequaat te documenteren. Een essentieel onderdeel van een efficiënt softwareproject is om de complexiteit beheersbaar te houden, wat bijzonder lastig wordt als niemand weet hoe je software gebruikt moet worden en welke methoden veilig zijn aan te roepen. Op de lange duur zorgen Semantisch Versioneren en het hameren op een goed gedocumenteerde API ervoor dat de zaken soepel lopen.\nWat als ik per ongeluk een niet-compatibele wijziging uitbreng als een mineurversie?\nAls je je realiseert dat je de regels van Semantisch Versioneren overtreden hebt, breng dan zo snel mogelijk een nieuwe mineurversie uit die het probleem oplost en de incompatibiliteit met de vorige versie repareert. Zelfs onder deze omstandigheden is het onacceptabel dat reeds uitgebrachte versies gewijzigd worden. Indien toepasselijk, documenteer de foute versie en informeer je gebruikers over het probleem zodat ze er rekening mee kunnen houden.\nWat moet ik doen als ik mijn eigen afhankelijkheden bijwerk zonder wijzigingen aan de publieke API?\nDit wordt beschouwd als compatibel omdat het geen effect heeft op de publieke API. Software die expliciet afhankelijk is van dezelfde afhankelijkheden als jouw package, dient eigen specificaties over deze afhankelijkheden te hebben waarbij de maker conflicten zal opmerken. Bepalen of de wijziging van het niveau patch of mineur is hangt af van het feit of je afhankelijkheden zijn bijgewerkt om een bug op te lossen of om nieuwe functionaliteit uit te brengen. Voor het tweede is er meestal nieuwe code toegevoegd, wat het zonder twijfel een mineure wijziging maakt.\nWat als ik per ongeluk de publieke API aanpas op een manier die niet strookt met de wijziging in het versienummer (bijvoorbeeld: de code introduceert een majeure niet-compatibele wijziging in een patchrelease)?\nGebruik je gezond verstand. Bij een groot publiek dat veel hinder ondervindt als het gedrag van de publieke API weer wordt aangepast, kan het de beste keus zijn om een majeure versie uit te brengen ook al is de wijziging eigenlijk een patch. Onthoud dat Semantisch Versioneren vooral gaat over het geven van betekenis aan de manier waarop het versienummer verandert. Als deze wijzigingen belangrijk zijn voor je gebruikers, zet dan het versienummer in om ze hierover te informeren.\nHoe moet ik omgaan met uitgefaseerde functionaliteit?\nHet uitfaseren van bestaande functionaliteit is een normaal onderdeel van softwareontwikkeling en is vaak vereist om voortgang te maken. Als een deel van je publieke API uitgefaseerd wordt, dienen er twee dingen te veranderen: (1) werk documentatie bij zodat gebruikers op de hoogte zijn van de wijziging, (2) breng een nieuwe mineurversie uit waaruit duidelijk wordt dat de functionaliteit wordt uitgefaseerd. Voordat je met een majeure versie de functionaliteit helemaal verwijdert, dient er tenminste één mineurversie uitgebracht te zijn die duidelijk maakt dat de functionaliteit wordt uitgefaseerd, zodat gebruikers een soepele overgang hebben naar de nieuwe API.\nIs er binnen SemVer een limiet op het aantal tekens van de versienaam?\nNee, maar hou het realistisch. Een versie die 255 karakters bevat is waarschijnlijk overdreven. Bepaalde systemen kunnen ook eigen limieten stellen aan de lengte van de versienaam.\nIs “v1.2.3” een semantische versie?\nNee, “v.1.2.3” is geen semantische versie. Echter, het prefixen van een semantische versie met de letter “v” is een veel voorkomende manier (in het Engels) om aan te geven dat het een versienummer betreft. Het afkorten van “versie” met “v” wordt vaak gezien bij versiebeheer. Voorbeeld: git tag v1.2.3 -m "Release version 1.2.3", in dit geval is “v.1.2.3” een naamtag en de semantische versie is “1.2.3”.\nBestaat er een reguliere expressie (RegEx) om een SemVer-tekenreeks te controleren?\nEr zijn er twee. De ene bevat named groups voor systemen die dit ondersteunen (PCRE [Perl Compatible Regular Expressions, zoals Perl, PHP and R], Python
en Go).\nZie ook: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nEn een met numbered capture groups (dus cg1 = majeur, cg2 = mineur, cg3 = patch, cg4 = prerelease and cg5 = buildmetadata) die compatibel is met ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,zoals Perl, PHP and R), Python and Go.\nZie ook: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nDe specificatie van Semantisch Versioneren is oorspronkelijk geschreven door Tom Preston-Werner, uitvinder van Gravatar en medeoprichter van GitHub.\nFeedback kan achtergelaten worden door een issue op GitHub te openen.\neen issue op GitHub te openen\nVertaling door: Niek van Galen (auteur), Pieter Edelman (redacteur), Alexander Henket (redacteur)\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nWersjonowanie semantyczne 2.0.0

Streszczenie

Dla numeru wersji MAJOR.MINOR.PATCH, zwiększaj:


  wersję MAJOR, gdy dokonujesz zmian niekompatybilnych z API,
  wersję MINOR, gdy dodajesz nową funkcjonalność, która jest kompatybilna
z poprzednimi wersjami,
  wersję PATCH, gdy naprawiasz błąd nie zrywając kompatybilności z poprzednimi
wersjami.


Dodatkowe oznaczenia dla wydania przedpremierowego lub meta-danych buildu są
dostępne jako rozszerzenia formatu MAJOR.MINOR.PATCH.

Wprowadzenie

W świecie zarządzania oprogramowaniem istnieje przerażające miejsce nazywane
„piekłem zależności”. Im bardziej twój system rośnie i im więcej pakietów
integrujesz w swoim oprogramowaniu, tym większe jest prawdopodobieństwo, że
pewnego dnia znajdziesz się w tej otchłani rozpaczy.

W systemach z wieloma zależnościami, wydawanie nowych wersji pakietu może szybko
stać się koszmarem. Jeśli zależności są określone zbyt wąsko, jesteś zagrożony
blokadą wersji (niemożnością zaktualizowania pakietu bez konieczności wydania
nowych wersji każdego zależnego pakietu). Jeśli zależności są określone zbyt
luźno, nieuchronnie natniesz się na „rozwiązłość wersji” (założenie
kompatybilności z większą liczbą kolejnych wersji niż jest to rozsądne). Piekłem
zależności jest sytuacja, w której blokada wersji i/lub rozwiązłość wersji
uniemożliwiają wygodny i bezpieczny rozwój twojego projektu.

Jako rozwiązanie tego problemu proponuję prosty zbiór zasad i wymogów, które
regulują jak przypisywać i zwiększać numery wersji. Zasady te są oparte, ale
niekoniecznie ograniczone, na istniejących wcześniej, szeroko rozpowszechnionych
praktykach, stosowanych zarówno w zamkniętym, jak i otwartym oprogramowaniu. Aby
ten system działał, musisz najpierw określić publiczne API. Może to być
dokumentacja lub może wymusić je sam kod źródłowy. Niezależnie od sposobu
określenia, ważne jest, by to API było przejrzyste i precyzyjne. Kiedy już masz
swoje publiczne API, komunikujesz zmiany w nim określonymi zwiększeniami w swoim
numerze wersji. Rozważmy format wersji X.Y.Z (major.minor.patch). Naprawy błędów
nieingerujących w API zwiększają wersję patch, kompatybilne wstecz
dodatki/zmiany w API zwiększają wersję minor, a niekompatybilne wstecz zmiany
w API zwiększają wersję major.

Nazywam ten system „wersjonowaniem semantycznym”. W tym układzie numery wersji
i sposób, w jaki się zmieniają, przenoszą informacje o kodzie pod spodem i co
było zmieniane z wersji na wersję.

Specyfikacja wersjonowania semantycznego (SemVer)

Terminy „MUSI” („MUST”), „NIE MOŻE” („MUST NOT”), „WYMAGANY” („REQUIRED”), „MA
BYĆ” („SHALL”), „NIE BĘDZIE” („SHALL NOT”), „POWINIEN” („SHOULD”), „NIE
POWINIEN” („SHOULD NOT”), „ZALECANY” („RECOMMENDED”), „MOŻE” („MAY”)
i „OPCJONALNY” („OPTIONAL”) w tym dokumencie należy interpretować jak opisano
w RFC 2119.


  
    Oprogramowanie używające wersjonowania semantycznego MUSI określać swoje
publiczne API. API to może być zadeklarowane w samym kodzie lub może istnieć
w samej dokumentacji. Jakkolwiek jest zdefiniowane, powinno być precyzyjne
i wyczerpujące.
  
  
    Standardowy numer wersji MUSI przyjąć formę X.Y.Z, gdzie X, Y i Z są
nieujemnymi liczbami całkowitymi i NIE MOGĄ zawierać wiodących zer. X jest
wersją major, Y wersją minor, a Z wersją patch. Każdy składnik MUSI rosnąć
numerycznie. Przykładowo: 1.9.0 → 1.10.0 → 1.11.0.
  
  
    Po wydaniu wersjonowanego pakietu zawartość tej wersji NIE MOŻE być
modyfikowana. Jakiekolwiek zmiany MUSZĄ być wydane jako nowa wersja.
  
  
    Wersja major zero (0.y.z) jest przeznaczona dla początkowej fazy rozwoju.
Wszystko może ulec zmianie w dowolnym momencie. Publiczne API nie powinno być
traktowane jako stabilne.
  
  
    Wersja 1.0.0 określa publiczne API. Sposób, w jaki numer wersji jest
zwiększany po tym wydaniu, zależy od tego publicznego API i jak się ono zmienia.
  
  
    Wersja patch Z (x.y.Z | x > 0) MUSI zostać zwiększona, jeśli wprowadza się
tylko kompatybilne wstecz naprawy błędów. Naprawa błędu definiowana jest jako
zmiana wewnętrzna, która usuwa nieprawidłowe działanie.
  
  
    Wersja minor Y (x.Y.z | x > 0) MUSI zostać zwiększona, jeśli nowa,
kompatybilna wstecz funkcjonalność zostaje wprowadzona do publicznego API. MUSI
zostać zwiększona, jeśli jakakolwiek funkcjonalność publicznego API zostaje
zdezaprobowana. MOŻE zostać zwiększona, jeśli wprowadzone zostają nowe znaczące
funkcjonalności lub ulepszenia w obrębie prywatnego kodu. MOŻE ona zawierać
zmiany na poziomie patch. Numer wersji patch MUSI być ustawiony na 0, gdy wersja
minor jest zwiększana.
  
  
    Wersja major X (X.y.z | X > 0) MUSI zostać zwiększona, jeżeli do publicznego
API są wprowadzane jakiekolwiek wstecznie niekompatybilne zmiany. MOŻE zawierać
zmiany na poziomie minor oraz patch. Numery wersji minor oraz patch MUSZĄ być
ustawione na 0, gdy wersja major jest zwiększana.
  
  
    Wydanie przedpremierowe MOŻE być oznaczone przez dołączenie dywizu oraz
zbioru identyfikatorów rozdzielonych kropkami, zaraz za numerem wersji
patch. Identyfikatory MUSZĄ składać się wyłącznie ze znaków alfanumerycznych
ASCII oraz myślników [0-9A-Za-z-]. Identyfikatory NIE MOGĄ być puste. Numeryczne
identyfikatory NIE MOGĄ zawierać wiodących zer. Wydania przedpremierowe
poprzedzają powiązane z nimi wersje standardowe. Wydanie przedpremierowe
wskazuje na niestabilność wersji i możliwość niespełniania wymogów
kompatybilności, które cechują powiązaną z nią standardową wersję. Przykłady:
1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Meta-dane buildu MOGĄ być oznaczone przez dołączenie znaku plus oraz zbioru
identyfikatorów rozdzielonych kropkami, zaraz za numerem wersji patch lub
wydania przedpremierowego. Identyfikatory MUSZĄ składać się wyłącznie ze znaków
alfanumerycznych ASCII oraz myślników [0-9A-Za-z-]. Identyfikatory NIE MOGĄ być
puste. Meta-dane buildu POWINNY być ignorowane przy ustalaniu kolejności wersji.
Zatem dwie wersje różniące się tylko meta-danymi buildu mają ten sam stopień
pierwszeństwa. Przykłady: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85.
  
  
    Pierwszeństwo odnosi się do sposobu porównywania wersji między sobą podczas
ich porządkowania. Pierwszeństwo MUSI być ustalane w rozdzieleniu wersji na
identyfikatory major, minor, patch oraz identyfikator przedpremierowy w podanej
kolejności (meta-dane buildu nie decydują o pierwszeństwie). Pierwszeństwo jest
ustalane przez pierwszą różnicę wykrytą podczas porównania każdego
z identyfikatorów od lewej do prawej: wersje major, minor, patch są zawsze
porównywane numerycznie. Przykład: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Gdy numery
wersji major, minor i patch są równe, wydanie przedpremierowe poprzedza wersję
standardową. Przykładowo: 1.0.0-alpha < 1.0.0. Pierwszeństwo dwóch wydań
przedpremierowych z takimi samymi numerami wersji major, minor i patch MUSI być
ustalane przez porównywanie każdego z identyfikatorów rozdzielonych kropkami
w kierunku od lewej do prawej, póki nie zostanie wykryta różnica w taki sposób:
identyfikatory złożone z samych cyfr porównywane są numerycznie,
a identyfikatory z literami lub dywizami porównywane są leksykalnie w kolejności
ASCII. Identyfikatory numeryczne zawsze poprzedzają identyfikatory
nienumeryczne. Większy zbiór przedpremierowych pól poprzedza mniejszy zbiór,
o ile wszystkie poprzedzające identyfikatory są sobie równe. Przykład:
1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 <
1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Gramatyka poprawnej wersji SemVer w zapisie BNF
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


Dlaczego warto stosować wersjonowanie semantyczne?

To nie jest nowy ani rewolucyjny pomysł. W zasadzie prawdopodobnie już
posługujesz się prawie tą samą metodą. Problem w tym, że „prawie” robi różnicę.
Bez zgodności z jakimś rodzajem formalnej specyfikacji, numery wersji są
całkowicie nieprzydatne przy zarządzaniu zależnościami. Poprzez nadanie nazwy
i jasnych definicji powyższym pomysłom, łatwiejszym staje się przekazywanie
twoich intencji użytkownikom twojego oprogramowania. Gdy te intencje są jasne,
wreszcie da się robić elastyczne (ale nie zbyt elastyczne) specyfikacje
zależności.

Prosty przykład może udowodnić, w jaki sposób wersjonowanie semantyczne może
zamienić piekło zależności w relikt przeszłości. Rozważmy bibliotekę nazwaną
„Wóz strażacki”. Wymaga ona wersjonowanego semantycznie pakietu o nazwie
„Drabina”. W czasie, gdy Wóz strażacki jest tworzony, Drabina jest w wersji
3.1.0. Jako że Wóz strażacki korzysta z funkcjonalności, które zostały
wprowadzone po raz pierwszy w wersji 3.1.0, możesz bezpiecznie założyć, że
wymagana wersja Drabiny jest większa lub równa 3.1.0, ale mniejsza niż 4.0.0.
Teraz gdy staną się dostępne wersje Drabiny 3.1.1 lub 3.2.0, możesz puścić je
w swoim systemie zarządzania pakietami ze świadomością, że będą one kompatybilne
z istniejącym zależnym oprogramowaniem.

Jako odpowiedzialny programista musisz oczywiście zweryfikować, że każde
aktualizacje pakietów działają, jak powinny. Prawdziwy świat potrafi dać w kość;
nic nie możemy z tym zrobić poza zachowaniem czujności. To, co ty możesz zrobić,
to pozwolić by wersjonowanie semantyczne dostarczyło ci rozsądną metodę
wydawania i aktualizowania pakietów bez konieczności wydawania nowych
wersji pakietów zależnych, oszczędzającą ci czas i wysiłek.

Jeśli to wszystko brzmi zachęcająco, wszystko, co musisz zrobić, aby korzystać
z wersjonowania semantycznego, to zadeklarować się, że będziesz to robić,
a następnie przestrzegać zasad. Podlinkuj tę stronę w swoim README, aby inni
znali te zasady i mogli z nich korzystać.

Często zadawane pytania

Jak powinienem zajmować się wersjami w 0.y.z początkowej fazie rozwoju?

Najprościej jest zacząć swoje wydanie początkowej fazy rozwoju od 0.1.0,
a następnie zwiększać wersję minor dla każdego kolejnego wydania.

Skąd mam wiedzieć, kiedy wydać 1.0.0?

Jeśli twoje oprogramowanie jest w użyciu w produkcji, powinno prawdopodobnie już
być 1.0.0. Jeśli masz stabilne API, z którego zaczęli korzystać użytkownicy,
powinieneś mieć 1.0.0. Jeśli dużo się martwisz o kompatybilność wstecz,
powinieneś prawdopodobnie już mieć 1.0.0.

Czy nie opóźnia to szybkiego rozwoju i szybkiej iteracji?

W wersji major zero chodzi o szybki rozwój. Jeśli zmieniasz API codziennie,
powinieneś albo być wciąż w wersji 0.y.z, albo w oddzielnej gałęzi rozwoju,
pracując nad nową wersją major.

Jeśli nawet najmniejsze niekompatybilne wstecz zmiany w publicznym API wymagają podbicia wersji major, czy bardzo szybko nie skończę na wersji 42.0.0?

To jest kwestia odpowiedzialnego programowania i dalekowzroczności.
Niekompatybilne zmiany nie powinny być wprowadzane z lekkością do
oprogramowania, które jest zależnością w wielu miejscach. Koszt, który trzeba
ponieść, by zaktualizować pakiet, może być znamienny. Konieczność podbijania
wersji major przy wprowadzaniu niekompatybilnych zmian powoduje, że będziesz
myślał przez pryzmat siły oddziaływania swoich zmian i szacował stosunek
poniesionych kosztów do zysków.

Stworzenie dokumentacji całego publicznego API to zbyt dużo pracy!

Jako profesjonalny programista jesteś odpowiedzialny za prawidłową dokumentację
oprogramowania, które jest przeznaczone do użytku przez innych. Zarządzanie
złożonością oprogramowania jest niezwykle ważną częścią utrzymania sprawności
projektu, a jest to trudne do zrobienia, jeśli nikt nie wie, jak używać twojego
oprogramowania albo z których metod jest bezpiecznie korzystać. Na dłuższą metę
wersjonowanie semantyczne oraz obstawanie przy dobrze zdefiniowanym publicznym
API pozwoli wszystkim i wszystkiemu działać płynnie.

Co zrobić, jeśli przez przypadek wypuściłem niekompatybilną wstecz zmianę jako wersję minor?

Jak tylko odkryjesz, że zaburzyłeś specyfikację semantycznego wersjonowania,
napraw ten błąd i wydaj nową wersję minor, która niweluje błąd i przywraca
wsteczną kompatybilność. Nawet w takich okolicznościach niedopuszczalne jest
modyfikowanie wydanej wersji. Jeśli możesz, opisz błędną wersję i poinformuj
użytkowników o problemie, aby byli świadomi, że ta wersja jest błędna.

Co powinienem zrobić, jeśli aktualizuję własne zależności bez zmiany publicznego API?

Taka aktualizacja jest uznawana za kompatybilną, gdyż nie narusza publicznego
API. Oprogramowanie, które opiera się na tych samych zależnościach co twój
pakiet, powinno mieć własną specyfikację zależności, a jego autor zauważy
konflikt. Ustalenie, czy zmiana jest na poziomie patch lub, czy jest modyfikacją
na poziomie minor, zależy od tego, czy zaktualizowałeś zależności w celu naprawy
błędu, czy w celu wprowadzenia nowej funkcjonalności. Zazwyczaj spodziewałbym
się dodatkowego kodu w tym drugim przypadku, co oczywiście oznacza zwiększenie
wersji minor.

Co zrobić, gdy nieumyślnie zmieniłem publiczne API w taki sposób, że nie jest już zgodne ze zmianą numeru wersji (tj. kod nieprawidłowo wprowadza zmianę major w wydaniu patch)?

Postępuj zgodnie z rozsądkiem. Jeśli oprogramowanie używane jest przez wielu
użytkowników, dla których zmiana publicznego API do poprzednio zamierzonego
stanu może być dużym uderzeniem, lepiej jest wypuścić nową wersję major, nawet
jeśli problem mógłby być rozwiązany wydaniem wersji patch. Należy pamiętać, że
w semantycznym wersjonowaniu chodzi przede wszystkim o przekazanie znaczenia
zmiany poprzez zmianę numeru wersji. Jeśli zmiany są ważne dla użytkowników,
poinformuj ich o tym poprzez numer wersji.

Jak powinienem radzić sobie z dezaprobowaniem funkcjonalności?

Dezaprobowanie istniejącej funkcjonalności jest normalną częścią programowania
i często jest konieczne, by móc rozwijać oprogramowanie. Gdy wycofujesz część
swojego publicznego API, powinieneś zrobić dwie rzeczy: (1) zaktualizować
dokumentację, by użytkownicy wiedzieli o tej zmianie, (2) wypuścić nowe wydanie
minor z informacją o zdezaprobowaniu. Zanim całkowicie usuniesz funkcjonalność
w nowym wydaniu major, powinno być co najmniej jedno wydanie minor zawierające
informację o zdezaprobowaniu, aby użytkownicy mogli płynnie przejść na nowe API.

Czy SemVer ma limit długości na oznaczenie wersji?

Nie, ale miej zdrowy rozsądek. Na przykład numer wersji długi na 255 znaków to
prawdopodobnie przesada. Ponadto konkretne systemy mogą narzucać swoje własne
ograniczenia na rozmiar tego ciągu znaków.

Czy ciąg „v1.2.3” spełnia zasady?

Nie, „v1.2.3” nie jest zgodne z wersjonowaniem semantycznym. Jednak przedrostek „v” jest
zazwyczaj używany w języku angielskim do oznaczenia, że mamy do czynienia z numerem wersji.
Skrót „v” od angielskiego słowa „version” jest często spotykany w systemach kontroli wersji.
Przykładowo, w przypadku git tag v1.2.3 -m "Release version 1.2.3", „v1.2.3” jest nazwą taga,
a semantyczna wersja to „1.2.3”.

Czy istnieje sugerowane wyrażenie regularne (RegEx) do weryfikacji porawności SemVer?

Istnieją dwa. Pierwsze wykorzystuje grupy nazwane i jest przeznaczone dla systemów, które
wspierają tę funkcjonalność (PCRE [Perl Compatible Regular Expressions, np. Perl, PHP i R], Python czy Go).

Patrz: https://regex101.com/r/Ly7O1x/3/
^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Druga wykorzystuje numerowane grupy przechwytujące (wzór gp1 = major, gp2 = minor, gp3 = patch, gp4 = przedpremierowa i gp5 =
meta-dane buildu) i jest kompatybilna z ECMA Script (JavaScript), PCRE [Perl Compatible Regular Expressions, np. Perl, PHP i R],
Python czy Go.

Patrz: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


O specyfikacji

Autorem specyfikacji wersjonowania semantycznego jest
Tom Preston-Werner, wynalazca Gravatara
i współzałożyciel GitHuba.

Jeśli chcesz podzielić się opinią, prosimy
o otworzenie zgłoszenia na GitHubie.

Licencja

Creative Commons – CC BY 3.0.\nWersjonowanie semantyczne 2.0.0\nDla numeru wersji MAJOR.MINOR.PATCH, zwiększaj:\nwersję MAJOR, gdy dokonujesz zmian niekompatybilnych z API,\nwersję MINOR, gdy dodajesz nową funkcjonalność, która jest kompatybilna
z poprzednimi wersjami,\nwersję PATCH, gdy naprawiasz błąd nie zrywając kompatybilności z poprzednimi
wersjami.\nDodatkowe oznaczenia dla wydania przedpremierowego lub meta-danych buildu są
dostępne jako rozszerzenia formatu MAJOR.MINOR.PATCH.\nW świecie zarządzania oprogramowaniem istnieje przerażające miejsce nazywane
„piekłem zależności”. Im bardziej twój system rośnie i im więcej pakietów
integrujesz w swoim oprogramowaniu, tym większe jest prawdopodobieństwo, że
pewnego dnia znajdziesz się w tej otchłani rozpaczy.\nW systemach z wieloma zależnościami, wydawanie nowych wersji pakietu może szybko
stać się koszmarem. Jeśli zależności są określone zbyt wąsko, jesteś zagrożony
blokadą wersji (niemożnością zaktualizowania pakietu bez konieczności wydania
nowych wersji każdego zależnego pakietu). Jeśli zależności są określone zbyt
luźno, nieuchronnie natniesz się na „rozwiązłość wersji” (założenie
kompatybilności z większą liczbą kolejnych wersji niż jest to rozsądne). Piekłem
zależności jest sytuacja, w której blokada wersji i/lub rozwiązłość wersji
uniemożliwiają wygodny i bezpieczny rozwój twojego projektu.\nJako rozwiązanie tego problemu proponuję prosty zbiór zasad i wymogów, które
regulują jak przypisywać i zwiększać numery wersji. Zasady te są oparte, ale
niekoniecznie ograniczone, na istniejących wcześniej, szeroko rozpowszechnionych
praktykach, stosowanych zarówno w zamkniętym, jak i otwartym oprogramowaniu. Aby
ten system działał, musisz najpierw określić publiczne API. Może to być
dokumentacja lub może wymusić je sam kod źródłowy. Niezależnie od sposobu
określenia, ważne jest, by to API było przejrzyste i precyzyjne. Kiedy już masz
swoje publiczne API, komunikujesz zmiany w nim określonymi zwiększeniami w swoim
numerze wersji. Rozważmy format wersji X.Y.Z (major.minor.patch). Naprawy błędów
nieingerujących w API zwiększają wersję patch, kompatybilne wstecz
dodatki/zmiany w API zwiększają wersję minor, a niekompatybilne wstecz zmiany
w API zwiększają wersję major.\nNazywam ten system „wersjonowaniem semantycznym”. W tym układzie numery wersji
i sposób, w jaki się zmieniają, przenoszą informacje o kodzie pod spodem i co
było zmieniane z wersji na wersję.\nSpecyfikacja wersjonowania semantycznego (SemVer)\nTerminy „MUSI” („MUST”), „NIE MOŻE” („MUST NOT”), „WYMAGANY” („REQUIRED”), „MA
BYĆ” („SHALL”), „NIE BĘDZIE” („SHALL NOT”), „POWINIEN” („SHOULD”), „NIE
POWINIEN” („SHOULD NOT”), „ZALECANY” („RECOMMENDED”), „MOŻE” („MAY”)
i „OPCJONALNY” („OPTIONAL”) w tym dokumencie należy interpretować jak opisano
w RFC 2119.\nOprogramowanie używające wersjonowania semantycznego MUSI określać swoje
publiczne API. API to może być zadeklarowane w samym kodzie lub może istnieć
w samej dokumentacji. Jakkolwiek jest zdefiniowane, powinno być precyzyjne
i wyczerpujące.\nOprogramowanie używające wersjonowania semantycznego MUSI określać swoje
publiczne API. API to może być zadeklarowane w samym kodzie lub może istnieć
w samej dokumentacji. Jakkolwiek jest zdefiniowane, powinno być precyzyjne
i wyczerpujące.\nStandardowy numer wersji MUSI przyjąć formę X.Y.Z, gdzie X, Y i Z są
nieujemnymi liczbami całkowitymi i NIE MOGĄ zawierać wiodących zer. X jest
wersją major, Y wersją minor, a Z wersją patch. Każdy składnik MUSI rosnąć
numerycznie. Przykładowo: 1.9.0 → 1.10.0 → 1.11.0.\nStandardowy numer wersji MUSI przyjąć formę X.Y.Z, gdzie X, Y i Z są
nieujemnymi liczbami całkowitymi i NIE MOGĄ zawierać wiodących zer. X jest
wersją major, Y wersją minor, a Z wersją patch. Każdy składnik MUSI rosnąć
numerycznie. Przykładowo: 1.9.0 → 1.10.0 → 1.11.0.\nPo wydaniu wersjonowanego pakietu zawartość tej wersji NIE MOŻE być
modyfikowana. Jakiekolwiek zmiany MUSZĄ być wydane jako nowa wersja.\nPo wydaniu wersjonowanego pakietu zawartość tej wersji NIE MOŻE być
modyfikowana. Jakiekolwiek zmiany MUSZĄ być wydane jako nowa wersja.\nWersja major zero (0.y.z) jest przeznaczona dla początkowej fazy rozwoju.
Wszystko może ulec zmianie w dowolnym momencie. Publiczne API nie powinno być
traktowane jako stabilne.\nWersja major zero (0.y.z) jest przeznaczona dla początkowej fazy rozwoju.
Wszystko może ulec zmianie w dowolnym momencie. Publiczne API nie powinno być
traktowane jako stabilne.\nWersja 1.0.0 określa publiczne API. Sposób, w jaki numer wersji jest
zwiększany po tym wydaniu, zależy od tego publicznego API i jak się ono zmienia.\nWersja 1.0.0 określa publiczne API. Sposób, w jaki numer wersji jest
zwiększany po tym wydaniu, zależy od tego publicznego API i jak się ono zmienia.\nWersja patch Z (x.y.Z | x > 0) MUSI zostać zwiększona, jeśli wprowadza się
tylko kompatybilne wstecz naprawy błędów. Naprawa błędu definiowana jest jako
zmiana wewnętrzna, która usuwa nieprawidłowe działanie.\nWersja patch Z (x.y.Z | x > 0) MUSI zostać zwiększona, jeśli wprowadza się
tylko kompatybilne wstecz naprawy błędów. Naprawa błędu definiowana jest jako
zmiana wewnętrzna, która usuwa nieprawidłowe działanie.\nWersja minor Y (x.Y.z | x > 0) MUSI zostać zwiększona, jeśli nowa,
kompatybilna wstecz funkcjonalność zostaje wprowadzona do publicznego API. MUSI
zostać zwiększona, jeśli jakakolwiek funkcjonalność publicznego API zostaje
zdezaprobowana. MOŻE zostać zwiększona, jeśli wprowadzone zostają nowe znaczące
funkcjonalności lub ulepszenia w obrębie prywatnego kodu. MOŻE ona zawierać
zmiany na poziomie patch. Numer wersji patch MUSI być ustawiony na 0, gdy wersja
minor jest zwiększana.\nWersja minor Y (x.Y.z | x > 0) MUSI zostać zwiększona, jeśli nowa,
kompatybilna wstecz funkcjonalność zostaje wprowadzona do publicznego API. MUSI
zostać zwiększona, jeśli jakakolwiek funkcjonalność publicznego API zostaje
zdezaprobowana. MOŻE zostać zwiększona, jeśli wprowadzone zostają nowe znaczące
funkcjonalności lub ulepszenia w obrębie prywatnego kodu. MOŻE ona zawierać
zmiany na poziomie patch. Numer wersji patch MUSI być ustawiony na 0, gdy wersja
minor jest zwiększana.\nWersja major X (X.y.z | X > 0) MUSI zostać zwiększona, jeżeli do publicznego
API są wprowadzane jakiekolwiek wstecznie niekompatybilne zmiany. MOŻE zawierać
zmiany na poziomie minor oraz patch. Numery wersji minor oraz patch MUSZĄ być
ustawione na 0, gdy wersja major jest zwiększana.\nWersja major X (X.y.z | X > 0) MUSI zostać zwiększona, jeżeli do publicznego
API są wprowadzane jakiekolwiek wstecznie niekompatybilne zmiany. MOŻE zawierać
zmiany na poziomie minor oraz patch. Numery wersji minor oraz patch MUSZĄ być
ustawione na 0, gdy wersja major jest zwiększana.\nWydanie przedpremierowe MOŻE być oznaczone przez dołączenie dywizu oraz
zbioru identyfikatorów rozdzielonych kropkami, zaraz za numerem wersji
patch. Identyfikatory MUSZĄ składać się wyłącznie ze znaków alfanumerycznych
ASCII oraz myślników [0-9A-Za-z-]. Identyfikatory NIE MOGĄ być puste. Numeryczne
identyfikatory NIE MOGĄ zawierać wiodących zer. Wydania przedpremierowe
poprzedzają powiązane z nimi wersje standardowe. Wydanie przedpremierowe
wskazuje na niestabilność wersji i możliwość niespełniania wymogów
kompatybilności, które cechują powiązaną z nią standardową wersję. Przykłady:
1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nWydanie przedpremierowe MOŻE być oznaczone przez dołączenie dywizu oraz
zbioru identyfikatorów rozdzielonych kropkami, zaraz za numerem wersji
patch. Identyfikatory MUSZĄ składać się wyłącznie ze znaków alfanumerycznych
ASCII oraz myślników [0-9A-Za-z-]. Identyfikatory NIE MOGĄ być puste. Numeryczne
identyfikatory NIE MOGĄ zawierać wiodących zer. Wydania przedpremierowe
poprzedzają powiązane z nimi wersje standardowe. Wydanie przedpremierowe
wskazuje na niestabilność wersji i możliwość niespełniania wymogów
kompatybilności, które cechują powiązaną z nią standardową wersję. Przykłady:
1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nMeta-dane buildu MOGĄ być oznaczone przez dołączenie znaku plus oraz zbioru
identyfikatorów rozdzielonych kropkami, zaraz za numerem wersji patch lub
wydania przedpremierowego. Identyfikatory MUSZĄ składać się wyłącznie ze znaków
alfanumerycznych ASCII oraz myślników [0-9A-Za-z-]. Identyfikatory NIE MOGĄ być
puste. Meta-dane buildu POWINNY być ignorowane przy ustalaniu kolejności wersji.
Zatem dwie wersje różniące się tylko meta-danymi buildu mają ten sam stopień
pierwszeństwa. Przykłady: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85.\nMeta-dane buildu MOGĄ być oznaczone przez dołączenie znaku plus oraz zbioru
identyfikatorów rozdzielonych kropkami, zaraz za numerem wersji patch lub
wydania przedpremierowego. Identyfikatory MUSZĄ składać się wyłącznie ze znaków
alfanumerycznych ASCII oraz myślników [0-9A-Za-z-]. Identyfikatory NIE MOGĄ być
puste. Meta-dane buildu POWINNY być ignorowane przy ustalaniu kolejności wersji.
Zatem dwie wersje różniące się tylko meta-danymi buildu mają ten sam stopień
pierwszeństwa. Przykłady: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85.\nPierwszeństwo odnosi się do sposobu porównywania wersji między sobą podczas
ich porządkowania. Pierwszeństwo MUSI być ustalane w rozdzieleniu wersji na
identyfikatory major, minor, patch oraz identyfikator przedpremierowy w podanej
kolejności (meta-dane buildu nie decydują o pierwszeństwie). Pierwszeństwo jest
ustalane przez pierwszą różnicę wykrytą podczas porównania każdego
z identyfikatorów od lewej do prawej: wersje major, minor, patch są zawsze
porównywane numerycznie. Przykład: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Gdy numery
wersji major, minor i patch są równe, wydanie przedpremierowe poprzedza wersję
standardową. Przykładowo: 1.0.0-alpha < 1.0.0. Pierwszeństwo dwóch wydań
przedpremierowych z takimi samymi numerami wersji major, minor i patch MUSI być
ustalane przez porównywanie każdego z identyfikatorów rozdzielonych kropkami
w kierunku od lewej do prawej, póki nie zostanie wykryta różnica w taki sposób:
identyfikatory złożone z samych cyfr porównywane są numerycznie,
a identyfikatory z literami lub dywizami porównywane są leksykalnie w kolejności
ASCII. Identyfikatory numeryczne zawsze poprzedzają identyfikatory
nienumeryczne. Większy zbiór przedpremierowych pól poprzedza mniejszy zbiór,
o ile wszystkie poprzedzające identyfikatory są sobie równe. Przykład:
1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 <
1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPierwszeństwo odnosi się do sposobu porównywania wersji między sobą podczas
ich porządkowania. Pierwszeństwo MUSI być ustalane w rozdzieleniu wersji na
identyfikatory major, minor, patch oraz identyfikator przedpremierowy w podanej
kolejności (meta-dane buildu nie decydują o pierwszeństwie). Pierwszeństwo jest
ustalane przez pierwszą różnicę wykrytą podczas porównania każdego
z identyfikatorów od lewej do prawej: wersje major, minor, patch są zawsze
porównywane numerycznie. Przykład: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Gdy numery
wersji major, minor i patch są równe, wydanie przedpremierowe poprzedza wersję
standardową. Przykładowo: 1.0.0-alpha < 1.0.0. Pierwszeństwo dwóch wydań
przedpremierowych z takimi samymi numerami wersji major, minor i patch MUSI być
ustalane przez porównywanie każdego z identyfikatorów rozdzielonych kropkami
w kierunku od lewej do prawej, póki nie zostanie wykryta różnica w taki sposób:
identyfikatory złożone z samych cyfr porównywane są numerycznie,
a identyfikatory z literami lub dywizami porównywane są leksykalnie w kolejności
ASCII. Identyfikatory numeryczne zawsze poprzedzają identyfikatory
nienumeryczne. Większy zbiór przedpremierowych pól poprzedza mniejszy zbiór,
o ile wszystkie poprzedzające identyfikatory są sobie równe. Przykład:
1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 <
1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nGramatyka poprawnej wersji SemVer w zapisie BNF\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nDlaczego warto stosować wersjonowanie semantyczne?\nTo nie jest nowy ani rewolucyjny pomysł. W zasadzie prawdopodobnie już
posługujesz się prawie tą samą metodą. Problem w tym, że „prawie” robi różnicę.
Bez zgodności z jakimś rodzajem formalnej specyfikacji, numery wersji są
całkowicie nieprzydatne przy zarządzaniu zależnościami. Poprzez nadanie nazwy
i jasnych definicji powyższym pomysłom, łatwiejszym staje się przekazywanie
twoich intencji użytkownikom twojego oprogramowania. Gdy te intencje są jasne,
wreszcie da się robić elastyczne (ale nie zbyt elastyczne) specyfikacje
zależności.\nProsty przykład może udowodnić, w jaki sposób wersjonowanie semantyczne może
zamienić piekło zależności w relikt przeszłości. Rozważmy bibliotekę nazwaną
„Wóz strażacki”. Wymaga ona wersjonowanego semantycznie pakietu o nazwie
„Drabina”. W czasie, gdy Wóz strażacki jest tworzony, Drabina jest w wersji
3.1.0. Jako że Wóz strażacki korzysta z funkcjonalności, które zostały
wprowadzone po raz pierwszy w wersji 3.1.0, możesz bezpiecznie założyć, że
wymagana wersja Drabiny jest większa lub równa 3.1.0, ale mniejsza niż 4.0.0.
Teraz gdy staną się dostępne wersje Drabiny 3.1.1 lub 3.2.0, możesz puścić je
w swoim systemie zarządzania pakietami ze świadomością, że będą one kompatybilne
z istniejącym zależnym oprogramowaniem.\nJako odpowiedzialny programista musisz oczywiście zweryfikować, że każde
aktualizacje pakietów działają, jak powinny. Prawdziwy świat potrafi dać w kość;
nic nie możemy z tym zrobić poza zachowaniem czujności. To, co ty możesz zrobić,
to pozwolić by wersjonowanie semantyczne dostarczyło ci rozsądną metodę
wydawania i aktualizowania pakietów bez konieczności wydawania nowych
wersji pakietów zależnych, oszczędzającą ci czas i wysiłek.\nJeśli to wszystko brzmi zachęcająco, wszystko, co musisz zrobić, aby korzystać
z wersjonowania semantycznego, to zadeklarować się, że będziesz to robić,
a następnie przestrzegać zasad. Podlinkuj tę stronę w swoim README, aby inni
znali te zasady i mogli z nich korzystać.\nCzęsto zadawane pytania\nJak powinienem zajmować się wersjami w 0.y.z początkowej fazie rozwoju?\nNajprościej jest zacząć swoje wydanie początkowej fazy rozwoju od 0.1.0,
a następnie zwiększać wersję minor dla każdego kolejnego wydania.\nSkąd mam wiedzieć, kiedy wydać 1.0.0?\nJeśli twoje oprogramowanie jest w użyciu w produkcji, powinno prawdopodobnie już
być 1.0.0. Jeśli masz stabilne API, z którego zaczęli korzystać użytkownicy,
powinieneś mieć 1.0.0. Jeśli dużo się martwisz o kompatybilność wstecz,
powinieneś prawdopodobnie już mieć 1.0.0.\nCzy nie opóźnia to szybkiego rozwoju i szybkiej iteracji?\nW wersji major zero chodzi o szybki rozwój. Jeśli zmieniasz API codziennie,
powinieneś albo być wciąż w wersji 0.y.z, albo w oddzielnej gałęzi rozwoju,
pracując nad nową wersją major.\nJeśli nawet najmniejsze niekompatybilne wstecz zmiany w publicznym API wymagają podbicia wersji major, czy bardzo szybko nie skończę na wersji 42.0.0?\nTo jest kwestia odpowiedzialnego programowania i dalekowzroczności.
Niekompatybilne zmiany nie powinny być wprowadzane z lekkością do
oprogramowania, które jest zależnością w wielu miejscach. Koszt, który trzeba
ponieść, by zaktualizować pakiet, może być znamienny. Konieczność podbijania
wersji major przy wprowadzaniu niekompatybilnych zmian powoduje, że będziesz
myślał przez pryzmat siły oddziaływania swoich zmian i szacował stosunek
poniesionych kosztów do zysków.\nStworzenie dokumentacji całego publicznego API to zbyt dużo pracy!\nJako profesjonalny programista jesteś odpowiedzialny za prawidłową dokumentację
oprogramowania, które jest przeznaczone do użytku przez innych. Zarządzanie
złożonością oprogramowania jest niezwykle ważną częścią utrzymania sprawności
projektu, a jest to trudne do zrobienia, jeśli nikt nie wie, jak używać twojego
oprogramowania albo z których metod jest bezpiecznie korzystać. Na dłuższą metę
wersjonowanie semantyczne oraz obstawanie przy dobrze zdefiniowanym publicznym
API pozwoli wszystkim i wszystkiemu działać płynnie.\nCo zrobić, jeśli przez przypadek wypuściłem niekompatybilną wstecz zmianę jako wersję minor?\nJak tylko odkryjesz, że zaburzyłeś specyfikację semantycznego wersjonowania,
napraw ten błąd i wydaj nową wersję minor, która niweluje błąd i przywraca
wsteczną kompatybilność. Nawet w takich okolicznościach niedopuszczalne jest
modyfikowanie wydanej wersji. Jeśli możesz, opisz błędną wersję i poinformuj
użytkowników o problemie, aby byli świadomi, że ta wersja jest błędna.\nCo powinienem zrobić, jeśli aktualizuję własne zależności bez zmiany publicznego API?\nTaka aktualizacja jest uznawana za kompatybilną, gdyż nie narusza publicznego
API. Oprogramowanie, które opiera się na tych samych zależnościach co twój
pakiet, powinno mieć własną specyfikację zależności, a jego autor zauważy
konflikt. Ustalenie, czy zmiana jest na poziomie patch lub, czy jest modyfikacją
na poziomie minor, zależy od tego, czy zaktualizowałeś zależności w celu naprawy
błędu, czy w celu wprowadzenia nowej funkcjonalności. Zazwyczaj spodziewałbym
się dodatkowego kodu w tym drugim przypadku, co oczywiście oznacza zwiększenie
wersji minor.\nCo zrobić, gdy nieumyślnie zmieniłem publiczne API w taki sposób, że nie jest już zgodne ze zmianą numeru wersji (tj. kod nieprawidłowo wprowadza zmianę major w wydaniu patch)?\nPostępuj zgodnie z rozsądkiem. Jeśli oprogramowanie używane jest przez wielu
użytkowników, dla których zmiana publicznego API do poprzednio zamierzonego
stanu może być dużym uderzeniem, lepiej jest wypuścić nową wersję major, nawet
jeśli problem mógłby być rozwiązany wydaniem wersji patch. Należy pamiętać, że
w semantycznym wersjonowaniu chodzi przede wszystkim o przekazanie znaczenia
zmiany poprzez zmianę numeru wersji. Jeśli zmiany są ważne dla użytkowników,
poinformuj ich o tym poprzez numer wersji.\nJak powinienem radzić sobie z dezaprobowaniem funkcjonalności?\nDezaprobowanie istniejącej funkcjonalności jest normalną częścią programowania
i często jest konieczne, by móc rozwijać oprogramowanie. Gdy wycofujesz część
swojego publicznego API, powinieneś zrobić dwie rzeczy: (1) zaktualizować
dokumentację, by użytkownicy wiedzieli o tej zmianie, (2) wypuścić nowe wydanie
minor z informacją o zdezaprobowaniu. Zanim całkowicie usuniesz funkcjonalność
w nowym wydaniu major, powinno być co najmniej jedno wydanie minor zawierające
informację o zdezaprobowaniu, aby użytkownicy mogli płynnie przejść na nowe API.\nCzy SemVer ma limit długości na oznaczenie wersji?\nNie, ale miej zdrowy rozsądek. Na przykład numer wersji długi na 255 znaków to
prawdopodobnie przesada. Ponadto konkretne systemy mogą narzucać swoje własne
ograniczenia na rozmiar tego ciągu znaków.\nCzy ciąg „v1.2.3” spełnia zasady?\nNie, „v1.2.3” nie jest zgodne z wersjonowaniem semantycznym. Jednak przedrostek „v” jest
zazwyczaj używany w języku angielskim do oznaczenia, że mamy do czynienia z numerem wersji.
Skrót „v” od angielskiego słowa „version” jest często spotykany w systemach kontroli wersji.
Przykładowo, w przypadku git tag v1.2.3 -m "Release version 1.2.3", „v1.2.3” jest nazwą taga,
a semantyczna wersja to „1.2.3”.\nCzy istnieje sugerowane wyrażenie regularne (RegEx) do weryfikacji porawności SemVer?\nIstnieją dwa. Pierwsze wykorzystuje grupy nazwane i jest przeznaczone dla systemów, które
wspierają tę funkcjonalność (PCRE [Perl Compatible Regular Expressions, np. Perl, PHP i R], Python czy Go).\nPatrz: https://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nDruga wykorzystuje numerowane grupy przechwytujące (wzór gp1 = major, gp2 = minor, gp3 = patch, gp4 = przedpremierowa i gp5 =
meta-dane buildu) i jest kompatybilna z ECMA Script (JavaScript), PCRE [Perl Compatible Regular Expressions, np. Perl, PHP i R],
Python czy Go.\nPatrz: https://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nAutorem specyfikacji wersjonowania semantycznego jest
Tom Preston-Werner, wynalazca Gravatara
i współzałożyciel GitHuba.\nJeśli chcesz podzielić się opinią, prosimy
o otworzenie zgłoszenia na GitHubie.\notworzenie zgłoszenia na GitHubie\nCreative Commons – CC BY 3.0.\nCreative Commons – CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nVersionamento Semântico 2.0.0

Sumário

Dado um número de versão MAJOR.MINOR.PATCH, incremente a:


  versão Maior(MAJOR): quando fizer mudanças incompatíveis na API,
  versão Menor(MINOR): quando adicionar funcionalidades mantendo 
compatibilidade, e
  versão de Correção(PATCH): quando corrigir falhas mantendo compatibilidade.


Rótulos adicionais para pré-lançamento(pre-release) e metadados de 
construção(build) estão disponíveis como extensão ao formato MAJOR.MINOR.PATCH.

Introdução

No mundo de gerenciamento de software existe algo terrível conhecido como
inferno das dependências (“dependency hell”). Quanto mais o sistema cresce, e 
mais pacotes são adicionados a ele, maior será a possibilidade de, um dia, você
encontrar-se neste poço de desespero.

Em sistemas com muitas dependências, lançar novos pacotes de versões pode se
tornar rapidamente um pesadelo. Se as especificações das dependências são muito
amarradas você corre o risco de um bloqueio de versão (A falta de capacidade de
atualizar um pacote sem ter de liberar novas versões de cada pacote dependente).
Se as dependências são vagamente especificadas, você irá inevitavelmente ser
mordido pela ‘promiscuidade da versão’ (assumindo compatibilidade com futuras
versões mais do que é razoável). O inferno das dependências é onde você está
quando um bloqueio de versão e/ou promiscuidade de versão te impede de seguir
em frente com seu projeto de maneira fácil e segura.

Como uma solução para este problema proponho um conjunto simples de regras e
requisitos que ditam como os números das versões são atribuídos e incrementados.

Essas regras são baseadas em, mas não necessariamente limitadas às, bem 
difundidas práticas comumente em uso tanto em softwares fechados como 
open-source.
Para que este sistema funcione, primeiro você precisa declarar uma API pública.
Isto pode consistir de documentação ou ser determinada pelo próprio código. De
qualquer maneira, é importante que esta API seja clara e precisa. Depois de
identificada a API pública, você comunica as mudanças com incrementos
específicos para o seu número de versão. Considere o formato de versão X.Y.Z
(Maior.Menor.Correção). Correção de falhas (bug fixes) que não afetam a API,
incrementa a versão de Correção, adições/alterações compatíveis com as versões
anteriores da API incrementa a versão Menor, e alterações incompatíveis com as
versões anteriores da API incrementa a versão Maior.

Eu chamo esse sistema de “Versionamento Semântico”. Sob este esquema, os números
de versão e a forma como eles mudam transmitem o significado do código
subjacente e o que foi modificado de uma versão para a próxima.

Especificação de Versionamento Semântico (SemVer)

As palavras-chaves “DEVE”, “NÃO DEVE”, “OBRIGATÓRIO”, “DEVERÁ”, “NÃO DEVERÁ”,
“PODEM”, “NÃO PODEM”, “RECOMENDADO”, “PODE” e “OPCIONAL” no presente 
documento devem ser interpretados como descrito na RFC 2119.


  
    Software usando Versionamento Semântico DEVE declarar uma API pública. Esta 
API poderá ser declarada no próprio código ou existir estritamente na 
documentação, desde que seja precisa e compreensiva.
  
  
    Um número de versão normal DEVE ter o formato de X.Y.Z, onde X, Y, e Z são
inteiros não negativos, e NÃO DEVE conter zeros à esquerda. X é a versão Maior,
Y é a versão Menor, e Z é a versão de Correção. Cada elemento DEVE aumentar 
numericamente. Por exemplo: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Uma vez que um pacote versionado foi lançado(released), o conteúdo desta
versão NÃO DEVE ser modificado. Qualquer modificação DEVE ser lançado como uma
nova versão.
  
  
    No início do desenvolvimento, a versão Maior DEVE ser zero (0.y.z). Qualquer
coisa PODE mudar a qualquer momento. A API pública NÃO DEVE ser considerada
estável.
  
  
    Versão 1.0.0 define a API como pública. A maneira como o número de versão é
incrementado após este lançamento é dependente da API pública e como ela muda.
  
  
    Versão de Correção Z (x.y.Z | x > 0) DEVE ser incrementado apenas se mantiver
compatibilidade e introduzir correção de bugs. Uma correção de bug é definida
como uma mudança interna que corrige um comportamento incorreto.
  
  
    Versão Menor Y (x.Y.z | x > 0) DEVE  ser incrementada se uma funcionalidade
nova e compatível for introduzida na API pública. DEVE ser incrementada se
qualquer funcionalidade da API pública for definida como descontinuada. PODE ser
incrementada se uma nova funcionalidade ou melhoria substancial for introduzida
dentro do código privado. PODE incluir mudanças a nível de correção. A versão de
Correção DEVE ser redefinida para 0(zero) quando a versão Menor for 
incrementada.
  
  
    Versão Maior X (X.y.z | X > 0) DEVE ser incrementada se forem introduzidas
mudanças incompatíveis na API pública. PODE incluir alterações a nível de versão
Menor e de versão de Correção. Versão de Correção e Versão Menor DEVEM ser 
redefinidas para 0(zero) quando a versão Maior for incrementada.
  
  
    Uma versão de Pré-Lançamento (pre-release) PODE ser identificada adicionando
um hífen (dash) e uma série de identificadores separados por ponto (dot)
imediatamente após a versão de Correção. Identificador DEVE incluir apenas
caracteres alfanuméricos e hífen [0-9A-Za-z-]. Identificador NÃO DEVE ser 
vazio. Indicador numérico NÃO DEVE incluir zeros à esquerda. Versão de
Pré-Lançamento tem precedência inferior à versão normal a que está associada.
Uma versão de Pré-Lançamento (pre-release) indica que a versão é instável e pode
não satisfazer os requisitos de compatibilidade pretendidos, como indicado por
sua versão normal associada. Exemplos: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.
  
  
    Metadados de construção(Build) PODE ser identificada por adicionar um
sinal de adição (+) e uma série de identificadores separados por ponto
imediatamente após a Correção ou Pré-Lançamento. Identificador DEVE 
ser composto apenas por caracteres alfanuméricos e hífen [0-9A-Za-z-].
Identificador NÃO DEVE ser vazio.  Metadados de construção PODEM ser ignorados 
quando se determina a versão de precedência. Assim, duas versões que diferem 
apenas nos metadados de construção, têm a mesma precedência. Exemplos:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    A precedência refere como as versões são comparadas uma com a outra quando 
solicitado.
  
  
    A precedência DEVE ser calculada separando identificadores de versão em Maior, Menor, Correção e Pré-lançamento, nesta ordem. (Metadados de construção não faz parte da precedência).

    
      
        A precedência é determinada pela primeira diferença quando se compara cada identificador da esquerda para 
 direita, como se segue: Versões Maior, Menor e Correção são sempre comparadas numericamente.

        Exemplo: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Quando Maior, Menor e Correção são iguais, a versão de Pré-Lançamento tem precedência menor que a versão normal.

        Exemplo: 1.0.0-alpha < 1.0.0.
      
      
        A precedência entre duas versões de Pré-lançamento com mesma versão Maior, Menor e Correção DEVE ser determinada comparando cada identificador separado por ponto da esquerda para direita até que seja encontrada diferença da seguinte forma:

        
          
            Identificadores consistindo apenas dígitos são comparados numericamente.
          
          
            Identificadores com letras ou hífen são comparados lexicalmente na ordem de classificação ASCII.
          
          
            Identificadores numéricos sempre têm menor precedência do que os não numéricos.
          
          
            Um conjunto maior de campos de pré-lançamento tem uma precedência maior do que
  um conjunto menor, se todos os identificadores anteriores são iguais.
          
        

        Exemplo: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
      
    
  


Por que usar Versionamento Semântico?
Esta não é uma ideia nova ou revolucionária. De fato, você provavelmente já faz
algo próximo a isso. O problema é que “próximo” não é bom o bastante. Sem a
aderência a algum tipo de especificação formal, os números de versão são
essencialmente inúteis para gerenciamento de dependências. Dando um nome e
definições claras às ideias acima, fica fácil comunicar suas intenções aos
usuários de seu software. Uma vez que estas intenções estão claras,
especificações de dependências flexíveis (mas não tão flexíveis) finalmente
podem ser feitas.

Um exemplo simples vai demonstrar como o Versionamento Semântico pode fazer do
inferno de dependência uma coisa do passado. Considere uma biblioteca chamada
“CaminhaoBombeiros”. Ela requer um pacote versionado dinamicamente chamado
“Escada”. Quando CaminhaoBombeiros foi criado, Escada estava na versão 3.1.0.
Como CaminhaoBombeiros utiliza algumas funcionalidades que foram inicialmente
introduzidas na versão 3.1.0, você pode especificar, com segurança, a
dependência da Escada como maior ou igual a 3.1.0 porém menor que 4.0.0. Agora,
quando Escada versão 3.1.1 e 3.2.0 estiverem disponíveis, você poderá lança-los
ao seu sistema de gerenciamento de pacote e saberá que eles serão compatíveis
com os softwares dependentes existentes.

Como um desenvolvedor responsável você irá, é claro, querer certificar-se que
qualquer atualização no pacote funcionará como anunciado. O mundo real é um
lugar bagunçado; não há nada que possamos fazer quanto a isso senão sermos
vigilantes. O que você pode fazer é deixar o Versionamento Semântico lhe
fornecer uma maneira sensata de lançar e atualizar pacotes sem precisar
atualizar para novas versões de pacotes dependentes, salvando-lhe tempo e
aborrecimento.

Se tudo isto soa desejável, tudo que você precisar fazer para começar a usar
Versionamento Semântico é declarar que você o esta usando e então, seguir as
regras. Adicione um link para este website no seu README para que outros saibam
as regras e possam beneficiar-se delas.

FAQ

Como devo lidar com revisões na fase 0.y.z de desenvolvimento inicial?

A coisa mais simples a se fazer é começar sua versão de desenvolvimento inicial
em 0.1.0 e, então, incrementar a uma versão ‘menor’ em cada lançamento
subsequente.

Como eu sei quando lançar a versão 1.0.0?

Se seu software está sendo usado em produção, ele já deve ser provavelmente
1.0.0. Se você possui uma API estável a qual usuários passaram a depender, deve
ser 1.0.0. Se você está se preocupando bastante com compatibilidade com versões
anteriores, já deve ser 1.0.0.

Isto não desencoraja o desenvolvimento ágil e iteração rápida?

A versão Maior zero tem o foco exatamente no desenvolvimento rápido. Se você
está mudando a API todo dia, provavelmente você está na versão 0.y.z ou num
branch separado de desenvolvimento, trabalhando numa próxima versão Maior.

Se mesmo a menor mudança incompatível com a API pública requer aumento da versão maior, não vou acabar na versão 42.0.0 muito rapidamente?

Esta é uma questão de desenvolvimento responsável e conhecimento antecipado.
Mudanças incompatíveis não devem ser levemente introduzidas para o software que
tem um monte de código dependente. O custo que deve ser incorrido para atualizar
pode ser significante. Tendo que aumentar a versão maior para lançar mudanças
incompatíveis, significa que você pensará no impacto das suas mudanças, e 
avaliará a relação de custo/benefício envolvida.

Documentar toda a API pública dá muito trabalho!

É sua responsabilidade como desenvolvedor profissional documentar corretamente o
software que será usado por outros. Gerenciar a complexidade de software é uma
parte muito importante para manter o projeto eficiente, e isto é difícil de
fazer se ninguém sabe como usá-lo ou que métodos são seguros de chamar. A longo
prazo, Versionamento Semântico e a insistência em uma API pública bem definida
podem deixar tudo e todos funcionando suavemente.

O que eu faço se, acidentalmente, liberar uma mudança incompatível com versões anteriores como uma versão menor (minor version)?

Assim que você perceber que quebrou a especificação de versionamento semântico,
conserte o problema e lance uma nova versão menor, que corrige o problema e
restaura a compatibilidade. Mesmo sob esta circunstância, é inaceitável 
modificar versões lançadas. Se for apropriado, documente a versão ofensiva e
informe seus usuários do problema de forma que eles fiquem cientes da versão em
questão.

O que devo fazer se eu atualizar minhas próprias dependências sem modificar a API pública?

Isso seria considerado compatível, uma vez que não afeta a API pública. Software
que depende explicitamente da mesmas dependências que seu pacote, deve ter sua
própria especificação de dependência e o autor notificará quaisquer conflitos.
Para determinar se a mudança é a nível de correção ou modificação de nível menor
dependente se você atualizou suas dependências a fim de corrigir um bug ou
introduzir nova funcionalidade. Eu normalmente esperaria código adicional para 
última instância, caso em que é obviamente um incremento no nível menor.

E se eu alterei inadvertidamente a API pública de forma incompatível com a mudança no número de versão (ex.: o código incorretamente introduz uma grande mudança incompatível em  liberação de um patch)

Use o bom senso. Se você tem um público enorme que será drasticamente impactado
pela mudança de comportamento de volta para o que a API pública pretendida, 
então pode ser melhor realizar um lançamento de uma versão maior, mesmo que a 
correção pudesse ser considerada estritamente uma versão de correção. Lembre-se, 
Versionamento Semântico trata de transmitir o conhecimento das mudanças 
ocorridas na versão. Se estas mudanças são importantes para seus usuários, 
utilize o número da versão para informá-los.

Como devo lidar com descontinuação de funcionalidades?

Descontinuar funcionalidades é um processo comum no desenvolvimento de software 
e muitas vezes é necessário para haver progresso. Quando você descontinua partes
de sua API pública, você deve fazer duas coisas: (1) atualizar sua documentação,
para que os usuários saibam das mudanças, (2) lançar uma versão Menor anunciando
a descontinuação. Antes de remover completamente a funcionalidade em uma versão 
Maior deve haver ao menos uma versão Menor que possui a descontinução anunciada, 
fazendo com que os usuários realizem uma transição tranquila para a nova API.

O SemVer tem um limite de tamanho para string de versão?

Não, mas use o bom senso. Uma string de versão com 255 caracteres por exemplo,
provavelmente é um exagero. Porém, sistemas específicos podem definir seus 
prórios limites para o tamanho da string.

Sobre

A Especificação da Semântica de Versionamento é autoria de Tom
Preston-Werner, criador do Gravatar e 
co-fundador do GitHub.

A tradução deste documento para Português-Brasil foi iniciada de forma 
colaborativa pela Wend Tecnologia através
de Walker de Alencar Oliveira e teve a 
participação de:


  William G. Comnisky
  Rafael Sirotheau
  Arthur Almeida
  Alberto Guimarães Viana
  Rafael Lúcio
  Josiel Rocha
  Alessandro Leite
  Vinícius Assef
  Silas Ribas Martins
  Lucas Honda Tonini


Toda colaboração na tradução pode ser acompanhada no link:
http://pad.okfn.org/p/Fh9hjBPVu9

Caso queira deixar sua opinião, por favor abra uma issue no GitHub.

Licença

Creative Commons ― CC BY 3.0\nVersionamento Semântico 2.0.0\nDado um número de versão MAJOR.MINOR.PATCH, incremente a:\nversão Maior(MAJOR): quando fizer mudanças incompatíveis na API,\nversão Menor(MINOR): quando adicionar funcionalidades mantendo 
compatibilidade, e\nversão de Correção(PATCH): quando corrigir falhas mantendo compatibilidade.\nRótulos adicionais para pré-lançamento(pre-release) e metadados de 
construção(build) estão disponíveis como extensão ao formato MAJOR.MINOR.PATCH.\nNo mundo de gerenciamento de software existe algo terrível conhecido como
inferno das dependências (“dependency hell”). Quanto mais o sistema cresce, e 
mais pacotes são adicionados a ele, maior será a possibilidade de, um dia, você
encontrar-se neste poço de desespero.\nEm sistemas com muitas dependências, lançar novos pacotes de versões pode se
tornar rapidamente um pesadelo. Se as especificações das dependências são muito
amarradas você corre o risco de um bloqueio de versão (A falta de capacidade de
atualizar um pacote sem ter de liberar novas versões de cada pacote dependente).
Se as dependências são vagamente especificadas, você irá inevitavelmente ser
mordido pela ‘promiscuidade da versão’ (assumindo compatibilidade com futuras
versões mais do que é razoável). O inferno das dependências é onde você está
quando um bloqueio de versão e/ou promiscuidade de versão te impede de seguir
em frente com seu projeto de maneira fácil e segura.\nComo uma solução para este problema proponho um conjunto simples de regras e
requisitos que ditam como os números das versões são atribuídos e incrementados.\nEssas regras são baseadas em, mas não necessariamente limitadas às, bem 
difundidas práticas comumente em uso tanto em softwares fechados como 
open-source.
Para que este sistema funcione, primeiro você precisa declarar uma API pública.
Isto pode consistir de documentação ou ser determinada pelo próprio código. De
qualquer maneira, é importante que esta API seja clara e precisa. Depois de
identificada a API pública, você comunica as mudanças com incrementos
específicos para o seu número de versão. Considere o formato de versão X.Y.Z
(Maior.Menor.Correção). Correção de falhas (bug fixes) que não afetam a API,
incrementa a versão de Correção, adições/alterações compatíveis com as versões
anteriores da API incrementa a versão Menor, e alterações incompatíveis com as
versões anteriores da API incrementa a versão Maior.\nEu chamo esse sistema de “Versionamento Semântico”. Sob este esquema, os números
de versão e a forma como eles mudam transmitem o significado do código
subjacente e o que foi modificado de uma versão para a próxima.\nEspecificação de Versionamento Semântico (SemVer)\nAs palavras-chaves “DEVE”, “NÃO DEVE”, “OBRIGATÓRIO”, “DEVERÁ”, “NÃO DEVERÁ”,
“PODEM”, “NÃO PODEM”, “RECOMENDADO”, “PODE” e “OPCIONAL” no presente 
documento devem ser interpretados como descrito na RFC 2119.\nSoftware usando Versionamento Semântico DEVE declarar uma API pública. Esta 
API poderá ser declarada no próprio código ou existir estritamente na 
documentação, desde que seja precisa e compreensiva.\nSoftware usando Versionamento Semântico DEVE declarar uma API pública. Esta 
API poderá ser declarada no próprio código ou existir estritamente na 
documentação, desde que seja precisa e compreensiva.\nUm número de versão normal DEVE ter o formato de X.Y.Z, onde X, Y, e Z são
inteiros não negativos, e NÃO DEVE conter zeros à esquerda. X é a versão Maior,
Y é a versão Menor, e Z é a versão de Correção. Cada elemento DEVE aumentar 
numericamente. Por exemplo: 1.9.0 -> 1.10.0 -> 1.11.0.\nUm número de versão normal DEVE ter o formato de X.Y.Z, onde X, Y, e Z são
inteiros não negativos, e NÃO DEVE conter zeros à esquerda. X é a versão Maior,
Y é a versão Menor, e Z é a versão de Correção. Cada elemento DEVE aumentar 
numericamente. Por exemplo: 1.9.0 -> 1.10.0 -> 1.11.0.\nUma vez que um pacote versionado foi lançado(released), o conteúdo desta
versão NÃO DEVE ser modificado. Qualquer modificação DEVE ser lançado como uma
nova versão.\nUma vez que um pacote versionado foi lançado(released), o conteúdo desta
versão NÃO DEVE ser modificado. Qualquer modificação DEVE ser lançado como uma
nova versão.\nNo início do desenvolvimento, a versão Maior DEVE ser zero (0.y.z). Qualquer
coisa PODE mudar a qualquer momento. A API pública NÃO DEVE ser considerada
estável.\nNo início do desenvolvimento, a versão Maior DEVE ser zero (0.y.z). Qualquer
coisa PODE mudar a qualquer momento. A API pública NÃO DEVE ser considerada
estável.\nVersão 1.0.0 define a API como pública. A maneira como o número de versão é
incrementado após este lançamento é dependente da API pública e como ela muda.\nVersão 1.0.0 define a API como pública. A maneira como o número de versão é
incrementado após este lançamento é dependente da API pública e como ela muda.\nVersão de Correção Z (x.y.Z | x > 0) DEVE ser incrementado apenas se mantiver
compatibilidade e introduzir correção de bugs. Uma correção de bug é definida
como uma mudança interna que corrige um comportamento incorreto.\nVersão de Correção Z (x.y.Z | x > 0) DEVE ser incrementado apenas se mantiver
compatibilidade e introduzir correção de bugs. Uma correção de bug é definida
como uma mudança interna que corrige um comportamento incorreto.\nVersão Menor Y (x.Y.z | x > 0) DEVE  ser incrementada se uma funcionalidade
nova e compatível for introduzida na API pública. DEVE ser incrementada se
qualquer funcionalidade da API pública for definida como descontinuada. PODE ser
incrementada se uma nova funcionalidade ou melhoria substancial for introduzida
dentro do código privado. PODE incluir mudanças a nível de correção. A versão de
Correção DEVE ser redefinida para 0(zero) quando a versão Menor for 
incrementada.\nVersão Menor Y (x.Y.z | x > 0) DEVE  ser incrementada se uma funcionalidade
nova e compatível for introduzida na API pública. DEVE ser incrementada se
qualquer funcionalidade da API pública for definida como descontinuada. PODE ser
incrementada se uma nova funcionalidade ou melhoria substancial for introduzida
dentro do código privado. PODE incluir mudanças a nível de correção. A versão de
Correção DEVE ser redefinida para 0(zero) quando a versão Menor for 
incrementada.\nVersão Maior X (X.y.z | X > 0) DEVE ser incrementada se forem introduzidas
mudanças incompatíveis na API pública. PODE incluir alterações a nível de versão
Menor e de versão de Correção. Versão de Correção e Versão Menor DEVEM ser 
redefinidas para 0(zero) quando a versão Maior for incrementada.\nVersão Maior X (X.y.z | X > 0) DEVE ser incrementada se forem introduzidas
mudanças incompatíveis na API pública. PODE incluir alterações a nível de versão
Menor e de versão de Correção. Versão de Correção e Versão Menor DEVEM ser 
redefinidas para 0(zero) quando a versão Maior for incrementada.\nUma versão de Pré-Lançamento (pre-release) PODE ser identificada adicionando
um hífen (dash) e uma série de identificadores separados por ponto (dot)
imediatamente após a versão de Correção. Identificador DEVE incluir apenas
caracteres alfanuméricos e hífen [0-9A-Za-z-]. Identificador NÃO DEVE ser 
vazio. Indicador numérico NÃO DEVE incluir zeros à esquerda. Versão de
Pré-Lançamento tem precedência inferior à versão normal a que está associada.
Uma versão de Pré-Lançamento (pre-release) indica que a versão é instável e pode
não satisfazer os requisitos de compatibilidade pretendidos, como indicado por
sua versão normal associada. Exemplos: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.\nUma versão de Pré-Lançamento (pre-release) PODE ser identificada adicionando
um hífen (dash) e uma série de identificadores separados por ponto (dot)
imediatamente após a versão de Correção. Identificador DEVE incluir apenas
caracteres alfanuméricos e hífen [0-9A-Za-z-]. Identificador NÃO DEVE ser 
vazio. Indicador numérico NÃO DEVE incluir zeros à esquerda. Versão de
Pré-Lançamento tem precedência inferior à versão normal a que está associada.
Uma versão de Pré-Lançamento (pre-release) indica que a versão é instável e pode
não satisfazer os requisitos de compatibilidade pretendidos, como indicado por
sua versão normal associada. Exemplos: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.\nMetadados de construção(Build) PODE ser identificada por adicionar um
sinal de adição (+) e uma série de identificadores separados por ponto
imediatamente após a Correção ou Pré-Lançamento. Identificador DEVE 
ser composto apenas por caracteres alfanuméricos e hífen [0-9A-Za-z-].
Identificador NÃO DEVE ser vazio.  Metadados de construção PODEM ser ignorados 
quando se determina a versão de precedência. Assim, duas versões que diferem 
apenas nos metadados de construção, têm a mesma precedência. Exemplos:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nMetadados de construção(Build) PODE ser identificada por adicionar um
sinal de adição (+) e uma série de identificadores separados por ponto
imediatamente após a Correção ou Pré-Lançamento. Identificador DEVE 
ser composto apenas por caracteres alfanuméricos e hífen [0-9A-Za-z-].
Identificador NÃO DEVE ser vazio.  Metadados de construção PODEM ser ignorados 
quando se determina a versão de precedência. Assim, duas versões que diferem 
apenas nos metadados de construção, têm a mesma precedência. Exemplos:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nA precedência refere como as versões são comparadas uma com a outra quando 
solicitado.\nA precedência refere como as versões são comparadas uma com a outra quando 
solicitado.\nA precedência DEVE ser calculada separando identificadores de versão em Maior, Menor, Correção e Pré-lançamento, nesta ordem. (Metadados de construção não faz parte da precedência).

    
      
        A precedência é determinada pela primeira diferença quando se compara cada identificador da esquerda para 
 direita, como se segue: Versões Maior, Menor e Correção são sempre comparadas numericamente.

        Exemplo: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Quando Maior, Menor e Correção são iguais, a versão de Pré-Lançamento tem precedência menor que a versão normal.

        Exemplo: 1.0.0-alpha < 1.0.0.
      
      
        A precedência entre duas versões de Pré-lançamento com mesma versão Maior, Menor e Correção DEVE ser determinada comparando cada identificador separado por ponto da esquerda para direita até que seja encontrada diferença da seguinte forma:

        
          
            Identificadores consistindo apenas dígitos são comparados numericamente.
          
          
            Identificadores com letras ou hífen são comparados lexicalmente na ordem de classificação ASCII.
          
          
            Identificadores numéricos sempre têm menor precedência do que os não numéricos.
          
          
            Um conjunto maior de campos de pré-lançamento tem uma precedência maior do que
  um conjunto menor, se todos os identificadores anteriores são iguais.
          
        

        Exemplo: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nA precedência DEVE ser calculada separando identificadores de versão em Maior, Menor, Correção e Pré-lançamento, nesta ordem. (Metadados de construção não faz parte da precedência).\nA precedência é determinada pela primeira diferença quando se compara cada identificador da esquerda para 
 direita, como se segue: Versões Maior, Menor e Correção são sempre comparadas numericamente.

        Exemplo: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nA precedência é determinada pela primeira diferença quando se compara cada identificador da esquerda para 
 direita, como se segue: Versões Maior, Menor e Correção são sempre comparadas numericamente.\nExemplo: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nQuando Maior, Menor e Correção são iguais, a versão de Pré-Lançamento tem precedência menor que a versão normal.

        Exemplo: 1.0.0-alpha < 1.0.0.\nQuando Maior, Menor e Correção são iguais, a versão de Pré-Lançamento tem precedência menor que a versão normal.\nExemplo: 1.0.0-alpha < 1.0.0.\nA precedência entre duas versões de Pré-lançamento com mesma versão Maior, Menor e Correção DEVE ser determinada comparando cada identificador separado por ponto da esquerda para direita até que seja encontrada diferença da seguinte forma:

        
          
            Identificadores consistindo apenas dígitos são comparados numericamente.
          
          
            Identificadores com letras ou hífen são comparados lexicalmente na ordem de classificação ASCII.
          
          
            Identificadores numéricos sempre têm menor precedência do que os não numéricos.
          
          
            Um conjunto maior de campos de pré-lançamento tem uma precedência maior do que
  um conjunto menor, se todos os identificadores anteriores são iguais.
          
        

        Exemplo: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nA precedência entre duas versões de Pré-lançamento com mesma versão Maior, Menor e Correção DEVE ser determinada comparando cada identificador separado por ponto da esquerda para direita até que seja encontrada diferença da seguinte forma:\nIdentificadores consistindo apenas dígitos são comparados numericamente.\nIdentificadores consistindo apenas dígitos são comparados numericamente.\nIdentificadores com letras ou hífen são comparados lexicalmente na ordem de classificação ASCII.\nIdentificadores com letras ou hífen são comparados lexicalmente na ordem de classificação ASCII.\nIdentificadores numéricos sempre têm menor precedência do que os não numéricos.\nIdentificadores numéricos sempre têm menor precedência do que os não numéricos.\nUm conjunto maior de campos de pré-lançamento tem uma precedência maior do que
  um conjunto menor, se todos os identificadores anteriores são iguais.\nUm conjunto maior de campos de pré-lançamento tem uma precedência maior do que
  um conjunto menor, se todos os identificadores anteriores são iguais.\nExemplo: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPor que usar Versionamento Semântico?\nEsta não é uma ideia nova ou revolucionária. De fato, você provavelmente já faz
algo próximo a isso. O problema é que “próximo” não é bom o bastante. Sem a
aderência a algum tipo de especificação formal, os números de versão são
essencialmente inúteis para gerenciamento de dependências. Dando um nome e
definições claras às ideias acima, fica fácil comunicar suas intenções aos
usuários de seu software. Uma vez que estas intenções estão claras,
especificações de dependências flexíveis (mas não tão flexíveis) finalmente
podem ser feitas.\nUm exemplo simples vai demonstrar como o Versionamento Semântico pode fazer do
inferno de dependência uma coisa do passado. Considere uma biblioteca chamada
“CaminhaoBombeiros”. Ela requer um pacote versionado dinamicamente chamado
“Escada”. Quando CaminhaoBombeiros foi criado, Escada estava na versão 3.1.0.
Como CaminhaoBombeiros utiliza algumas funcionalidades que foram inicialmente
introduzidas na versão 3.1.0, você pode especificar, com segurança, a
dependência da Escada como maior ou igual a 3.1.0 porém menor que 4.0.0. Agora,
quando Escada versão 3.1.1 e 3.2.0 estiverem disponíveis, você poderá lança-los
ao seu sistema de gerenciamento de pacote e saberá que eles serão compatíveis
com os softwares dependentes existentes.\nComo um desenvolvedor responsável você irá, é claro, querer certificar-se que
qualquer atualização no pacote funcionará como anunciado. O mundo real é um
lugar bagunçado; não há nada que possamos fazer quanto a isso senão sermos
vigilantes. O que você pode fazer é deixar o Versionamento Semântico lhe
fornecer uma maneira sensata de lançar e atualizar pacotes sem precisar
atualizar para novas versões de pacotes dependentes, salvando-lhe tempo e
aborrecimento.\nSe tudo isto soa desejável, tudo que você precisar fazer para começar a usar
Versionamento Semântico é declarar que você o esta usando e então, seguir as
regras. Adicione um link para este website no seu README para que outros saibam
as regras e possam beneficiar-se delas.\nComo devo lidar com revisões na fase 0.y.z de desenvolvimento inicial?\nA coisa mais simples a se fazer é começar sua versão de desenvolvimento inicial
em 0.1.0 e, então, incrementar a uma versão ‘menor’ em cada lançamento
subsequente.\nComo eu sei quando lançar a versão 1.0.0?\nSe seu software está sendo usado em produção, ele já deve ser provavelmente
1.0.0. Se você possui uma API estável a qual usuários passaram a depender, deve
ser 1.0.0. Se você está se preocupando bastante com compatibilidade com versões
anteriores, já deve ser 1.0.0.\nIsto não desencoraja o desenvolvimento ágil e iteração rápida?\nA versão Maior zero tem o foco exatamente no desenvolvimento rápido. Se você
está mudando a API todo dia, provavelmente você está na versão 0.y.z ou num
branch separado de desenvolvimento, trabalhando numa próxima versão Maior.\nSe mesmo a menor mudança incompatível com a API pública requer aumento da versão maior, não vou acabar na versão 42.0.0 muito rapidamente?\nEsta é uma questão de desenvolvimento responsável e conhecimento antecipado.
Mudanças incompatíveis não devem ser levemente introduzidas para o software que
tem um monte de código dependente. O custo que deve ser incorrido para atualizar
pode ser significante. Tendo que aumentar a versão maior para lançar mudanças
incompatíveis, significa que você pensará no impacto das suas mudanças, e 
avaliará a relação de custo/benefício envolvida.\nDocumentar toda a API pública dá muito trabalho!\nÉ sua responsabilidade como desenvolvedor profissional documentar corretamente o
software que será usado por outros. Gerenciar a complexidade de software é uma
parte muito importante para manter o projeto eficiente, e isto é difícil de
fazer se ninguém sabe como usá-lo ou que métodos são seguros de chamar. A longo
prazo, Versionamento Semântico e a insistência em uma API pública bem definida
podem deixar tudo e todos funcionando suavemente.\nO que eu faço se, acidentalmente, liberar uma mudança incompatível com versões anteriores como uma versão menor (minor version)?\nAssim que você perceber que quebrou a especificação de versionamento semântico,
conserte o problema e lance uma nova versão menor, que corrige o problema e
restaura a compatibilidade. Mesmo sob esta circunstância, é inaceitável 
modificar versões lançadas. Se for apropriado, documente a versão ofensiva e
informe seus usuários do problema de forma que eles fiquem cientes da versão em
questão.\nO que devo fazer se eu atualizar minhas próprias dependências sem modificar a API pública?\nIsso seria considerado compatível, uma vez que não afeta a API pública. Software
que depende explicitamente da mesmas dependências que seu pacote, deve ter sua
própria especificação de dependência e o autor notificará quaisquer conflitos.
Para determinar se a mudança é a nível de correção ou modificação de nível menor
dependente se você atualizou suas dependências a fim de corrigir um bug ou
introduzir nova funcionalidade. Eu normalmente esperaria código adicional para 
última instância, caso em que é obviamente um incremento no nível menor.\nE se eu alterei inadvertidamente a API pública de forma incompatível com a mudança no número de versão (ex.: o código incorretamente introduz uma grande mudança incompatível em  liberação de um patch)\nUse o bom senso. Se você tem um público enorme que será drasticamente impactado
pela mudança de comportamento de volta para o que a API pública pretendida, 
então pode ser melhor realizar um lançamento de uma versão maior, mesmo que a 
correção pudesse ser considerada estritamente uma versão de correção. Lembre-se, 
Versionamento Semântico trata de transmitir o conhecimento das mudanças 
ocorridas na versão. Se estas mudanças são importantes para seus usuários, 
utilize o número da versão para informá-los.\nComo devo lidar com descontinuação de funcionalidades?\nDescontinuar funcionalidades é um processo comum no desenvolvimento de software 
e muitas vezes é necessário para haver progresso. Quando você descontinua partes
de sua API pública, você deve fazer duas coisas: (1) atualizar sua documentação,
para que os usuários saibam das mudanças, (2) lançar uma versão Menor anunciando
a descontinuação. Antes de remover completamente a funcionalidade em uma versão 
Maior deve haver ao menos uma versão Menor que possui a descontinução anunciada, 
fazendo com que os usuários realizem uma transição tranquila para a nova API.\nO SemVer tem um limite de tamanho para string de versão?\nNão, mas use o bom senso. Uma string de versão com 255 caracteres por exemplo,
provavelmente é um exagero. Porém, sistemas específicos podem definir seus 
prórios limites para o tamanho da string.\nA Especificação da Semântica de Versionamento é autoria de Tom
Preston-Werner, criador do Gravatar e 
co-fundador do GitHub.\nA tradução deste documento para Português-Brasil foi iniciada de forma 
colaborativa pela Wend Tecnologia através
de Walker de Alencar Oliveira e teve a 
participação de:\nWalker de Alencar Oliveira\nAlberto Guimarães Viana\nAlberto Guimarães Viana\nToda colaboração na tradução pode ser acompanhada no link:
http://pad.okfn.org/p/Fh9hjBPVu9\nCaso queira deixar sua opinião, por favor abra uma issue no GitHub.\nabra uma issue no GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nNumerotarea Semantica a Versiunii Software 2.0.0

Sumar
Fiind dat un număr de versiune MAJOR.MINOR.PATCH, se incrementează:

  Numărul MAJOR atunci când se fac modificări ale API-ului ce nu sunt 
compatibile cu versiunea precedenta,
  Numărul MINOR atunci când se adaugă funcționalitate care nu afectează 
compatibilitatea, și
  Numărul PATCH atunci când se adaugă corectări de bug-uri care nu afectează 
compatibilitatea.


Etichete adiționale pentru pre-release și build sunt disponibile ca extensii ale 
formatului MAJOR.MINOR.PATCH.

Introducere

În lumea dezvoltării de software exista ceea ce se numește “iadul
dependențelor”. Cu cât sistemul crește și cu cât integrezi mai multe pachete în
soft-ul tău, cu atât crește posibilitatea să ajungi, într-o zi, în acest iad.

În sistemele cu multe dependențe, lansarea de versiuni noi ale pachetelor poate
sa devină ușor un coșmar. Daca specificațiile dependențelor sunt prea stricte,
există riscul de înghețare a versiunii (inabilitatea de a îmbunătății un pachet 
fara a lansa versiuni noi pentru fiecare din pachetele dependente). Dacă
specificațiile sunt prea flexibile, exista riscul de promiscuitate a versiunii 
(compatibilitate cu prea multe versiuni viitoare). Iadul dependențelor este
acela când înghețarea versiunii sau promiscuitatea versiunii te împiedică să
avansezi proiectul ușor și sigur.

Ca o soluție la această problemă, propun un set de reguli și cerințe simple care
să stabilească modul în care să se stabilească și să se incrementeze numerele
de versiune. Aceste reguli sunt bazate pe, dar nu neapărat limitate la, 
practici răspândite folosite în dezvoltarea de software open-source și 
closed-source. Pentru ca acest sistem de numerotare a versiunii sa funcționeze,
întâi trebuie stabilit și declarat un API public. Acesta poate consta în 
documentație sau să reiasă automat din codul sursă. Indiferent de metoda aleasă,
este important ca acest API sa fie clar și foarte specific. Odată ce ai stabilit
API-ul public, vei comunica schimbări efectuate asupra sa prin incrementări ale
numărului de versiune. Sa luam în considerare formatul X.Y.Z 
(Major.Minor.Patch). Corectările de bug-uri care nu afectează API-ul vor 
incrementa versiunea patch, adăugările și modificările care de asemenea păstrează 
compatibilitatea vor incrementa versiunea minoră, iar adăugările și modificările
care sunt incompatibile vor incrementa versiunea majoră.

Am numit acest sistem “numerotarea semantică a versiunii software”. Sub aceasta
schema de numerotare, numerele de versiune și modul în care ele se schimbă,
oferă o semnificație anume despre codul sursă și ce a fost modificat de la o
versiune la alta.

Specificații pentru numerotarea semantica a versiunii software (SemVer)
Cuvintele cheie “TREBUIE”, “NU TREBUIE”, “NECESAR”, “TREBUIE”, “NU TREBUIE”, 
“AR TREBUI SĂ”, “NU AR TREBUI SĂ”, “RECOMANDAT”, “POATE” și “OPTIONAL” în acest 
document trebuiesc interpretate in maniera descrisă in 
RFC 2119.


  
    Software-ul care folosește Numerotarea Semantică a Versiunii TREBUIE să 
declare un API public. Acest API poate fi declarat în codul sursă să existe 
numai în documentație. Indiferent cum este declarat AR TREBUI să fie exact și 
complet.
  
  
    Un număr de versiune normal TREBUIE să ia forma X.Y.Z unde, Z, Y și Z sunt 
numere naturale și NU TREBUIE să conțină cifre zero în față. X este versiunea 
majoră, Y este versiunea minoră și Z este versiunea de corecție (patch). Fiecare 
element TREBUIE să crească numeric. Spre exemplu: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Odată ce un pachet versionat a fost lansat, conținutul acelei versiuni 
NU TREBUIE să fie modificat. Orice modificare TREBUIE să fie lansată ca o nouă 
versiune.
  
  
    Versiunea majoră zero (0.y.z) este pentru faza inițială de dezvoltare. Orice 
POATE să fie modificat la orice moment în această versiune majoră. API-ul public 
NU AR TREBUI SA fie considerat stabil.
  
  
    Versiunea 1.0.0 definește API-ul public. Modul în care numărul versiunii este 
incrementat după această lansare (en. release) depinde de acest API public și 
felul în care acesta se schimbă.
  
  
    Versiunea de corecție (patch-ul) Z (x.y.Z | x > 0) TREBUIE să fie incrementat 
doar dacă există corecții (en. bug fixes) compatibile cu versiunile anterioare au 
fost introduse. O corecție este definită ca o modificare internă care corectează 
un comportament incorect.
  
  
    Versiunea minoră Y (x.Y.z | x > 0) TREBUIE sa fie incrementată dacă 
funcționalitate nouă, compatibilă cu versiunea anterioară, este introdusă in 
API-ul public. TREBUIE să fie incrementată dacă orice funcționalitate din API-ul 
public este marcată ca învechită (en. deprecated). POATE fi incrementată dacă 
funcționalitate sau îmbunătățiri substanțiale sunt introduse in codul privat. 
POATE include modificări de tip corecție. Numărul versiunii de corecție TREBUIE 
resetat la 0 când numărul versiunii minore este incrementat.
  
  
    Numărul versiunii majore X (X.y.z | X > 0) TREBUIE incrementat daca modificări 
care nu sunt compatibile cu versiunile anterioare au fost introduse in API-ul 
public. POATE de asemenea include modificări ale numărului versiunii minore și 
ale numărului de versiune de corecție. Numerele de versiune minor și de corecție 
TREBUIE să fie resetate la 0 când versiunea majoră este incrementată.
  
  
    O versiune de tipul pre-lansare (en. pre-release) POATE fi notată adaugând o 
liniuță separatoare și o serie de identificatori separați prin punct imediat 
după numărul versiunii de corecție. Identificatorii TREBUIE să conțină numai 
caractere ASCII alfanumerice și caracterul liniuță [0-9A-Za-z-]. Identificatorii 
NU TREBUIE să fie goi. Identificatorii numerici NU TREBUIE să conțină zerouri în 
față. Versiunile pre-lansare au o precedență față de versiunea normală asociată. 
O versiune pre-lansare indică faptul că versiunea este instabilă și ar putea să 
nu satisfacă nevoile de compatibilitate pe care le implică numărul versiunii 
normale. Exemple: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.–.
  
  
    Metadatele de build POT fi notate adăugând un plus și o serie de identificatori 
separați cu punct imediat după versiunea de corecție sau de pre-lansare. 
Identificatorii TREBUIE să fie compuși doar din caractere ASCII alfanumerice și 
liniuțe [0-9A-Za-z-]. Identificatorii nu trebuie să fie goi. Metadatele de build 
trebuie ignorate când se determină precedența versiunii. Astfel două versiuni 
care diferă doar prin metadatele de build au aceeași precedență. Exemple: 
1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3—-117B344092BD.
  
  
    Precedența se referă la cum versiunile sunt comparate una cu alta atunci când 
se sortează.
  
  
    Precedența trebuie calculată separând versiunea in identificatori major, 
minor, corecți și pre-lansare în această ordine (metadata de build nu este 
luată în considerare la calculul precedenței).
  
  
    Precedența este determinată de prima diferență când se compară fiecare 
dintre acești identificatori de la stânga la dreapta după cum urmează: major, 
minor și corecție sunt întotdeauna comparate numeric.

    Exemplu: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
  
  
    Când numerele versiunii majore, minore și de corecție sunt egale, o versiune 
de pre-lansare are precedență mai mică decât o versiune normală.

    Exemplu: 1.0.0-alpha < 1.0.0.
  
  
    Precedența a două versiuni pre-lansare cu aceeași versiune majoră, minoră și 
de corecție TREBUIE determinată comparând fiecare identificator separat cu 
punct, de la stânga la dreapta până când o diferență este găsită, după cum 
urmează:

    
      
        Identificatorii care consistă in cifre sunt comparați numeric.
      
      
        Identificatorii cu litere sau liniuță sunt comparați lexical in ordinea 
   de sortare ASCII.
      
      
        Identificatorii numerici au întotdeauna precedență mai mică decât cei 
non-numerici.
      
      
        Un set mai mare de câmpuri pre-lansare are o precedență mai mare decât 
un set mai mic, daca toți identificatorii precedenți sunt egali.

        Exemplu: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
      
    
  


Forma gramaticală Backus–Naur pentru versiuni SemVer valide
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


De ce să folosim numerotarea semantică a versiunii?

Aceasta nu este o idee nouă sau revoluționară. De fapt, deja poate faci ceva de 
genul acesta deja. Problema este că “ceva de genul” nu este suficient de bine. 
Fără a adera la o specificație formală, numerele de versiune sunt în esență 
inutile pentru managementul dependințelor. Oferind un nume și o definiție clară 
ideilor de mai sus, devine facil să comunici intențiile tale utilizatorilor 
software-ului dezvoltat de tine. Odată ce aceste intenții sunt clare, specificații 
de dependințe flexibile (dar nu mult prea flexibile) pot fi făcute.

Un exemplu simplu va demonstra cum Versionarea Semantică poate face iadul 
dependințelor (en. dependency hell) o realitate de domeniul trecutului. Să 
considerăm o bibliotecă numită “Firetruck”. Necesită un package cu Versionare 
Semantică numit “Ladder”. La momentul când Firetruck este creat, Ladder este 
la versiunea 3.1.0. Din moment ce Firetruck folosește niște funcționalitate care 
a fost introdusă pentru prima dată în
3.1.0 poți specifica în siguranță ca dependința pentru Ladder este mai mare sau 
egală cu 3.1.0 dar mai mică decât 4.0.0. Când versiunile pentru Ladder 3.1.1 și 
3.2.0 vor fi disponibile, le poți lansa în sistemul tău de management al 
pachetelor știind că vor fi compatibile cu software-ul dependent, existent.

Fiind un dezvoltator responsabil, desigur vei dori să verifici ca orice 
upgrade-uri de pachete funcționează așa cum trebuie. Realitatea este un loc 
dezordonat și cu probleme; nu putem face nimic în privința asta decât să fim 
vigilenți. Ce poți face este să lași Versionarea Semantică să îți ofere o cale 
sănătoasă prin care să lansezi și upgradezi pachete fără a fi nevoie să dezvolți 
noi versiuni de pachete dependente, fără a pierde vremea și cu deranj minim.

Dacă toate acestea sună ca ceva ce îți dorești să ai, tot ce trebuie să faci ca 
să începi să folosești Versionarea Semantică este să declari asta și să urmezi 
regulile. Include un link către acest site web đin fișierul README pentru ca 
alții să știe regulile și să beneficieze de pe urma lor.

Întrebări frecvente

Care este modul de lucru cu revizuiri (en. revisions) 0.y.z in faza inițială de dezvoltare?

Cel mai simplu lucru care poate fi făcut este să începi lansarea de dezvoltare 
inițială la 0.1.0 și apoi să incrementezi versiunea minoră la fiecare lansare 
ulterioară.

Când știu că este momentul să lansez 1.0.0?

Daca software-ul tău este folosit în producție, ar trebui să fie deja 1.0.0. Dacă 
ai un API stabil de care utilizatorii au ajuns să depindă, at trebui să fie 1.0.0. 
Dacă îti faci griji despre compatibilitate cu versiunile anterioare, ar trebui 
deja să fie 1.0.0.

Nu descurajează asta dezvoltarea și iterațiile rapide?

Versiunea majoră zero este pentru și despre dezvoltare rapidă. Dacă schimbi 
API-ul în fiecare zi ar trebui să fi încă in versiunea 0.y.z sau pe o ramură de 
dezvoltare separată, lucrând la următoarea versiune majoră.

Dacă până și cele mai mici modificări ale API-ului public care nu mențin compatibilitatea cu versiunile anterioare necesită o incrementare a versiunii majore, nu voi ajunge foarte repede la versiunea 42.0.0?

Aceasta este o chestiune de dezvoltare responsabilă și prevedere. Modificările 
incompatibile nu ar trebui introduse cu ușurință în software care are foarte 
mult cod dependent. Costul care poate apărea pentru a upgrada poate să fie 
semnificativ. Să crești versiunea majoră pentru a lansa modificări care nu 
mențin compatibilitatea înseamna să te gândești dinainte la impactul pe care 
îl vor avea modificările și să evaluezi rația costuri/beneficii.

Să documentez întregul API public necesită prea multă muncă!

Este responsabilitatea ta ca dezvoltator profesionist să documentezi software 
care este intenționat spre a fi folosit de alții. Managementul complexității 
software este un aspect deosebit de important în a menține un proiect la un 
nivel înalt de eficiență și asta este ceva dificil de realizat dacă nimeni nu 
știe cum sa folosească software-ul dezvoltat de tine sau ce metode poate să 
apeleze în siguranță. Pe termen lung, Versionarea Semantică, și insistarea pe 
a avea un API public foarte bine definit poate să mențină totul într-o stare bună.

Ce fac dacă în mod accidental lansez o versiune minoră care este incompatibilă cu versiunile anterioare?

Imediat ce realizezi că ai încălcat specificațiile Versionării Semantice, 
rezolvă problema și lansează o nouă versiune minoră care rezolvă problema 
incompatibilității și reface compatibilitatea cu versiunile anterioare. 
Chiar și în acest caz, nu este acceptabil să modifici versiuni deja lansate. 
Dacă este cazul, documentează versiunea care introducea această problemă și 
informează utilizatorii de această problemă pentru ca și ei să cunoască 
problema introdusă de versiunea în cauză.

Ce să fac dacă înnoiesc propriile mele dependințe fără a modifica API-ul public?

Acest lucru este considerat compatibil deoarece nu afectează API-ul public. 
Software care in mod explicit depinde de aceleași dependințe de care depinde 
pachetul tău, ar trebui să aibă propriile sale specificații de dependințe și 
autorul sau va realiza orice conflicte. Determinarea dacă modificarea este una 
de tip corecție sau de nivel minor, depinde dacă ai înnoit dependințele pentru 
a rezolva un bug sau pentru a introduce funcționalități noi. In mod normal ca 
dezvoltator mă aștept la cod adițional pentru al doilea caz și natural ar fi o 
incrementare de nivel minor.

Dacă din neatenție alterez API-ul public într-o manieră care nu aderă la principiile schimbării de versiune (ex. codul în mod incorect introduce o modificare care afectează funcționalitatea într-o lansare de tip corecție)

Folosește-ți judecata. Dacă ai o audiență uriașă care va fi afectată în mod 
drastic schimbând comportamentul pachetului înapoi la ce se intenționa din 
API-ul public, atunci ar putea fi cel mai bine să lansezi o versiune majoră, d
eși corecția în mod strict ar putea fi considerată o versiune de corecție. 
Reamintește-ți ca Versionarea Semantică este despre a oferi o semnificație 
în funcție de cum se schimbă numărul de versiune. Dacă aceste schimbări sunt 
importante pentru utilizatorii tăi, folosește-te de numărul de versiune 
pentru a-i informa.

Cum abordez funcționalitatea care este pe cale să devină învechită?

Funcționalitatea existentă care este pe cale să devină învechită 
(en. deprecating) este un aspect normal al dezvoltării software și este de 
multe ori necesară pentru a obține progresul. Când parte din API-ul public 
devine învechită, ar trebi să faci două lucruri: (1) înnoiește documentația 
pentru ca utilizatorii să știe de modificare, (2) lansează o nouă versiune 
minoră în care păstrezi codul învechit. Înainte de a elimina complet codul 
învechit într-o lansare majoră, ar trebuie să fie cel puțin o lansare minoră 
care conține codul învechit care va fi eliminat, pentru ca utilizatorii să 
poată trece elegant la noul API.

Are SemVer o dimensiune limită a șirului de caractere care definește versiunea?

Nu, dar folosește o judecată sănătoasă. Un șir de 255 de caractere este probabil 
exagerat spre exemplu. De asemenea, sisteme specifice ar putea impune propriile 
lor limite în ceea ce privește dimensiunea șirului de caractere.

Este “v1.2.3” o versiune semantică?

Nu, “v1.2.3” nu este o versiune semantică. Totuși, prefixarea unei versiuni 
semantice cu un “v” este o modalitate comună (în engleză și română) pentru a 
indica faptul că este un număr de versiune. Abrevierea cuvântului “versiune” 
prin “v” este un comportament văzut des în sistemele de control al versiunii. 
Examplu: git tag v1.2.3 -m "Lansare versiune 1.2.3", în acest caz “v1.2.3” 
este o etichetă (en. tag) și versiunea semantică este “1.2.3”.

Există o expresie regulată (RegEx) pentru a verifica un șir de caractere SemVer?

Există două. Una cu grupuri cu denumire pentru acele sisteme care le suportă 
(PCRE “Perl Compatible Regular Expressions”, i.e. Perl, PHP and R], Python and Go).

Vezi: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Și una cu grupuri de captură numerotate (așadar cg1 = major, cg2 = minor,
cg3 = corecție, cg4 = pre-lansare și cg5 = metainformație de build) care sunt compatibile cu ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
i.e. Perl, PHP and R), Python și Go.

Vezi: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Despre

Specificațiile nmerotării semantice a versiunii a fost original creată de Tom
Preston-Werner, inventatorul Gravatar și co-fondator al GitHub.

Dacă dorești să oferi feedback, te rugăm înaintează o sesizare pe GitHub.

Traducerea în română a fost realizată de catre echipele de dezvoltatori software ai 
Epigrade, 
Locatorix, 
Moneeva și 
Lux Rehabs.

Licență

Creative Commons ― CC BY 3.0\nNumerotarea Semantica a Versiunii Software 2.0.0\nFiind dat un număr de versiune MAJOR.MINOR.PATCH, se incrementează:\nNumărul MAJOR atunci când se fac modificări ale API-ului ce nu sunt 
compatibile cu versiunea precedenta,\nNumărul MINOR atunci când se adaugă funcționalitate care nu afectează 
compatibilitatea, și\nNumărul PATCH atunci când se adaugă corectări de bug-uri care nu afectează 
compatibilitatea.\nEtichete adiționale pentru pre-release și build sunt disponibile ca extensii ale 
formatului MAJOR.MINOR.PATCH.\nÎn lumea dezvoltării de software exista ceea ce se numește “iadul
dependențelor”. Cu cât sistemul crește și cu cât integrezi mai multe pachete în
soft-ul tău, cu atât crește posibilitatea să ajungi, într-o zi, în acest iad.\nÎn sistemele cu multe dependențe, lansarea de versiuni noi ale pachetelor poate
sa devină ușor un coșmar. Daca specificațiile dependențelor sunt prea stricte,
există riscul de înghețare a versiunii (inabilitatea de a îmbunătății un pachet 
fara a lansa versiuni noi pentru fiecare din pachetele dependente). Dacă
specificațiile sunt prea flexibile, exista riscul de promiscuitate a versiunii 
(compatibilitate cu prea multe versiuni viitoare). Iadul dependențelor este
acela când înghețarea versiunii sau promiscuitatea versiunii te împiedică să
avansezi proiectul ușor și sigur.\nCa o soluție la această problemă, propun un set de reguli și cerințe simple care
să stabilească modul în care să se stabilească și să se incrementeze numerele
de versiune. Aceste reguli sunt bazate pe, dar nu neapărat limitate la, 
practici răspândite folosite în dezvoltarea de software open-source și 
closed-source. Pentru ca acest sistem de numerotare a versiunii sa funcționeze,
întâi trebuie stabilit și declarat un API public. Acesta poate consta în 
documentație sau să reiasă automat din codul sursă. Indiferent de metoda aleasă,
este important ca acest API sa fie clar și foarte specific. Odată ce ai stabilit
API-ul public, vei comunica schimbări efectuate asupra sa prin incrementări ale
numărului de versiune. Sa luam în considerare formatul X.Y.Z 
(Major.Minor.Patch). Corectările de bug-uri care nu afectează API-ul vor 
incrementa versiunea patch, adăugările și modificările care de asemenea păstrează 
compatibilitatea vor incrementa versiunea minoră, iar adăugările și modificările
care sunt incompatibile vor incrementa versiunea majoră.\nAm numit acest sistem “numerotarea semantică a versiunii software”. Sub aceasta
schema de numerotare, numerele de versiune și modul în care ele se schimbă,
oferă o semnificație anume despre codul sursă și ce a fost modificat de la o
versiune la alta.\nSpecificații pentru numerotarea semantica a versiunii software (SemVer)\nCuvintele cheie “TREBUIE”, “NU TREBUIE”, “NECESAR”, “TREBUIE”, “NU TREBUIE”, 
“AR TREBUI SĂ”, “NU AR TREBUI SĂ”, “RECOMANDAT”, “POATE” și “OPTIONAL” în acest 
document trebuiesc interpretate in maniera descrisă in 
RFC 2119.\nSoftware-ul care folosește Numerotarea Semantică a Versiunii TREBUIE să 
declare un API public. Acest API poate fi declarat în codul sursă să existe 
numai în documentație. Indiferent cum este declarat AR TREBUI să fie exact și 
complet.\nSoftware-ul care folosește Numerotarea Semantică a Versiunii TREBUIE să 
declare un API public. Acest API poate fi declarat în codul sursă să existe 
numai în documentație. Indiferent cum este declarat AR TREBUI să fie exact și 
complet.\nUn număr de versiune normal TREBUIE să ia forma X.Y.Z unde, Z, Y și Z sunt 
numere naturale și NU TREBUIE să conțină cifre zero în față. X este versiunea 
majoră, Y este versiunea minoră și Z este versiunea de corecție (patch). Fiecare 
element TREBUIE să crească numeric. Spre exemplu: 1.9.0 -> 1.10.0 -> 1.11.0.\nUn număr de versiune normal TREBUIE să ia forma X.Y.Z unde, Z, Y și Z sunt 
numere naturale și NU TREBUIE să conțină cifre zero în față. X este versiunea 
majoră, Y este versiunea minoră și Z este versiunea de corecție (patch). Fiecare 
element TREBUIE să crească numeric. Spre exemplu: 1.9.0 -> 1.10.0 -> 1.11.0.\nOdată ce un pachet versionat a fost lansat, conținutul acelei versiuni 
NU TREBUIE să fie modificat. Orice modificare TREBUIE să fie lansată ca o nouă 
versiune.\nOdată ce un pachet versionat a fost lansat, conținutul acelei versiuni 
NU TREBUIE să fie modificat. Orice modificare TREBUIE să fie lansată ca o nouă 
versiune.\nVersiunea majoră zero (0.y.z) este pentru faza inițială de dezvoltare. Orice 
POATE să fie modificat la orice moment în această versiune majoră. API-ul public 
NU AR TREBUI SA fie considerat stabil.\nVersiunea majoră zero (0.y.z) este pentru faza inițială de dezvoltare. Orice 
POATE să fie modificat la orice moment în această versiune majoră. API-ul public 
NU AR TREBUI SA fie considerat stabil.\nVersiunea 1.0.0 definește API-ul public. Modul în care numărul versiunii este 
incrementat după această lansare (en. release) depinde de acest API public și 
felul în care acesta se schimbă.\nVersiunea 1.0.0 definește API-ul public. Modul în care numărul versiunii este 
incrementat după această lansare (en. release) depinde de acest API public și 
felul în care acesta se schimbă.\nVersiunea de corecție (patch-ul) Z (x.y.Z | x > 0) TREBUIE să fie incrementat 
doar dacă există corecții (en. bug fixes) compatibile cu versiunile anterioare au 
fost introduse. O corecție este definită ca o modificare internă care corectează 
un comportament incorect.\nVersiunea de corecție (patch-ul) Z (x.y.Z | x > 0) TREBUIE să fie incrementat 
doar dacă există corecții (en. bug fixes) compatibile cu versiunile anterioare au 
fost introduse. O corecție este definită ca o modificare internă care corectează 
un comportament incorect.\nVersiunea minoră Y (x.Y.z | x > 0) TREBUIE sa fie incrementată dacă 
funcționalitate nouă, compatibilă cu versiunea anterioară, este introdusă in 
API-ul public. TREBUIE să fie incrementată dacă orice funcționalitate din API-ul 
public este marcată ca învechită (en. deprecated). POATE fi incrementată dacă 
funcționalitate sau îmbunătățiri substanțiale sunt introduse in codul privat. 
POATE include modificări de tip corecție. Numărul versiunii de corecție TREBUIE 
resetat la 0 când numărul versiunii minore este incrementat.\nVersiunea minoră Y (x.Y.z | x > 0) TREBUIE sa fie incrementată dacă 
funcționalitate nouă, compatibilă cu versiunea anterioară, este introdusă in 
API-ul public. TREBUIE să fie incrementată dacă orice funcționalitate din API-ul 
public este marcată ca învechită (en. deprecated). POATE fi incrementată dacă 
funcționalitate sau îmbunătățiri substanțiale sunt introduse in codul privat. 
POATE include modificări de tip corecție. Numărul versiunii de corecție TREBUIE 
resetat la 0 când numărul versiunii minore este incrementat.\nNumărul versiunii majore X (X.y.z | X > 0) TREBUIE incrementat daca modificări 
care nu sunt compatibile cu versiunile anterioare au fost introduse in API-ul 
public. POATE de asemenea include modificări ale numărului versiunii minore și 
ale numărului de versiune de corecție. Numerele de versiune minor și de corecție 
TREBUIE să fie resetate la 0 când versiunea majoră este incrementată.\nNumărul versiunii majore X (X.y.z | X > 0) TREBUIE incrementat daca modificări 
care nu sunt compatibile cu versiunile anterioare au fost introduse in API-ul 
public. POATE de asemenea include modificări ale numărului versiunii minore și 
ale numărului de versiune de corecție. Numerele de versiune minor și de corecție 
TREBUIE să fie resetate la 0 când versiunea majoră este incrementată.\nO versiune de tipul pre-lansare (en. pre-release) POATE fi notată adaugând o 
liniuță separatoare și o serie de identificatori separați prin punct imediat 
după numărul versiunii de corecție. Identificatorii TREBUIE să conțină numai 
caractere ASCII alfanumerice și caracterul liniuță [0-9A-Za-z-]. Identificatorii 
NU TREBUIE să fie goi. Identificatorii numerici NU TREBUIE să conțină zerouri în 
față. Versiunile pre-lansare au o precedență față de versiunea normală asociată. 
O versiune pre-lansare indică faptul că versiunea este instabilă și ar putea să 
nu satisfacă nevoile de compatibilitate pe care le implică numărul versiunii 
normale. Exemple: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.–.\nO versiune de tipul pre-lansare (en. pre-release) POATE fi notată adaugând o 
liniuță separatoare și o serie de identificatori separați prin punct imediat 
după numărul versiunii de corecție. Identificatorii TREBUIE să conțină numai 
caractere ASCII alfanumerice și caracterul liniuță [0-9A-Za-z-]. Identificatorii 
NU TREBUIE să fie goi. Identificatorii numerici NU TREBUIE să conțină zerouri în 
față. Versiunile pre-lansare au o precedență față de versiunea normală asociată. 
O versiune pre-lansare indică faptul că versiunea este instabilă și ar putea să 
nu satisfacă nevoile de compatibilitate pe care le implică numărul versiunii 
normale. Exemple: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.–.\nMetadatele de build POT fi notate adăugând un plus și o serie de identificatori 
separați cu punct imediat după versiunea de corecție sau de pre-lansare. 
Identificatorii TREBUIE să fie compuși doar din caractere ASCII alfanumerice și 
liniuțe [0-9A-Za-z-]. Identificatorii nu trebuie să fie goi. Metadatele de build 
trebuie ignorate când se determină precedența versiunii. Astfel două versiuni 
care diferă doar prin metadatele de build au aceeași precedență. Exemple: 
1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3—-117B344092BD.\nMetadatele de build POT fi notate adăugând un plus și o serie de identificatori 
separați cu punct imediat după versiunea de corecție sau de pre-lansare. 
Identificatorii TREBUIE să fie compuși doar din caractere ASCII alfanumerice și 
liniuțe [0-9A-Za-z-]. Identificatorii nu trebuie să fie goi. Metadatele de build 
trebuie ignorate când se determină precedența versiunii. Astfel două versiuni 
care diferă doar prin metadatele de build au aceeași precedență. Exemple: 
1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3—-117B344092BD.\nPrecedența se referă la cum versiunile sunt comparate una cu alta atunci când 
se sortează.\nPrecedența se referă la cum versiunile sunt comparate una cu alta atunci când 
se sortează.\nPrecedența trebuie calculată separând versiunea in identificatori major, 
minor, corecți și pre-lansare în această ordine (metadata de build nu este 
luată în considerare la calculul precedenței).\nPrecedența trebuie calculată separând versiunea in identificatori major, 
minor, corecți și pre-lansare în această ordine (metadata de build nu este 
luată în considerare la calculul precedenței).\nPrecedența este determinată de prima diferență când se compară fiecare 
dintre acești identificatori de la stânga la dreapta după cum urmează: major, 
minor și corecție sunt întotdeauna comparate numeric.

    Exemplu: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nPrecedența este determinată de prima diferență când se compară fiecare 
dintre acești identificatori de la stânga la dreapta după cum urmează: major, 
minor și corecție sunt întotdeauna comparate numeric.\nExemplu: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nCând numerele versiunii majore, minore și de corecție sunt egale, o versiune 
de pre-lansare are precedență mai mică decât o versiune normală.

    Exemplu: 1.0.0-alpha < 1.0.0.\nCând numerele versiunii majore, minore și de corecție sunt egale, o versiune 
de pre-lansare are precedență mai mică decât o versiune normală.\nExemplu: 1.0.0-alpha < 1.0.0.\nPrecedența a două versiuni pre-lansare cu aceeași versiune majoră, minoră și 
de corecție TREBUIE determinată comparând fiecare identificator separat cu 
punct, de la stânga la dreapta până când o diferență este găsită, după cum 
urmează:

    
      
        Identificatorii care consistă in cifre sunt comparați numeric.
      
      
        Identificatorii cu litere sau liniuță sunt comparați lexical in ordinea 
   de sortare ASCII.
      
      
        Identificatorii numerici au întotdeauna precedență mai mică decât cei 
non-numerici.
      
      
        Un set mai mare de câmpuri pre-lansare are o precedență mai mare decât 
un set mai mic, daca toți identificatorii precedenți sunt egali.

        Exemplu: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPrecedența a două versiuni pre-lansare cu aceeași versiune majoră, minoră și 
de corecție TREBUIE determinată comparând fiecare identificator separat cu 
punct, de la stânga la dreapta până când o diferență este găsită, după cum 
urmează:\nIdentificatorii care consistă in cifre sunt comparați numeric.\nIdentificatorii care consistă in cifre sunt comparați numeric.\nIdentificatorii cu litere sau liniuță sunt comparați lexical in ordinea 
   de sortare ASCII.\nIdentificatorii cu litere sau liniuță sunt comparați lexical in ordinea 
   de sortare ASCII.\nIdentificatorii numerici au întotdeauna precedență mai mică decât cei 
non-numerici.\nIdentificatorii numerici au întotdeauna precedență mai mică decât cei 
non-numerici.\nUn set mai mare de câmpuri pre-lansare are o precedență mai mare decât 
un set mai mic, daca toți identificatorii precedenți sunt egali.

        Exemplu: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nUn set mai mare de câmpuri pre-lansare are o precedență mai mare decât 
un set mai mic, daca toți identificatorii precedenți sunt egali.\nExemplu: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nForma gramaticală Backus–Naur pentru versiuni SemVer valide\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nDe ce să folosim numerotarea semantică a versiunii?\nAceasta nu este o idee nouă sau revoluționară. De fapt, deja poate faci ceva de 
genul acesta deja. Problema este că “ceva de genul” nu este suficient de bine. 
Fără a adera la o specificație formală, numerele de versiune sunt în esență 
inutile pentru managementul dependințelor. Oferind un nume și o definiție clară 
ideilor de mai sus, devine facil să comunici intențiile tale utilizatorilor 
software-ului dezvoltat de tine. Odată ce aceste intenții sunt clare, specificații 
de dependințe flexibile (dar nu mult prea flexibile) pot fi făcute.\nUn exemplu simplu va demonstra cum Versionarea Semantică poate face iadul 
dependințelor (en. dependency hell) o realitate de domeniul trecutului. Să 
considerăm o bibliotecă numită “Firetruck”. Necesită un package cu Versionare 
Semantică numit “Ladder”. La momentul când Firetruck este creat, Ladder este 
la versiunea 3.1.0. Din moment ce Firetruck folosește niște funcționalitate care 
a fost introdusă pentru prima dată în
3.1.0 poți specifica în siguranță ca dependința pentru Ladder este mai mare sau 
egală cu 3.1.0 dar mai mică decât 4.0.0. Când versiunile pentru Ladder 3.1.1 și 
3.2.0 vor fi disponibile, le poți lansa în sistemul tău de management al 
pachetelor știind că vor fi compatibile cu software-ul dependent, existent.\nFiind un dezvoltator responsabil, desigur vei dori să verifici ca orice 
upgrade-uri de pachete funcționează așa cum trebuie. Realitatea este un loc 
dezordonat și cu probleme; nu putem face nimic în privința asta decât să fim 
vigilenți. Ce poți face este să lași Versionarea Semantică să îți ofere o cale 
sănătoasă prin care să lansezi și upgradezi pachete fără a fi nevoie să dezvolți 
noi versiuni de pachete dependente, fără a pierde vremea și cu deranj minim.\nDacă toate acestea sună ca ceva ce îți dorești să ai, tot ce trebuie să faci ca 
să începi să folosești Versionarea Semantică este să declari asta și să urmezi 
regulile. Include un link către acest site web đin fișierul README pentru ca 
alții să știe regulile și să beneficieze de pe urma lor.\nCare este modul de lucru cu revizuiri (en. revisions) 0.y.z in faza inițială de dezvoltare?\nCel mai simplu lucru care poate fi făcut este să începi lansarea de dezvoltare 
inițială la 0.1.0 și apoi să incrementezi versiunea minoră la fiecare lansare 
ulterioară.\nCând știu că este momentul să lansez 1.0.0?\nDaca software-ul tău este folosit în producție, ar trebui să fie deja 1.0.0. Dacă 
ai un API stabil de care utilizatorii au ajuns să depindă, at trebui să fie 1.0.0. 
Dacă îti faci griji despre compatibilitate cu versiunile anterioare, ar trebui 
deja să fie 1.0.0.\nNu descurajează asta dezvoltarea și iterațiile rapide?\nVersiunea majoră zero este pentru și despre dezvoltare rapidă. Dacă schimbi 
API-ul în fiecare zi ar trebui să fi încă in versiunea 0.y.z sau pe o ramură de 
dezvoltare separată, lucrând la următoarea versiune majoră.\nDacă până și cele mai mici modificări ale API-ului public care nu mențin compatibilitatea cu versiunile anterioare necesită o incrementare a versiunii majore, nu voi ajunge foarte repede la versiunea 42.0.0?\nAceasta este o chestiune de dezvoltare responsabilă și prevedere. Modificările 
incompatibile nu ar trebui introduse cu ușurință în software care are foarte 
mult cod dependent. Costul care poate apărea pentru a upgrada poate să fie 
semnificativ. Să crești versiunea majoră pentru a lansa modificări care nu 
mențin compatibilitatea înseamna să te gândești dinainte la impactul pe care 
îl vor avea modificările și să evaluezi rația costuri/beneficii.\nSă documentez întregul API public necesită prea multă muncă!\nEste responsabilitatea ta ca dezvoltator profesionist să documentezi software 
care este intenționat spre a fi folosit de alții. Managementul complexității 
software este un aspect deosebit de important în a menține un proiect la un 
nivel înalt de eficiență și asta este ceva dificil de realizat dacă nimeni nu 
știe cum sa folosească software-ul dezvoltat de tine sau ce metode poate să 
apeleze în siguranță. Pe termen lung, Versionarea Semantică, și insistarea pe 
a avea un API public foarte bine definit poate să mențină totul într-o stare bună.\nCe fac dacă în mod accidental lansez o versiune minoră care este incompatibilă cu versiunile anterioare?\nImediat ce realizezi că ai încălcat specificațiile Versionării Semantice, 
rezolvă problema și lansează o nouă versiune minoră care rezolvă problema 
incompatibilității și reface compatibilitatea cu versiunile anterioare. 
Chiar și în acest caz, nu este acceptabil să modifici versiuni deja lansate. 
Dacă este cazul, documentează versiunea care introducea această problemă și 
informează utilizatorii de această problemă pentru ca și ei să cunoască 
problema introdusă de versiunea în cauză.\nCe să fac dacă înnoiesc propriile mele dependințe fără a modifica API-ul public?\nAcest lucru este considerat compatibil deoarece nu afectează API-ul public. 
Software care in mod explicit depinde de aceleași dependințe de care depinde 
pachetul tău, ar trebui să aibă propriile sale specificații de dependințe și 
autorul sau va realiza orice conflicte. Determinarea dacă modificarea este una 
de tip corecție sau de nivel minor, depinde dacă ai înnoit dependințele pentru 
a rezolva un bug sau pentru a introduce funcționalități noi. In mod normal ca 
dezvoltator mă aștept la cod adițional pentru al doilea caz și natural ar fi o 
incrementare de nivel minor.\nDacă din neatenție alterez API-ul public într-o manieră care nu aderă la principiile schimbării de versiune (ex. codul în mod incorect introduce o modificare care afectează funcționalitatea într-o lansare de tip corecție)\nFolosește-ți judecata. Dacă ai o audiență uriașă care va fi afectată în mod 
drastic schimbând comportamentul pachetului înapoi la ce se intenționa din 
API-ul public, atunci ar putea fi cel mai bine să lansezi o versiune majoră, d
eși corecția în mod strict ar putea fi considerată o versiune de corecție. 
Reamintește-ți ca Versionarea Semantică este despre a oferi o semnificație 
în funcție de cum se schimbă numărul de versiune. Dacă aceste schimbări sunt 
importante pentru utilizatorii tăi, folosește-te de numărul de versiune 
pentru a-i informa.\nCum abordez funcționalitatea care este pe cale să devină învechită?\nFuncționalitatea existentă care este pe cale să devină învechită 
(en. deprecating) este un aspect normal al dezvoltării software și este de 
multe ori necesară pentru a obține progresul. Când parte din API-ul public 
devine învechită, ar trebi să faci două lucruri: (1) înnoiește documentația 
pentru ca utilizatorii să știe de modificare, (2) lansează o nouă versiune 
minoră în care păstrezi codul învechit. Înainte de a elimina complet codul 
învechit într-o lansare majoră, ar trebuie să fie cel puțin o lansare minoră 
care conține codul învechit care va fi eliminat, pentru ca utilizatorii să 
poată trece elegant la noul API.\nAre SemVer o dimensiune limită a șirului de caractere care definește versiunea?\nNu, dar folosește o judecată sănătoasă. Un șir de 255 de caractere este probabil 
exagerat spre exemplu. De asemenea, sisteme specifice ar putea impune propriile 
lor limite în ceea ce privește dimensiunea șirului de caractere.\nEste “v1.2.3” o versiune semantică?\nNu, “v1.2.3” nu este o versiune semantică. Totuși, prefixarea unei versiuni 
semantice cu un “v” este o modalitate comună (în engleză și română) pentru a 
indica faptul că este un număr de versiune. Abrevierea cuvântului “versiune” 
prin “v” este un comportament văzut des în sistemele de control al versiunii. 
Examplu: git tag v1.2.3 -m "Lansare versiune 1.2.3", în acest caz “v1.2.3” 
este o etichetă (en. tag) și versiunea semantică este “1.2.3”.\nExistă o expresie regulată (RegEx) pentru a verifica un șir de caractere SemVer?\nExistă două. Una cu grupuri cu denumire pentru acele sisteme care le suportă 
(PCRE “Perl Compatible Regular Expressions”, i.e. Perl, PHP and R], Python and Go).\nVezi: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nȘi una cu grupuri de captură numerotate (așadar cg1 = major, cg2 = minor,
cg3 = corecție, cg4 = pre-lansare și cg5 = metainformație de build) care sunt compatibile cu ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
i.e. Perl, PHP and R), Python și Go.\nVezi: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nSpecificațiile nmerotării semantice a versiunii a fost original creată de Tom
Preston-Werner, inventatorul Gravatar și co-fondator al GitHub.\nDacă dorești să oferi feedback, te rugăm înaintează o sesizare pe GitHub.\nînaintează o sesizare pe GitHub\nTraducerea în română a fost realizată de catre echipele de dezvoltatori software ai 
Epigrade, 
Locatorix, 
Moneeva și 
Lux Rehabs.\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nСемантическое Версионирование 2.0.0

Кратко

Учитывая номер версии МАЖОРНАЯ.МИНОРНАЯ.ПАТЧ, следует увеличивать:


  МАЖОРНУЮ версию, когда сделаны обратно несовместимые изменения API.
  МИНОРНУЮ версию, когда вы добавляете новую функциональность, не нарушая обратной
совместимости.
  ПАТЧ-версию, когда вы делаете обратно совместимые исправления.


Дополнительные обозначения для предрелизных и билд-метаданных возможны как
дополнения к МАЖОРНАЯ.МИНОРНАЯ.ПАТЧ формату.

Вступление

В мире управления процессом разработки есть понятие «ад зависимостей»
(dependency hell). Чем больше растёт ваша система и чем больше библиотек вы
интегрируете в ваш проект, тем больше вероятность оказаться в этой ситуации.

В системе с множественными зависимостями выпуск новой версии может быстро
превратиться в кошмар. Если спецификации зависимости слишком жесткие, вы
находитесь в опасности блокирования выпуска новой версии (невозможность
обновить пакет без необходимости выпуска новой версии каждой зависимой
библиотеки). Если спецификация зависимостей слишком свободна, вас неизбежно
настигнет версионное несоответствие (необоснованное предположение совместимости
с будущими версиями).

В качестве решения данной проблемы я предлагаю простой набор правил и
требований, которые определяют, как назначаются и увеличиваются номера версий.
Для того чтобы эта система работала, вам необходимо определить публичный API.
Он может быть описан в документации или определяться самим кодом. Главное,
чтобы этот API был ясным и точным. Однажды определив публичный API, вы
сообщаете об изменениях в нём особым увеличением номера версий. Рассмотрим
формат версий X.Y.Z (мажорная, минорная, патч). Баг-фиксы, не влияющие на
API, увеличивают патч-версию, обратно совместимые добавления/изменения API
увеличивают минорную версию и обратно несовместимые изменения API увеличивают
мажорную версию.

Я называю эту систему «Семантическое Версионирование» (Semantic Versioning). По
этой схеме номера версий и то, как они изменяются, передают смысл содержания
исходного кода и что было модифицировано от одной версии к другой.

Спецификация Семантического Версионирования (SemVer)

Слова «ДОЛЖЕН» (MUST), «НЕ ДОЛЖЕН» (MUST NOT), «ОБЯЗАТЕЛЬНО» (REQUIRED),
«СЛЕДУЕТ» (SHOULD), «НЕ СЛЕДУЕТ» (SHOULD NOT), «РЕКОМЕНДОВАННЫЙ» (RECOMMENDED),
«МОЖЕТ» (MAY) и «НЕОБЯЗАТЕЛЬНЫЙ» (OPTIONAL) в этом документе должны быть
интерпретированы в соответствии с RFC 2119.


  
    ПО, использующее Семантическое Версионирование, должно объявить публичный
API. Этот API может быть объявлен самим кодом или существовать строго в
документации.  Как бы ни было это сделано, он должен быть точным и
исчерпывающим.
  
  
    Обычный номер версии ДОЛЖЕН иметь формат X.Y.Z, где X, Y и Z — неотрицательные
целые числа и НЕ ДОЛЖНЫ начинаться с нуля. X — мажорная версия, Y — минорная
версия и Z — патч-версия. Каждый элемент ДОЛЖЕН увеличиваться численно.
Например: 1.9.0 ->1.10.0 -> 1.11.0.
  
  
    После релиза новой версии пакета содержание этой версии НЕ ДОЛЖНО быть
модифицировано. Любые изменения ДОЛЖНЫ быть выпущены как новая версия.
  
  
    Мажорная версия ноль (0.y.z) предназначена для начальной разработки. Всё
может измениться в любой момент. Публичный API не должен рассматриваться как
стабильный.
  
  
    Версия 1.0.0 определяет публичный API. После этого релиза номера версий
увеличиваются в зависимости от того, как изменяется публичный API.
  
  
    Патч-версия  Z (x.y.Z | x > 0) ДОЛЖНА быть увеличена только если содержит
обратно совместимые баг-фиксы. Определение баг-фикс означает внутренние
изменения, которые исправляют некорректное поведение.
  
  
    Минорная версия (x.Y.z | x > 0) ДОЛЖНА быть увеличена, если в публичном API
представлена новая обратно совместимая функциональность. Версия ДОЛЖНА быть увеличена,
если какая-либо функциональность публичного API помечена как устаревшая (deprecated).
Версия МОЖЕТ быть увеличена в случае реализации новой функциональности или
существенного усовершенствования в приватном коде. Версия МОЖЕТ включать в себя
изменения, характерные для патчей. Патч-версия ДОЛЖНА быть обнулена, когда
увеличивается минорная версия.
  
  
    Мажорная версия X (X.y.z | X > 0) ДОЛЖНА быть увеличена, если в публичном API
представлены какие-либо обратно несовместимые изменения. Она МОЖЕТ включать в
себя изменения, характерные для уровня минорных версий и патчей. Когда
увеличивается мажорная версия, минорная и патч-версия ДОЛЖНЫ быть обнулены.
  
  
    Предрелизная версия МОЖЕТ быть обозначена добавлением дефиса и серией
разделённых точкой идентификаторов, следующих сразу за патч-версией.
Идентификаторы ДОЛЖНЫ содержать только ASCII буквенно-цифровые символы и дефис
[0-9A-Za-z-]. Идентификаторы НЕ ДОЛЖНЫ быть пустыми. Числовые идентификаторы
НЕ ДОЛЖНЫ начинаться с нуля. Предрелизные версии имеют более низкий приоритет,
чем соответствующая релизная версия. Предрелизная версия указывает на то, что
эта версия не стабильна и может не удовлетворять требованиям совместимости,
обозначенными соответствующей нормальной версией. Примеры: 1.0.0-alpha,
1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Сборочные метаданные МОГУТ быть обозначены добавлением знака плюс и ряда
разделённых точкой идентификаторов, следующих сразу за патчем или предрелизной
версией. Идентификаторы ДОЛЖНЫ содержать только ASCII буквенно-цифровые символы
и дефис [0-9A-Za-z-]. Идентификаторы НЕ ДОЛЖНЫ быть пустыми. Сборочные
метаданные СЛЕДУЕТ игнорировать, когда определяется старшинство версий. Поэтому
два пакета с одинаковой версией, но разными сборочными метаданными,
рассматриваются как одна и та же версия. Примеры: 1.0.0-alpha+001,
1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    Приоритет определяет, как версии соотносятся друг с другом, когда
упорядочиваются. Приоритет версий ДОЛЖЕН рассчитываться путём разделения номеров
версий на мажорную, минорную, патч и предрелизные идентификаторы. Именно в
такой последовательности (сборочные метаданные не фигурируют в расчёте).
Приоритет определяется по первому отличию при сравнении каждого из этих
идентификаторов слева направо: Мажорная, минорная и патч-версия всегда
сравниваются численно. Пример: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Когда мажорная,
минорная и патч-версия равны, предрелизная версия имеет более низкий приоритет,
чем нормальная версия. Пример: 1.0.0-alpha < 1.0.0. Приоритет двух предрелизных
версий с одинаковыми мажорной, минорной и патч-версией ДОЛЖНЫ быть определены
сравнением каждого разделённого точкой идентификатора слева направо до тех пор,
пока различие не будет найдено следующим образом: идентификаторы, состоящие
только из цифр, сравниваются численно; буквенные идентификаторы или дефисы
сравниваются лексически в ASCII-порядке. Численные идентификаторы всегда имеют
низший приоритет, чем символьные. Больший набор предрелизных символов имеет
больший приоритет, чем меньший набор, если сравниваемые идентификаторы равны.
Пример: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Зачем использовать семантическое версионирование?

Это не новая или революционная идея. Вероятно, вы уже используете что-то
подобное. Проблема в том, что «подобное» — не достаточно хорошо. Без
соответствия формальной спецификации, номера версий практически бесполезны для
управления зависимостями. Ясно определив и сформулировав идею версионирования,
становится легче сообщать о намерениях пользователям вашего ПО. Когда эти
намерения ясны, гибки (но не слишком), спецификации зависимостей наконец могут
быть созданы.

Простой пример демонстрирует, как Семантическое Версионирование может сделать
«ад зависимостей» вещью из прошлого. Представим библиотеку, названную
«Firetruck». Она требует Семантически Версионированный пакет под названием
«Ladder». Когда Firetruck был создан, Ladder был 3.1.0 версии. Так как Firetruck
использует функциональность версии 3.1.0,  вы спокойно можете объявить зависимость от
Ladder версии 3.1.0, но менее чем 4.0.0. Теперь, когда доступен Ladder 3.1.1 и
3.2.0 версии, вы можете интегрировать его в вашу систему и знать, что он будет
совместим с текущей функциональностью.

Как ответственный разработчик, вы, конечно, хотите быть уверены, что все
обновления функционируют как заявлено. В реальном мире полный бардак и ничего
нельзя с этим поделать. Что вы можете сделать — это дать Семантическому
Версионированию предоставить способ выпуска релизов без выпуска новых версий
зависимых пакетов и сохранить вам время и нервы.

Если это звучит соблазнительно, всё что вам нужно — это начать использовать
Семантическое Версионирование, объявить, что вы его используете, и следовать
правилам. Добавьте ссылку на этот сайт в вашем README, тогда пользователи будут
знать правила и извлекать из этого пользу.

FAQ

Что я должен делать с ревизиями в 0.y.z на начальной стадии разработки?

Самое простое — начать разработку с 0.1.0 и затем увеличивать минорную версию
для каждого последующего релиза.

Как я узнаю, когда пора делать релиз 1.0.0?

Если ваше ПО используется на продакшене, оно, вероятно, уже должно быть версии
1.0.0. Если у вас стабильный API, от которого зависят пользователи, версия
должна быть 1.0.0. Если вы беспокоитесь за обратную совместимость, вероятно,
версия вашего ПО уже 1.0.0.

Не препятствует ли это быстрой разработке и коротким итерациям?

Мажорная версия 0 как раз и означает быструю разработку. Если вы изменяете API
каждый день, вы должны быть на версии 0.y.z или на отдельной ветке разработки
работать над следующей главной версией.

Даже если малейшие обратно несовместимые изменения в публичном API требуют выпуска новой главной версии, не закончится ли это тем, что очень скоро версия станет 42.0.0?

Это вопрос ответственной разработки и предвидения. Несовместимые изменения не
должны быть представлены как незначительные в ПО, имеющем много зависимого кода.
Стоимость обновления может быть велика. Практика увеличения главных версий
релизов с обратно несовместимыми изменениями означает, что вам придётся думать о
последствиях ваших изменений и учитывать соотношение цена/качество.

Документирование всего API — слишком много работы!

Это ваша ответственность, как профессионального разработчика, правильно
документировать ПО, предназначенное для широкого использования. Управление
сложностью ПО очень важная часть поддержки высокой эффективности проекта. Это
тяжело сделать, если никто не знает, как использовать ваше ПО или какой метод
можно вызывать безопасно. В долгосрочной перспективе Семантическое
Версионирование и настойчивость в качественном документировании публичного API
поможет всем и всему работать слаженно.

Что мне делать, если я случайно зарелизил обратно несовместимые изменения как минорную версию?

Как только вы поняли, что нарушили спецификации Семантического Версионирования,
исправьте проблему и выпустите новую минорную версию, которая исправляет
проблему и восстанавливает обратную совместимость. Даже в таких обстоятельствах
неприемлемо модифицировать уже выпущенные релизы. Если это необходимо, укажите в
документации о нарушении обратной совместимости, версионирования и
проинформируйте ваших пользователей, чтобы они знали о нарушении порядка версий.

Что я должен делать, если я обновляю свои собственные зависимости без изменения публичного API?

Это можно рассматривать как совместимые изменения, так как они не влияют на
публичный API. ПО, которое явно зависит от тех же зависимостей что и ваш пакет,
должно иметь собственные спецификации зависимостей и автор будет уведомлен о
возможных конфликтах. Являются ли данные изменения уровня патча или
минорного уровня, зависит от того, обновили ли вы свои зависимости чтобы
исправить баг или реализовать новую функциональность. В последнем случае, как правило,
добавляется некоторое количество дополнительного кода и как следствие,
увеличивается минорная версия.

Что если я нечаянно изменил публичный API в несоответствии с изменением номера версии (т.е. код содержит обратно несовместимые изменения в патч-релизе)?

На ваше усмотрение. Если у вас огромная аудитория, которая будет поставлена
перед фактом возвращения прежнего поведения API, то лучше выпустить новый релиз
с увеличением главной версии, даже несмотря на то, что фикс содержит исправления
уровня патча. Запомните, в Семантическом Версионировании номера версий
изменяются строго следуя спецификации. Если эти изменения важны для ваших
пользователей, используйте номер версии, чтобы информировать их.

Что делать с устаревшей функциональностью?

Объявление функциональности устаревшей — это обычное дело в ходе разработки и часто
необходимо для продвижения вперёд. Когда вы объявляете устаревшим часть
публичного API, вы должны сделать две вещи: (1) обновить вашу документацию,
чтобы дать пользователям узнать об этом изменении; (2) выпустить новый релиз с
увеличением минорной версии. Прежде чем вы полностью удалите устаревшую
функциональность в релизе с увеличением главной версии, должен быть как минимум один
минорный релиз, содержащий объявление функциональности устаревшей, чтобы
пользователи могли плавно перейти на новый API.

Есть ли в SemVer лимиты на длину строки версии?

Нет, но руководствуйтесь здравым смыслом. 255 символов в строке версии, пожалуй,
перебор. Кроме того, определенные системы могут предъявлять свои
собственные ограничения на размер строки.

Об авторе

Авторство спецификаций Семантического Версионирования принадлежит
Тому Престон-Вернеру, основателю Gravatars и
соучредителю GitHub.

Если вы хотите оставить отзыв, пожалуйста, создайте запрос на
GitHub.

Лицензия

Creative Commons — CC BY 3.0\nСемантическое Версионирование 2.0.0\nУчитывая номер версии МАЖОРНАЯ.МИНОРНАЯ.ПАТЧ, следует увеличивать:\nМАЖОРНУЮ версию, когда сделаны обратно несовместимые изменения API.\nМИНОРНУЮ версию, когда вы добавляете новую функциональность, не нарушая обратной
совместимости.\nПАТЧ-версию, когда вы делаете обратно совместимые исправления.\nДополнительные обозначения для предрелизных и билд-метаданных возможны как
дополнения к МАЖОРНАЯ.МИНОРНАЯ.ПАТЧ формату.\nВ мире управления процессом разработки есть понятие «ад зависимостей»
(dependency hell). Чем больше растёт ваша система и чем больше библиотек вы
интегрируете в ваш проект, тем больше вероятность оказаться в этой ситуации.\nВ системе с множественными зависимостями выпуск новой версии может быстро
превратиться в кошмар. Если спецификации зависимости слишком жесткие, вы
находитесь в опасности блокирования выпуска новой версии (невозможность
обновить пакет без необходимости выпуска новой версии каждой зависимой
библиотеки). Если спецификация зависимостей слишком свободна, вас неизбежно
настигнет версионное несоответствие (необоснованное предположение совместимости
с будущими версиями).\nВ качестве решения данной проблемы я предлагаю простой набор правил и
требований, которые определяют, как назначаются и увеличиваются номера версий.
Для того чтобы эта система работала, вам необходимо определить публичный API.
Он может быть описан в документации или определяться самим кодом. Главное,
чтобы этот API был ясным и точным. Однажды определив публичный API, вы
сообщаете об изменениях в нём особым увеличением номера версий. Рассмотрим
формат версий X.Y.Z (мажорная, минорная, патч). Баг-фиксы, не влияющие на
API, увеличивают патч-версию, обратно совместимые добавления/изменения API
увеличивают минорную версию и обратно несовместимые изменения API увеличивают
мажорную версию.\nЯ называю эту систему «Семантическое Версионирование» (Semantic Versioning). По
этой схеме номера версий и то, как они изменяются, передают смысл содержания
исходного кода и что было модифицировано от одной версии к другой.\nСпецификация Семантического Версионирования (SemVer)\nСлова «ДОЛЖЕН» (MUST), «НЕ ДОЛЖЕН» (MUST NOT), «ОБЯЗАТЕЛЬНО» (REQUIRED),
«СЛЕДУЕТ» (SHOULD), «НЕ СЛЕДУЕТ» (SHOULD NOT), «РЕКОМЕНДОВАННЫЙ» (RECOMMENDED),
«МОЖЕТ» (MAY) и «НЕОБЯЗАТЕЛЬНЫЙ» (OPTIONAL) в этом документе должны быть
интерпретированы в соответствии с RFC 2119.\nПО, использующее Семантическое Версионирование, должно объявить публичный
API. Этот API может быть объявлен самим кодом или существовать строго в
документации.  Как бы ни было это сделано, он должен быть точным и
исчерпывающим.\nПО, использующее Семантическое Версионирование, должно объявить публичный
API. Этот API может быть объявлен самим кодом или существовать строго в
документации.  Как бы ни было это сделано, он должен быть точным и
исчерпывающим.\nОбычный номер версии ДОЛЖЕН иметь формат X.Y.Z, где X, Y и Z — неотрицательные
целые числа и НЕ ДОЛЖНЫ начинаться с нуля. X — мажорная версия, Y — минорная
версия и Z — патч-версия. Каждый элемент ДОЛЖЕН увеличиваться численно.
Например: 1.9.0 ->1.10.0 -> 1.11.0.\nОбычный номер версии ДОЛЖЕН иметь формат X.Y.Z, где X, Y и Z — неотрицательные
целые числа и НЕ ДОЛЖНЫ начинаться с нуля. X — мажорная версия, Y — минорная
версия и Z — патч-версия. Каждый элемент ДОЛЖЕН увеличиваться численно.
Например: 1.9.0 ->1.10.0 -> 1.11.0.\nПосле релиза новой версии пакета содержание этой версии НЕ ДОЛЖНО быть
модифицировано. Любые изменения ДОЛЖНЫ быть выпущены как новая версия.\nПосле релиза новой версии пакета содержание этой версии НЕ ДОЛЖНО быть
модифицировано. Любые изменения ДОЛЖНЫ быть выпущены как новая версия.\nМажорная версия ноль (0.y.z) предназначена для начальной разработки. Всё
может измениться в любой момент. Публичный API не должен рассматриваться как
стабильный.\nМажорная версия ноль (0.y.z) предназначена для начальной разработки. Всё
может измениться в любой момент. Публичный API не должен рассматриваться как
стабильный.\nВерсия 1.0.0 определяет публичный API. После этого релиза номера версий
увеличиваются в зависимости от того, как изменяется публичный API.\nВерсия 1.0.0 определяет публичный API. После этого релиза номера версий
увеличиваются в зависимости от того, как изменяется публичный API.\nПатч-версия  Z (x.y.Z | x > 0) ДОЛЖНА быть увеличена только если содержит
обратно совместимые баг-фиксы. Определение баг-фикс означает внутренние
изменения, которые исправляют некорректное поведение.\nПатч-версия  Z (x.y.Z | x > 0) ДОЛЖНА быть увеличена только если содержит
обратно совместимые баг-фиксы. Определение баг-фикс означает внутренние
изменения, которые исправляют некорректное поведение.\nМинорная версия (x.Y.z | x > 0) ДОЛЖНА быть увеличена, если в публичном API
представлена новая обратно совместимая функциональность. Версия ДОЛЖНА быть увеличена,
если какая-либо функциональность публичного API помечена как устаревшая (deprecated).
Версия МОЖЕТ быть увеличена в случае реализации новой функциональности или
существенного усовершенствования в приватном коде. Версия МОЖЕТ включать в себя
изменения, характерные для патчей. Патч-версия ДОЛЖНА быть обнулена, когда
увеличивается минорная версия.\nМинорная версия (x.Y.z | x > 0) ДОЛЖНА быть увеличена, если в публичном API
представлена новая обратно совместимая функциональность. Версия ДОЛЖНА быть увеличена,
если какая-либо функциональность публичного API помечена как устаревшая (deprecated).
Версия МОЖЕТ быть увеличена в случае реализации новой функциональности или
существенного усовершенствования в приватном коде. Версия МОЖЕТ включать в себя
изменения, характерные для патчей. Патч-версия ДОЛЖНА быть обнулена, когда
увеличивается минорная версия.\nМажорная версия X (X.y.z | X > 0) ДОЛЖНА быть увеличена, если в публичном API
представлены какие-либо обратно несовместимые изменения. Она МОЖЕТ включать в
себя изменения, характерные для уровня минорных версий и патчей. Когда
увеличивается мажорная версия, минорная и патч-версия ДОЛЖНЫ быть обнулены.\nМажорная версия X (X.y.z | X > 0) ДОЛЖНА быть увеличена, если в публичном API
представлены какие-либо обратно несовместимые изменения. Она МОЖЕТ включать в
себя изменения, характерные для уровня минорных версий и патчей. Когда
увеличивается мажорная версия, минорная и патч-версия ДОЛЖНЫ быть обнулены.\nПредрелизная версия МОЖЕТ быть обозначена добавлением дефиса и серией
разделённых точкой идентификаторов, следующих сразу за патч-версией.
Идентификаторы ДОЛЖНЫ содержать только ASCII буквенно-цифровые символы и дефис
[0-9A-Za-z-]. Идентификаторы НЕ ДОЛЖНЫ быть пустыми. Числовые идентификаторы
НЕ ДОЛЖНЫ начинаться с нуля. Предрелизные версии имеют более низкий приоритет,
чем соответствующая релизная версия. Предрелизная версия указывает на то, что
эта версия не стабильна и может не удовлетворять требованиям совместимости,
обозначенными соответствующей нормальной версией. Примеры: 1.0.0-alpha,
1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nПредрелизная версия МОЖЕТ быть обозначена добавлением дефиса и серией
разделённых точкой идентификаторов, следующих сразу за патч-версией.
Идентификаторы ДОЛЖНЫ содержать только ASCII буквенно-цифровые символы и дефис
[0-9A-Za-z-]. Идентификаторы НЕ ДОЛЖНЫ быть пустыми. Числовые идентификаторы
НЕ ДОЛЖНЫ начинаться с нуля. Предрелизные версии имеют более низкий приоритет,
чем соответствующая релизная версия. Предрелизная версия указывает на то, что
эта версия не стабильна и может не удовлетворять требованиям совместимости,
обозначенными соответствующей нормальной версией. Примеры: 1.0.0-alpha,
1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nСборочные метаданные МОГУТ быть обозначены добавлением знака плюс и ряда
разделённых точкой идентификаторов, следующих сразу за патчем или предрелизной
версией. Идентификаторы ДОЛЖНЫ содержать только ASCII буквенно-цифровые символы
и дефис [0-9A-Za-z-]. Идентификаторы НЕ ДОЛЖНЫ быть пустыми. Сборочные
метаданные СЛЕДУЕТ игнорировать, когда определяется старшинство версий. Поэтому
два пакета с одинаковой версией, но разными сборочными метаданными,
рассматриваются как одна и та же версия. Примеры: 1.0.0-alpha+001,
1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nСборочные метаданные МОГУТ быть обозначены добавлением знака плюс и ряда
разделённых точкой идентификаторов, следующих сразу за патчем или предрелизной
версией. Идентификаторы ДОЛЖНЫ содержать только ASCII буквенно-цифровые символы
и дефис [0-9A-Za-z-]. Идентификаторы НЕ ДОЛЖНЫ быть пустыми. Сборочные
метаданные СЛЕДУЕТ игнорировать, когда определяется старшинство версий. Поэтому
два пакета с одинаковой версией, но разными сборочными метаданными,
рассматриваются как одна и та же версия. Примеры: 1.0.0-alpha+001,
1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nПриоритет определяет, как версии соотносятся друг с другом, когда
упорядочиваются. Приоритет версий ДОЛЖЕН рассчитываться путём разделения номеров
версий на мажорную, минорную, патч и предрелизные идентификаторы. Именно в
такой последовательности (сборочные метаданные не фигурируют в расчёте).
Приоритет определяется по первому отличию при сравнении каждого из этих
идентификаторов слева направо: Мажорная, минорная и патч-версия всегда
сравниваются численно. Пример: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Когда мажорная,
минорная и патч-версия равны, предрелизная версия имеет более низкий приоритет,
чем нормальная версия. Пример: 1.0.0-alpha < 1.0.0. Приоритет двух предрелизных
версий с одинаковыми мажорной, минорной и патч-версией ДОЛЖНЫ быть определены
сравнением каждого разделённого точкой идентификатора слева направо до тех пор,
пока различие не будет найдено следующим образом: идентификаторы, состоящие
только из цифр, сравниваются численно; буквенные идентификаторы или дефисы
сравниваются лексически в ASCII-порядке. Численные идентификаторы всегда имеют
низший приоритет, чем символьные. Больший набор предрелизных символов имеет
больший приоритет, чем меньший набор, если сравниваемые идентификаторы равны.
Пример: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nПриоритет определяет, как версии соотносятся друг с другом, когда
упорядочиваются. Приоритет версий ДОЛЖЕН рассчитываться путём разделения номеров
версий на мажорную, минорную, патч и предрелизные идентификаторы. Именно в
такой последовательности (сборочные метаданные не фигурируют в расчёте).
Приоритет определяется по первому отличию при сравнении каждого из этих
идентификаторов слева направо: Мажорная, минорная и патч-версия всегда
сравниваются численно. Пример: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Когда мажорная,
минорная и патч-версия равны, предрелизная версия имеет более низкий приоритет,
чем нормальная версия. Пример: 1.0.0-alpha < 1.0.0. Приоритет двух предрелизных
версий с одинаковыми мажорной, минорной и патч-версией ДОЛЖНЫ быть определены
сравнением каждого разделённого точкой идентификатора слева направо до тех пор,
пока различие не будет найдено следующим образом: идентификаторы, состоящие
только из цифр, сравниваются численно; буквенные идентификаторы или дефисы
сравниваются лексически в ASCII-порядке. Численные идентификаторы всегда имеют
низший приоритет, чем символьные. Больший набор предрелизных символов имеет
больший приоритет, чем меньший набор, если сравниваемые идентификаторы равны.
Пример: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nЗачем использовать семантическое версионирование?\nЭто не новая или революционная идея. Вероятно, вы уже используете что-то
подобное. Проблема в том, что «подобное» — не достаточно хорошо. Без
соответствия формальной спецификации, номера версий практически бесполезны для
управления зависимостями. Ясно определив и сформулировав идею версионирования,
становится легче сообщать о намерениях пользователям вашего ПО. Когда эти
намерения ясны, гибки (но не слишком), спецификации зависимостей наконец могут
быть созданы.\nПростой пример демонстрирует, как Семантическое Версионирование может сделать
«ад зависимостей» вещью из прошлого. Представим библиотеку, названную
«Firetruck». Она требует Семантически Версионированный пакет под названием
«Ladder». Когда Firetruck был создан, Ladder был 3.1.0 версии. Так как Firetruck
использует функциональность версии 3.1.0,  вы спокойно можете объявить зависимость от
Ladder версии 3.1.0, но менее чем 4.0.0. Теперь, когда доступен Ladder 3.1.1 и
3.2.0 версии, вы можете интегрировать его в вашу систему и знать, что он будет
совместим с текущей функциональностью.\nКак ответственный разработчик, вы, конечно, хотите быть уверены, что все
обновления функционируют как заявлено. В реальном мире полный бардак и ничего
нельзя с этим поделать. Что вы можете сделать — это дать Семантическому
Версионированию предоставить способ выпуска релизов без выпуска новых версий
зависимых пакетов и сохранить вам время и нервы.\nЕсли это звучит соблазнительно, всё что вам нужно — это начать использовать
Семантическое Версионирование, объявить, что вы его используете, и следовать
правилам. Добавьте ссылку на этот сайт в вашем README, тогда пользователи будут
знать правила и извлекать из этого пользу.\nЧто я должен делать с ревизиями в 0.y.z на начальной стадии разработки?\nСамое простое — начать разработку с 0.1.0 и затем увеличивать минорную версию
для каждого последующего релиза.\nКак я узнаю, когда пора делать релиз 1.0.0?\nЕсли ваше ПО используется на продакшене, оно, вероятно, уже должно быть версии
1.0.0. Если у вас стабильный API, от которого зависят пользователи, версия
должна быть 1.0.0. Если вы беспокоитесь за обратную совместимость, вероятно,
версия вашего ПО уже 1.0.0.\nНе препятствует ли это быстрой разработке и коротким итерациям?\nМажорная версия 0 как раз и означает быструю разработку. Если вы изменяете API
каждый день, вы должны быть на версии 0.y.z или на отдельной ветке разработки
работать над следующей главной версией.\nДаже если малейшие обратно несовместимые изменения в публичном API требуют выпуска новой главной версии, не закончится ли это тем, что очень скоро версия станет 42.0.0?\nЭто вопрос ответственной разработки и предвидения. Несовместимые изменения не
должны быть представлены как незначительные в ПО, имеющем много зависимого кода.
Стоимость обновления может быть велика. Практика увеличения главных версий
релизов с обратно несовместимыми изменениями означает, что вам придётся думать о
последствиях ваших изменений и учитывать соотношение цена/качество.\nДокументирование всего API — слишком много работы!\nЭто ваша ответственность, как профессионального разработчика, правильно
документировать ПО, предназначенное для широкого использования. Управление
сложностью ПО очень важная часть поддержки высокой эффективности проекта. Это
тяжело сделать, если никто не знает, как использовать ваше ПО или какой метод
можно вызывать безопасно. В долгосрочной перспективе Семантическое
Версионирование и настойчивость в качественном документировании публичного API
поможет всем и всему работать слаженно.\nЧто мне делать, если я случайно зарелизил обратно несовместимые изменения как минорную версию?\nКак только вы поняли, что нарушили спецификации Семантического Версионирования,
исправьте проблему и выпустите новую минорную версию, которая исправляет
проблему и восстанавливает обратную совместимость. Даже в таких обстоятельствах
неприемлемо модифицировать уже выпущенные релизы. Если это необходимо, укажите в
документации о нарушении обратной совместимости, версионирования и
проинформируйте ваших пользователей, чтобы они знали о нарушении порядка версий.\nЧто я должен делать, если я обновляю свои собственные зависимости без изменения публичного API?\nЭто можно рассматривать как совместимые изменения, так как они не влияют на
публичный API. ПО, которое явно зависит от тех же зависимостей что и ваш пакет,
должно иметь собственные спецификации зависимостей и автор будет уведомлен о
возможных конфликтах. Являются ли данные изменения уровня патча или
минорного уровня, зависит от того, обновили ли вы свои зависимости чтобы
исправить баг или реализовать новую функциональность. В последнем случае, как правило,
добавляется некоторое количество дополнительного кода и как следствие,
увеличивается минорная версия.\nЧто если я нечаянно изменил публичный API в несоответствии с изменением номера версии (т.е. код содержит обратно несовместимые изменения в патч-релизе)?\nНа ваше усмотрение. Если у вас огромная аудитория, которая будет поставлена
перед фактом возвращения прежнего поведения API, то лучше выпустить новый релиз
с увеличением главной версии, даже несмотря на то, что фикс содержит исправления
уровня патча. Запомните, в Семантическом Версионировании номера версий
изменяются строго следуя спецификации. Если эти изменения важны для ваших
пользователей, используйте номер версии, чтобы информировать их.\nЧто делать с устаревшей функциональностью?\nОбъявление функциональности устаревшей — это обычное дело в ходе разработки и часто
необходимо для продвижения вперёд. Когда вы объявляете устаревшим часть
публичного API, вы должны сделать две вещи: (1) обновить вашу документацию,
чтобы дать пользователям узнать об этом изменении; (2) выпустить новый релиз с
увеличением минорной версии. Прежде чем вы полностью удалите устаревшую
функциональность в релизе с увеличением главной версии, должен быть как минимум один
минорный релиз, содержащий объявление функциональности устаревшей, чтобы
пользователи могли плавно перейти на новый API.\nЕсть ли в SemVer лимиты на длину строки версии?\nНет, но руководствуйтесь здравым смыслом. 255 символов в строке версии, пожалуй,
перебор. Кроме того, определенные системы могут предъявлять свои
собственные ограничения на размер строки.\nАвторство спецификаций Семантического Версионирования принадлежит
Тому Престон-Вернеру, основателю Gravatars и
соучредителю GitHub.\nЕсли вы хотите оставить отзыв, пожалуйста, создайте запрос на
GitHub.\nсоздайте запрос на
GitHub\nCreative Commons — CC BY 3.0\nCreative Commons — CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSémantické verziovanie 2.0.0

Zhrnutie

V čísle verzie vo formáte MAJOR.MINOR.PATCH zväčšujeme číslo:


  MAJOR verzie, keď sme spravili zmeny, ktoré nie sú spätne kompatibilné,
  MINOR verzie, keď sme pridali funkcionalitu so zachovaním spätnej
kompatibility,
  PATCH verzie, keď sme opravili chyby a ostala zachovaná spätná kompatibilita.


Značenie predbežných verzií a pridávanie metadát verzií je možné rozšírením
spomínaného formátu MAJOR.MINOR.PATCH o potrebné informácie.

Úvod

Vo svete softvéru, jeho vývoja a správy existuje hrozné miesto nazývané peklo
závislostí (angl. dependency hell). Znamená to, že čím viac váš systém rastie
a máte v ňom integrovaných čoraz viac knižníc, tým je väčšia pravdepodobnosť,
že sa, kompletne zúfalí, v tomto pekle sami ocitnete.

Ak majú systémy veľa závislostí, raz-dva sa vám stane, že vydávanie novej verzie sa
stane nočnou morou. Ak je špecifikácia závislostí príliš striktná, hrozí vám, že
ostanete na jednej verzii (angl. version lock) a nebudete mať možnosť prejsť
na ďalšiu verziu bez toho, aby ste vydali ďalšie verzie všetkých balíčkov, na
ktorých závisí. Naopak, ak je špecifikácia závislostí príliš voľná, prídete na
to, že váš systém je kompatibilný s viac verziami, ako je potrebné. V pekle
závislostí sa nachádzate, ak ste zviazaný určitou verziou, prípadne nie je presne
špecifikované, ktorú máte použiť. Jednoducho, bráni vám to v tom, aby ste sa so
svojim projektom pohli bezpečne vpred.

Riešením tohto problému je jednoduchý súbor pravidiel, ktorý
určuje, ako budú čísla verzií priraďované a zväčšované. Tieto pravidlá sú
založené (no nie nevyhnutne obmedzené) na už existujúcich bežne zaužívaných
praktikách vo vývoji otvoreného, či uzavretého softvéru. Pre fungovanie
tohto systému si musíte najskôr zadefinovať rozhranie popisujúce spôsob,
akým sa bude komunikovať s vaším systémom (ďalej len API). Môže byť zadefinované
formou dokumentácie, prípadne vynútené samotným kódom. Bez ohľadu na formu akou
to bude, je
dôležité aby toto API bolo presné a jasné. Akonáhle budete mať zadefinované vaše
API, jeho zmeny budete oznamovať špecifickým zväčšením čísla verzie vášho
systému. Uvažujme, že číslo verzie bude vo formáte MAJOR.MINOR.PATCH. Opravy
chýb, ktoré nemenia vaše API, zväčšujú číslo PATCH verzie. Spätne kompatibilné
zmeny API zväčšujú číslo MINOR verzie a spätne nekompatibilné zmeny API zväčšujú
číslo MAJOR verzie.

Tento systém je nazývaný Sémantické verziovanie. Čísla verzií v tomto systéme a
spôsob, akým sa menia nesú so sebou informáciu o použitom kóde a zmenách medzi
jednotlivými verziami.

Špecifikácia sémantického verziovania (SemVer)

Kľúčové slová “MUSÍ” (angl. MUST, REQUIRED, SHALL), “NESMIE” (angl. MUST NOT,
SHALL NOT), “MALO BY” (angl. SHOULD, RECOMMENDED), “NEMALO BY” (angl. SHOULD
NOT) a “MÔŽE” (angl. MAY, OPTIONAL) sú interpretovené ako je popísané
v dokumente RFC 2119.


  
    Softvér používajúci Sémentické verziovanie MUSÍ mať zadefinované API. Toto API
môže byť definované priamo v kóde, prípadne môže existovať v dokumentácii. Nech
už to je tak alebo onak, malo by byť presné a komplexné.
  
  
    Normálne číslo verzie MUSÍ byť vo formáte X.Y.Z, kde X, Y a Z sú nezáporné
celé čísla a NESMÚ obsahovať úvodné nuly. X je číslo MAJOR verzie, Y je číslo
MINOR verzie a Z je číslo PATCH verzie. Každé z týchto čísel sa musí zväčšovať
štandardne. Napr.: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Akonáhle je takto očíslovaná verzia vydaná, softvér pod číslom tejto verzie
už NESMIE byť modifikovaný a každá zmena MUSÍ byť vydaná ako nová verzia.
  
  
    MAJOR verzia s číslom 0 (0.y.z) je pre začiatočný vývoj. Čokoľvek sa môže
zmeniť a API takto očíslovanej verzie by nemalo byť považované za stabilné.
  
  
    Verzia 1.0.0 už presne definuje API. Spôsob, akým sa po vydaní takejto verzie
mení číslo verzie je závislý na tomto API a jeho zmenách.
  
  
    Číslo PATCH verzie Z (x.y.Z | x > 0) MUSÍ byť zväčšené len vtedy, ak
boli implementované spätne kompatibilné opravy chýb. Oprava chyby je definovaná
ako interná zmena opravujúca nežiadúce chovanie.
  
  
    Číslo MINOR verzie Y (x.Y.z | x > 0) MUSÍ byť zväčšené, ak bola do API
pridaná nová, spätne kompatibilná funkcionalita a tiež MUSÍ byť zväčšené, ak
bola nejaká funcionalita označená ako zastaralá. MÔŽE tiež byť zväčšené, ak bola
pridaná alebo vylepšená podstatná funkcionalita v rámci kódu, ktorý
neovplyvňuje API. MÔŽE zahrnúť aj zmenu v rámci PATCH verzie. Číslo PATCH verzie
MUSÍ byť nastavené na 0 vždy, keď sa zmení číslo MINOR verzie.
  
  
    Číslo MAJOR verzie X (X.y.z | X > 0) MUSÍ byť zväčšené, ak boli pridané
zmeny, ktoré spôsobili, že API nie je spätne kompatibilné. MÔŽE zahrnúť aj zmenu
v rámci MINOR a PATCH verzie. Číslo MINOR aj PATCH verzie MUSÍ byť nastavené na 0
vždy, keď sa zmení číslo MAJOR verzie.
  
  
    Predbežná verzia (angl. pre-release) MÔŽE byť označená pridaním pomlčky
a sériou identifikátorov oddelených bodkou, hneď za číslo PATCH verzie.
Identifikátory MUSIA obsahovať len ASCII alfanumerické znaky a pomlčku
[0-9A-Za-z-], NESMÚ byť prázdne a číselné identifikátory NESMÚ obsahovať úvodné
nuly. Predbežné verzie majú nižšiu prioritu ako súvisiace normálne verzie.
Predbežná verzia je nestabilná a nemusí spĺňať požiadavky a závislosti ako
súvisiaca normálna verzia. Napr.: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.
  
  
    Metadáta MÔŽU byť označené vo verzii pridaním znaku plus (+) a sériou
identifikátorov oddelených bodkou, hneď za číslo PATCH alebo predbežnej verzie.
Identifikátory MUSIA obsahovať len ASCII alfanumerické znaky a pomlčku
[0-9A-Za-z-], NESMÚ byť prázdne a číselné identifikátory NESMÚ obsahovať úvodné
nuly. Metadáta by MALI BYŤ ignorované pri rozhodovaní o priorite verzie, a teda
dve verzie, ktoré sa líšia len v metadátach majú rovnakú prioritu.
Napr.: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    Priorita sa vzťahuje k tomu, ako sú verzie navzájom porovnávané. Priorita
MUSÍ byť určovaná rozdelením verzie na MAJOR, MINOR, PATCH a identifikátory
predbežných verzií ― presne v takomto poradí (s metadátami sa nepočíta).
Priorita je daná prvým rozdielom pri porovnávaní zľava doprava pričom čísla
MAJOR, MINOR a PATCH sú porovnávané vždy ako čísla. Napr.: 1.0.0 < 2.0.0 <
2.1.0 < 2.1.1. Keď sú čísla MAJOR, MINOR a PATCH rovnaké, predbežná verzia má
menšiu prioritu ako normálna. Napr.: 1.0.0-alpha < 1.0.0. Priorita pre dve
predbežné verzie, ktoré sa zhodujú v číslach MAJOR, MINOR a PATCH MUSÍ byť
počítaná z bodkou oddelených identifikátorov zľava doprava a to dovtedy, 
pokým sa nenájde rozdiel nasledovným spôsobom: (1) Identifikátory obsahujúce
iba číslice sú porovnávané číselne a identifikátory s písmenami alebo pomlčkami
sú porovnávané lexikálne, zoradené podľa ASCII. (2) Číselné identifikátory majú
vždy nižšiu prioritu ako nečíselné. (3) Ak sú všetky predchádzajúce
identifikátory v predbežnej verzii rovnaké, tak väčšie množstvo identifikátorov
značí vyššiu prioritu ako menšie množstvo. Napr.: 1.0.0-alpha < 1.0.0-alpha.1 <
1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Prečo používať Sémantické verziovanie?

Sémantické verziovanie nie je revolučná myšlienka a ak vydávate softvér,
pravdepodobne robíte niečo podobné. Problémom je, že “niečo podobné” nestačí.
Bez dodržiavania akejsi formálnej špecifikácie sú čísla pre manažment závislostí
v podstate nanič. Tým, že hore uvedeným myšlienkam dávame presnú a jasnú
definíciu, je ľahšie komunikovať zámery vášho softvéru jeho používateľom.
Akonáhle sú zámery jasné a flexibilné (ale nie príliš), špecifikácia závislostí
môže začať.

Jednoduchým príkladom demonštrujeme, že peklo závislostí môže byť pre vás ľahko
minulosťou. Predstavte si, že máte knižnicu Hasičské auto. Táto knižnica
vyžaduje sémanticky verziovanú knižnicu Rebrík. V čase, kedy je Hasičské auto
vytvorené, verzia Rebríka je 3.1.0. Keďže Hasičské auto používa funkcie,
ktoré boli pridané vo verzii 3.1.0, môžete bezpečne špecifikovať, že potrebujete
verziu Rebríka väčšiu alebo rovnú 3.1.0, no menšiu ako 4.0.0. A potom, keď vyjde
nová verzia Rebríka 3.1.1 alebo 3.2.0, môžete ju použiť vo vašom Hasičskom aute
a budete vedieť, že je s ním kompatibilná.

Ako zodpovední developeri si určite budete chcieť skontrolovať, či všetko
funguje podľa predpokladov. V skutočnosti je však všade neporiadok; tam nám
pomôže iba dávať si pozor. Čo však môžete spraviť je nechať Sémantické
verziovanie aby vám umožnilo rozumný spôsob ako vydávať a aktualizovať
knižnice tak, aby ste nemuseli riešiť nové verzie závislostí, ušetrili čas
a vyhli sa zmätkom.

Ak to znie rozumne, všetko čo potrebujete spraviť pre začatie používania
Sémantického verziovania je povedať, že to robíte a následne dodržiavať pravidlá.
Odkážte z README vášho softvéru na tieto stránky, nech aj ostatní vedia, aké
pravidlá používate a majú z nich prospech.

Často kladené otázky (FAQ)

Ako si poradiť s verziami 0.y.z na začiatku vývoja?

Najjednoduchším spôsobom je začať vývoj na verzii 0.1.0 a potom zväčšovať MINOR
verziu pri každom ďalšom vydaní softvéru.

Ako vedieť, kedy vydať verziu 1.0.0?

Ak sa váš softvér už používa v produkcii, už by pravdepodobne mal mať verziu
1.0.0. Ak máte stabilné API, ktoré už používatelia majú medzi svojimi
závislosťami, mali by ste mať verziu 1.0.0. Taktiež, ak sa obávate o spätnú
kompatibilitu, už by ste mali mať 1.0.0.

Neodrádza to od rýchleho vývoja a iterácií?

MAJOR verzia nula je o rýchlom vývoji. Ak každý deň meníte API, stále by ste
mali byť niekde vo fáze 0.x.y alebo na separátnej vývojovej vetve, kde sa
pripravuje nasledujúca MAJOR verzia.

Ak aj tie najmenšie spätne nekompatibilné zmeny v API znamenajú zväčšenie MAJOR verzie, neskončíme pomerne rýchlo niekde pri verzii 42.0.0?

To je otázka zodpovedného vývoja a prognóz. Nekompatibilné zmeny by nemali byť
do softvéru, ktorý má veľa závislostí zavádzané len tak. Náklady vynaložené na
aktualizáciu môžu byť dosť veľké. To, že musíte vydať novú MAJOR verziu znamená,
že ste si dobre premysleli dopad vašich zmien a zrátali aké to bude mať výhody
a následky.

Zdokumentovať celé API je strašne veľa práce!

Je vašou zodpovednosťou, ako profesionálnych developerov, správne dokumentovať
softvér, ktorý je určený na používanie aj pre ostatných. Spravovanie zložitosti
softvéru je veľmi dôležitá časť, ak chcete projekt udržať efektívny. A to nebude
možné, ak nikto nebude vedieť ako váš softvér používať alebo ktoré metódy je
bezpečné volať. Z dlhodobého hľadiska sa Sémantické verziovanie a dôraz na dobre
definované API ukázali ako správna voľba umožňujúca bežať veciam hladko.

Čo spraviť, keď vydám spätne nekompatibilnú verziu ako MINOR?

Akonáhle zistíte, že ste porušili pravidlá Sémantického verziovania, opravte
problém a vydajte ďalšiu MINOR verziu, ktorá opäť vráti spätnú kompatibilitu.
Napriek takejto situácii, je neprípustné aby ste menili už vydanú verziu. A ak
je to možné a vhodné, informujte používateľov o zlej verzii, aby vedeli, že sa
jedná o chybu a danej verzii sa vyhli.

Čo robiť, keď som aktualizoval vlastné závislosti bez toho, aby sa zmenilo API?

Môžeme to považovať za kompatibilné, keďže to nijako neovplyvnilo API. Softvér,
ktorý presne závisí na balíčkoch ako váš, by mal mať vlastnú definíciu
závislostí a autor si všimne akékoľvek konflikty. Rozhodnutie, či sa jedná o
MINOR alebo PATCH závisí od toho, či ste upravili vaše závislosti kvôli nejakej
chybe alebo preto, že ste pridali novú funkcionalitu. Ak sa jedná o druhý
prípad, zvyčajne tam bude aj nejaký kód, a tak sa jedná o zväčšenie MINOR
verzie.

Čo keď som nechtiac zmenil API, spôsobom, ktorý nie v súlade so zmenou čísla verzie (napríklad som zaviedol MAJOR zmenu v PATCH verzii)?

Usúďte, čo je najlepšie. Ak máte veľkú skupinu používateľov, ktorá by bola
ovplyvnená zmenou späť, tak asi bude najlepšie vydať MAJOR verziu, napriek tomu,
že oprava späť by mala byť súčasťou PATCH verzie. Pamätajte, že Sémantické
verziovanie je o tom, ako sa verzie menia. Ak sú zmeny pre vašich používateľov
dôležité, použite také číslo verzie, aby ste ich informovali.

Ako sa vysporiadať so zastarávaním funkcionality?

Označenie funcionality ako zastaralej je štandardná časť softvérového vývoja
a väčšinou je žiadané ísť vpred, takže k tomu jednoducho dôjde. Keď zastarávate
časť svojho API, mali by ste spraviť dve veci: (1) upraviť dokumentáciu aby
používatelia vedeli o zmene, (2) vydať ďalšiu MINOR verziu, ktorá funcionalitu
zastaráva. A teda, predtým ako funkcionalitu kompletne odstránite v ďalšej
MAJOR verzii, mali by ste spraviť aspoň jednu MINOR verziu, ktorá obsahuje
zastaranie a používatelia mohli ľahko prejsť na nové API.

Má Sémantické verziovanie nejaký limit na dĺžku označenia verzie?

Nie, no použite zdravý rozum. Číslo verzie, ktoré má 255 znakov je už asi moc,
no špecifické systémy môžu mať vlastné limity na dĺžku čísla verzie.

O špecifikácii

Autorom špecifikácie sémantického verziovania je
Tom Preston-Werner, autor projektu Gravatar a
spoluzakladateľ projektu Github.

Ak chcete zanechať spätnú väzbu, prosím
cez GitHub.

Preklad

Vladimír Kriška (autor),
Tibor Soviš (korektor),
Peter Dulačka (korektor),
Jaroslav Brtiš (korektor)

Licencia

Creative Commons ― CC BY 3.0\nSémantické verziovanie 2.0.0\nV čísle verzie vo formáte MAJOR.MINOR.PATCH zväčšujeme číslo:\nMAJOR verzie, keď sme spravili zmeny, ktoré nie sú spätne kompatibilné,\nMINOR verzie, keď sme pridali funkcionalitu so zachovaním spätnej
kompatibility,\nPATCH verzie, keď sme opravili chyby a ostala zachovaná spätná kompatibilita.\nZnačenie predbežných verzií a pridávanie metadát verzií je možné rozšírením
spomínaného formátu MAJOR.MINOR.PATCH o potrebné informácie.\nVo svete softvéru, jeho vývoja a správy existuje hrozné miesto nazývané peklo
závislostí (angl. dependency hell). Znamená to, že čím viac váš systém rastie
a máte v ňom integrovaných čoraz viac knižníc, tým je väčšia pravdepodobnosť,
že sa, kompletne zúfalí, v tomto pekle sami ocitnete.\nAk majú systémy veľa závislostí, raz-dva sa vám stane, že vydávanie novej verzie sa
stane nočnou morou. Ak je špecifikácia závislostí príliš striktná, hrozí vám, že
ostanete na jednej verzii (angl. version lock) a nebudete mať možnosť prejsť
na ďalšiu verziu bez toho, aby ste vydali ďalšie verzie všetkých balíčkov, na
ktorých závisí. Naopak, ak je špecifikácia závislostí príliš voľná, prídete na
to, že váš systém je kompatibilný s viac verziami, ako je potrebné. V pekle
závislostí sa nachádzate, ak ste zviazaný určitou verziou, prípadne nie je presne
špecifikované, ktorú máte použiť. Jednoducho, bráni vám to v tom, aby ste sa so
svojim projektom pohli bezpečne vpred.\nRiešením tohto problému je jednoduchý súbor pravidiel, ktorý
určuje, ako budú čísla verzií priraďované a zväčšované. Tieto pravidlá sú
založené (no nie nevyhnutne obmedzené) na už existujúcich bežne zaužívaných
praktikách vo vývoji otvoreného, či uzavretého softvéru. Pre fungovanie
tohto systému si musíte najskôr zadefinovať rozhranie popisujúce spôsob,
akým sa bude komunikovať s vaším systémom (ďalej len API). Môže byť zadefinované
formou dokumentácie, prípadne vynútené samotným kódom. Bez ohľadu na formu akou
to bude, je
dôležité aby toto API bolo presné a jasné. Akonáhle budete mať zadefinované vaše
API, jeho zmeny budete oznamovať špecifickým zväčšením čísla verzie vášho
systému. Uvažujme, že číslo verzie bude vo formáte MAJOR.MINOR.PATCH. Opravy
chýb, ktoré nemenia vaše API, zväčšujú číslo PATCH verzie. Spätne kompatibilné
zmeny API zväčšujú číslo MINOR verzie a spätne nekompatibilné zmeny API zväčšujú
číslo MAJOR verzie.\nTento systém je nazývaný Sémantické verziovanie. Čísla verzií v tomto systéme a
spôsob, akým sa menia nesú so sebou informáciu o použitom kóde a zmenách medzi
jednotlivými verziami.\nŠpecifikácia sémantického verziovania (SemVer)\nKľúčové slová “MUSÍ” (angl. MUST, REQUIRED, SHALL), “NESMIE” (angl. MUST NOT,
SHALL NOT), “MALO BY” (angl. SHOULD, RECOMMENDED), “NEMALO BY” (angl. SHOULD
NOT) a “MÔŽE” (angl. MAY, OPTIONAL) sú interpretovené ako je popísané
v dokumente RFC 2119.\nSoftvér používajúci Sémentické verziovanie MUSÍ mať zadefinované API. Toto API
môže byť definované priamo v kóde, prípadne môže existovať v dokumentácii. Nech
už to je tak alebo onak, malo by byť presné a komplexné.\nSoftvér používajúci Sémentické verziovanie MUSÍ mať zadefinované API. Toto API
môže byť definované priamo v kóde, prípadne môže existovať v dokumentácii. Nech
už to je tak alebo onak, malo by byť presné a komplexné.\nNormálne číslo verzie MUSÍ byť vo formáte X.Y.Z, kde X, Y a Z sú nezáporné
celé čísla a NESMÚ obsahovať úvodné nuly. X je číslo MAJOR verzie, Y je číslo
MINOR verzie a Z je číslo PATCH verzie. Každé z týchto čísel sa musí zväčšovať
štandardne. Napr.: 1.9.0 -> 1.10.0 -> 1.11.0.\nNormálne číslo verzie MUSÍ byť vo formáte X.Y.Z, kde X, Y a Z sú nezáporné
celé čísla a NESMÚ obsahovať úvodné nuly. X je číslo MAJOR verzie, Y je číslo
MINOR verzie a Z je číslo PATCH verzie. Každé z týchto čísel sa musí zväčšovať
štandardne. Napr.: 1.9.0 -> 1.10.0 -> 1.11.0.\nAkonáhle je takto očíslovaná verzia vydaná, softvér pod číslom tejto verzie
už NESMIE byť modifikovaný a každá zmena MUSÍ byť vydaná ako nová verzia.\nAkonáhle je takto očíslovaná verzia vydaná, softvér pod číslom tejto verzie
už NESMIE byť modifikovaný a každá zmena MUSÍ byť vydaná ako nová verzia.\nMAJOR verzia s číslom 0 (0.y.z) je pre začiatočný vývoj. Čokoľvek sa môže
zmeniť a API takto očíslovanej verzie by nemalo byť považované za stabilné.\nMAJOR verzia s číslom 0 (0.y.z) je pre začiatočný vývoj. Čokoľvek sa môže
zmeniť a API takto očíslovanej verzie by nemalo byť považované za stabilné.\nVerzia 1.0.0 už presne definuje API. Spôsob, akým sa po vydaní takejto verzie
mení číslo verzie je závislý na tomto API a jeho zmenách.\nVerzia 1.0.0 už presne definuje API. Spôsob, akým sa po vydaní takejto verzie
mení číslo verzie je závislý na tomto API a jeho zmenách.\nČíslo PATCH verzie Z (x.y.Z | x > 0) MUSÍ byť zväčšené len vtedy, ak
boli implementované spätne kompatibilné opravy chýb. Oprava chyby je definovaná
ako interná zmena opravujúca nežiadúce chovanie.\nČíslo PATCH verzie Z (x.y.Z | x > 0) MUSÍ byť zväčšené len vtedy, ak
boli implementované spätne kompatibilné opravy chýb. Oprava chyby je definovaná
ako interná zmena opravujúca nežiadúce chovanie.\nČíslo MINOR verzie Y (x.Y.z | x > 0) MUSÍ byť zväčšené, ak bola do API
pridaná nová, spätne kompatibilná funkcionalita a tiež MUSÍ byť zväčšené, ak
bola nejaká funcionalita označená ako zastaralá. MÔŽE tiež byť zväčšené, ak bola
pridaná alebo vylepšená podstatná funkcionalita v rámci kódu, ktorý
neovplyvňuje API. MÔŽE zahrnúť aj zmenu v rámci PATCH verzie. Číslo PATCH verzie
MUSÍ byť nastavené na 0 vždy, keď sa zmení číslo MINOR verzie.\nČíslo MINOR verzie Y (x.Y.z | x > 0) MUSÍ byť zväčšené, ak bola do API
pridaná nová, spätne kompatibilná funkcionalita a tiež MUSÍ byť zväčšené, ak
bola nejaká funcionalita označená ako zastaralá. MÔŽE tiež byť zväčšené, ak bola
pridaná alebo vylepšená podstatná funkcionalita v rámci kódu, ktorý
neovplyvňuje API. MÔŽE zahrnúť aj zmenu v rámci PATCH verzie. Číslo PATCH verzie
MUSÍ byť nastavené na 0 vždy, keď sa zmení číslo MINOR verzie.\nČíslo MAJOR verzie X (X.y.z | X > 0) MUSÍ byť zväčšené, ak boli pridané
zmeny, ktoré spôsobili, že API nie je spätne kompatibilné. MÔŽE zahrnúť aj zmenu
v rámci MINOR a PATCH verzie. Číslo MINOR aj PATCH verzie MUSÍ byť nastavené na 0
vždy, keď sa zmení číslo MAJOR verzie.\nČíslo MAJOR verzie X (X.y.z | X > 0) MUSÍ byť zväčšené, ak boli pridané
zmeny, ktoré spôsobili, že API nie je spätne kompatibilné. MÔŽE zahrnúť aj zmenu
v rámci MINOR a PATCH verzie. Číslo MINOR aj PATCH verzie MUSÍ byť nastavené na 0
vždy, keď sa zmení číslo MAJOR verzie.\nPredbežná verzia (angl. pre-release) MÔŽE byť označená pridaním pomlčky
a sériou identifikátorov oddelených bodkou, hneď za číslo PATCH verzie.
Identifikátory MUSIA obsahovať len ASCII alfanumerické znaky a pomlčku
[0-9A-Za-z-], NESMÚ byť prázdne a číselné identifikátory NESMÚ obsahovať úvodné
nuly. Predbežné verzie majú nižšiu prioritu ako súvisiace normálne verzie.
Predbežná verzia je nestabilná a nemusí spĺňať požiadavky a závislosti ako
súvisiaca normálna verzia. Napr.: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.\nPredbežná verzia (angl. pre-release) MÔŽE byť označená pridaním pomlčky
a sériou identifikátorov oddelených bodkou, hneď za číslo PATCH verzie.
Identifikátory MUSIA obsahovať len ASCII alfanumerické znaky a pomlčku
[0-9A-Za-z-], NESMÚ byť prázdne a číselné identifikátory NESMÚ obsahovať úvodné
nuly. Predbežné verzie majú nižšiu prioritu ako súvisiace normálne verzie.
Predbežná verzia je nestabilná a nemusí spĺňať požiadavky a závislosti ako
súvisiaca normálna verzia. Napr.: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.\nMetadáta MÔŽU byť označené vo verzii pridaním znaku plus (+) a sériou
identifikátorov oddelených bodkou, hneď za číslo PATCH alebo predbežnej verzie.
Identifikátory MUSIA obsahovať len ASCII alfanumerické znaky a pomlčku
[0-9A-Za-z-], NESMÚ byť prázdne a číselné identifikátory NESMÚ obsahovať úvodné
nuly. Metadáta by MALI BYŤ ignorované pri rozhodovaní o priorite verzie, a teda
dve verzie, ktoré sa líšia len v metadátach majú rovnakú prioritu.
Napr.: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nMetadáta MÔŽU byť označené vo verzii pridaním znaku plus (+) a sériou
identifikátorov oddelených bodkou, hneď za číslo PATCH alebo predbežnej verzie.
Identifikátory MUSIA obsahovať len ASCII alfanumerické znaky a pomlčku
[0-9A-Za-z-], NESMÚ byť prázdne a číselné identifikátory NESMÚ obsahovať úvodné
nuly. Metadáta by MALI BYŤ ignorované pri rozhodovaní o priorite verzie, a teda
dve verzie, ktoré sa líšia len v metadátach majú rovnakú prioritu.
Napr.: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nPriorita sa vzťahuje k tomu, ako sú verzie navzájom porovnávané. Priorita
MUSÍ byť určovaná rozdelením verzie na MAJOR, MINOR, PATCH a identifikátory
predbežných verzií ― presne v takomto poradí (s metadátami sa nepočíta).
Priorita je daná prvým rozdielom pri porovnávaní zľava doprava pričom čísla
MAJOR, MINOR a PATCH sú porovnávané vždy ako čísla. Napr.: 1.0.0 < 2.0.0 <
2.1.0 < 2.1.1. Keď sú čísla MAJOR, MINOR a PATCH rovnaké, predbežná verzia má
menšiu prioritu ako normálna. Napr.: 1.0.0-alpha < 1.0.0. Priorita pre dve
predbežné verzie, ktoré sa zhodujú v číslach MAJOR, MINOR a PATCH MUSÍ byť
počítaná z bodkou oddelených identifikátorov zľava doprava a to dovtedy, 
pokým sa nenájde rozdiel nasledovným spôsobom: (1) Identifikátory obsahujúce
iba číslice sú porovnávané číselne a identifikátory s písmenami alebo pomlčkami
sú porovnávané lexikálne, zoradené podľa ASCII. (2) Číselné identifikátory majú
vždy nižšiu prioritu ako nečíselné. (3) Ak sú všetky predchádzajúce
identifikátory v predbežnej verzii rovnaké, tak väčšie množstvo identifikátorov
značí vyššiu prioritu ako menšie množstvo. Napr.: 1.0.0-alpha < 1.0.0-alpha.1 <
1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPriorita sa vzťahuje k tomu, ako sú verzie navzájom porovnávané. Priorita
MUSÍ byť určovaná rozdelením verzie na MAJOR, MINOR, PATCH a identifikátory
predbežných verzií ― presne v takomto poradí (s metadátami sa nepočíta).
Priorita je daná prvým rozdielom pri porovnávaní zľava doprava pričom čísla
MAJOR, MINOR a PATCH sú porovnávané vždy ako čísla. Napr.: 1.0.0 < 2.0.0 <
2.1.0 < 2.1.1. Keď sú čísla MAJOR, MINOR a PATCH rovnaké, predbežná verzia má
menšiu prioritu ako normálna. Napr.: 1.0.0-alpha < 1.0.0. Priorita pre dve
predbežné verzie, ktoré sa zhodujú v číslach MAJOR, MINOR a PATCH MUSÍ byť
počítaná z bodkou oddelených identifikátorov zľava doprava a to dovtedy, 
pokým sa nenájde rozdiel nasledovným spôsobom: (1) Identifikátory obsahujúce
iba číslice sú porovnávané číselne a identifikátory s písmenami alebo pomlčkami
sú porovnávané lexikálne, zoradené podľa ASCII. (2) Číselné identifikátory majú
vždy nižšiu prioritu ako nečíselné. (3) Ak sú všetky predchádzajúce
identifikátory v predbežnej verzii rovnaké, tak väčšie množstvo identifikátorov
značí vyššiu prioritu ako menšie množstvo. Napr.: 1.0.0-alpha < 1.0.0-alpha.1 <
1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPrečo používať Sémantické verziovanie?\nSémantické verziovanie nie je revolučná myšlienka a ak vydávate softvér,
pravdepodobne robíte niečo podobné. Problémom je, že “niečo podobné” nestačí.
Bez dodržiavania akejsi formálnej špecifikácie sú čísla pre manažment závislostí
v podstate nanič. Tým, že hore uvedeným myšlienkam dávame presnú a jasnú
definíciu, je ľahšie komunikovať zámery vášho softvéru jeho používateľom.
Akonáhle sú zámery jasné a flexibilné (ale nie príliš), špecifikácia závislostí
môže začať.\nJednoduchým príkladom demonštrujeme, že peklo závislostí môže byť pre vás ľahko
minulosťou. Predstavte si, že máte knižnicu Hasičské auto. Táto knižnica
vyžaduje sémanticky verziovanú knižnicu Rebrík. V čase, kedy je Hasičské auto
vytvorené, verzia Rebríka je 3.1.0. Keďže Hasičské auto používa funkcie,
ktoré boli pridané vo verzii 3.1.0, môžete bezpečne špecifikovať, že potrebujete
verziu Rebríka väčšiu alebo rovnú 3.1.0, no menšiu ako 4.0.0. A potom, keď vyjde
nová verzia Rebríka 3.1.1 alebo 3.2.0, môžete ju použiť vo vašom Hasičskom aute
a budete vedieť, že je s ním kompatibilná.\nAko zodpovední developeri si určite budete chcieť skontrolovať, či všetko
funguje podľa predpokladov. V skutočnosti je však všade neporiadok; tam nám
pomôže iba dávať si pozor. Čo však môžete spraviť je nechať Sémantické
verziovanie aby vám umožnilo rozumný spôsob ako vydávať a aktualizovať
knižnice tak, aby ste nemuseli riešiť nové verzie závislostí, ušetrili čas
a vyhli sa zmätkom.\nAk to znie rozumne, všetko čo potrebujete spraviť pre začatie používania
Sémantického verziovania je povedať, že to robíte a následne dodržiavať pravidlá.
Odkážte z README vášho softvéru na tieto stránky, nech aj ostatní vedia, aké
pravidlá používate a majú z nich prospech.\nČasto kladené otázky (FAQ)\nAko si poradiť s verziami 0.y.z na začiatku vývoja?\nNajjednoduchším spôsobom je začať vývoj na verzii 0.1.0 a potom zväčšovať MINOR
verziu pri každom ďalšom vydaní softvéru.\nAko vedieť, kedy vydať verziu 1.0.0?\nAk sa váš softvér už používa v produkcii, už by pravdepodobne mal mať verziu
1.0.0. Ak máte stabilné API, ktoré už používatelia majú medzi svojimi
závislosťami, mali by ste mať verziu 1.0.0. Taktiež, ak sa obávate o spätnú
kompatibilitu, už by ste mali mať 1.0.0.\nNeodrádza to od rýchleho vývoja a iterácií?\nMAJOR verzia nula je o rýchlom vývoji. Ak každý deň meníte API, stále by ste
mali byť niekde vo fáze 0.x.y alebo na separátnej vývojovej vetve, kde sa
pripravuje nasledujúca MAJOR verzia.\nAk aj tie najmenšie spätne nekompatibilné zmeny v API znamenajú zväčšenie MAJOR verzie, neskončíme pomerne rýchlo niekde pri verzii 42.0.0?\nTo je otázka zodpovedného vývoja a prognóz. Nekompatibilné zmeny by nemali byť
do softvéru, ktorý má veľa závislostí zavádzané len tak. Náklady vynaložené na
aktualizáciu môžu byť dosť veľké. To, že musíte vydať novú MAJOR verziu znamená,
že ste si dobre premysleli dopad vašich zmien a zrátali aké to bude mať výhody
a následky.\nZdokumentovať celé API je strašne veľa práce!\nJe vašou zodpovednosťou, ako profesionálnych developerov, správne dokumentovať
softvér, ktorý je určený na používanie aj pre ostatných. Spravovanie zložitosti
softvéru je veľmi dôležitá časť, ak chcete projekt udržať efektívny. A to nebude
možné, ak nikto nebude vedieť ako váš softvér používať alebo ktoré metódy je
bezpečné volať. Z dlhodobého hľadiska sa Sémantické verziovanie a dôraz na dobre
definované API ukázali ako správna voľba umožňujúca bežať veciam hladko.\nČo spraviť, keď vydám spätne nekompatibilnú verziu ako MINOR?\nAkonáhle zistíte, že ste porušili pravidlá Sémantického verziovania, opravte
problém a vydajte ďalšiu MINOR verziu, ktorá opäť vráti spätnú kompatibilitu.
Napriek takejto situácii, je neprípustné aby ste menili už vydanú verziu. A ak
je to možné a vhodné, informujte používateľov o zlej verzii, aby vedeli, že sa
jedná o chybu a danej verzii sa vyhli.\nČo robiť, keď som aktualizoval vlastné závislosti bez toho, aby sa zmenilo API?\nMôžeme to považovať za kompatibilné, keďže to nijako neovplyvnilo API. Softvér,
ktorý presne závisí na balíčkoch ako váš, by mal mať vlastnú definíciu
závislostí a autor si všimne akékoľvek konflikty. Rozhodnutie, či sa jedná o
MINOR alebo PATCH závisí od toho, či ste upravili vaše závislosti kvôli nejakej
chybe alebo preto, že ste pridali novú funkcionalitu. Ak sa jedná o druhý
prípad, zvyčajne tam bude aj nejaký kód, a tak sa jedná o zväčšenie MINOR
verzie.\nČo keď som nechtiac zmenil API, spôsobom, ktorý nie v súlade so zmenou čísla verzie (napríklad som zaviedol MAJOR zmenu v PATCH verzii)?\nUsúďte, čo je najlepšie. Ak máte veľkú skupinu používateľov, ktorá by bola
ovplyvnená zmenou späť, tak asi bude najlepšie vydať MAJOR verziu, napriek tomu,
že oprava späť by mala byť súčasťou PATCH verzie. Pamätajte, že Sémantické
verziovanie je o tom, ako sa verzie menia. Ak sú zmeny pre vašich používateľov
dôležité, použite také číslo verzie, aby ste ich informovali.\nAko sa vysporiadať so zastarávaním funkcionality?\nOznačenie funcionality ako zastaralej je štandardná časť softvérového vývoja
a väčšinou je žiadané ísť vpred, takže k tomu jednoducho dôjde. Keď zastarávate
časť svojho API, mali by ste spraviť dve veci: (1) upraviť dokumentáciu aby
používatelia vedeli o zmene, (2) vydať ďalšiu MINOR verziu, ktorá funcionalitu
zastaráva. A teda, predtým ako funkcionalitu kompletne odstránite v ďalšej
MAJOR verzii, mali by ste spraviť aspoň jednu MINOR verziu, ktorá obsahuje
zastaranie a používatelia mohli ľahko prejsť na nové API.\nMá Sémantické verziovanie nejaký limit na dĺžku označenia verzie?\nNie, no použite zdravý rozum. Číslo verzie, ktoré má 255 znakov je už asi moc,
no špecifické systémy môžu mať vlastné limity na dĺžku čísla verzie.\nAutorom špecifikácie sémantického verziovania je
Tom Preston-Werner, autor projektu Gravatar a
spoluzakladateľ projektu Github.\nAk chcete zanechať spätnú väzbu, prosím
cez GitHub.\nVladimír Kriška (autor),
Tibor Soviš (korektor),
Peter Dulačka (korektor),
Jaroslav Brtiš (korektor)\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSemantične verzije 2.0.0

Povzetek

Dane številke verzij GLAVNA.MANJŠA.POPRAVEK povečajte:


  GLAVNO verzijo, ko naredite nazaj nezdružljive spremembe API-ja,
  MANJŠO verzijo, ko dodate funkcionalnost na način združljivosti za
nazaj in
  POPRAVEK verzije, ko naredite popravke hroščev z združljivostjo za nazaj.


Dodatne oznake za pred-izdaje in metapodatki gradnje so na voljo kot razširitve v obliki GLAVNA.MANJŠA.POPRAVEK.

Uvod

V svetu programske opreme obstaja grozen prostor imenovan
“pekel odvisnosti”. Večji kot sistem zraste in več je paketov,
ki jih integrirate v vašo programsko opremo, bolj možno se boste našli nekega
dne v tem obupu.

V sistemih z veliko odvisnostmi lahko izdaja nove verzije paketa hitro
postane nočna mora. Če so specifikacije odvisnosti preveč ozke, ste v
nevarnosti zaklenjenih verzij (nezmožnost nadgradnje paketa brez, da
izdajate nove verzije za vsak odvisni paket). Če so odvisnosti
določene preveč ohlapno, boste neizogibno ugriznjeni s strani promiskuitete verzije
(ob predpostavki, da je združljivost z večimi prihodnjimi verzijami razumna).
Pekel odvisnosti je, kjer ste vi, ko je verzija zaklenjena in/ali vam promiskuiteta verzije
preprečuje, da enostavno in varno prestavite vaš projekt naprej.

Kot rešitev tega problema, predlagam enostaven skupek pravil in
zahtev, ki diktirajo, kako naj bodo številke verzij določene in povečane.
Ta pravila so osnovana na in ne nujno omejena na pred obstoječe
široko skupne prakse v uporabi tako v programski opremi zaprte kode kot odprte kode.
Da ta sistem deluje, morate najprej določiti javni API. To lahko sestoji
iz dokumentacije ali je izvršeno s strani same kode. Ne glede na to,
pomembno je, da je ta API jasen in točen. Ko enkrat identificirate vaš javni
API, lahko komunicirate spremembe na njem z določenimi povečanji na vaši številki
verzije. Smatrajte obliko verzije X.Y.Z (Glavna.Manjša.Popravek). Popravki hroščev ne
vplivajo na API a povečujejo številko popravka, nazaj združljivi API
dodatki/spremembe povečujejo manjšo verzijo in nazaj nezdružljive API
spremembe povečujejo glavno verzijo.

Ta sistem se imenuje “Semantične verzije.” Pod to shemo, številke verzij
in način, kako spreminjajo poslani pomen o podležeči kodi in kaj je bilo
spremenjeno iz ene verzije v naslednji.

Specifikacija semantičnih verzij (SemVer)

Ključne besede “MORA”, “NE SME”, “ZAHTEVANO”, “BO”, “NE BO”, “BI MORALO”,
“NE BI SMELO”, “PRIPOROČLJIVO”, “LAHKO” in “OPCIJSKO” se v tem dokumentu
interpretira, kot so opisane v RFC 2119.


  
    Programska oprema, ki uporablja semantične verzije MORA določiti javni API. Ta API
je lahko določen v sami kodi ali obstaja striktno v dokumentaciji.
Kakorkoli je končan, bi moral biti točen in celovit.
  
  
    Običajna številka verzije MORA biti oblike X.Y.Z, kjer so X, Y, in Z
pozitivna cena števila in NE SMEJO vsebovati vodilnih ničel. X je
glavna verzija, Y je manjša verzija in Z je verzija popravka.
Vsak element se MORA povečati numerično. Na primer: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Ko je enkrat paket verzije izdan, se vsebina te verzija
NE SME spremeniti. Kakršnekoli spremembe MORAJO biti izdane kot nova verzija.
  
  
    Glavna verzija nič (0.y.z) je za začetni razvoj. Karkoli se lahko spremeni
kadarkoli. Javni API ne bi smel biti smatran za stabilnega.
  
  
    Verzija 1.0.0 definira javni API. Način, kako je številka verzija
povečana za to izdajo je odvisno od tega javnega API-ja in kako se
spremeni.
  
  
    Verzija popravka Z (x.y.Z | x > 0) MORA biti povečana, če so predstavljeni samo nazaj
združljivi popravki hroščev. Popravek hrošča je definiran kot notranja
sprememba, ki popravi nepravilno obnašanje.
  
  
    Manjša verzija Y (x.Y.z | x > 0) MORA biti povečana, če so nove nazaj
združljive funkcionalnosti predstavljene javnemu API-ju. MORA biti
povečana, če je katerakoli funkcionalnost javnega API-ja označena za opuščeno. LAHKO
je povečana, če so znatna nova funkcionalnost ali izboljšave predstavljene
znotraj privatne kode. LAHKO vključuje spremembe nivoja popravka. Verzija popravka
MORA biti ponastavljena na nič, ko je manjša verzija povečana.
  
  
    Glavna verzija X (X.y.z | X > 0) MORA biti povečevana, če je kakršnakoli nazaj
nezdružljiva sprememba predstavljena javnemu API-ju. LAHKO vključuje spremembe
manjše verzije in verzije popravka. Manjša verzija in popravek MORATA biti ponastavljena na 0, ko je
glavna verzija povečana.
  
  
    Verzija pred-izdaje je LAHKO označena z dodajanjem vezaja in
serije s pikami ločenih identifikatorjev, ki jim takoj sledi verzija
popravka. Identifikatorji MORAJO biti sestavljeni iz samo alfanumeričnih ASCII-jev in vezaja
[0-9A-Za-z-]. Identifikatorji NE SMEJO biti prazni. Numerični identifikatorji NE
SMEJO vključevati vodilnih ničel. Verzije pred-izdaj imajo manjši
vrstni red, ko povezana običajna verzija. Verzija pred-izdaje
označuje, da je verzija nestabilna in lahko ne zadosti
namenjenim zahtevam združljivosti, kot je označeno z njihovimi povezanimi
normalnimi verzijami. Na primer: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.
  
  
    Metapodatki gradnje so LAHKO označeni z dodajanjem znaka plus in serije pik
ločenih identifikatorjev, ki jim takoj sledi popravek ali verzija pred-izdaje.
Identifikatorji MORAJO biti sestavljeni iz samo alfanumeričnih ASCII-jev in vezajev [0-9A-Za-z-].
Identifikatorji NE SMEJO biti prazni. Podatki metagradnje BI MORALI biti ignorirani, ko se določa
vrstni red verzij. Zato dve verziji, ki se razlikujeta samo v metapodatkih gradnje,
imata enak vrstni red. Na primer: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85.
  
  
    Vrstni red se sklicuje na to, kako so verzije primerjane druga z drugo, ko so urejene.
Vrstni red MORA biti izračunan z ločitvijo verzije v glavno, manjšo, popravek
in identifikator pred-izdaje v tem vrstnem redu (metapodatki gradnje ne pašejo
v vrstni red). Vrstni red je določen s prvo razliko, ko
primerjate vsako od teh identifikatorjev iz leve proti desni kot sledi: Verzije glavna, manjša
in popravek so vedno primerjane s številkami. Na primer: 1.0.0 < 2.0.0 <
2.1.0 < 2.1.1. Ko so glavna, manjša in popravek enake, ima verzija pred-izdaje
manjši vrstni red kot običajne izdaje. Na primer 1.0.0-alpha < 1.0.0. Vrstni red
za dve verziji pred-izdaje z enako verzijo glavne, manjše in popravka MORATA
biti določeli s primerjanjem vsake pike ločenega identifikatorja iz leve proti desni
dokler ni razlika najdena kot sledi: identifikatorji sestavljeni iz samo številk
so primerjani numerično in identifikatorji s črkami ali vezaji so primerjani
besedno v ASCII vrstnem redu. Numerični identifikatorji imajo vedno manjši vrstni red
kot ne-numerični identifikatorji. Večji skupek polj pred-izdaje imajo večji
vrstni red kot manjši skupek, če vsi prejšnji identifikatorji so enaki.
Na primer: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Zakaj uporabljati semantične verzije?

To ni nova ali revolucionarna ideja. V bistvu delate nekaj podobnega
temu že sedaj. Problem je, da “nekaj podobnega” ni dovolj dobro. Brez
skladnosti z nekakšno uradno specifikacijo, so številke verzij
v bistvu neuporabne za upravljanje odvisnosti. Z dodajanjem imena in jasne
definicije zgornjim idejam, postane enostavno za komunicirati vaše namere
uporabnikom vaše programske opreme. Ko enkrat postanejo te namere jasne, fleksibilne (vendar
ne preveč fleksibilne), se lahko končno naredi specifikacija odvisnosti.

Enostaven primer bo demonstriral, kako semantične verzije lahko naredijo pekel
odvisnosti stvar preteklosti. Premislite o knjižnici imenovani “Firetruck”. Zahteva
paket s semantično verzijo in se imenuje “Ladder”. Ko je Firetruck
narejen, je Ladder pri verziji 3.1.0, lahko varno določite verzijo odvisnosti Ladder
kot večjo ali enako 3.1.0, vendar manjšo kot 4.0.0. Sedaj ko postane
Ladder verzija 3.1.1 in 3.2.0 postane na voljo, jih lahko izdate v vašem
sistemu paketnega upravljanja in veste, da bodo postale kompatibilne z obstoječo
odvisno programsko opremo.

Kot odgovoren razvijalec boste seveda želeli preveriti, da katerikoli
paket nadgradnje funkcionira, kot je oglaševano. Realni svet je grdo mesto;
ničesar ni, kar bi lahko naredili o tem, razen da smo pazljivi. Kar lahko naredite je
omogočiti semantičnim verzijam, da vam ponudijo pameten način izdaje in nadgradnje
paketov brez, da morate kotaliti nove verzije odvisnih paketov, kar vam prihrani
čas in težave.

Če to vse zveni zaželjeno, je vse kar morate storiti, da začnete uporabljati semantične
verzije, razglasitev, da to tako delate in nato slediti pravilom. Povežite
na to spletno stran iz vaše datoteke README, da ostali vedo pravila in jih lahko
koristijo.

Pogosta vprašanja

Kako ravnam z revizijami v 0.y.z začetni fazi razvoja?

Najenostavnejše narediti je začeti vašo začetno razvojno izdajo pri 0.1.0
in nato povečevati manjše verzije za vsako naknadno izdajo.

Kako vem, kdaj izdati 1.0.0?

Če je vaša programska oprema uporabljena v produkciji, bi morala verjeno že biti
1.0.0. Če imate stabilni API od katerega so postali uporabniki odvisni, bi morali
imeti 1.0.0. Če vas skrbi veliko o združljivosti za nazaj, bi morali verjetno
že biti na 1.0.0.

Ali to ne odvrača hitrega razvoja in hitrih interacij?

Glavna verzija nič je vse o hitrem razvoju. Če spreminjate API
vsak dan, bi morali ali biti še vedno na verziji 0.y.z ali na ločeni
razvojni veji delati na naslednji glavni verziji.

Če tudi najmanjša nazaj nezdružljiva sprememba javnega API-ja zahteva povečanje glavne verzije, ali ne bom potem končal pri verziji 42.0.0 zelo hitro?

To je vprašanje odgovornega razvoja in vpogleda vnaprej. Nezdružljive
spremembe ne bi smele biti predstavljene ohlapno v programsko opremo, ki ima
veliko odvisne kode. Cena, ki mora nastati za nadgradnjo, je lahko pomembna.
Povečanje glavnih verzij za izdajo nekompatibilnih sprememb pomeni, da boste
premislili skozi vpliv vaših sprememb in ocenili vpleteno razmerje
cena/korist.

Dokumentiranje celotnega javnega API-ja je preveč dela!

Vaša odgovornost kot profesionalnega razvijalca je, da ustrezno dokumentirate
programsko opremo, ki je nameravana za uporabo s strani drugih. Upravljanje kompleksnosti programske opreme je
zelo pomemben del, da obdržite projekt učinkovit in to narediti je težko, če
nihče ne ve, kako uporabiti vašo programsko opremo ali katere metode so varne za klicanje. Na
dolgi rok semantične verzije in vztrajanje na dobro definiranem javnem
API-ju lahko obdrži poganjanje vsakogar in vsega gladko.

Kaj narediti, če ponesreči izdam nazaj nezdružljivo spremembo kot manjšo verzijo?

Kakor hitro se zaveste, da ste prelomili specifikacijo semantičnih verzij, popravite
problem in izdajte novo manjšo verzijo, ki popravi problem in
povrne združljivost za nazaj. Tudi pod temi okoliščinami, ni
sprejemljivo spreminjati verzij izdaj. Če je primerno,
dokumentirajte kršeno izdajo in obvestite vaše uporabnike o problemu, da so
seznanjeni o kršeni izdaji.

Kaj naj naredim, če posodobim svoje lastne odvisnosti brez spremembe javnega API-ja?

To bi moralo biti smatrano kompatibilno, ker ne vpliva na javni API.
Programska oprema, ki je eksplicitno odvisna od istih odvistnosti, bi vaš paket
moral imeti svoje lastne specifikacije odvisnosti in avtor bo opazil kakršnekoli
konflikte. Določanje ali je sprememba modifikacije nivoja popravka ali manjšega nivoja
zavisi na tem ali posodabljate vaše odvisnosti z namenom popraviti hrošč ali dodati novo
funkcionalnost. Običajno bi pričakoval dodatno kodo
za slednjo instanco, v katerem primeru je očitno povečanje manjšega nivoja.

Kaj če nehote spremenim javni API na način, ki ni skladen s spremembo številke verzije (t.j. koda nepravilno predstavi glavno zlomljivo spremembo v izdaji popravka)?

Uporabite vašo najboljšo presojo. Če imate veliko občinstvo, ki bo močno
vplivano s spreminjanjem obnašanja nazaj k čemur je bil javni API namenjen, potem
je lahko najboljše opraviti glavno verzijo izdaje, četudi bi popravek
striktno bil smatran za izdajo popravka. Spomnimo se, semantične verzije so samo
transportiranje, kar pomeni za koliko se številka verzije spremeni. Če so te
verzije pomembne za vaše uporabnike, uporabite številko verzije, da jih obvestite.

Kako ravnam z opuščenimi funkcionalnostmi?

Opuščanje obstoječe funkcionalnosti je običajen del razvoja programske opreme in
je pogosto zahtevano za narediti, da se naredi nadaljnji razvoj. Ko opuščate del vašega
javnega API-ja, bi morali narediti dve stvari: (1) posodobiti vašo dokumentacijo, da
obvestite uporabnike o spremembi, (2) izdati novo manjšo verzijo z opuščenostjo
na mestu. Preden v celoti odstranite funkcionalnost v novi glavni izdaji
bi morala biti vsaj ena manjša izdaja, ki vsebuje opuščenost, da
lahko uporabniki gladko preidejo na nov API.

Ali ima semver omejitev velikosti na nizu verzije?

Ne, vendar uporabite dobro presojo. Na primer verzija z 255 dolgim nizom je verjetno pretiravanje.
Tudi določeni sistemi lahko nalagajo njihove lastne omejitve na velikosti
niza.

O projektu

Specifikacija sementičnih verzij je avtorizirana s strani Toma
Preston-Werner-ja, izumitelja Gravatarjev in
soustanovitelja GitHub-a.

Slovenski prevod so prispevali:


  Peter Kokot
  Aleš Šarkanj


Če želite pustiti povratne informacije, prosimo, da odprete vprašanje na
GitHub-u.

Licenca

Creative Commons ― CC BY 3.0\nSemantične verzije 2.0.0\nDane številke verzij GLAVNA.MANJŠA.POPRAVEK povečajte:\nGLAVNO verzijo, ko naredite nazaj nezdružljive spremembe API-ja,\nMANJŠO verzijo, ko dodate funkcionalnost na način združljivosti za
nazaj in\nPOPRAVEK verzije, ko naredite popravke hroščev z združljivostjo za nazaj.\nDodatne oznake za pred-izdaje in metapodatki gradnje so na voljo kot razširitve v obliki GLAVNA.MANJŠA.POPRAVEK.\nV svetu programske opreme obstaja grozen prostor imenovan
“pekel odvisnosti”. Večji kot sistem zraste in več je paketov,
ki jih integrirate v vašo programsko opremo, bolj možno se boste našli nekega
dne v tem obupu.\nV sistemih z veliko odvisnostmi lahko izdaja nove verzije paketa hitro
postane nočna mora. Če so specifikacije odvisnosti preveč ozke, ste v
nevarnosti zaklenjenih verzij (nezmožnost nadgradnje paketa brez, da
izdajate nove verzije za vsak odvisni paket). Če so odvisnosti
določene preveč ohlapno, boste neizogibno ugriznjeni s strani promiskuitete verzije
(ob predpostavki, da je združljivost z večimi prihodnjimi verzijami razumna).
Pekel odvisnosti je, kjer ste vi, ko je verzija zaklenjena in/ali vam promiskuiteta verzije
preprečuje, da enostavno in varno prestavite vaš projekt naprej.\nKot rešitev tega problema, predlagam enostaven skupek pravil in
zahtev, ki diktirajo, kako naj bodo številke verzij določene in povečane.
Ta pravila so osnovana na in ne nujno omejena na pred obstoječe
široko skupne prakse v uporabi tako v programski opremi zaprte kode kot odprte kode.
Da ta sistem deluje, morate najprej določiti javni API. To lahko sestoji
iz dokumentacije ali je izvršeno s strani same kode. Ne glede na to,
pomembno je, da je ta API jasen in točen. Ko enkrat identificirate vaš javni
API, lahko komunicirate spremembe na njem z določenimi povečanji na vaši številki
verzije. Smatrajte obliko verzije X.Y.Z (Glavna.Manjša.Popravek). Popravki hroščev ne
vplivajo na API a povečujejo številko popravka, nazaj združljivi API
dodatki/spremembe povečujejo manjšo verzijo in nazaj nezdružljive API
spremembe povečujejo glavno verzijo.\nTa sistem se imenuje “Semantične verzije.” Pod to shemo, številke verzij
in način, kako spreminjajo poslani pomen o podležeči kodi in kaj je bilo
spremenjeno iz ene verzije v naslednji.\nSpecifikacija semantičnih verzij (SemVer)\nKljučne besede “MORA”, “NE SME”, “ZAHTEVANO”, “BO”, “NE BO”, “BI MORALO”,
“NE BI SMELO”, “PRIPOROČLJIVO”, “LAHKO” in “OPCIJSKO” se v tem dokumentu
interpretira, kot so opisane v RFC 2119.\nProgramska oprema, ki uporablja semantične verzije MORA določiti javni API. Ta API
je lahko določen v sami kodi ali obstaja striktno v dokumentaciji.
Kakorkoli je končan, bi moral biti točen in celovit.\nProgramska oprema, ki uporablja semantične verzije MORA določiti javni API. Ta API
je lahko določen v sami kodi ali obstaja striktno v dokumentaciji.
Kakorkoli je končan, bi moral biti točen in celovit.\nObičajna številka verzije MORA biti oblike X.Y.Z, kjer so X, Y, in Z
pozitivna cena števila in NE SMEJO vsebovati vodilnih ničel. X je
glavna verzija, Y je manjša verzija in Z je verzija popravka.
Vsak element se MORA povečati numerično. Na primer: 1.9.0 -> 1.10.0 -> 1.11.0.\nObičajna številka verzije MORA biti oblike X.Y.Z, kjer so X, Y, in Z
pozitivna cena števila in NE SMEJO vsebovati vodilnih ničel. X je
glavna verzija, Y je manjša verzija in Z je verzija popravka.
Vsak element se MORA povečati numerično. Na primer: 1.9.0 -> 1.10.0 -> 1.11.0.\nKo je enkrat paket verzije izdan, se vsebina te verzija
NE SME spremeniti. Kakršnekoli spremembe MORAJO biti izdane kot nova verzija.\nKo je enkrat paket verzije izdan, se vsebina te verzija
NE SME spremeniti. Kakršnekoli spremembe MORAJO biti izdane kot nova verzija.\nGlavna verzija nič (0.y.z) je za začetni razvoj. Karkoli se lahko spremeni
kadarkoli. Javni API ne bi smel biti smatran za stabilnega.\nGlavna verzija nič (0.y.z) je za začetni razvoj. Karkoli se lahko spremeni
kadarkoli. Javni API ne bi smel biti smatran za stabilnega.\nVerzija 1.0.0 definira javni API. Način, kako je številka verzija
povečana za to izdajo je odvisno od tega javnega API-ja in kako se
spremeni.\nVerzija 1.0.0 definira javni API. Način, kako je številka verzija
povečana za to izdajo je odvisno od tega javnega API-ja in kako se
spremeni.\nVerzija popravka Z (x.y.Z | x > 0) MORA biti povečana, če so predstavljeni samo nazaj
združljivi popravki hroščev. Popravek hrošča je definiran kot notranja
sprememba, ki popravi nepravilno obnašanje.\nVerzija popravka Z (x.y.Z | x > 0) MORA biti povečana, če so predstavljeni samo nazaj
združljivi popravki hroščev. Popravek hrošča je definiran kot notranja
sprememba, ki popravi nepravilno obnašanje.\nManjša verzija Y (x.Y.z | x > 0) MORA biti povečana, če so nove nazaj
združljive funkcionalnosti predstavljene javnemu API-ju. MORA biti
povečana, če je katerakoli funkcionalnost javnega API-ja označena za opuščeno. LAHKO
je povečana, če so znatna nova funkcionalnost ali izboljšave predstavljene
znotraj privatne kode. LAHKO vključuje spremembe nivoja popravka. Verzija popravka
MORA biti ponastavljena na nič, ko je manjša verzija povečana.\nManjša verzija Y (x.Y.z | x > 0) MORA biti povečana, če so nove nazaj
združljive funkcionalnosti predstavljene javnemu API-ju. MORA biti
povečana, če je katerakoli funkcionalnost javnega API-ja označena za opuščeno. LAHKO
je povečana, če so znatna nova funkcionalnost ali izboljšave predstavljene
znotraj privatne kode. LAHKO vključuje spremembe nivoja popravka. Verzija popravka
MORA biti ponastavljena na nič, ko je manjša verzija povečana.\nGlavna verzija X (X.y.z | X > 0) MORA biti povečevana, če je kakršnakoli nazaj
nezdružljiva sprememba predstavljena javnemu API-ju. LAHKO vključuje spremembe
manjše verzije in verzije popravka. Manjša verzija in popravek MORATA biti ponastavljena na 0, ko je
glavna verzija povečana.\nGlavna verzija X (X.y.z | X > 0) MORA biti povečevana, če je kakršnakoli nazaj
nezdružljiva sprememba predstavljena javnemu API-ju. LAHKO vključuje spremembe
manjše verzije in verzije popravka. Manjša verzija in popravek MORATA biti ponastavljena na 0, ko je
glavna verzija povečana.\nVerzija pred-izdaje je LAHKO označena z dodajanjem vezaja in
serije s pikami ločenih identifikatorjev, ki jim takoj sledi verzija
popravka. Identifikatorji MORAJO biti sestavljeni iz samo alfanumeričnih ASCII-jev in vezaja
[0-9A-Za-z-]. Identifikatorji NE SMEJO biti prazni. Numerični identifikatorji NE
SMEJO vključevati vodilnih ničel. Verzije pred-izdaj imajo manjši
vrstni red, ko povezana običajna verzija. Verzija pred-izdaje
označuje, da je verzija nestabilna in lahko ne zadosti
namenjenim zahtevam združljivosti, kot je označeno z njihovimi povezanimi
normalnimi verzijami. Na primer: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.\nVerzija pred-izdaje je LAHKO označena z dodajanjem vezaja in
serije s pikami ločenih identifikatorjev, ki jim takoj sledi verzija
popravka. Identifikatorji MORAJO biti sestavljeni iz samo alfanumeričnih ASCII-jev in vezaja
[0-9A-Za-z-]. Identifikatorji NE SMEJO biti prazni. Numerični identifikatorji NE
SMEJO vključevati vodilnih ničel. Verzije pred-izdaj imajo manjši
vrstni red, ko povezana običajna verzija. Verzija pred-izdaje
označuje, da je verzija nestabilna in lahko ne zadosti
namenjenim zahtevam združljivosti, kot je označeno z njihovimi povezanimi
normalnimi verzijami. Na primer: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.\nMetapodatki gradnje so LAHKO označeni z dodajanjem znaka plus in serije pik
ločenih identifikatorjev, ki jim takoj sledi popravek ali verzija pred-izdaje.
Identifikatorji MORAJO biti sestavljeni iz samo alfanumeričnih ASCII-jev in vezajev [0-9A-Za-z-].
Identifikatorji NE SMEJO biti prazni. Podatki metagradnje BI MORALI biti ignorirani, ko se določa
vrstni red verzij. Zato dve verziji, ki se razlikujeta samo v metapodatkih gradnje,
imata enak vrstni red. Na primer: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85.\nMetapodatki gradnje so LAHKO označeni z dodajanjem znaka plus in serije pik
ločenih identifikatorjev, ki jim takoj sledi popravek ali verzija pred-izdaje.
Identifikatorji MORAJO biti sestavljeni iz samo alfanumeričnih ASCII-jev in vezajev [0-9A-Za-z-].
Identifikatorji NE SMEJO biti prazni. Podatki metagradnje BI MORALI biti ignorirani, ko se določa
vrstni red verzij. Zato dve verziji, ki se razlikujeta samo v metapodatkih gradnje,
imata enak vrstni red. Na primer: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85.\nVrstni red se sklicuje na to, kako so verzije primerjane druga z drugo, ko so urejene.
Vrstni red MORA biti izračunan z ločitvijo verzije v glavno, manjšo, popravek
in identifikator pred-izdaje v tem vrstnem redu (metapodatki gradnje ne pašejo
v vrstni red). Vrstni red je določen s prvo razliko, ko
primerjate vsako od teh identifikatorjev iz leve proti desni kot sledi: Verzije glavna, manjša
in popravek so vedno primerjane s številkami. Na primer: 1.0.0 < 2.0.0 <
2.1.0 < 2.1.1. Ko so glavna, manjša in popravek enake, ima verzija pred-izdaje
manjši vrstni red kot običajne izdaje. Na primer 1.0.0-alpha < 1.0.0. Vrstni red
za dve verziji pred-izdaje z enako verzijo glavne, manjše in popravka MORATA
biti določeli s primerjanjem vsake pike ločenega identifikatorja iz leve proti desni
dokler ni razlika najdena kot sledi: identifikatorji sestavljeni iz samo številk
so primerjani numerično in identifikatorji s črkami ali vezaji so primerjani
besedno v ASCII vrstnem redu. Numerični identifikatorji imajo vedno manjši vrstni red
kot ne-numerični identifikatorji. Večji skupek polj pred-izdaje imajo večji
vrstni red kot manjši skupek, če vsi prejšnji identifikatorji so enaki.
Na primer: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nVrstni red se sklicuje na to, kako so verzije primerjane druga z drugo, ko so urejene.
Vrstni red MORA biti izračunan z ločitvijo verzije v glavno, manjšo, popravek
in identifikator pred-izdaje v tem vrstnem redu (metapodatki gradnje ne pašejo
v vrstni red). Vrstni red je določen s prvo razliko, ko
primerjate vsako od teh identifikatorjev iz leve proti desni kot sledi: Verzije glavna, manjša
in popravek so vedno primerjane s številkami. Na primer: 1.0.0 < 2.0.0 <
2.1.0 < 2.1.1. Ko so glavna, manjša in popravek enake, ima verzija pred-izdaje
manjši vrstni red kot običajne izdaje. Na primer 1.0.0-alpha < 1.0.0. Vrstni red
za dve verziji pred-izdaje z enako verzijo glavne, manjše in popravka MORATA
biti določeli s primerjanjem vsake pike ločenega identifikatorja iz leve proti desni
dokler ni razlika najdena kot sledi: identifikatorji sestavljeni iz samo številk
so primerjani numerično in identifikatorji s črkami ali vezaji so primerjani
besedno v ASCII vrstnem redu. Numerični identifikatorji imajo vedno manjši vrstni red
kot ne-numerični identifikatorji. Večji skupek polj pred-izdaje imajo večji
vrstni red kot manjši skupek, če vsi prejšnji identifikatorji so enaki.
Na primer: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nZakaj uporabljati semantične verzije?\nTo ni nova ali revolucionarna ideja. V bistvu delate nekaj podobnega
temu že sedaj. Problem je, da “nekaj podobnega” ni dovolj dobro. Brez
skladnosti z nekakšno uradno specifikacijo, so številke verzij
v bistvu neuporabne za upravljanje odvisnosti. Z dodajanjem imena in jasne
definicije zgornjim idejam, postane enostavno za komunicirati vaše namere
uporabnikom vaše programske opreme. Ko enkrat postanejo te namere jasne, fleksibilne (vendar
ne preveč fleksibilne), se lahko končno naredi specifikacija odvisnosti.\nEnostaven primer bo demonstriral, kako semantične verzije lahko naredijo pekel
odvisnosti stvar preteklosti. Premislite o knjižnici imenovani “Firetruck”. Zahteva
paket s semantično verzijo in se imenuje “Ladder”. Ko je Firetruck
narejen, je Ladder pri verziji 3.1.0, lahko varno določite verzijo odvisnosti Ladder
kot večjo ali enako 3.1.0, vendar manjšo kot 4.0.0. Sedaj ko postane
Ladder verzija 3.1.1 in 3.2.0 postane na voljo, jih lahko izdate v vašem
sistemu paketnega upravljanja in veste, da bodo postale kompatibilne z obstoječo
odvisno programsko opremo.\nKot odgovoren razvijalec boste seveda želeli preveriti, da katerikoli
paket nadgradnje funkcionira, kot je oglaševano. Realni svet je grdo mesto;
ničesar ni, kar bi lahko naredili o tem, razen da smo pazljivi. Kar lahko naredite je
omogočiti semantičnim verzijam, da vam ponudijo pameten način izdaje in nadgradnje
paketov brez, da morate kotaliti nove verzije odvisnih paketov, kar vam prihrani
čas in težave.\nČe to vse zveni zaželjeno, je vse kar morate storiti, da začnete uporabljati semantične
verzije, razglasitev, da to tako delate in nato slediti pravilom. Povežite
na to spletno stran iz vaše datoteke README, da ostali vedo pravila in jih lahko
koristijo.\nKako ravnam z revizijami v 0.y.z začetni fazi razvoja?\nNajenostavnejše narediti je začeti vašo začetno razvojno izdajo pri 0.1.0
in nato povečevati manjše verzije za vsako naknadno izdajo.\nKako vem, kdaj izdati 1.0.0?\nČe je vaša programska oprema uporabljena v produkciji, bi morala verjeno že biti
1.0.0. Če imate stabilni API od katerega so postali uporabniki odvisni, bi morali
imeti 1.0.0. Če vas skrbi veliko o združljivosti za nazaj, bi morali verjetno
že biti na 1.0.0.\nAli to ne odvrača hitrega razvoja in hitrih interacij?\nGlavna verzija nič je vse o hitrem razvoju. Če spreminjate API
vsak dan, bi morali ali biti še vedno na verziji 0.y.z ali na ločeni
razvojni veji delati na naslednji glavni verziji.\nČe tudi najmanjša nazaj nezdružljiva sprememba javnega API-ja zahteva povečanje glavne verzije, ali ne bom potem končal pri verziji 42.0.0 zelo hitro?\nTo je vprašanje odgovornega razvoja in vpogleda vnaprej. Nezdružljive
spremembe ne bi smele biti predstavljene ohlapno v programsko opremo, ki ima
veliko odvisne kode. Cena, ki mora nastati za nadgradnjo, je lahko pomembna.
Povečanje glavnih verzij za izdajo nekompatibilnih sprememb pomeni, da boste
premislili skozi vpliv vaših sprememb in ocenili vpleteno razmerje
cena/korist.\nDokumentiranje celotnega javnega API-ja je preveč dela!\nVaša odgovornost kot profesionalnega razvijalca je, da ustrezno dokumentirate
programsko opremo, ki je nameravana za uporabo s strani drugih. Upravljanje kompleksnosti programske opreme je
zelo pomemben del, da obdržite projekt učinkovit in to narediti je težko, če
nihče ne ve, kako uporabiti vašo programsko opremo ali katere metode so varne za klicanje. Na
dolgi rok semantične verzije in vztrajanje na dobro definiranem javnem
API-ju lahko obdrži poganjanje vsakogar in vsega gladko.\nKaj narediti, če ponesreči izdam nazaj nezdružljivo spremembo kot manjšo verzijo?\nKakor hitro se zaveste, da ste prelomili specifikacijo semantičnih verzij, popravite
problem in izdajte novo manjšo verzijo, ki popravi problem in
povrne združljivost za nazaj. Tudi pod temi okoliščinami, ni
sprejemljivo spreminjati verzij izdaj. Če je primerno,
dokumentirajte kršeno izdajo in obvestite vaše uporabnike o problemu, da so
seznanjeni o kršeni izdaji.\nKaj naj naredim, če posodobim svoje lastne odvisnosti brez spremembe javnega API-ja?\nTo bi moralo biti smatrano kompatibilno, ker ne vpliva na javni API.
Programska oprema, ki je eksplicitno odvisna od istih odvistnosti, bi vaš paket
moral imeti svoje lastne specifikacije odvisnosti in avtor bo opazil kakršnekoli
konflikte. Določanje ali je sprememba modifikacije nivoja popravka ali manjšega nivoja
zavisi na tem ali posodabljate vaše odvisnosti z namenom popraviti hrošč ali dodati novo
funkcionalnost. Običajno bi pričakoval dodatno kodo
za slednjo instanco, v katerem primeru je očitno povečanje manjšega nivoja.\nKaj če nehote spremenim javni API na način, ki ni skladen s spremembo številke verzije (t.j. koda nepravilno predstavi glavno zlomljivo spremembo v izdaji popravka)?\nUporabite vašo najboljšo presojo. Če imate veliko občinstvo, ki bo močno
vplivano s spreminjanjem obnašanja nazaj k čemur je bil javni API namenjen, potem
je lahko najboljše opraviti glavno verzijo izdaje, četudi bi popravek
striktno bil smatran za izdajo popravka. Spomnimo se, semantične verzije so samo
transportiranje, kar pomeni za koliko se številka verzije spremeni. Če so te
verzije pomembne za vaše uporabnike, uporabite številko verzije, da jih obvestite.\nKako ravnam z opuščenimi funkcionalnostmi?\nOpuščanje obstoječe funkcionalnosti je običajen del razvoja programske opreme in
je pogosto zahtevano za narediti, da se naredi nadaljnji razvoj. Ko opuščate del vašega
javnega API-ja, bi morali narediti dve stvari: (1) posodobiti vašo dokumentacijo, da
obvestite uporabnike o spremembi, (2) izdati novo manjšo verzijo z opuščenostjo
na mestu. Preden v celoti odstranite funkcionalnost v novi glavni izdaji
bi morala biti vsaj ena manjša izdaja, ki vsebuje opuščenost, da
lahko uporabniki gladko preidejo na nov API.\nAli ima semver omejitev velikosti na nizu verzije?\nNe, vendar uporabite dobro presojo. Na primer verzija z 255 dolgim nizom je verjetno pretiravanje.
Tudi določeni sistemi lahko nalagajo njihove lastne omejitve na velikosti
niza.\nSpecifikacija sementičnih verzij je avtorizirana s strani Toma
Preston-Werner-ja, izumitelja Gravatarjev in
soustanovitelja GitHub-a.\nToma
Preston-Werner-ja\nSlovenski prevod so prispevali:\nČe želite pustiti povratne informacije, prosimo, da odprete vprašanje na
GitHub-u.\nodprete vprašanje na
GitHub-u\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSemantičko Verzionisanje 2.0.0

Sažetak

Za dati broj verzije MAJOR.MINOR.PATCH, inkrementirajte:


  MAJOR (GLAVNU) verziju kada unesete nekompatibilne izmene API-ja
  MINOR (MANJU) verziju kada dodate unazad kompatibilnu funkcionalnost
  PATCH (ZAKRPU) verziju kada dodate unazad kompatibilne ispravke bug-ova (grešaka)


Dodatne oznake za predizdanja i metapodatke build-a (izrade) dostupne su kao proširenja
u formatu MAJOR.MINOR.PATCH.

Uvod

U svetu upravljanja softverom postoji užasno mesto koje nazivamo
„pakao zavisnosti“. Kako vaš sistem raste i što više paketa
integrišete u svoj softver, veća je verovatnoća da ćete se naći
u ovom stanju dubokog očaja.

U sistemima sa mnoštvom zavisnosti, objavljivanje novih verzija paketa može brzo
postati košmar. Ako su specifikacije zavisnosti suviše stroge, nalazite se u opasnosti
od zaključavanja verzije (nemogućnost nadogradnje paketa bez neophodne
objave nove verzije svakog zavisnog paketa). Takođe, ako su specifikacije zavisnosti isuviše labave, neizbežno će vas dovesti u situaciju verzijskog promiskuiteta
(pod pretpostavkom kompatibilnosti sa više budućih verzija nego što je razumno).
Pakao zavisnosti je situacija u kojoj se nalazite kada zaključavanje verzije i/ili verzijski promiskuitet sprečavaju jednostavno i bezbedno napredovanje projekta.

Kao rešenje ovog problema, predlažemo jednostavan skup pravila i
zahteva koji diktiraju kako se brojevi verzija dodeljuju i inkrementiraju.
Ova pravila su zasnovana, ali nisu nužno ograničena na već postojeće i
široko rasprostranjene uobičajene prakse koje se koriste u closed i open-source
softveru. Kako bi ovaj sistem funkcionisao, neophodno je prvo objaviti public (javni) API.
Možemo to primeniti u dokumentaciji ili u samom kodu. U svakom slučaju, važno je da
API bude jasan i precizan. Jednom kad identifkujemo public API, izmene prenosimo
kroz specifikovane inkrementacije broja verzije.
Razmotrimo format verzije X.Y.Z (Major.Minor.Patch). Ispravke bug-ova (grešaka) koji
ne utiču na API inkrementiraju patch (zakrpa) verziju, a unazad nekompatibilne promene API-ju inkrementiraju major (glavnu) verziju.

Ovaj sistem nazivamo „Semantičko Verzionisanje“. Prema ovoj šemi, brojevi verzija
i način na koji se menjaju daju informacije o osnovnom kodu koji se nalazi pod datom verzijom, kao i šta se menjalo od jedne verzije do sledeće.

Specifikacija Semantičkog Verzionisanja (SemVer)

Ključne reči “MUST” (“MORA”), “MUST NOT” (“NE SME”), “REQUIRED (“NEOPHODNO”), “SHALL”(“HOĆE”), “SHALL NOT” (“NEĆE”),”SHOULD” (“TREBA”), “SHOULD NOT” (“NE TREBA”), “RECOMMENDED” (“PREPORUČENO”), “MAY” (“MOŽE”) i “OPTIONAL” (“OPCIONO”) u ovom dokumentu treba tumačiti kako je opisano u RFC 2119.


  
    Softver koji koristi Semantičko Verzionisanje MUST (MORA) objaviti publlic (javni) API. Ovaj API može biti deklarisan u samom kodu ili postojati striktno u dokumentaciji.
U svakom slučaju, SHOULD (TREBA) da bude precizan i sveobuhvatan.
  
  
    Normalna oznaka verzije MUST (MORA) biti u formatu X.Y.Z gde su X, Y i Z ne-negativni
celi brojevi i ne smeju počinjati sa nulom. X označava glavnu verziju, Y manju
verziju, a Z zakrpu. Svaki element MUST (MORA) se numerički inkrementirati.
Na primer: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Jednom kad je verzionisani paket objavljen, sadržaj te verzije MUST NOT (NE SME) se
menjati. Svaka izmena MUST (MORA) se objavljivati kao nova verzija.
  
  
    MAJOR (GLAVNA) verzija nula (0.y.z) je za inicijalni razvoj. Bilo šta se MAY (MOŽE) menjati
u svakom trenutku. Ovaj public (javni) API SHOULD NOT (NE TREBA) smatrati stabilnim.
  
  
    Verzija 1.0.0 definiše public (javni) API. Način na koji će se oznaka verzije
inkrementirati nakon ove objave zavisi od ovog public (javnog) API-ja i izmena na njemu.
  
  
    Patch (zakrpa) verzija Z (x.y.Z | x > 0) MUST (MORA) se inkrementirati kada se dodaju samo unazad kompatibilne ispravke bug-ova (gresaka). Ispravke bug-ova (gresaka) su definisane kao promene koda
koje ispravljaju nepravilno ponašanje.
  
  
    
      
        
          Minor (manja) verzija Y (x.Y.z
          x > 0) MUST (MORA) se inkrementirati ako je nova, unazad kompatibilna funkcionalnost uvedena u javni API. Takođe MUST (MORA) se inkrementirati kada se neka od funkcionalnosti API-ja označi kao deprecated (zastarela). MAY (MOŽE) biti inkrementirana ukoliko se uvedu substancijalno nove funkcionalnosti ili poboljšanja u okviru privatnog koda. MAY (MOŽE) uključivati promene nivoa patch (zakrpe). Patch (Zakrpa) verzija MUST (MORA) se resetovati na 0 kada se minor (manja) verzija inkrementira.
        
      
    
  
  
    Major (glavna) verzija X (X.y.z | X > 0) MUST (MORA) se inkrementirati ako se unazad nekompatibilne promene uvode u javni API. MAY (MOŽE) uključivati i promene minor (manje) i promene na nivou patch
(zakrpe) verzije. Patch (zakrpe) i minor (manje) verzije MUST (MORA) da se resetuju na 0 kada se
major (glavna) verzija inkrementira.
  
  
    Verzija predizdanja MAY (MOŽE) biti označena dodavanjem hyphen-a (povlake) i serijom identifikatora razdvojenih tačkom neposredno nakon patch (zakrpe) verzije. Identifikatori MUST (MORAJU) sadržati samo ASCII alfanumeričke znakove i hyphen-e (povlake)
[0-9A-Za-z-]. Identifikatori MUST NOT (NE SMEJU) biti prazni. Numerički identifikatori MUST NOT (NE SMEJU) počinjati nulom. Verzije predizdanja imaju niži prioritet od povezane normalne verzije. Verzija predizdanja označava da je verzija nestabilna i da možda neće biti zadovoljeni predviđeni zahtevi kompatibilnosti kao što je označeno njenom povezanom normalnom verzijom. Primeri: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.--.
  
  
    Metadata (metapodaci) build-a (izrade) MAY (MOGU) biti označeni dodavanjem znaka plus
i niza identifikatora odvojenih tačkom, koji se odmah nastavljaju na patch (zakrpu) verziju ili verziju predizdanja. Identifikatori MUST (MORAJU) da sadrže iskljucivo ASCII alfanumeričke znakove i hyphen-e (povlake) [0-9A-Za-z-]. Identifikatori MUST NOT (NE SMEJU) da budu prazni. Metadata (metapodaci) o build-u (izgradnji) MUST (MORAJU) se zanemariti prilikom određivanja prioriteta verzije. Prema tome dve verzije koje se razlikuju samo u metapodacima build-a (izrade), imaju isti prioritet. Primeri:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85,
1.0.0+21AF26D3----117B344092BD.
  
  
    Prioritet se odnosi na način kojim se verzije u poretku međusobno upoređuju.

    
      
        Prioritet se MUST (MORA) izračunati razdvajanjem verzije na major (glavne),
 minor (manje), patch (zakrpe) i identifikatore predizdanja (metadata (metapodaci) build-a (izrade) nemaju ulogu u određivanju prioriteta).
      
      
        Prioritet se određuje prvom razlikom kada se upoređuje svaki od identifikatora sa leva na desno:
major (glavni), minor (manji) i patch (zakrpa). Verzije se uvek upoređuju brojčano.

        Primer: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Kada su major (glavna), minor (manja) i patch (zakrpa) jednake, verzija predizdanja ima niži
prioritet od normalne verzije.

        Primer: 1.0.0-alpha < 1.0.0.
      
      
        Prioritet između dve verzije predizdanja sa jednakim major (glavnom), minor (manjom) i patch
(zakrpom) MUST (MORA) biti određen upoređivanjem svakog identifikatora razdvojenog tačkama sa leva na desno dok se ne pronađe razlika na sledeći način:

        
          
            Identifikatori koji se sastoje samo od cifara upoređuju se numerički.
          
          
            Identifikatori sa slovima ili hyphen-ima (povlakama) se upoređuju leksički u ASCII
  poretku.
          
          
            Numerički identifikatori uvek imaju niži prioritet od nenumeričkih
  identifikatora.
          
          
            Veći skup oznaka predizdanja ima viši prioritet od manjeg skupa, ako su svi prethodni
  identifikatori jednaki.
          
        

        Primer: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
  1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
      
    
  


Backus–Naur Gramatički Obrazac za Validne SemVer Verzije

<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


Zašto koristiti Semantičko Verzionisanje?

Ovo nije nova ili revolucionarna ideja. Tačnije, verovatno već radite nešto vrlo slično. Problem je što nešto “slično” nije dovoljno dobro. Bez usaglašenosti sa nekom vrstom formalne specifikacije, brojevi verzija su
u suštini beskorisni za upravljanje zavisnostima. Davanjem imena i jasne
definicije gore navedenih ideja, postaje lako preneti svoje namere
korisnicima vašeg softvera. Jednom kada su ove namere jasne, fleksibilne (ali
ne previše fleksibilne) specifikacije zavisnosti konačno je moguće napraviti.

Jednostavan primer može pokazati kako pakao zavisnosti uz Semantičko Verzionisanje ostaje stvar prošlosti. Zamislite library (biblioteku) pod nazivom “Vatrogasno_vozilo”. Neophodan joj je Semantičko Verzionisani paket pod nazivom “Merdevine”. U trenutku kreiranja Vatrogasno_vozilo, Merdevine su u verziji 3.1.0. Pošto Vatrogasno_vozilo koristi neke funkcije prvobitno uvedene
u 3.1.0, možete bezbedno specifikovati zavisnost od Merdevine kao veću ili jednaku 3.1.0, ali manju od 4.0.0. Sada, kada Merdevine verzije 3.1.1 i 3.2.0 postanu dostupne, možete ih uneti u svoj sistem upravljanja paketima i biti siguni da će biti kompatibilni sa postojećim zavisnim softverom.

Kao odgovoran programer, vi ćete, naravno, želeti da verifikujete da li upgrade (nadgradnje) paketa funkcionišu kako je navedeno. Stvarni svet je mahom neuređeno mesto; ne možemo ništa uraditi povodom toga osim da budemo oprezni.
Ono što možemo uciniti je da usvojimo Semantičko Verzionisanje koje nam pruža razuman način za objavljivanje i nadogradnju paketa, bez potrebe za pokretanjem novih verzija zavisnih paketa, štedeći vreme i trud.

Ako vam ovo zvuči poželjno, sve što je potrebno uraditi da biste počeli da koristite Semantičko Verzionisanje je da se deklarišete kao korisnik i da potom
sledite pravila. Linkujte ovaj website sa vašim README-ma tako da bi i drugi bili svesni pravila i mogu imati koristi od njih.

FAQ

Kako se nositi sa revizijama 0.y.z u inicijalnoj fazi razvoja?

Najjednostavniji način je da započnete inicijalni razvoj objavom verzije
0.1.0 i potom inkrementirate oznaku minor (manje) verzije za svako sledeće izdanje.

Kako da znamo kada treba objaviti verziju 1.0.0??

Ako se softver koristi u produkciji, već bi verovatno trebalo biti 1.0.0. Ako već imate stabilni API, na koji se korisnici mogu pouzdati, trebalo bi
biti 1.0.0. Ukoliko ste prilično zabrinuti oko kompatibilnosti unazad, softver
bi već trebalo da je objavljen pod verzijom 1.0.0.

Zar to ne obeshrabruje rapidan razvoj i brzu iteraciju?

Major (glavna) verzija nula je zapravo predodređena rapidnom razvoju. Ako menjate API svaki dan, trebalo bi ostati na verziji 0.y.z ili na posebnoj grani za razvoj raditi na sledećoj major (glavnoj) verziji.

Ukoliko i najsitnije unazad nekompatibilne izmene u API-ju zahtevaju naglo uvećavanje major (glavne) verzije, nećemo li vrlo brzo doći do verzije 42.0.0?

Ovo je pitanje odgovornog razvoja i predviđanja. U softver koji ima puno
zavisnog koda, nekompatibilne promene ne treba olako uvoditi. Troškovi
nadogradnje mogu biti značajni. Ako morate povećati major (glavnu) verziju, kako biste objavili verziju sa nekompatibilnim izmenama, morate razmisliti o uticaju tih izmena i proceniti odnos uključenih troškova i koristi.

Dokumentacija celokupnog public (javnog) API-ja zahteva previše posla

Vaša je odgovornost kao profesionalnih programera da pravilno dokumentujete
softver koji je namenjen korisnicima. Upravljanje složenošću softvera je izuzetno važan deo održavanja efikasnosti projekta, što je teško ako korisnici ne znaju kako koristiti vaš softver ili koje metode mogu bezbedno pozvati. Dugoročno, Semantičko Verzionisanje i insistiranje na kvalitetno definisanom API-ju omogućiće da svi i sve rade glatko.

Šta ukoliko slučajno objavimo unazad nekompatibilne izmene kao minor (manju) verziju?

Čim primetite da ste prekršili specifikacije Semantičkog Verzionisanja,
potrebno je ispraviti grešku pa objaviti minor (manju) verziju koja će ispraviti problem i povratiti kompatibilnost unazad. Čak i u takvim uslovima, nije prihvatljivo modifikovati verzionisane objave. Ako je prikladno, dokumentujte verziju koja krši specifikaciju i tako obavestite korisnike kako bi bili svesni toga.

Šta činiti ukoliko izmenimo sopstvene zavisnosti bez promene public (javnog) API-ja?

Takve izmene smatramo kompatibilnima jer ne utiču na public (javni) API. Softver koji
eksplicitno zavisi od istih zavisnosti kao i naš sopstveni paket treba imati vlastite specifikacije zavisnosti, a autor će primetiti eventualne konflikte. Je li promjena na nivou patch (zakrpe) ili minor (manje) verzije, zavisi od toga da li ste dodavali svoje zavisnosti kao ispravke bug-ova (grešaka) ili ste ih uveli kao nove funkcionalnosti. U posljednjem slučaju
možemo očekivati i dodatni kod, pri čemu se očigledno radi o inkrementu minor (manje) verzije.

Šta ukoliko slučajno izmenimo public (javni) API na način koji ne odgovara izmeni broja verzije (npr. u kod neispravno uvedemo veću unazad nekompatibilnu izmenu u okviru objave patch (zakrpe))?

Koristite svoju najbolju procenu. Ako imate veliki broj korisnika, na koje će
značajno uticati promena unatrag, najbolje je da objavite major (glavnu) verziju, iako
bi takav ispravak mogli smatrati izdanjem zakrpe. Zapamtite, svrha Semantičkog
Verzionisanja je prenošenje značenja putem izmene broja verzije. Ako su takve
izmene važne za vaše korisnike, koristite broj verzije da biste ih informisali.

Kako postupati sa deprecating (zastarelim) funkcionalnostima?

Postojeće funkcionalnosti koje zastarevaju, sastavni su deo razvoja softvera
i često su neophodne kako bi razvoj napredovao. Kad označavate deo public (javnog) API-ja kao deprecated (zastareli), potrebno je učiniti dve stvari: (1) ažurirati dokumentaciju kako bismo informisali korisnike, (2) objaviti novu minor (manju) verziju sa definisanim deprecated (zastarelim) delovima softvera. Pre nego što potpuno uklonite funkcionalnost u novoj major (glavnoj) verziji, potrebno je izdati barem jednu minor (manju) verziju koja sadrži deprecated (zastarele) delove, kako bi korisnici nesmetano prešli na novu verziju API-ja.

Ima li SemVer ograničenu veličinu stringa verzije?

Ne, ali procenite sami. String verzije od 255 znakova je verovatno preteran,
na primer. Takođe, neki sistemi mogu imati svoja ograničenja veličine stringa.

Da li je “v1.2.3” semantička verzija?

Ne, “v1.2.3” nije semantička verzija. Međutim, prefiksiranje semantičke verzije
sa “v” je uobičajen način (na engleskom) da se naznači da je to broj verzije.
Skraćenje “verzije” kao “v” se često vidi sa kontrolom verzija. Primer:
git tag v1.2.3 -m "Release version 1.2.3", u kom slučaju je “v1.2.3” naziv
taga (oznake), a semantička verzija je “1.2.3”.

Da li postoji predloženi regularni izraz (RegEx) za proveru SemVer stringa?

Postoje dva. Jedan sa imenovanim grupama za one sisteme koji ih podržavaju
(PCRE [Perl Compatible Regular Expressions (Perl kompatibilni regularni izrazi), tj. Perl, PHP i R], Python
i Go).

Pogledajte: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


I drugi sa numerisanim grupama (znači ng1 = major (glavna), ng2 = minor (manja),
ng3 = patch (zakrpa), ng4 = prerelease (predizdanje) i ng5 = buildmetadata (metapodaci)) koji su kompatibilni
sa ECMA Script (JavaScript), PCRE [Perl Compatible Regular Expressions (Perl kompatibilni regularni izrazi),
tj. Perl, PHP i R], Python i Go.

Pogledajte: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


O projektu

Autor specifikacije Semantičkog Verzionisanja je Tom
Preston-Werner, pronalazač Gravatar-a i suosnivač GitHub-a.

Ako želite ostaviti povratne informacije, molimo otvorite issue na
GitHub-u.

Licenca

Creative Commons ― CC BY 3.0\nSemantičko Verzionisanje 2.0.0\nZa dati broj verzije MAJOR.MINOR.PATCH, inkrementirajte:\nMAJOR (GLAVNU) verziju kada unesete nekompatibilne izmene API-ja\nMINOR (MANJU) verziju kada dodate unazad kompatibilnu funkcionalnost\nPATCH (ZAKRPU) verziju kada dodate unazad kompatibilne ispravke bug-ova (grešaka)\nDodatne oznake za predizdanja i metapodatke build-a (izrade) dostupne su kao proširenja
u formatu MAJOR.MINOR.PATCH.\nU svetu upravljanja softverom postoji užasno mesto koje nazivamo
„pakao zavisnosti“. Kako vaš sistem raste i što više paketa
integrišete u svoj softver, veća je verovatnoća da ćete se naći
u ovom stanju dubokog očaja.\nU sistemima sa mnoštvom zavisnosti, objavljivanje novih verzija paketa može brzo
postati košmar. Ako su specifikacije zavisnosti suviše stroge, nalazite se u opasnosti
od zaključavanja verzije (nemogućnost nadogradnje paketa bez neophodne
objave nove verzije svakog zavisnog paketa). Takođe, ako su specifikacije zavisnosti isuviše labave, neizbežno će vas dovesti u situaciju verzijskog promiskuiteta
(pod pretpostavkom kompatibilnosti sa više budućih verzija nego što je razumno).
Pakao zavisnosti je situacija u kojoj se nalazite kada zaključavanje verzije i/ili verzijski promiskuitet sprečavaju jednostavno i bezbedno napredovanje projekta.\nKao rešenje ovog problema, predlažemo jednostavan skup pravila i
zahteva koji diktiraju kako se brojevi verzija dodeljuju i inkrementiraju.
Ova pravila su zasnovana, ali nisu nužno ograničena na već postojeće i
široko rasprostranjene uobičajene prakse koje se koriste u closed i open-source
softveru. Kako bi ovaj sistem funkcionisao, neophodno je prvo objaviti public (javni) API.
Možemo to primeniti u dokumentaciji ili u samom kodu. U svakom slučaju, važno je da
API bude jasan i precizan. Jednom kad identifkujemo public API, izmene prenosimo
kroz specifikovane inkrementacije broja verzije.
Razmotrimo format verzije X.Y.Z (Major.Minor.Patch). Ispravke bug-ova (grešaka) koji
ne utiču na API inkrementiraju patch (zakrpa) verziju, a unazad nekompatibilne promene API-ju inkrementiraju major (glavnu) verziju.\nOvaj sistem nazivamo „Semantičko Verzionisanje“. Prema ovoj šemi, brojevi verzija
i način na koji se menjaju daju informacije o osnovnom kodu koji se nalazi pod datom verzijom, kao i šta se menjalo od jedne verzije do sledeće.\nSpecifikacija Semantičkog Verzionisanja (SemVer)\nKljučne reči “MUST” (“MORA”), “MUST NOT” (“NE SME”), “REQUIRED (“NEOPHODNO”), “SHALL”(“HOĆE”), “SHALL NOT” (“NEĆE”),”SHOULD” (“TREBA”), “SHOULD NOT” (“NE TREBA”), “RECOMMENDED” (“PREPORUČENO”), “MAY” (“MOŽE”) i “OPTIONAL” (“OPCIONO”) u ovom dokumentu treba tumačiti kako je opisano u RFC 2119.\nSoftver koji koristi Semantičko Verzionisanje MUST (MORA) objaviti publlic (javni) API. Ovaj API može biti deklarisan u samom kodu ili postojati striktno u dokumentaciji.
U svakom slučaju, SHOULD (TREBA) da bude precizan i sveobuhvatan.\nSoftver koji koristi Semantičko Verzionisanje MUST (MORA) objaviti publlic (javni) API. Ovaj API može biti deklarisan u samom kodu ili postojati striktno u dokumentaciji.
U svakom slučaju, SHOULD (TREBA) da bude precizan i sveobuhvatan.\nNormalna oznaka verzije MUST (MORA) biti u formatu X.Y.Z gde su X, Y i Z ne-negativni
celi brojevi i ne smeju počinjati sa nulom. X označava glavnu verziju, Y manju
verziju, a Z zakrpu. Svaki element MUST (MORA) se numerički inkrementirati.
Na primer: 1.9.0 -> 1.10.0 -> 1.11.0.\nNormalna oznaka verzije MUST (MORA) biti u formatu X.Y.Z gde su X, Y i Z ne-negativni
celi brojevi i ne smeju počinjati sa nulom. X označava glavnu verziju, Y manju
verziju, a Z zakrpu. Svaki element MUST (MORA) se numerički inkrementirati.
Na primer: 1.9.0 -> 1.10.0 -> 1.11.0.\nJednom kad je verzionisani paket objavljen, sadržaj te verzije MUST NOT (NE SME) se
menjati. Svaka izmena MUST (MORA) se objavljivati kao nova verzija.\nJednom kad je verzionisani paket objavljen, sadržaj te verzije MUST NOT (NE SME) se
menjati. Svaka izmena MUST (MORA) se objavljivati kao nova verzija.\nMAJOR (GLAVNA) verzija nula (0.y.z) je za inicijalni razvoj. Bilo šta se MAY (MOŽE) menjati
u svakom trenutku. Ovaj public (javni) API SHOULD NOT (NE TREBA) smatrati stabilnim.\nMAJOR (GLAVNA) verzija nula (0.y.z) je za inicijalni razvoj. Bilo šta se MAY (MOŽE) menjati
u svakom trenutku. Ovaj public (javni) API SHOULD NOT (NE TREBA) smatrati stabilnim.\nVerzija 1.0.0 definiše public (javni) API. Način na koji će se oznaka verzije
inkrementirati nakon ove objave zavisi od ovog public (javnog) API-ja i izmena na njemu.\nVerzija 1.0.0 definiše public (javni) API. Način na koji će se oznaka verzije
inkrementirati nakon ove objave zavisi od ovog public (javnog) API-ja i izmena na njemu.\nPatch (zakrpa) verzija Z (x.y.Z | x > 0) MUST (MORA) se inkrementirati kada se dodaju samo unazad kompatibilne ispravke bug-ova (gresaka). Ispravke bug-ova (gresaka) su definisane kao promene koda
koje ispravljaju nepravilno ponašanje.\nPatch (zakrpa) verzija Z (x.y.Z | x > 0) MUST (MORA) se inkrementirati kada se dodaju samo unazad kompatibilne ispravke bug-ova (gresaka). Ispravke bug-ova (gresaka) su definisane kao promene koda
koje ispravljaju nepravilno ponašanje.\nMinor (manja) verzija Y (x.Y.z
          x > 0) MUST (MORA) se inkrementirati ako je nova, unazad kompatibilna funkcionalnost uvedena u javni API. Takođe MUST (MORA) se inkrementirati kada se neka od funkcionalnosti API-ja označi kao deprecated (zastarela). MAY (MOŽE) biti inkrementirana ukoliko se uvedu substancijalno nove funkcionalnosti ili poboljšanja u okviru privatnog koda. MAY (MOŽE) uključivati promene nivoa patch (zakrpe). Patch (Zakrpa) verzija MUST (MORA) se resetovati na 0 kada se minor (manja) verzija inkrementira.\nMinor (manja) verzija Y (x.Y.z\nx > 0) MUST (MORA) se inkrementirati ako je nova, unazad kompatibilna funkcionalnost uvedena u javni API. Takođe MUST (MORA) se inkrementirati kada se neka od funkcionalnosti API-ja označi kao deprecated (zastarela). MAY (MOŽE) biti inkrementirana ukoliko se uvedu substancijalno nove funkcionalnosti ili poboljšanja u okviru privatnog koda. MAY (MOŽE) uključivati promene nivoa patch (zakrpe). Patch (Zakrpa) verzija MUST (MORA) se resetovati na 0 kada se minor (manja) verzija inkrementira.\nMajor (glavna) verzija X (X.y.z | X > 0) MUST (MORA) se inkrementirati ako se unazad nekompatibilne promene uvode u javni API. MAY (MOŽE) uključivati i promene minor (manje) i promene na nivou patch
(zakrpe) verzije. Patch (zakrpe) i minor (manje) verzije MUST (MORA) da se resetuju na 0 kada se
major (glavna) verzija inkrementira.\nMajor (glavna) verzija X (X.y.z | X > 0) MUST (MORA) se inkrementirati ako se unazad nekompatibilne promene uvode u javni API. MAY (MOŽE) uključivati i promene minor (manje) i promene na nivou patch
(zakrpe) verzije. Patch (zakrpe) i minor (manje) verzije MUST (MORA) da se resetuju na 0 kada se
major (glavna) verzija inkrementira.\nVerzija predizdanja MAY (MOŽE) biti označena dodavanjem hyphen-a (povlake) i serijom identifikatora razdvojenih tačkom neposredno nakon patch (zakrpe) verzije. Identifikatori MUST (MORAJU) sadržati samo ASCII alfanumeričke znakove i hyphen-e (povlake)
[0-9A-Za-z-]. Identifikatori MUST NOT (NE SMEJU) biti prazni. Numerički identifikatori MUST NOT (NE SMEJU) počinjati nulom. Verzije predizdanja imaju niži prioritet od povezane normalne verzije. Verzija predizdanja označava da je verzija nestabilna i da možda neće biti zadovoljeni predviđeni zahtevi kompatibilnosti kao što je označeno njenom povezanom normalnom verzijom. Primeri: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.--.\nVerzija predizdanja MAY (MOŽE) biti označena dodavanjem hyphen-a (povlake) i serijom identifikatora razdvojenih tačkom neposredno nakon patch (zakrpe) verzije. Identifikatori MUST (MORAJU) sadržati samo ASCII alfanumeričke znakove i hyphen-e (povlake)
[0-9A-Za-z-]. Identifikatori MUST NOT (NE SMEJU) biti prazni. Numerički identifikatori MUST NOT (NE SMEJU) počinjati nulom. Verzije predizdanja imaju niži prioritet od povezane normalne verzije. Verzija predizdanja označava da je verzija nestabilna i da možda neće biti zadovoljeni predviđeni zahtevi kompatibilnosti kao što je označeno njenom povezanom normalnom verzijom. Primeri: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.--.\nMetadata (metapodaci) build-a (izrade) MAY (MOGU) biti označeni dodavanjem znaka plus
i niza identifikatora odvojenih tačkom, koji se odmah nastavljaju na patch (zakrpu) verziju ili verziju predizdanja. Identifikatori MUST (MORAJU) da sadrže iskljucivo ASCII alfanumeričke znakove i hyphen-e (povlake) [0-9A-Za-z-]. Identifikatori MUST NOT (NE SMEJU) da budu prazni. Metadata (metapodaci) o build-u (izgradnji) MUST (MORAJU) se zanemariti prilikom određivanja prioriteta verzije. Prema tome dve verzije koje se razlikuju samo u metapodacima build-a (izrade), imaju isti prioritet. Primeri:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85,
1.0.0+21AF26D3----117B344092BD.\nMetadata (metapodaci) build-a (izrade) MAY (MOGU) biti označeni dodavanjem znaka plus
i niza identifikatora odvojenih tačkom, koji se odmah nastavljaju na patch (zakrpu) verziju ili verziju predizdanja. Identifikatori MUST (MORAJU) da sadrže iskljucivo ASCII alfanumeričke znakove i hyphen-e (povlake) [0-9A-Za-z-]. Identifikatori MUST NOT (NE SMEJU) da budu prazni. Metadata (metapodaci) o build-u (izgradnji) MUST (MORAJU) se zanemariti prilikom određivanja prioriteta verzije. Prema tome dve verzije koje se razlikuju samo u metapodacima build-a (izrade), imaju isti prioritet. Primeri:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85,
1.0.0+21AF26D3----117B344092BD.\nPrioritet se odnosi na način kojim se verzije u poretku međusobno upoređuju.

    
      
        Prioritet se MUST (MORA) izračunati razdvajanjem verzije na major (glavne),
 minor (manje), patch (zakrpe) i identifikatore predizdanja (metadata (metapodaci) build-a (izrade) nemaju ulogu u određivanju prioriteta).
      
      
        Prioritet se određuje prvom razlikom kada se upoređuje svaki od identifikatora sa leva na desno:
major (glavni), minor (manji) i patch (zakrpa). Verzije se uvek upoređuju brojčano.

        Primer: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Kada su major (glavna), minor (manja) i patch (zakrpa) jednake, verzija predizdanja ima niži
prioritet od normalne verzije.

        Primer: 1.0.0-alpha < 1.0.0.
      
      
        Prioritet između dve verzije predizdanja sa jednakim major (glavnom), minor (manjom) i patch
(zakrpom) MUST (MORA) biti određen upoređivanjem svakog identifikatora razdvojenog tačkama sa leva na desno dok se ne pronađe razlika na sledeći način:

        
          
            Identifikatori koji se sastoje samo od cifara upoređuju se numerički.
          
          
            Identifikatori sa slovima ili hyphen-ima (povlakama) se upoređuju leksički u ASCII
  poretku.
          
          
            Numerički identifikatori uvek imaju niži prioritet od nenumeričkih
  identifikatora.
          
          
            Veći skup oznaka predizdanja ima viši prioritet od manjeg skupa, ako su svi prethodni
  identifikatori jednaki.
          
        

        Primer: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
  1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPrioritet se odnosi na način kojim se verzije u poretku međusobno upoređuju.\nPrioritet se MUST (MORA) izračunati razdvajanjem verzije na major (glavne),
 minor (manje), patch (zakrpe) i identifikatore predizdanja (metadata (metapodaci) build-a (izrade) nemaju ulogu u određivanju prioriteta).\nPrioritet se MUST (MORA) izračunati razdvajanjem verzije na major (glavne),
 minor (manje), patch (zakrpe) i identifikatore predizdanja (metadata (metapodaci) build-a (izrade) nemaju ulogu u određivanju prioriteta).\nPrioritet se određuje prvom razlikom kada se upoređuje svaki od identifikatora sa leva na desno:
major (glavni), minor (manji) i patch (zakrpa). Verzije se uvek upoređuju brojčano.

        Primer: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nPrioritet se određuje prvom razlikom kada se upoređuje svaki od identifikatora sa leva na desno:
major (glavni), minor (manji) i patch (zakrpa). Verzije se uvek upoređuju brojčano.\nPrimer: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nKada su major (glavna), minor (manja) i patch (zakrpa) jednake, verzija predizdanja ima niži
prioritet od normalne verzije.

        Primer: 1.0.0-alpha < 1.0.0.\nKada su major (glavna), minor (manja) i patch (zakrpa) jednake, verzija predizdanja ima niži
prioritet od normalne verzije.\nPrimer: 1.0.0-alpha < 1.0.0.\nPrioritet između dve verzije predizdanja sa jednakim major (glavnom), minor (manjom) i patch
(zakrpom) MUST (MORA) biti određen upoređivanjem svakog identifikatora razdvojenog tačkama sa leva na desno dok se ne pronađe razlika na sledeći način:

        
          
            Identifikatori koji se sastoje samo od cifara upoređuju se numerički.
          
          
            Identifikatori sa slovima ili hyphen-ima (povlakama) se upoređuju leksički u ASCII
  poretku.
          
          
            Numerički identifikatori uvek imaju niži prioritet od nenumeričkih
  identifikatora.
          
          
            Veći skup oznaka predizdanja ima viši prioritet od manjeg skupa, ako su svi prethodni
  identifikatori jednaki.
          
        

        Primer: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
  1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPrioritet između dve verzije predizdanja sa jednakim major (glavnom), minor (manjom) i patch
(zakrpom) MUST (MORA) biti određen upoređivanjem svakog identifikatora razdvojenog tačkama sa leva na desno dok se ne pronađe razlika na sledeći način:\nIdentifikatori koji se sastoje samo od cifara upoređuju se numerički.\nIdentifikatori koji se sastoje samo od cifara upoređuju se numerički.\nIdentifikatori sa slovima ili hyphen-ima (povlakama) se upoređuju leksički u ASCII
  poretku.\nIdentifikatori sa slovima ili hyphen-ima (povlakama) se upoređuju leksički u ASCII
  poretku.\nNumerički identifikatori uvek imaju niži prioritet od nenumeričkih
  identifikatora.\nNumerički identifikatori uvek imaju niži prioritet od nenumeričkih
  identifikatora.\nVeći skup oznaka predizdanja ima viši prioritet od manjeg skupa, ako su svi prethodni
  identifikatori jednaki.\nVeći skup oznaka predizdanja ima viši prioritet od manjeg skupa, ako su svi prethodni
  identifikatori jednaki.\nPrimer: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
  1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nBackus–Naur Gramatički Obrazac za Validne SemVer Verzije\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nZašto koristiti Semantičko Verzionisanje?\nOvo nije nova ili revolucionarna ideja. Tačnije, verovatno već radite nešto vrlo slično. Problem je što nešto “slično” nije dovoljno dobro. Bez usaglašenosti sa nekom vrstom formalne specifikacije, brojevi verzija su
u suštini beskorisni za upravljanje zavisnostima. Davanjem imena i jasne
definicije gore navedenih ideja, postaje lako preneti svoje namere
korisnicima vašeg softvera. Jednom kada su ove namere jasne, fleksibilne (ali
ne previše fleksibilne) specifikacije zavisnosti konačno je moguće napraviti.\nJednostavan primer može pokazati kako pakao zavisnosti uz Semantičko Verzionisanje ostaje stvar prošlosti. Zamislite library (biblioteku) pod nazivom “Vatrogasno_vozilo”. Neophodan joj je Semantičko Verzionisani paket pod nazivom “Merdevine”. U trenutku kreiranja Vatrogasno_vozilo, Merdevine su u verziji 3.1.0. Pošto Vatrogasno_vozilo koristi neke funkcije prvobitno uvedene
u 3.1.0, možete bezbedno specifikovati zavisnost od Merdevine kao veću ili jednaku 3.1.0, ali manju od 4.0.0. Sada, kada Merdevine verzije 3.1.1 i 3.2.0 postanu dostupne, možete ih uneti u svoj sistem upravljanja paketima i biti siguni da će biti kompatibilni sa postojećim zavisnim softverom.\nKao odgovoran programer, vi ćete, naravno, želeti da verifikujete da li upgrade (nadgradnje) paketa funkcionišu kako je navedeno. Stvarni svet je mahom neuređeno mesto; ne možemo ništa uraditi povodom toga osim da budemo oprezni.
Ono što možemo uciniti je da usvojimo Semantičko Verzionisanje koje nam pruža razuman način za objavljivanje i nadogradnju paketa, bez potrebe za pokretanjem novih verzija zavisnih paketa, štedeći vreme i trud.\nAko vam ovo zvuči poželjno, sve što je potrebno uraditi da biste počeli da koristite Semantičko Verzionisanje je da se deklarišete kao korisnik i da potom
sledite pravila. Linkujte ovaj website sa vašim README-ma tako da bi i drugi bili svesni pravila i mogu imati koristi od njih.\nKako se nositi sa revizijama 0.y.z u inicijalnoj fazi razvoja?\nNajjednostavniji način je da započnete inicijalni razvoj objavom verzije
0.1.0 i potom inkrementirate oznaku minor (manje) verzije za svako sledeće izdanje.\nKako da znamo kada treba objaviti verziju 1.0.0??\nAko se softver koristi u produkciji, već bi verovatno trebalo biti 1.0.0. Ako već imate stabilni API, na koji se korisnici mogu pouzdati, trebalo bi
biti 1.0.0. Ukoliko ste prilično zabrinuti oko kompatibilnosti unazad, softver
bi već trebalo da je objavljen pod verzijom 1.0.0.\nZar to ne obeshrabruje rapidan razvoj i brzu iteraciju?\nMajor (glavna) verzija nula je zapravo predodređena rapidnom razvoju. Ako menjate API svaki dan, trebalo bi ostati na verziji 0.y.z ili na posebnoj grani za razvoj raditi na sledećoj major (glavnoj) verziji.\nUkoliko i najsitnije unazad nekompatibilne izmene u API-ju zahtevaju naglo uvećavanje major (glavne) verzije, nećemo li vrlo brzo doći do verzije 42.0.0?\nOvo je pitanje odgovornog razvoja i predviđanja. U softver koji ima puno
zavisnog koda, nekompatibilne promene ne treba olako uvoditi. Troškovi
nadogradnje mogu biti značajni. Ako morate povećati major (glavnu) verziju, kako biste objavili verziju sa nekompatibilnim izmenama, morate razmisliti o uticaju tih izmena i proceniti odnos uključenih troškova i koristi.\nDokumentacija celokupnog public (javnog) API-ja zahteva previše posla\nVaša je odgovornost kao profesionalnih programera da pravilno dokumentujete
softver koji je namenjen korisnicima. Upravljanje složenošću softvera je izuzetno važan deo održavanja efikasnosti projekta, što je teško ako korisnici ne znaju kako koristiti vaš softver ili koje metode mogu bezbedno pozvati. Dugoročno, Semantičko Verzionisanje i insistiranje na kvalitetno definisanom API-ju omogućiće da svi i sve rade glatko.\nŠta ukoliko slučajno objavimo unazad nekompatibilne izmene kao minor (manju) verziju?\nČim primetite da ste prekršili specifikacije Semantičkog Verzionisanja,
potrebno je ispraviti grešku pa objaviti minor (manju) verziju koja će ispraviti problem i povratiti kompatibilnost unazad. Čak i u takvim uslovima, nije prihvatljivo modifikovati verzionisane objave. Ako je prikladno, dokumentujte verziju koja krši specifikaciju i tako obavestite korisnike kako bi bili svesni toga.\nŠta činiti ukoliko izmenimo sopstvene zavisnosti bez promene public (javnog) API-ja?\nTakve izmene smatramo kompatibilnima jer ne utiču na public (javni) API. Softver koji
eksplicitno zavisi od istih zavisnosti kao i naš sopstveni paket treba imati vlastite specifikacije zavisnosti, a autor će primetiti eventualne konflikte. Je li promjena na nivou patch (zakrpe) ili minor (manje) verzije, zavisi od toga da li ste dodavali svoje zavisnosti kao ispravke bug-ova (grešaka) ili ste ih uveli kao nove funkcionalnosti. U posljednjem slučaju
možemo očekivati i dodatni kod, pri čemu se očigledno radi o inkrementu minor (manje) verzije.\nŠta ukoliko slučajno izmenimo public (javni) API na način koji ne odgovara izmeni broja verzije (npr. u kod neispravno uvedemo veću unazad nekompatibilnu izmenu u okviru objave patch (zakrpe))?\nKoristite svoju najbolju procenu. Ako imate veliki broj korisnika, na koje će
značajno uticati promena unatrag, najbolje je da objavite major (glavnu) verziju, iako
bi takav ispravak mogli smatrati izdanjem zakrpe. Zapamtite, svrha Semantičkog
Verzionisanja je prenošenje značenja putem izmene broja verzije. Ako su takve
izmene važne za vaše korisnike, koristite broj verzije da biste ih informisali.\nKako postupati sa deprecating (zastarelim) funkcionalnostima?\nPostojeće funkcionalnosti koje zastarevaju, sastavni su deo razvoja softvera
i često su neophodne kako bi razvoj napredovao. Kad označavate deo public (javnog) API-ja kao deprecated (zastareli), potrebno je učiniti dve stvari: (1) ažurirati dokumentaciju kako bismo informisali korisnike, (2) objaviti novu minor (manju) verziju sa definisanim deprecated (zastarelim) delovima softvera. Pre nego što potpuno uklonite funkcionalnost u novoj major (glavnoj) verziji, potrebno je izdati barem jednu minor (manju) verziju koja sadrži deprecated (zastarele) delove, kako bi korisnici nesmetano prešli na novu verziju API-ja.\nIma li SemVer ograničenu veličinu stringa verzije?\nNe, ali procenite sami. String verzije od 255 znakova je verovatno preteran,
na primer. Takođe, neki sistemi mogu imati svoja ograničenja veličine stringa.\nDa li je “v1.2.3” semantička verzija?\nNe, “v1.2.3” nije semantička verzija. Međutim, prefiksiranje semantičke verzije
sa “v” je uobičajen način (na engleskom) da se naznači da je to broj verzije.
Skraćenje “verzije” kao “v” se često vidi sa kontrolom verzija. Primer:
git tag v1.2.3 -m "Release version 1.2.3", u kom slučaju je “v1.2.3” naziv
taga (oznake), a semantička verzija je “1.2.3”.\nDa li postoji predloženi regularni izraz (RegEx) za proveru SemVer stringa?\nPostoje dva. Jedan sa imenovanim grupama za one sisteme koji ih podržavaju
(PCRE [Perl Compatible Regular Expressions (Perl kompatibilni regularni izrazi), tj. Perl, PHP i R], Python
i Go).\nPogledajte: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nI drugi sa numerisanim grupama (znači ng1 = major (glavna), ng2 = minor (manja),
ng3 = patch (zakrpa), ng4 = prerelease (predizdanje) i ng5 = buildmetadata (metapodaci)) koji su kompatibilni
sa ECMA Script (JavaScript), PCRE [Perl Compatible Regular Expressions (Perl kompatibilni regularni izrazi),
tj. Perl, PHP i R], Python i Go.\nPogledajte: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nAutor specifikacije Semantičkog Verzionisanja je Tom
Preston-Werner, pronalazač Gravatar-a i suosnivač GitHub-a.\nAko želite ostaviti povratne informacije, molimo otvorite issue na
GitHub-u.\notvorite issue na
GitHub-u\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSemantisk versionshantering 2.0.0

Sammanfattning

Givet ett versionsnummer på formen MAJOR.MINOR.PATCH, räkna upp varje del enligt följande:


  Öka MAJOR med 1 när du gör ändringar som påverkar bakåtkompatibiliteten för API:t.
  Öka MINOR med 1 när du lägger till ny funktionalitet men 100 % bakåtkompatibilitet bibehålls.
  Öka PATCH med 1 när du fixar buggar förutsatt att 100 % bakåtkompatibilitet bibehålls.


Ibland kan det även förekomma ytterligare delar i versionsnumret för att markera
t.ex. en test- eller betaversion.

Introduktion

I mjukvaruutvecklingens värld finns det en obehaglig plats, det så kallade “beroendeträsket”.
Ju större ditt system blir och ju fler paket du integrerar i ditt program, desto
större är risken att du en dag finner dig själv i förtvivlans grepp.

I system med många beroenden kan nya versioner av paket snabbt bli en mardröm. Om
de specificerade beroendena är för hårt satta är risken stor att du hamnar i ett
versionslås (oförmågan att uppgradera ett paket utan att släppa nya versioner av
alla paket det finns beroende till). Om beroendena är specificerade för löst kommer
du oundvikligen hamna i en versionsnaivitet (övertro på kompabilitet med nyare
versioner). Du är i ett beroendeträsk om versionslås och/eller versionsnaivitet
förhindrar dig att enkelt och säkert ta ditt projekt framåt.

Som en lösning på detta problem föreslår jag en enkel samling regler och krav som
beskriver hur versionsnummer ska tilldelas och räknas upp. Dessa regler är baserade
på, men inte nödvändigt begränsade till, redan existerande välkänd och vanlig praxis
som används både för sluten och öppen källkod. För att detta system ska fungera måste
du deklarera ett publikt API. Detta kan bestå av dokumentation eller vara en del av
själva källkoden. Oavsett vilket är det viktigt att detta API är klart och tydligt.
När du har identifierat ditt publika API kommunicerar du ändringar i det med
specifik ökning av versionsnumret. Överväg X.Y.Z (Major.Minor.Patch) som format på
versionsnumret. Buggfixar som ej påverkar API:t ökar patch-versionen, bakåtkompatibla
API-ändringar/tillägg ökar minor-versionen och icke bakåtkompatibla API-ändringar
ökar major-versionen.

Jag kallar detta system “Semantisk versionshantering”. Under detta schema förmedlar
versionsnumret och dess förändringar mening till den underliggande koden och hur den
har förändrats från en version till en annan.

Specifikation av Semantisk versionshantering (SemVer)

Nyckelorden “MÅSTE”/”FÅR ENBART” (MUST/SHALL/REQUIRED), “FÅR INTE” (MUST NOT/SHALL NOT),
“BÖR” (SHOULD/RECOMMENDED), “BÖR INTE” (SHOULD NOT) och “KAN” (MAY/OPTIONAL) i detta
dokument skall tolkas enligt beskrivning i RFC 2119.


  
    Program som använder Semantisk versionshantering MÅSTE deklarera ett publikt API.
Detta API kan deklareras i själva koden eller enbart existera i dokumentationen.
Oavsett hur det görs BÖR det vara precist och heltäckande.
  
  
    Ett normalt versionsnummer MÅSTE ha formen X.Y.Z där X, Y och Z är
positiva heltal och FÅR INTE innehålla inledande nollor. X är major-versionen,
Y är minor-versionen och Z är patch-versionen. Varje element MÅSTE ökas numeriskt,
t.ex. 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    När ett versionshanterat paket har släppts FÅR INTE innehållet i den versionen
förändras. Alla modifieringar MÅSTE släppas som en ny version.
  
  
    Major-versionen noll (0.y.z) är för inledande utveckling. Vad som helst KAN förändras när som helst.
Publikt API BÖR ej ses som stabilt.
  
  
    Version 1.0.0 definierar det publika API:t. Hur versionsnumret ökar efter detta släpp
är beroende på detta publika API och hur det förändras.
  
  
    Patch-version Z (x.y.Z | x > 0) FÅR ENBART ökas om bakåtkompatibla buggfixar är
introducerade. En buggfix definieras som en intern förändring som åtgärdar ett felaktigt beteende.
  
  
    Minor-version Y (x.Y.z | x > 0) MÅSTE ökas om ny bakåtkompatibel funktionalitet introduceras
i det publika API:t. Det MÅSTE ökas om någon funktion i det publika API:t markeras som
föråldrad (deprecated). Det KAN ökas om väsentlig ny funktionalitet eller förbättringar
införs i den privata koden. Även förändringar på patch-nivå KAN ingå. Patch-versionen MÅSTE
återställas till 0 när minor-versionen ökar.
  
  
    Major-versionen X (X.y.z | X > 0) MÅSTE ökas om någon icke bakåtkompatibel förändring
introduceras i det publika API:t. Även förändringar på minor- och patch-nivå KAN ingå. Patch-
och minor-versionerna MÅSTE återställas till 0 när major-versionen ökar.
  
  
    En förhandsversion KAN markeras genom att lägga till ett bindestreck och en serie av
punktseparerade identifierare direkt efter patch-versionen.  Identifierare FÅR ENBART innehålla
alfanumeriska ASCII-tecken och bindestreck [0-9A-Za-z-]. Identifierare FÅR INTE vara tomma.
Numeriska identifierare FÅR INTE ha inledande nollor. En förhandsversion har en lägre prioritet
än tillhörande normal version. En förhandsversion indikerar att versionen är instabil och
kanske inte uppfyller avsedda kompabilitetskrav som utmärker dess tillhörande normala version.
Exempel: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Metadata för byggen KAN markeras genom att lägga till ett plustecken och en serie
punktseparerade identifierare direkt efter patch-versionen eller information om förhandsversion.
Identifierare FÅR ENBART innehålla alfanumeriska ASCII-tecken och bindestreck [0-9A-Za-z-].
Identifierare FÅR INTE vara tomma. Bygg-metadata MÅSTE ignoreras när versionsprioritet skall
fastställas. Således har två versioner som enbart skiljer i bygg-metadata samma prioritet.
Exempel: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    Versionsprioritet syftar på hur versioner jämförs när de sorteras. Prioritet MÅSTE beräknas
genom att separera versionen i major, minor, patch och identifierare för förhandsversion i given
ordning (bygg-metadata påverkar ej rangordningen). Prioritet bestäms av första skillnaden
när var och en av dessa identifierare jämförs i tur och ordning från vänster till höger enligt:
Major-, minor- och patch-version jämförs alltid numeriskt.
Exempel: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. När major, minor och patch är lika har en förhandsversion
lägre prioritet än en normal version. Exempel: 1.0.0-alpha < 1.0.0. Prioritet för två
förhandsversioner med samma major-, minor- och patch-version MÅSTE bestämmas genom att jämföra
varje punktseparerad identifierare från vänster till höger till dess att en skillnad hittas enligt
följande: identifierare som enbart består av siffror jämförs numeriskt och identifierare med
bokstäver och bindestreck jämförs lexikalt enligt sorteringsordningen i ASCII. Numeriska
identifierare har alltid lägre prioritet än icke numeriska identifierare. En större uppsättning
förhandsversionsidentifierare har en högre prioritet än en med färre antal ifall alla inledande
identifierare är lika. Exempel: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Varför använda Semantisk versionshantering?

Detta är inte en ny eller revolutionerande idé. Faktum är att du förmodligen redan gör det på
nästan samma sätt. Problemet är att ”nästan” inte är tillräckligt bra. Utan någon form av formell
specifikation att följa är versionsnummer så gott som värdelösa när det gäller beroendehantering.
Genom att ge ett namn och tydlig definition till ovanstående idéer blir det enkelt att kommunicera
dina avsikter till användarna av din mjukvara. När dessa avsikter är tydliga kan flexibla
(men inte för flexibla) beroendespecifikationer göras.

Ett enkelt exempel kommer här demonstrera hur Semantisk versionshantering kan göra beroendeträsket
till ett minne blott. Tänk dig ett bibliotek kallat ”Brandbil”. Det kräver ett semantiskt
versionshanterat paket kallat ”Stege”. När Brandbil skapas finns Stege i version 3.1.0. Då Brandbil
använder funktionalitet som introducerades i version 3.1.0 av Stege, kan du med säkerhet specificera
ett beroende till versioner högre eller lika med 3.1.0 men lägre än 4.0.0. När sedan version 3.1.1
och 3.2.0 av Stege blir tillgängliga kan du släppa dem till ditt pakethanteringssystem och vara
säker på att de kommer vara kompatibla med existerande programvara.

Som en ansvarsfull utvecklare vill du förstås verifiera att varje paketuppgradering fungerar som väntat.
Verkligheten är en rörig plats, det finns inget vi kan göra åt det mer än att vara vaksamma. Vad du
kan göra är att låta Semantisk versionshantering ge dig ett sunt sätt att släppa och uppgradera paket
utan att behöva rulla ut nya versioner av paket beroende av det första, vilket kommer att bespara dig
tid och problem.

Låter detta attraktivt? Allt du behöver göra för att börja använda Semantisk versionshantering är
att ange att du gör det och börja följa reglerna. Länka till denna hemsida i din README så att andra
känner till reglerna och kan dra nytta av dem.

Vanliga frågor

Hur ska jag hantera revisioner i den inledande utvecklingsfasen (0.y.z)?

Enklast är att sätta versionsnummer 0.1.0 på den första utvecklingsversionen och sedan öka
minor-versionen för varje efterföljande version.

Hur vet jag när jag ska släppa version 1.0.0?

Om din mjukvara används i produktion borde det förmodligen redan heta 1.0.0. Om du har ett stabilt
API som användare redan har beroende till borde du använda 1.0.0. Om du oroar dig för bakåtkompabilitet
borde du sannolikt redan vara på 1.0.0.

Kommer inte detta avskräcka från snabb utveckling och snabba iterationer?

Major-version noll handlar helt om snabb utveckling. Om du ändrar API:t varje dag bör du antingen
vara kvar i version 0.y.z eller jobba med nästa stora version på en separat utvecklingsgren.

Även de minsta icke bakåtkompatibla ändringar förändrar det publika API:t, vilket kräver ett steg upp i major-versionen. Skulle jag inte då snabbt komma upp i version 42.0.0?

Detta är en fråga om ansvarsfull utveckling och planering. Inkompatibla förändringar bör inte
introduceras lättvindigt i mjukvara som många har beroende till. Kostnaden man drar på sig för
att uppgradera kan bli betydande. Att öka major-versionen för att släppa inkompatibla ändringar
innebär att du också måste tänka genom konsekvenserna av dina ändringar och utvärdera kostnad
kontra nytta.

Det är för mycket jobb att dokumentera hela det publika API:t!

Det är ditt ansvar som en professionell utvecklare att korrekt dokumentera mjukvara som är
avsedd att användas av andra. Att hantera mjukvarukomplexitet är en stor och viktig del i att
hålla ett projekt effektivt, och det blir svårt om ingen vet hur mjukvaran ska användas eller
vilka metoder som är säkra att anropa. I långa loppet gör Semantisk versionshantering och krav
på väl dokumenterat publikt API att allt flyter på smidigt.

Vad gör jag om jag av misstag släpper en icke bakåtkompatibel ändring som en minor-version?

Så fort du inser att du har brutit specifikationen i Semantisk versionshantering, fixa problemet
och släpp en ny minor-version som korrigerar problemet och återställer bakåtkompabiliteten.
Även under dessa omständigheter är det helt oacceptabelt att modifiera den släppta versionen.
Om lämpligt, dokumentera den felande versionen och informera dina användare om problemet så
att de är medvetna om den felande versionen.

Vad bör jag göra om jag uppdatera mina egna beroenden utan att ändra det publika API:t?

Det skulle kunna ses som kompatibelt då det inte påverka det publika API:t. Programvara som
uttryckligen är beroende av samma sak som ditt paket bör ha sin egen beroendespecifikation och
skaparen kommer att märka eventuella konflikter. Att avgöra om förändringen är på patch- eller
minor-nivå beror på om du uppdaterade beroendet för att fixa en bugg eller för att introducera
ny funktionalitet. För det senare fallet hade jag förväntat mig att ny kod hade skrivits då
det naturligtvis är på minor-nivå.

Vad gör jag om jag tvingas förändra det publika API:t på ett sätt som inte följer versionsnumrets förändring (d.v.s. koden introducerar en stor icke kompatibel förändring i en patch-version)?

Använd ditt omdöme. Om du har en stor publik som kommer att påverkas stort av att beteendet
förändras mot vad som förväntas av det, då är det bäst att skapa en major-version även om
ändringen strikt borde ses som en patch-version. Kom ihåg att Semantisk versionshantering
handlar om att förmedla innebörden av hur versionsnummer förändras. Om dessa förändringar
är viktiga för dina användare, använd versionsnumret för att informera dem.

Hur ska jag hantera föråldrad funktionalitet?

Att markera existerande funktionalitet som föråldrad är en normal del av mjukvaruutveckling
och krävs oftast för att komma framåt. När du markera delar av ditt publika API som föråldrat
bör du göra två saker: (1) uppdatera din dokumentation så att användarna blir medvetna om
ändringen, (2) skapa en ny minor-version med funktionaliteten markerad som föråldrad. Innan
du helt tar bort funktionaliteten i en ny major-version bör det vara minst en minor-version
innehållandes markering om föråldrad kod så att användarna smidigt kan gå över till det
nya API:t.

Har SemVer en storleksbegränsning på versionssträngen?

Nej, men använd sunt förnuft. En versionssträng på t.ex. 255 tecken är förmodligen överdrivet.
Dessutom kan vissa system ha egna begränsningar på hur lång den får vara.

Är “v1.2.3” en semantisk version?

Nej, “v1.2.3” är inte en semantisk version. Å andra sidan är det vanligt att (på engelska)
använda prefixet “v” på semantiska versionsnummer för att förtydliga att det är ett versionsnummer.
Förkortningen “v” för “version” syns ofta i samband med versionshantering.
Exempel: git tag v1.2.3 -m "Release version 1.2.3", i detta fallet är “v1.2.3” ett tagg-namn
och “1.2.3” den semantiska versionen.

Om

Specifikationen för Semantisk versionshantering är skriven av Tom
Preston-Werner, skapare av Gravatars och medgrundare av
GitHub.

Om du vill lämna feedback, öppna en fråga på GitHub.

Licens

Creative Commons ― CC BY 3.0\nSemantisk versionshantering 2.0.0\nGivet ett versionsnummer på formen MAJOR.MINOR.PATCH, räkna upp varje del enligt följande:\nÖka MAJOR med 1 när du gör ändringar som påverkar bakåtkompatibiliteten för API:t.\nÖka MINOR med 1 när du lägger till ny funktionalitet men 100 % bakåtkompatibilitet bibehålls.\nÖka PATCH med 1 när du fixar buggar förutsatt att 100 % bakåtkompatibilitet bibehålls.\nIbland kan det även förekomma ytterligare delar i versionsnumret för att markera
t.ex. en test- eller betaversion.\nI mjukvaruutvecklingens värld finns det en obehaglig plats, det så kallade “beroendeträsket”.
Ju större ditt system blir och ju fler paket du integrerar i ditt program, desto
större är risken att du en dag finner dig själv i förtvivlans grepp.\nI system med många beroenden kan nya versioner av paket snabbt bli en mardröm. Om
de specificerade beroendena är för hårt satta är risken stor att du hamnar i ett
versionslås (oförmågan att uppgradera ett paket utan att släppa nya versioner av
alla paket det finns beroende till). Om beroendena är specificerade för löst kommer
du oundvikligen hamna i en versionsnaivitet (övertro på kompabilitet med nyare
versioner). Du är i ett beroendeträsk om versionslås och/eller versionsnaivitet
förhindrar dig att enkelt och säkert ta ditt projekt framåt.\nSom en lösning på detta problem föreslår jag en enkel samling regler och krav som
beskriver hur versionsnummer ska tilldelas och räknas upp. Dessa regler är baserade
på, men inte nödvändigt begränsade till, redan existerande välkänd och vanlig praxis
som används både för sluten och öppen källkod. För att detta system ska fungera måste
du deklarera ett publikt API. Detta kan bestå av dokumentation eller vara en del av
själva källkoden. Oavsett vilket är det viktigt att detta API är klart och tydligt.
När du har identifierat ditt publika API kommunicerar du ändringar i det med
specifik ökning av versionsnumret. Överväg X.Y.Z (Major.Minor.Patch) som format på
versionsnumret. Buggfixar som ej påverkar API:t ökar patch-versionen, bakåtkompatibla
API-ändringar/tillägg ökar minor-versionen och icke bakåtkompatibla API-ändringar
ökar major-versionen.\nJag kallar detta system “Semantisk versionshantering”. Under detta schema förmedlar
versionsnumret och dess förändringar mening till den underliggande koden och hur den
har förändrats från en version till en annan.\nSpecifikation av Semantisk versionshantering (SemVer)\nNyckelorden “MÅSTE”/”FÅR ENBART” (MUST/SHALL/REQUIRED), “FÅR INTE” (MUST NOT/SHALL NOT),
“BÖR” (SHOULD/RECOMMENDED), “BÖR INTE” (SHOULD NOT) och “KAN” (MAY/OPTIONAL) i detta
dokument skall tolkas enligt beskrivning i RFC 2119.\nProgram som använder Semantisk versionshantering MÅSTE deklarera ett publikt API.
Detta API kan deklareras i själva koden eller enbart existera i dokumentationen.
Oavsett hur det görs BÖR det vara precist och heltäckande.\nProgram som använder Semantisk versionshantering MÅSTE deklarera ett publikt API.
Detta API kan deklareras i själva koden eller enbart existera i dokumentationen.
Oavsett hur det görs BÖR det vara precist och heltäckande.\nEtt normalt versionsnummer MÅSTE ha formen X.Y.Z där X, Y och Z är
positiva heltal och FÅR INTE innehålla inledande nollor. X är major-versionen,
Y är minor-versionen och Z är patch-versionen. Varje element MÅSTE ökas numeriskt,
t.ex. 1.9.0 -> 1.10.0 -> 1.11.0.\nEtt normalt versionsnummer MÅSTE ha formen X.Y.Z där X, Y och Z är
positiva heltal och FÅR INTE innehålla inledande nollor. X är major-versionen,
Y är minor-versionen och Z är patch-versionen. Varje element MÅSTE ökas numeriskt,
t.ex. 1.9.0 -> 1.10.0 -> 1.11.0.\nNär ett versionshanterat paket har släppts FÅR INTE innehållet i den versionen
förändras. Alla modifieringar MÅSTE släppas som en ny version.\nNär ett versionshanterat paket har släppts FÅR INTE innehållet i den versionen
förändras. Alla modifieringar MÅSTE släppas som en ny version.\nMajor-versionen noll (0.y.z) är för inledande utveckling. Vad som helst KAN förändras när som helst.
Publikt API BÖR ej ses som stabilt.\nMajor-versionen noll (0.y.z) är för inledande utveckling. Vad som helst KAN förändras när som helst.
Publikt API BÖR ej ses som stabilt.\nVersion 1.0.0 definierar det publika API:t. Hur versionsnumret ökar efter detta släpp
är beroende på detta publika API och hur det förändras.\nVersion 1.0.0 definierar det publika API:t. Hur versionsnumret ökar efter detta släpp
är beroende på detta publika API och hur det förändras.\nPatch-version Z (x.y.Z | x > 0) FÅR ENBART ökas om bakåtkompatibla buggfixar är
introducerade. En buggfix definieras som en intern förändring som åtgärdar ett felaktigt beteende.\nPatch-version Z (x.y.Z | x > 0) FÅR ENBART ökas om bakåtkompatibla buggfixar är
introducerade. En buggfix definieras som en intern förändring som åtgärdar ett felaktigt beteende.\nMinor-version Y (x.Y.z | x > 0) MÅSTE ökas om ny bakåtkompatibel funktionalitet introduceras
i det publika API:t. Det MÅSTE ökas om någon funktion i det publika API:t markeras som
föråldrad (deprecated). Det KAN ökas om väsentlig ny funktionalitet eller förbättringar
införs i den privata koden. Även förändringar på patch-nivå KAN ingå. Patch-versionen MÅSTE
återställas till 0 när minor-versionen ökar.\nMinor-version Y (x.Y.z | x > 0) MÅSTE ökas om ny bakåtkompatibel funktionalitet introduceras
i det publika API:t. Det MÅSTE ökas om någon funktion i det publika API:t markeras som
föråldrad (deprecated). Det KAN ökas om väsentlig ny funktionalitet eller förbättringar
införs i den privata koden. Även förändringar på patch-nivå KAN ingå. Patch-versionen MÅSTE
återställas till 0 när minor-versionen ökar.\nMajor-versionen X (X.y.z | X > 0) MÅSTE ökas om någon icke bakåtkompatibel förändring
introduceras i det publika API:t. Även förändringar på minor- och patch-nivå KAN ingå. Patch-
och minor-versionerna MÅSTE återställas till 0 när major-versionen ökar.\nMajor-versionen X (X.y.z | X > 0) MÅSTE ökas om någon icke bakåtkompatibel förändring
introduceras i det publika API:t. Även förändringar på minor- och patch-nivå KAN ingå. Patch-
och minor-versionerna MÅSTE återställas till 0 när major-versionen ökar.\nEn förhandsversion KAN markeras genom att lägga till ett bindestreck och en serie av
punktseparerade identifierare direkt efter patch-versionen.  Identifierare FÅR ENBART innehålla
alfanumeriska ASCII-tecken och bindestreck [0-9A-Za-z-]. Identifierare FÅR INTE vara tomma.
Numeriska identifierare FÅR INTE ha inledande nollor. En förhandsversion har en lägre prioritet
än tillhörande normal version. En förhandsversion indikerar att versionen är instabil och
kanske inte uppfyller avsedda kompabilitetskrav som utmärker dess tillhörande normala version.
Exempel: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nEn förhandsversion KAN markeras genom att lägga till ett bindestreck och en serie av
punktseparerade identifierare direkt efter patch-versionen.  Identifierare FÅR ENBART innehålla
alfanumeriska ASCII-tecken och bindestreck [0-9A-Za-z-]. Identifierare FÅR INTE vara tomma.
Numeriska identifierare FÅR INTE ha inledande nollor. En förhandsversion har en lägre prioritet
än tillhörande normal version. En förhandsversion indikerar att versionen är instabil och
kanske inte uppfyller avsedda kompabilitetskrav som utmärker dess tillhörande normala version.
Exempel: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nMetadata för byggen KAN markeras genom att lägga till ett plustecken och en serie
punktseparerade identifierare direkt efter patch-versionen eller information om förhandsversion.
Identifierare FÅR ENBART innehålla alfanumeriska ASCII-tecken och bindestreck [0-9A-Za-z-].
Identifierare FÅR INTE vara tomma. Bygg-metadata MÅSTE ignoreras när versionsprioritet skall
fastställas. Således har två versioner som enbart skiljer i bygg-metadata samma prioritet.
Exempel: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nMetadata för byggen KAN markeras genom att lägga till ett plustecken och en serie
punktseparerade identifierare direkt efter patch-versionen eller information om förhandsversion.
Identifierare FÅR ENBART innehålla alfanumeriska ASCII-tecken och bindestreck [0-9A-Za-z-].
Identifierare FÅR INTE vara tomma. Bygg-metadata MÅSTE ignoreras när versionsprioritet skall
fastställas. Således har två versioner som enbart skiljer i bygg-metadata samma prioritet.
Exempel: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nVersionsprioritet syftar på hur versioner jämförs när de sorteras. Prioritet MÅSTE beräknas
genom att separera versionen i major, minor, patch och identifierare för förhandsversion i given
ordning (bygg-metadata påverkar ej rangordningen). Prioritet bestäms av första skillnaden
när var och en av dessa identifierare jämförs i tur och ordning från vänster till höger enligt:
Major-, minor- och patch-version jämförs alltid numeriskt.
Exempel: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. När major, minor och patch är lika har en förhandsversion
lägre prioritet än en normal version. Exempel: 1.0.0-alpha < 1.0.0. Prioritet för två
förhandsversioner med samma major-, minor- och patch-version MÅSTE bestämmas genom att jämföra
varje punktseparerad identifierare från vänster till höger till dess att en skillnad hittas enligt
följande: identifierare som enbart består av siffror jämförs numeriskt och identifierare med
bokstäver och bindestreck jämförs lexikalt enligt sorteringsordningen i ASCII. Numeriska
identifierare har alltid lägre prioritet än icke numeriska identifierare. En större uppsättning
förhandsversionsidentifierare har en högre prioritet än en med färre antal ifall alla inledande
identifierare är lika. Exempel: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nVersionsprioritet syftar på hur versioner jämförs när de sorteras. Prioritet MÅSTE beräknas
genom att separera versionen i major, minor, patch och identifierare för förhandsversion i given
ordning (bygg-metadata påverkar ej rangordningen). Prioritet bestäms av första skillnaden
när var och en av dessa identifierare jämförs i tur och ordning från vänster till höger enligt:
Major-, minor- och patch-version jämförs alltid numeriskt.
Exempel: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. När major, minor och patch är lika har en förhandsversion
lägre prioritet än en normal version. Exempel: 1.0.0-alpha < 1.0.0. Prioritet för två
förhandsversioner med samma major-, minor- och patch-version MÅSTE bestämmas genom att jämföra
varje punktseparerad identifierare från vänster till höger till dess att en skillnad hittas enligt
följande: identifierare som enbart består av siffror jämförs numeriskt och identifierare med
bokstäver och bindestreck jämförs lexikalt enligt sorteringsordningen i ASCII. Numeriska
identifierare har alltid lägre prioritet än icke numeriska identifierare. En större uppsättning
förhandsversionsidentifierare har en högre prioritet än en med färre antal ifall alla inledande
identifierare är lika. Exempel: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nVarför använda Semantisk versionshantering?\nDetta är inte en ny eller revolutionerande idé. Faktum är att du förmodligen redan gör det på
nästan samma sätt. Problemet är att ”nästan” inte är tillräckligt bra. Utan någon form av formell
specifikation att följa är versionsnummer så gott som värdelösa när det gäller beroendehantering.
Genom att ge ett namn och tydlig definition till ovanstående idéer blir det enkelt att kommunicera
dina avsikter till användarna av din mjukvara. När dessa avsikter är tydliga kan flexibla
(men inte för flexibla) beroendespecifikationer göras.\nEtt enkelt exempel kommer här demonstrera hur Semantisk versionshantering kan göra beroendeträsket
till ett minne blott. Tänk dig ett bibliotek kallat ”Brandbil”. Det kräver ett semantiskt
versionshanterat paket kallat ”Stege”. När Brandbil skapas finns Stege i version 3.1.0. Då Brandbil
använder funktionalitet som introducerades i version 3.1.0 av Stege, kan du med säkerhet specificera
ett beroende till versioner högre eller lika med 3.1.0 men lägre än 4.0.0. När sedan version 3.1.1
och 3.2.0 av Stege blir tillgängliga kan du släppa dem till ditt pakethanteringssystem och vara
säker på att de kommer vara kompatibla med existerande programvara.\nSom en ansvarsfull utvecklare vill du förstås verifiera att varje paketuppgradering fungerar som väntat.
Verkligheten är en rörig plats, det finns inget vi kan göra åt det mer än att vara vaksamma. Vad du
kan göra är att låta Semantisk versionshantering ge dig ett sunt sätt att släppa och uppgradera paket
utan att behöva rulla ut nya versioner av paket beroende av det första, vilket kommer att bespara dig
tid och problem.\nLåter detta attraktivt? Allt du behöver göra för att börja använda Semantisk versionshantering är
att ange att du gör det och börja följa reglerna. Länka till denna hemsida i din README så att andra
känner till reglerna och kan dra nytta av dem.\nHur ska jag hantera revisioner i den inledande utvecklingsfasen (0.y.z)?\nEnklast är att sätta versionsnummer 0.1.0 på den första utvecklingsversionen och sedan öka
minor-versionen för varje efterföljande version.\nHur vet jag när jag ska släppa version 1.0.0?\nOm din mjukvara används i produktion borde det förmodligen redan heta 1.0.0. Om du har ett stabilt
API som användare redan har beroende till borde du använda 1.0.0. Om du oroar dig för bakåtkompabilitet
borde du sannolikt redan vara på 1.0.0.\nKommer inte detta avskräcka från snabb utveckling och snabba iterationer?\nMajor-version noll handlar helt om snabb utveckling. Om du ändrar API:t varje dag bör du antingen
vara kvar i version 0.y.z eller jobba med nästa stora version på en separat utvecklingsgren.\nÄven de minsta icke bakåtkompatibla ändringar förändrar det publika API:t, vilket kräver ett steg upp i major-versionen. Skulle jag inte då snabbt komma upp i version 42.0.0?\nDetta är en fråga om ansvarsfull utveckling och planering. Inkompatibla förändringar bör inte
introduceras lättvindigt i mjukvara som många har beroende till. Kostnaden man drar på sig för
att uppgradera kan bli betydande. Att öka major-versionen för att släppa inkompatibla ändringar
innebär att du också måste tänka genom konsekvenserna av dina ändringar och utvärdera kostnad
kontra nytta.\nDet är för mycket jobb att dokumentera hela det publika API:t!\nDet är ditt ansvar som en professionell utvecklare att korrekt dokumentera mjukvara som är
avsedd att användas av andra. Att hantera mjukvarukomplexitet är en stor och viktig del i att
hålla ett projekt effektivt, och det blir svårt om ingen vet hur mjukvaran ska användas eller
vilka metoder som är säkra att anropa. I långa loppet gör Semantisk versionshantering och krav
på väl dokumenterat publikt API att allt flyter på smidigt.\nVad gör jag om jag av misstag släpper en icke bakåtkompatibel ändring som en minor-version?\nSå fort du inser att du har brutit specifikationen i Semantisk versionshantering, fixa problemet
och släpp en ny minor-version som korrigerar problemet och återställer bakåtkompabiliteten.
Även under dessa omständigheter är det helt oacceptabelt att modifiera den släppta versionen.
Om lämpligt, dokumentera den felande versionen och informera dina användare om problemet så
att de är medvetna om den felande versionen.\nVad bör jag göra om jag uppdatera mina egna beroenden utan att ändra det publika API:t?\nDet skulle kunna ses som kompatibelt då det inte påverka det publika API:t. Programvara som
uttryckligen är beroende av samma sak som ditt paket bör ha sin egen beroendespecifikation och
skaparen kommer att märka eventuella konflikter. Att avgöra om förändringen är på patch- eller
minor-nivå beror på om du uppdaterade beroendet för att fixa en bugg eller för att introducera
ny funktionalitet. För det senare fallet hade jag förväntat mig att ny kod hade skrivits då
det naturligtvis är på minor-nivå.\nVad gör jag om jag tvingas förändra det publika API:t på ett sätt som inte följer versionsnumrets förändring (d.v.s. koden introducerar en stor icke kompatibel förändring i en patch-version)?\nAnvänd ditt omdöme. Om du har en stor publik som kommer att påverkas stort av att beteendet
förändras mot vad som förväntas av det, då är det bäst att skapa en major-version även om
ändringen strikt borde ses som en patch-version. Kom ihåg att Semantisk versionshantering
handlar om att förmedla innebörden av hur versionsnummer förändras. Om dessa förändringar
är viktiga för dina användare, använd versionsnumret för att informera dem.\nHur ska jag hantera föråldrad funktionalitet?\nAtt markera existerande funktionalitet som föråldrad är en normal del av mjukvaruutveckling
och krävs oftast för att komma framåt. När du markera delar av ditt publika API som föråldrat
bör du göra två saker: (1) uppdatera din dokumentation så att användarna blir medvetna om
ändringen, (2) skapa en ny minor-version med funktionaliteten markerad som föråldrad. Innan
du helt tar bort funktionaliteten i en ny major-version bör det vara minst en minor-version
innehållandes markering om föråldrad kod så att användarna smidigt kan gå över till det
nya API:t.\nHar SemVer en storleksbegränsning på versionssträngen?\nNej, men använd sunt förnuft. En versionssträng på t.ex. 255 tecken är förmodligen överdrivet.
Dessutom kan vissa system ha egna begränsningar på hur lång den får vara.\nÄr “v1.2.3” en semantisk version?\nNej, “v1.2.3” är inte en semantisk version. Å andra sidan är det vanligt att (på engelska)
använda prefixet “v” på semantiska versionsnummer för att förtydliga att det är ett versionsnummer.
Förkortningen “v” för “version” syns ofta i samband med versionshantering.
Exempel: git tag v1.2.3 -m "Release version 1.2.3", i detta fallet är “v1.2.3” ett tagg-namn
och “1.2.3” den semantiska versionen.\nSpecifikationen för Semantisk versionshantering är skriven av Tom
Preston-Werner, skapare av Gravatars och medgrundare av
GitHub.\nOm du vill lämna feedback, öppna en fråga på GitHub.\nöppna en fråga på GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nAnlamsal Sürümleme 2.0.0

Özet

BÜYÜK.KÜÇÜK.YAMA diye belirtilen bir sürüm numarasında,


  Önceki sürümle uyumsuz API değişiklikleri yaptığınızda BÜYÜK sürümü,
  Önceki sürümle uyumlu bir davranış eklediğinizde KÜÇÜK sürümü, ve
  Önceki sürümle uyumlu bir hata düzeltmesi yaptığınızda YAMA sürümünü


arttırın.

Ayrıca, BÜYÜK.KÜÇÜK.YAMA biçiminin sonuna ön-sunum (pre-release) ve derleme üstverisi (build metadata) gibi etiketler eklenebilmektedir.

Giriş

Yazılım yönetimi dünyasında “bağımlılık cehennemi” (dependency hell) adında korkulu bir diyar vardır. Sisteminiz büyüdükçe ve yazılımınıza daha çok paket eklediğinizde, büyük ihtimalle bir gün gelecek ve kendinizi bu çaresizlik batağında bulacaksınız.

Bir çok bağımlılığı olan sistemlerde, yeni bir paket sürümü çıkarmak bir kabusa dönüşebilir. Bağımlılıklar çok sıkı belirlenmişse, sürüm kitlenmesi (bağımlı olunan tüm paketlerin yeni sürümünü yükseltmeden istenen paketin sürümünü yükseltememek) tehlikesiyle karşı karşıyasınız demektir. Eğer bağımlılıklar çok gevşek belirlenmişse, ister istemez sürüm çeşitliliği (gelecekteki sürümlerle aşırı uyumluluk varsaymak) tarafından ısırılacaksınızdır.

Sürüm kitlenmesi ve/veya sürüm çeşitliliği nedeniyle projenizi güvenli bir şekilde ilerletemediğinizde bağımlılık cehenneminin içindesiniz demektir.

Bu soruna bir çözüm olarak, sürüm numaralarının nasıl verildiği ve arttırıldığı konusunda bazı basit kurallar ve gereklilikler öneriyorum. Bu kurallar, genel kabul görmüş, hem kapalı hem de açık-kaynak yazılım uygulamalarına dayansa da, onlarla sınırlı değildir. Bu sistemin çalışması için, öncelikle erişime açık bir API (public API) tanımlamanız gerekiyor. Bu, belgeleme veya kod tarafından konulmuş bir kuraldan oluşabilir. Ne şekilde olursa olsun, önemli olan bu API’ın açık ve kesin olmasıdır. Erişime açık API’ınızı tanımladığınız anda, bundan sonra geçireceği değişimleri, sürüm numaranızı belirli arttırımlara tabi tutarak iletmelisiniz. Şu şekilde bir sürüm numarası ele alalım: X.Y.Z (Büyük.Küçük.Yama). API’ı etkilemeyen hata düzeltmeleri yama sürümünü arttırır, önceki sürümlerle uyumlu API eklemeleri/değişiklikleri küçük sürümü arttırır, ve önceki sürümler ile uyumsuz API değişikleri büyük sürümü arttırır.

Bu sistemi: “Anlamsal Sürümleme” diye nitelendiriyorum. Bu düzen sayesinde, sürüm numaraları ve sürüm numaralarının değişim şekilleri, kodda, bir sürümden diğerine neyin değiştiğini anlatır hale gelmektedir.

Anlamsal Sürümleme Tanımı (SemVer)

Bu belge içindeki anahtar sözcükler ve/veya eklerinden oluşan “-MALI”, “-MELİ”, “-MAMALI”, “-MEMELİ”, “GEREKLİ”, “-ECEK”, “-ACAK”, “-MEYECEK”, “-MAYACAK”, “-EBİLİR”, ÖNERİLİR”, “OLABİLİR”, ve “KEYFE BAĞLI”, RFC 2119‘da belirtildiği şekilde anlaşılmalıdır.


  
    Anlamsal Sürümleme kullanan bir yazılım erişime açık bir API tanımlamalıdır. Bu API, kodun kendi içinde veya yalnızca zaten var olan bir belgelemenin içinde tanımlanabilir. Nasıl yapılırsa yapılsın, kesin ve eksiksiz olmalıdır.
  
  
    Normal bir sürüm numarası X.Y.Z biçimde OLMALIDIR; burada X, Y, ve Z negatif olmayan tam sayılardır, ve başlarında sıfır İÇERMEMELİDİR. X büyük sürümdür, Y küçük sürümdür, ve Z yama sürümüdür. Her öğe sayısal olarak ARTMALIDIR. Örnek: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Sürümlenmiş bir paket sunulduğunda, o sürümün içeriği DEĞİŞTİRİLMEMELİDİR. Yapılan her hangi bir değişim yeni bir sürüm olarak sunulmalıdır.
  
  
    Büyük sürüm sıfırı başlangıçta yapılan yazılım geliştirme içindir. Her şey her an değişebilir. Erişime açık API dengeli (stable) diye değerlendirilmemelidir.
  
  
    1.0.0 sürümü erişime açık API’ı tanımlar. Sürüm numarasının bu sürümden sonra nasıl arttırılacağı bu erişime açık API’a ve nasıl değiştiğine bağlıdır.
  
  
    Yama sürümü Z (x.y.Z | X > 0) sadece önceki sürümle uyumlu hata düzeltmeleri yapıldığında ARTTIRILMALIDIR. Hata düzeltmesi şöyle tanımlanır: Yanlış bir davranışı düzelten içsel bir değişiklik.
  
  
    Küçük sürüm Y (x.Y.z | x > 0), erişime açık API’a yeni, önceki sürümle uyumlu bir işlevsellik eklendiğinde ARTTIRILMALIDIR. Erişime açık API’daki bir işlevsellik çürümüş (deprecated) diye işaretlendiğinde ARTTIRILMALIDIR. Özel koda ciddi oranda yeni işlevler veya geliştirmeler katıldığında ARTTIRILABİLİR. Yama düzeyindeki değişiklikler buna dahil EDİLEBİLİR. Yama sürümü, küçük sürüm arttırıldığında SIFIRLANMALIDIR.
  
  
    Büyük sürüm X (X.y.z | X > 0) önceki sürümle uyumsuz değişiklikler yapıldığında ARTTIRILMALIDIR. Yama ve küçük düzeydeki değişiklikler buna dahil edilebilir. Büyük sürüm arttırıldığında, yama ve küçük sürüm SIFIRLANMALIDIR.
  
  
    Bir ön-sunum (pre-release) sürümü, yama sürümünden hemen sonraki kısımda, bir tire işaretiyle ve bir dizi nokta ayracıyla GÖSTERİLEBİLİR. Tanımlayıcılar yalnızca ASCII alfasayısal ve tire işaretlerinden [0-9A-Za-z-] OLUŞMALIDIR. Tanımlayıcılar boş OLMAMALIDIR. Sayısal tanımlayıcılar öncül sıfırlar İÇERMEMELİDİR. Ön-sunum sürümleri ilişkili normal sürümden daha düşük önceliğe sahiptir. İlişkili normal sürümün tersine, bir ön-sunum sürümü, sürümün dengesiz olduğunu ve beklenen uyumluluk gereksinimlerini karşılayamayacağını gösterir. Örnekler: 1.0.0-ilk, 1.0.0-ilk.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Derleme üst verisi, yama sürümünü veya ön-sunum sürümünü hemen takip ederek eklenen bir artı işaretiyle ve bir dizi nokta ayracıyla GÖSTERİLEBİLİR. Tanımlayıcılar yalnızca ASCII alfasayısal ve tire işaretlerinden [0-9A-Za-z-] OLUŞMALIDIR. Tanımlayıcılar boş OLMAMALIDIR. Derleme üstverisi sürüm önceliği belirlenirken dikkate ALINMAMALIDIR. Böylece, yalnızca derleme üstverisiyle farklılık gösteren iki sürüm de aynı önceliğe sahip olacaktır. Örnekler: 1.0.0-ilk+001, 1.0.0+20130313144700, 1.0.0-ikincil+deneme.sha.5114f85.
  
  
    Öncelik, sürümlerin sıralandıklarında, birbirleriyle sıralarının nasıl karşılaştırılacaklarını belirtir. Öncelik sürüm numarası büyük, küçük, yama ve ön-sunum tanımlayıcılarıyla, burada yazıldığı sırada (Derleme üstverisi öncelik belirlenirken anlamsızdır) ayırarak HESAPLANMALIDIR. Öncelik, soldan sağa doğru tanımlayıcıların her birini şu şekilde karşılaştırırken belirlenir: Büyük, küçük, ve yama sürümleri daima sayısal olarak karşılaştırılır. Örnek: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Büyük, küçük, ve yama eşit olduğunda, bir ön-sunum sürümü, normal bir sürümden daha düşük önceliğe sahiptir. Örnek: 1.0.0-ilk < 1.0.0.  Aynı büyük, küçük, ve yama sürümüne sahip iki ön-sunum sürümünün önceliği, şu şekilde gösterildiği gibi, soldan sağa doğru her bir tanımlayıcıyı ayırıp karşılaştırarak BELİRLENMELİDİR: yalnızca rakamlardan oluşan tanımlayıcılar sayısal olarak karşılaştırılır ve harfli veya tire çizgili tanımlayıcılar ise ASCII sözcük sıralamalarına göre karşılaştırılırlar. Sayısal tanımlayıcılar, sayısal-olmayan tanımlayıcılardan daima daha düşük önceliğe sahiptirler.
  


Önce gelen tüm tanımlayıcıları eşitse, büyük bir dizi ön-sunumun alanlarının, daha küçük bir dizininkinden daha yüksek önceliği vardır. Örnek: 1.0.0-ilk < 1.0.0-ilk.1 < 1.0.0-ilk.ikincil < 1.0.0-ikincil < 1.0.0-ikincil.2 < 1.0.0-ikincil.11 < 1.0.0-sa.1 < 1.0.0.

Anlamsal Sürümlendirme Neden Kullanılmalıdır?

Aslında, bu yeni veya çığır açan bir fikir değil. Büyük olasılıkla buna yakın bir şeyler zaten yapıyorsunuzdur. Sorun şudur: “yakın” olması yeterince iyi değildir. Bir şekilde belirlenmiş, resmi bir şartnameye uymadan, sürüm sayıları bağımlılık yönetimi için gerçek hayatta kullanışsızdır. Üstteki fikirleri isimlendirip, açık tanımlamalar yaparak, yazılımınızın kullanıcılarına niyetinizi iletmeniz kolaylaşır. Niyetler bir kere açık, esnek (fakat aşırı esnekleştirmeden) oldu mu, bağımlılık tanımlamaları yapılabilir hale gelir.

Basit bir örnek Anlamsal Sürümlendirme’nin bağımlılık cehennemini nasıl mazinin bir parçası haline getirebildiğini gösterecek. “İtfaiye Aracı” isminde bir kütüphaneyi ele alalım. “Merdiven” adındaki Anlamsal Sürümlendirilmiş bir pakete ihtiyaç duymaktadır. İtfaiye Aracı yaratıldığında, Merdiven 3.1.0 sürümündedir. İtfaiye Aracı 3.1.0’da eklenmiş bazı işlevlere ihtiyaç duyduğundan, Merdiven bağımlılığının 3.1.0’a eşit ya da daha büyük fakat 4.0.0’dan küçük olduğunu güvenle belirtebilirsiniz. Böylelikle, Merdiven sürüm 3.1.1 ve 3.2.0 kullanılabilir olduğunda, paket yönetim sisteminize bunları sunabilirsiniz ve halihazırdaki bağımlılığı bulunduğu yazılımla uyumlu olacağını bilirsiniz.

Sorumluluk sahibi bir yazılım geliştirici olarak, tabii ki, her paket güncellemesinin reklam edildiği şekilde işlediğini kontrol etmek isteyeceksiniz. Gerçek dünya karışık bir yerdir; gözünüzü açık tutmak dışında yapabileceğiniz pek bir şey yoktur. Ancak, yapabileceğiniz şudur: Bağımlı olunan paketlerin yeni sürümlerini çıkarmaya gerek kalmadan paketleri sunmak ve yükseltmek için sizi zaman ve eziyetten kurtaracak mantıklı bir yol öneren Anlamsal Sürümlendirme’yi kullanmaktır.

Bütün bunlar hoşunuza gittiyse, Anlamsal Sürünlendirme’yi kullanmaya başlamak için yapmanız gereken tek şey kullanmaya başladığınızı ve kurallarını takip ettiğinizi duyurmaktır. BENİOKU (README) dosyanızdan bu web sitesine bağlantı vererek diğerlerinin de kuralları bilmesini ve bunlardan yarar sağlamalarını sağlayabilirsiniz.

SSS

İlk geliştirme fazı olan 0.y.z’deki değişikliklerle nasıl başa çıkmalıyım?

Yapılabilecek en basit şey ilk geliştirme sunumunuzu 0.1.0’da başlatmaktır ve takip eden her sunum için küçük sürümü arttırmaktır.

1.0.0’ı ne zaman sunacağımı nasıl anlarım?

Yazılımınız piyasa (production) ortamında kullanılmaya başlanmışsa, zaten muhtemelen 1.0.0’dır. Kullanıcıların güvenebildiği dengeli bir API’a sahipseniz, 1.0.0 olmalısınız. Önceki sürümle uyumlu olmayı dert ediyorsanız, büyük olasılıkla, çoktandır 1.0.0 olmalısınız.

Seri geliştirmeden ve hızlı döngüden caydırmaz mı?

Büyük sürümün sıfır olması tamamen seri geliştirmeyle alakalıdır. Eğer API’ı her gün değiştiriyorsanız ya hala 0.y.z sürümü ya da sıradaki büyük sürümün üzerinde çalıştığınız ayrı bir geliştirme dalı (branch) üzerinde olmalısınız.

Erişime açık API’ımın önceki bir sürümüyle uyumsuz en küçük değişiklikler bile büyük sürümü arttıracaksa, kendimi birden 42.0.0 sürümünde bulmayacak mıyım?

Bu sorumluluk sahibi yazılım geliştirmekle ve ileri görüşlülükle alakalı bir sorudur. Bir çok bağımlılığı olan bir yazılıma uyumsuz değişiklikler öylesine eklenmemelidir. Maruz kalınacak yükseltme maliyeti ciddi boyutlarda olabilir. Uyumsuz değişikliklerde büyük sürümü arttırmak demek yaptığınız değişikliklerin etkileri hakkında etraflıca düşüneceğinizi, ve maliyet/kazanç oranına göre karar vermenizi gerektirecektir.

Erişime açık API’ın tamamını belgelendirmek büyük iş!

Başkaları tarafından kullanılacağı düşünülen bir yazılımı düzgün bir şekilde belgelendirmek usta bir yazılım geliştirici olarak sizin sorumluluğunuzdur. Yazılım karmaşıklığını yönetmek bir projeyi verimli tutmanın çok önemli bir kısmıdır ve kimse yazılımınızı nasıl kullanacağını ya da hangi yöntemleri (methods) çağırmanın güvenli olacağını bilemiyorsa bunu yapmak zordur. Anlamlı Sürümlendirme, uzun dönemde, ve iyi tanımlanmış erişime açık bir API ile herkesin ve her şeyin sorunsuzca devam etmesini sağlar.

Önceki sürümle uyumsuz bir değişikliği yanlışlıkla küçük bir sürüm olarak sunarsam ne yaparım?

Anlamsal Sürümlendirme şartnamesini bozduğunuzu farkettiğiniz anda, sorunu düzeltin ve sorunu düzelten ve önceki sürümle uyumluluğunu sağlayan yeni bir küçük sürüm sunun. Bu şartlar altında bile, sürümlendirilmiş sunumları kesinlikle değiştirmeyin. Mümkünse, sıkıntı çıkaran sürümü belgelendirin ve kullanıcılarınızı sorunla alakalı olarak bilgilendirin böylece sıkıntı çıkaran sürümden haberleri olmuş olur.

Erişime açık API’ı değiştirmeden yazılımın bağımlılıklarını güncellersem ne yapmalıyım?

Erişime açık API’ı etkilemediğinden uyumlu olarak değerlendirilebilecek bir durumdur. Paketinizle aynı bağımlılıklara sahip olan bir yazılımın kendi bağımlılık şartnameleri olmalıdır ve yazılımcısı tüm uyuşmazlıkları farkedecektir. Bir hatayı düzeltmek ya da yeni bir işlev kazandırmak için bağımlılıklarınızı güncelleyip güncellemediğiniz, yama ya da küçük seviyede bir değişiklik yapıp yapmadığınızı belirler. İkinci örnekteki durum için genelde ek kod beklerim; her iki durumun da küçük seviye bir artış olduğu bellidir.

Ya yanlışlıkla erişime açık API’ı sürüm numarasıyla uyumlu olmayacak bir şekilde değiştirmişsem (örn: yama sunumunda büyük bir kırıcı değişim oluşturan kod)?

Sağduyunuzu kullanın. Erişime açık API’ın davranışını beklenen, önceki haline geri getirmenizden etkilenecek büyük bir kitleniz varsa, düzeltmeniz bir yama sunumu gibi değerlendirilebilir olsa da, büyük bir sürüm sunumu yapmak en iyisi olabilir. Anlamsal Sürümlendirme’nin tüm amacının sürüm numaralarının nasıl değiştiğini ifade ettiğini unutmayın. Eğer bu değişiklikler kullanıcılarınız için önemliyse, sürüm numarasını kullanarak onları bilgilendirin.

Çürüyen bir işlevi nasıl ele almalıyım?

Varolan işlevlerin çürümesi yazılım geliştirmenin normal bir parçasıdır ve ileri adım atabilmek için genellikle gerekir. Erişime açık API’ınızın bir kısmını çürüttüğünüzde, iki şey yapmalısınız: (1) değişiklik konusunda kullanıcılarınızı bilgilendirmek için belgelendirmenizi güncelleyin, (2) çürümenin konduğu küçük bir sunum çıkarın. İşlevi büyük bir sunumla tamamen kaldırmadan önce, kullanıcılarınızın yeni API’a kolayca geçiş yapabilmeleri için çürümeyi içeren en az bir adet küçük bir sunum olmalıdır.

Semver, sürüm karakterlerinde (string)  bir sınıra sahip midir?

Hayır, fakat sağduyunuzu kullanın. Örneğin, 255 karaktere sahip bir sürüm karakteri muhtemelen gereksizdir. Ayrıca, karakterlerin uzunluğu konusunda bazı sistemler kendi sınırlarını koyabilirler.

Hakkında

Anlamsal Sürümlendirme şartnamesi, Gravatar’ların kaşifi ve GitHub’un kurucu ortaklarından olan Tom Preston-Werner tarafından yazılmıştır.

Yorum bırakmak isterseniz, lütfen GitHub’da bir konu açın.

Lisans

Creative Commons ― CC BY 3.0\nAnlamsal Sürümleme 2.0.0\nBÜYÜK.KÜÇÜK.YAMA diye belirtilen bir sürüm numarasında,\nÖnceki sürümle uyumsuz API değişiklikleri yaptığınızda BÜYÜK sürümü,\nÖnceki sürümle uyumlu bir davranış eklediğinizde KÜÇÜK sürümü, ve\nÖnceki sürümle uyumlu bir hata düzeltmesi yaptığınızda YAMA sürümünü\nAyrıca, BÜYÜK.KÜÇÜK.YAMA biçiminin sonuna ön-sunum (pre-release) ve derleme üstverisi (build metadata) gibi etiketler eklenebilmektedir.\nYazılım yönetimi dünyasında “bağımlılık cehennemi” (dependency hell) adında korkulu bir diyar vardır. Sisteminiz büyüdükçe ve yazılımınıza daha çok paket eklediğinizde, büyük ihtimalle bir gün gelecek ve kendinizi bu çaresizlik batağında bulacaksınız.\nBir çok bağımlılığı olan sistemlerde, yeni bir paket sürümü çıkarmak bir kabusa dönüşebilir. Bağımlılıklar çok sıkı belirlenmişse, sürüm kitlenmesi (bağımlı olunan tüm paketlerin yeni sürümünü yükseltmeden istenen paketin sürümünü yükseltememek) tehlikesiyle karşı karşıyasınız demektir. Eğer bağımlılıklar çok gevşek belirlenmişse, ister istemez sürüm çeşitliliği (gelecekteki sürümlerle aşırı uyumluluk varsaymak) tarafından ısırılacaksınızdır.\nSürüm kitlenmesi ve/veya sürüm çeşitliliği nedeniyle projenizi güvenli bir şekilde ilerletemediğinizde bağımlılık cehenneminin içindesiniz demektir.\nBu soruna bir çözüm olarak, sürüm numaralarının nasıl verildiği ve arttırıldığı konusunda bazı basit kurallar ve gereklilikler öneriyorum. Bu kurallar, genel kabul görmüş, hem kapalı hem de açık-kaynak yazılım uygulamalarına dayansa da, onlarla sınırlı değildir. Bu sistemin çalışması için, öncelikle erişime açık bir API (public API) tanımlamanız gerekiyor. Bu, belgeleme veya kod tarafından konulmuş bir kuraldan oluşabilir. Ne şekilde olursa olsun, önemli olan bu API’ın açık ve kesin olmasıdır. Erişime açık API’ınızı tanımladığınız anda, bundan sonra geçireceği değişimleri, sürüm numaranızı belirli arttırımlara tabi tutarak iletmelisiniz. Şu şekilde bir sürüm numarası ele alalım: X.Y.Z (Büyük.Küçük.Yama). API’ı etkilemeyen hata düzeltmeleri yama sürümünü arttırır, önceki sürümlerle uyumlu API eklemeleri/değişiklikleri küçük sürümü arttırır, ve önceki sürümler ile uyumsuz API değişikleri büyük sürümü arttırır.\nBu sistemi: “Anlamsal Sürümleme” diye nitelendiriyorum. Bu düzen sayesinde, sürüm numaraları ve sürüm numaralarının değişim şekilleri, kodda, bir sürümden diğerine neyin değiştiğini anlatır hale gelmektedir.\nAnlamsal Sürümleme Tanımı (SemVer)\nBu belge içindeki anahtar sözcükler ve/veya eklerinden oluşan “-MALI”, “-MELİ”, “-MAMALI”, “-MEMELİ”, “GEREKLİ”, “-ECEK”, “-ACAK”, “-MEYECEK”, “-MAYACAK”, “-EBİLİR”, ÖNERİLİR”, “OLABİLİR”, ve “KEYFE BAĞLI”, RFC 2119‘da belirtildiği şekilde anlaşılmalıdır.\nAnlamsal Sürümleme kullanan bir yazılım erişime açık bir API tanımlamalıdır. Bu API, kodun kendi içinde veya yalnızca zaten var olan bir belgelemenin içinde tanımlanabilir. Nasıl yapılırsa yapılsın, kesin ve eksiksiz olmalıdır.\nAnlamsal Sürümleme kullanan bir yazılım erişime açık bir API tanımlamalıdır. Bu API, kodun kendi içinde veya yalnızca zaten var olan bir belgelemenin içinde tanımlanabilir. Nasıl yapılırsa yapılsın, kesin ve eksiksiz olmalıdır.\nNormal bir sürüm numarası X.Y.Z biçimde OLMALIDIR; burada X, Y, ve Z negatif olmayan tam sayılardır, ve başlarında sıfır İÇERMEMELİDİR. X büyük sürümdür, Y küçük sürümdür, ve Z yama sürümüdür. Her öğe sayısal olarak ARTMALIDIR. Örnek: 1.9.0 -> 1.10.0 -> 1.11.0.\nNormal bir sürüm numarası X.Y.Z biçimde OLMALIDIR; burada X, Y, ve Z negatif olmayan tam sayılardır, ve başlarında sıfır İÇERMEMELİDİR. X büyük sürümdür, Y küçük sürümdür, ve Z yama sürümüdür. Her öğe sayısal olarak ARTMALIDIR. Örnek: 1.9.0 -> 1.10.0 -> 1.11.0.\nSürümlenmiş bir paket sunulduğunda, o sürümün içeriği DEĞİŞTİRİLMEMELİDİR. Yapılan her hangi bir değişim yeni bir sürüm olarak sunulmalıdır.\nSürümlenmiş bir paket sunulduğunda, o sürümün içeriği DEĞİŞTİRİLMEMELİDİR. Yapılan her hangi bir değişim yeni bir sürüm olarak sunulmalıdır.\nBüyük sürüm sıfırı başlangıçta yapılan yazılım geliştirme içindir. Her şey her an değişebilir. Erişime açık API dengeli (stable) diye değerlendirilmemelidir.\nBüyük sürüm sıfırı başlangıçta yapılan yazılım geliştirme içindir. Her şey her an değişebilir. Erişime açık API dengeli (stable) diye değerlendirilmemelidir.\n1.0.0 sürümü erişime açık API’ı tanımlar. Sürüm numarasının bu sürümden sonra nasıl arttırılacağı bu erişime açık API’a ve nasıl değiştiğine bağlıdır.\n1.0.0 sürümü erişime açık API’ı tanımlar. Sürüm numarasının bu sürümden sonra nasıl arttırılacağı bu erişime açık API’a ve nasıl değiştiğine bağlıdır.\nYama sürümü Z (x.y.Z | X > 0) sadece önceki sürümle uyumlu hata düzeltmeleri yapıldığında ARTTIRILMALIDIR. Hata düzeltmesi şöyle tanımlanır: Yanlış bir davranışı düzelten içsel bir değişiklik.\nYama sürümü Z (x.y.Z | X > 0) sadece önceki sürümle uyumlu hata düzeltmeleri yapıldığında ARTTIRILMALIDIR. Hata düzeltmesi şöyle tanımlanır: Yanlış bir davranışı düzelten içsel bir değişiklik.\nKüçük sürüm Y (x.Y.z | x > 0), erişime açık API’a yeni, önceki sürümle uyumlu bir işlevsellik eklendiğinde ARTTIRILMALIDIR. Erişime açık API’daki bir işlevsellik çürümüş (deprecated) diye işaretlendiğinde ARTTIRILMALIDIR. Özel koda ciddi oranda yeni işlevler veya geliştirmeler katıldığında ARTTIRILABİLİR. Yama düzeyindeki değişiklikler buna dahil EDİLEBİLİR. Yama sürümü, küçük sürüm arttırıldığında SIFIRLANMALIDIR.\nKüçük sürüm Y (x.Y.z | x > 0), erişime açık API’a yeni, önceki sürümle uyumlu bir işlevsellik eklendiğinde ARTTIRILMALIDIR. Erişime açık API’daki bir işlevsellik çürümüş (deprecated) diye işaretlendiğinde ARTTIRILMALIDIR. Özel koda ciddi oranda yeni işlevler veya geliştirmeler katıldığında ARTTIRILABİLİR. Yama düzeyindeki değişiklikler buna dahil EDİLEBİLİR. Yama sürümü, küçük sürüm arttırıldığında SIFIRLANMALIDIR.\nBüyük sürüm X (X.y.z | X > 0) önceki sürümle uyumsuz değişiklikler yapıldığında ARTTIRILMALIDIR. Yama ve küçük düzeydeki değişiklikler buna dahil edilebilir. Büyük sürüm arttırıldığında, yama ve küçük sürüm SIFIRLANMALIDIR.\nBüyük sürüm X (X.y.z | X > 0) önceki sürümle uyumsuz değişiklikler yapıldığında ARTTIRILMALIDIR. Yama ve küçük düzeydeki değişiklikler buna dahil edilebilir. Büyük sürüm arttırıldığında, yama ve küçük sürüm SIFIRLANMALIDIR.\nBir ön-sunum (pre-release) sürümü, yama sürümünden hemen sonraki kısımda, bir tire işaretiyle ve bir dizi nokta ayracıyla GÖSTERİLEBİLİR. Tanımlayıcılar yalnızca ASCII alfasayısal ve tire işaretlerinden [0-9A-Za-z-] OLUŞMALIDIR. Tanımlayıcılar boş OLMAMALIDIR. Sayısal tanımlayıcılar öncül sıfırlar İÇERMEMELİDİR. Ön-sunum sürümleri ilişkili normal sürümden daha düşük önceliğe sahiptir. İlişkili normal sürümün tersine, bir ön-sunum sürümü, sürümün dengesiz olduğunu ve beklenen uyumluluk gereksinimlerini karşılayamayacağını gösterir. Örnekler: 1.0.0-ilk, 1.0.0-ilk.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nBir ön-sunum (pre-release) sürümü, yama sürümünden hemen sonraki kısımda, bir tire işaretiyle ve bir dizi nokta ayracıyla GÖSTERİLEBİLİR. Tanımlayıcılar yalnızca ASCII alfasayısal ve tire işaretlerinden [0-9A-Za-z-] OLUŞMALIDIR. Tanımlayıcılar boş OLMAMALIDIR. Sayısal tanımlayıcılar öncül sıfırlar İÇERMEMELİDİR. Ön-sunum sürümleri ilişkili normal sürümden daha düşük önceliğe sahiptir. İlişkili normal sürümün tersine, bir ön-sunum sürümü, sürümün dengesiz olduğunu ve beklenen uyumluluk gereksinimlerini karşılayamayacağını gösterir. Örnekler: 1.0.0-ilk, 1.0.0-ilk.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nDerleme üst verisi, yama sürümünü veya ön-sunum sürümünü hemen takip ederek eklenen bir artı işaretiyle ve bir dizi nokta ayracıyla GÖSTERİLEBİLİR. Tanımlayıcılar yalnızca ASCII alfasayısal ve tire işaretlerinden [0-9A-Za-z-] OLUŞMALIDIR. Tanımlayıcılar boş OLMAMALIDIR. Derleme üstverisi sürüm önceliği belirlenirken dikkate ALINMAMALIDIR. Böylece, yalnızca derleme üstverisiyle farklılık gösteren iki sürüm de aynı önceliğe sahip olacaktır. Örnekler: 1.0.0-ilk+001, 1.0.0+20130313144700, 1.0.0-ikincil+deneme.sha.5114f85.\nDerleme üst verisi, yama sürümünü veya ön-sunum sürümünü hemen takip ederek eklenen bir artı işaretiyle ve bir dizi nokta ayracıyla GÖSTERİLEBİLİR. Tanımlayıcılar yalnızca ASCII alfasayısal ve tire işaretlerinden [0-9A-Za-z-] OLUŞMALIDIR. Tanımlayıcılar boş OLMAMALIDIR. Derleme üstverisi sürüm önceliği belirlenirken dikkate ALINMAMALIDIR. Böylece, yalnızca derleme üstverisiyle farklılık gösteren iki sürüm de aynı önceliğe sahip olacaktır. Örnekler: 1.0.0-ilk+001, 1.0.0+20130313144700, 1.0.0-ikincil+deneme.sha.5114f85.\nÖncelik, sürümlerin sıralandıklarında, birbirleriyle sıralarının nasıl karşılaştırılacaklarını belirtir. Öncelik sürüm numarası büyük, küçük, yama ve ön-sunum tanımlayıcılarıyla, burada yazıldığı sırada (Derleme üstverisi öncelik belirlenirken anlamsızdır) ayırarak HESAPLANMALIDIR. Öncelik, soldan sağa doğru tanımlayıcıların her birini şu şekilde karşılaştırırken belirlenir: Büyük, küçük, ve yama sürümleri daima sayısal olarak karşılaştırılır. Örnek: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Büyük, küçük, ve yama eşit olduğunda, bir ön-sunum sürümü, normal bir sürümden daha düşük önceliğe sahiptir. Örnek: 1.0.0-ilk < 1.0.0.  Aynı büyük, küçük, ve yama sürümüne sahip iki ön-sunum sürümünün önceliği, şu şekilde gösterildiği gibi, soldan sağa doğru her bir tanımlayıcıyı ayırıp karşılaştırarak BELİRLENMELİDİR: yalnızca rakamlardan oluşan tanımlayıcılar sayısal olarak karşılaştırılır ve harfli veya tire çizgili tanımlayıcılar ise ASCII sözcük sıralamalarına göre karşılaştırılırlar. Sayısal tanımlayıcılar, sayısal-olmayan tanımlayıcılardan daima daha düşük önceliğe sahiptirler.\nÖncelik, sürümlerin sıralandıklarında, birbirleriyle sıralarının nasıl karşılaştırılacaklarını belirtir. Öncelik sürüm numarası büyük, küçük, yama ve ön-sunum tanımlayıcılarıyla, burada yazıldığı sırada (Derleme üstverisi öncelik belirlenirken anlamsızdır) ayırarak HESAPLANMALIDIR. Öncelik, soldan sağa doğru tanımlayıcıların her birini şu şekilde karşılaştırırken belirlenir: Büyük, küçük, ve yama sürümleri daima sayısal olarak karşılaştırılır. Örnek: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Büyük, küçük, ve yama eşit olduğunda, bir ön-sunum sürümü, normal bir sürümden daha düşük önceliğe sahiptir. Örnek: 1.0.0-ilk < 1.0.0.  Aynı büyük, küçük, ve yama sürümüne sahip iki ön-sunum sürümünün önceliği, şu şekilde gösterildiği gibi, soldan sağa doğru her bir tanımlayıcıyı ayırıp karşılaştırarak BELİRLENMELİDİR: yalnızca rakamlardan oluşan tanımlayıcılar sayısal olarak karşılaştırılır ve harfli veya tire çizgili tanımlayıcılar ise ASCII sözcük sıralamalarına göre karşılaştırılırlar. Sayısal tanımlayıcılar, sayısal-olmayan tanımlayıcılardan daima daha düşük önceliğe sahiptirler.\nÖnce gelen tüm tanımlayıcıları eşitse, büyük bir dizi ön-sunumun alanlarının, daha küçük bir dizininkinden daha yüksek önceliği vardır. Örnek: 1.0.0-ilk < 1.0.0-ilk.1 < 1.0.0-ilk.ikincil < 1.0.0-ikincil < 1.0.0-ikincil.2 < 1.0.0-ikincil.11 < 1.0.0-sa.1 < 1.0.0.\nAnlamsal Sürümlendirme Neden Kullanılmalıdır?\nAslında, bu yeni veya çığır açan bir fikir değil. Büyük olasılıkla buna yakın bir şeyler zaten yapıyorsunuzdur. Sorun şudur: “yakın” olması yeterince iyi değildir. Bir şekilde belirlenmiş, resmi bir şartnameye uymadan, sürüm sayıları bağımlılık yönetimi için gerçek hayatta kullanışsızdır. Üstteki fikirleri isimlendirip, açık tanımlamalar yaparak, yazılımınızın kullanıcılarına niyetinizi iletmeniz kolaylaşır. Niyetler bir kere açık, esnek (fakat aşırı esnekleştirmeden) oldu mu, bağımlılık tanımlamaları yapılabilir hale gelir.\nBasit bir örnek Anlamsal Sürümlendirme’nin bağımlılık cehennemini nasıl mazinin bir parçası haline getirebildiğini gösterecek. “İtfaiye Aracı” isminde bir kütüphaneyi ele alalım. “Merdiven” adındaki Anlamsal Sürümlendirilmiş bir pakete ihtiyaç duymaktadır. İtfaiye Aracı yaratıldığında, Merdiven 3.1.0 sürümündedir. İtfaiye Aracı 3.1.0’da eklenmiş bazı işlevlere ihtiyaç duyduğundan, Merdiven bağımlılığının 3.1.0’a eşit ya da daha büyük fakat 4.0.0’dan küçük olduğunu güvenle belirtebilirsiniz. Böylelikle, Merdiven sürüm 3.1.1 ve 3.2.0 kullanılabilir olduğunda, paket yönetim sisteminize bunları sunabilirsiniz ve halihazırdaki bağımlılığı bulunduğu yazılımla uyumlu olacağını bilirsiniz.\nSorumluluk sahibi bir yazılım geliştirici olarak, tabii ki, her paket güncellemesinin reklam edildiği şekilde işlediğini kontrol etmek isteyeceksiniz. Gerçek dünya karışık bir yerdir; gözünüzü açık tutmak dışında yapabileceğiniz pek bir şey yoktur. Ancak, yapabileceğiniz şudur: Bağımlı olunan paketlerin yeni sürümlerini çıkarmaya gerek kalmadan paketleri sunmak ve yükseltmek için sizi zaman ve eziyetten kurtaracak mantıklı bir yol öneren Anlamsal Sürümlendirme’yi kullanmaktır.\nBütün bunlar hoşunuza gittiyse, Anlamsal Sürünlendirme’yi kullanmaya başlamak için yapmanız gereken tek şey kullanmaya başladığınızı ve kurallarını takip ettiğinizi duyurmaktır. BENİOKU (README) dosyanızdan bu web sitesine bağlantı vererek diğerlerinin de kuralları bilmesini ve bunlardan yarar sağlamalarını sağlayabilirsiniz.\nİlk geliştirme fazı olan 0.y.z’deki değişikliklerle nasıl başa çıkmalıyım?\nYapılabilecek en basit şey ilk geliştirme sunumunuzu 0.1.0’da başlatmaktır ve takip eden her sunum için küçük sürümü arttırmaktır.\n1.0.0’ı ne zaman sunacağımı nasıl anlarım?\nYazılımınız piyasa (production) ortamında kullanılmaya başlanmışsa, zaten muhtemelen 1.0.0’dır. Kullanıcıların güvenebildiği dengeli bir API’a sahipseniz, 1.0.0 olmalısınız. Önceki sürümle uyumlu olmayı dert ediyorsanız, büyük olasılıkla, çoktandır 1.0.0 olmalısınız.\nSeri geliştirmeden ve hızlı döngüden caydırmaz mı?\nBüyük sürümün sıfır olması tamamen seri geliştirmeyle alakalıdır. Eğer API’ı her gün değiştiriyorsanız ya hala 0.y.z sürümü ya da sıradaki büyük sürümün üzerinde çalıştığınız ayrı bir geliştirme dalı (branch) üzerinde olmalısınız.\nErişime açık API’ımın önceki bir sürümüyle uyumsuz en küçük değişiklikler bile büyük sürümü arttıracaksa, kendimi birden 42.0.0 sürümünde bulmayacak mıyım?\nBu sorumluluk sahibi yazılım geliştirmekle ve ileri görüşlülükle alakalı bir sorudur. Bir çok bağımlılığı olan bir yazılıma uyumsuz değişiklikler öylesine eklenmemelidir. Maruz kalınacak yükseltme maliyeti ciddi boyutlarda olabilir. Uyumsuz değişikliklerde büyük sürümü arttırmak demek yaptığınız değişikliklerin etkileri hakkında etraflıca düşüneceğinizi, ve maliyet/kazanç oranına göre karar vermenizi gerektirecektir.\nErişime açık API’ın tamamını belgelendirmek büyük iş!\nBaşkaları tarafından kullanılacağı düşünülen bir yazılımı düzgün bir şekilde belgelendirmek usta bir yazılım geliştirici olarak sizin sorumluluğunuzdur. Yazılım karmaşıklığını yönetmek bir projeyi verimli tutmanın çok önemli bir kısmıdır ve kimse yazılımınızı nasıl kullanacağını ya da hangi yöntemleri (methods) çağırmanın güvenli olacağını bilemiyorsa bunu yapmak zordur. Anlamlı Sürümlendirme, uzun dönemde, ve iyi tanımlanmış erişime açık bir API ile herkesin ve her şeyin sorunsuzca devam etmesini sağlar.\nÖnceki sürümle uyumsuz bir değişikliği yanlışlıkla küçük bir sürüm olarak sunarsam ne yaparım?\nAnlamsal Sürümlendirme şartnamesini bozduğunuzu farkettiğiniz anda, sorunu düzeltin ve sorunu düzelten ve önceki sürümle uyumluluğunu sağlayan yeni bir küçük sürüm sunun. Bu şartlar altında bile, sürümlendirilmiş sunumları kesinlikle değiştirmeyin. Mümkünse, sıkıntı çıkaran sürümü belgelendirin ve kullanıcılarınızı sorunla alakalı olarak bilgilendirin böylece sıkıntı çıkaran sürümden haberleri olmuş olur.\nErişime açık API’ı değiştirmeden yazılımın bağımlılıklarını güncellersem ne yapmalıyım?\nErişime açık API’ı etkilemediğinden uyumlu olarak değerlendirilebilecek bir durumdur. Paketinizle aynı bağımlılıklara sahip olan bir yazılımın kendi bağımlılık şartnameleri olmalıdır ve yazılımcısı tüm uyuşmazlıkları farkedecektir. Bir hatayı düzeltmek ya da yeni bir işlev kazandırmak için bağımlılıklarınızı güncelleyip güncellemediğiniz, yama ya da küçük seviyede bir değişiklik yapıp yapmadığınızı belirler. İkinci örnekteki durum için genelde ek kod beklerim; her iki durumun da küçük seviye bir artış olduğu bellidir.\nYa yanlışlıkla erişime açık API’ı sürüm numarasıyla uyumlu olmayacak bir şekilde değiştirmişsem (örn: yama sunumunda büyük bir kırıcı değişim oluşturan kod)?\nSağduyunuzu kullanın. Erişime açık API’ın davranışını beklenen, önceki haline geri getirmenizden etkilenecek büyük bir kitleniz varsa, düzeltmeniz bir yama sunumu gibi değerlendirilebilir olsa da, büyük bir sürüm sunumu yapmak en iyisi olabilir. Anlamsal Sürümlendirme’nin tüm amacının sürüm numaralarının nasıl değiştiğini ifade ettiğini unutmayın. Eğer bu değişiklikler kullanıcılarınız için önemliyse, sürüm numarasını kullanarak onları bilgilendirin.\nÇürüyen bir işlevi nasıl ele almalıyım?\nVarolan işlevlerin çürümesi yazılım geliştirmenin normal bir parçasıdır ve ileri adım atabilmek için genellikle gerekir. Erişime açık API’ınızın bir kısmını çürüttüğünüzde, iki şey yapmalısınız: (1) değişiklik konusunda kullanıcılarınızı bilgilendirmek için belgelendirmenizi güncelleyin, (2) çürümenin konduğu küçük bir sunum çıkarın. İşlevi büyük bir sunumla tamamen kaldırmadan önce, kullanıcılarınızın yeni API’a kolayca geçiş yapabilmeleri için çürümeyi içeren en az bir adet küçük bir sunum olmalıdır.\nSemver, sürüm karakterlerinde (string)  bir sınıra sahip midir?\nHayır, fakat sağduyunuzu kullanın. Örneğin, 255 karaktere sahip bir sürüm karakteri muhtemelen gereksizdir. Ayrıca, karakterlerin uzunluğu konusunda bazı sistemler kendi sınırlarını koyabilirler.\nAnlamsal Sürümlendirme şartnamesi, Gravatar’ların kaşifi ve GitHub’un kurucu ortaklarından olan Tom Preston-Werner tarafından yazılmıştır.\nYorum bırakmak isterseniz, lütfen GitHub’da bir konu açın.\nGitHub’da bir konu açın\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nСемантичне Версіонування 2.0.0

Коротко

У випадку, коли версія має вигляд МАЖОРНА.МІНОРНА.ПАТЧ, слід збільшувати:


  МАЖОРНУ версію, якщо зроблені зміни API, що несумісні з попередньою версією
  МІНОРНУ версію, якщо додана нова функціональність, що є сумісною з попередньою версією
  ПАТЧ версію, якщо були зроблені виправлення помилок, що не впливають на сумісність з попередньою версією


Додаткові позначки для передрелізних збірок дозволені, як розширення до формату МАЖОРНА.МІНОРНА.ПАТЧ.

Вступ

У світі управління програмним забезпеченням існує таке поняття, як  “dependency hell” (пекло залежностей). Із розростанням системи та інтеграцією в неї великої кількості пакетів дуже ймовірно опинитись у цій ситуації.

У системах з багатьма залежностями випуск нових версій пакетів може швидко перетворитись на жах. Якщо специфікації залежностей занадто жорсткі, існує небезпека блокування випуску нової версії (неможливість оновити пакет без випуску нових версій кожного залежного пакета). Якщо ж залежності специфіковані занадто вільно, ви неминуче будете покарані безладом у версіях (припускаючи сумісність з більшою кількістю майбутніх версій, ніж це доцільно). Пекло залежностей ― це ситуація, коли блокування версій та/або несумісність версій заважає легко і безпечно просувати ваш проект вперед.

В якості вирішення цієї проблеми пропонується простий набір правил і вимог, які визначають те, як призначаються та збільшуються номери версій. Ці правила ґрунтуються (але цим не обмежуються) на існуючих поширених практиках, що використовуються як в закритому, так і у відкритому програмному забезпеченні. Щоб ця система працювала, спочатку потрібно оголосити публічний API. Він може описуватись в  документації, або ж безпосередньо кодом. Незалежно від форми, важливо, щоб цей API був чітким і точним. Після того, як був визначений публічний API, ви сповіщаєте про його зміни шляхом збільшення певних номерів версії. Розглянемо формат версії X.Y.Z (МАЖОРНА.МІНОРНА.ПАТЧ). Виправлення помилок, які не впливають на API, збільшують ПАТЧ-версію. Розширення/зміни API, що сумісні з попередньою версією, збільшують МІНОРНУ версію. Ті ж зміни API, що несумісні із минулою версією, збільшують МАЖОРНУ версію.

Цю систему названо “Семантичне Версіонування”. Відповідно до неї, номери версій і спосіб їх зміни передають інформацію про базовий код і про те, що змінено від попередньої до нової версії.

Специфікація Семантичного Версіонування (SemVer)

Ключові слова “ПОВИНЕН” (MUST), “НЕ ПОВИНЕН” (MUST NOT), “ОБОВ’ЯЗКОВО” (REQUIRED), “МАЄ” (SHALL), “НЕ МАЄ” (SHALL NOT), “БАЖАНО” (SHOULD), “НЕ БАЖАНО” (SHOULD NOT), “РЕКОМЕНДОВАНО” (RECOMMENDED), “МОЖЕ” (MAY), та “НЕ ОБОВ’ЯЗКОВО” (OPTIONAL), що використані в цьому документі, повинні бути інтерпретовані за RFC 2119.


  
    Програмне забезпечення, що використовує Семантичне Версіонування, ПОВИННЕ оголосити публічний API. Цей API може бути оголошений безпосередньо в коді, або ж існувати лише у вигляді документації. Незалежно від типу оголошення, воно повинне бути точним і всебічним.
  
  
    Правильний номер версії ПОВИНЕН мати форму X.Y.Z, де X, Y і Z є невід’ємними цілими числами, і НЕ ПОВИННІ мати нулі на початку. X ― мажорна версія, Y ― мінорна версія, а Z ― патч версія. Кожен елемент повинен збільшуватися чисельно. Наприклад: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Після випуску пакета конкретної версії, він НЕ ПОВИНЕН змінюватись. Будь-які зміни ПОВИННІ бути випущені, як нова версія.
  
  
    Нульова мажорна версія (0.y.z) призначена для початкової розробки. Будь-що МОЖЕ змінюватись в будь-який час. Публічний API такої версії не слід вважати стабільним.
  
  
    Версія 1.0.0 визначає публічний API. Спосіб, яким збільшуються номери версій після цього випуску, залежить від цього публічного API і від того, як він змінюється.
  
  
    Патч версія Z (x.y.Z | x > 0) ПОВИННА бути збільшена тільки якщо вона містить лише зворотньосумісні виправлення помилок. Виправленою помилкою називається внутрішня зміна, яка виправляє неправильну поведінку.
  
  
    Мінорна версія Y (x.Y.z | x > 0) ПОВИННА бути збільшена, якщо до публічного API додана нова зворотньосумісна функціональність. Вона ПОВИННА бути збільшена, якщо будь-яка функціональність публічного API позначена, як застаріла (deprecated). Вона МОЖЕ бути збільшена, якщо в приватний код внесені істотні зміни функціональних можливостей або вдосконалення. Вона МОЖЕ включати зміни рівня патчів. Патч версія ПОВИННА бути скинута до 0 при збільшенні мінорної версії.
  
  
    Мажорна версія X (X.y.z | X > 0) ПОВИННА бути збільшена, якщо до публічного API внесені будь-які зміни, що не сумісні з попередньою версією. Вона може включати зміни рівня мінорної та патч версій. Номери патч версії та мінорної версії ПОВИННІ бути скинуті до 0 при збільшенні мажорної версії.
  
  
    Передрелізна версія МОЖЕ бути позначена шляхом додавання безпосередньо після патч версії дефісу і ряду ідентифікаторів, розділених крапками. Ідентифікатори ПОВИННІ містити лише алфавітно-цифрові символи ASCII та дефіс [0-9A-Za-z-]. Ідентифікатори НЕ ПОВИННІ бути порожніми. Числові ідентифікатори НЕ ПОВИННІ мати нулі на початку. Передрелізні версії мають менший пріорітет за відповідні нормальні версії. Передрелізна версія вказує, що версія нестабільна і може не відповідати вимогам сумісності, на які вказує номер пов’язаної із нею нормальної версії. Приклади: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Метадані збірки МОЖНА позначати додаванням знаку плюс і ряду ідентифікаторів, розділених крапками, відразу після номеру патч версії або передрелізної версії. Ідентифікатори ПОВИННІ містити лише алфавітно-цифрові символи ASCII та дефіс [0-9A-Za-z-]. Ідентифікатори НЕ ПОВИННІ бути порожніми. Метадані збірки ПОВИННІ ігноруватися при визначенні пріоритету версії. Таким чином, дві версії, які відрізняються тільки метаданими, мають однаковий пріоритет. Приклади: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    Пріоритет визначає, як версії порівнюються одна з одною при упорядкуванні. Пріоритет ПОВИНЕН визначатись шляхом поділу версії на мажорний, мінорний, патч та передрелізний ідентифікатори саме в такому порядку (метадані збірки не впливають на пріоритет). Пріоритет визначається першою відмінністю під час порівняння кожного з цих ідентифікаторів зліва направо наступним чином: мажорні, мінорні та патч версії завжди порівнюються чисельно. Приклад: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Коли мажорна, мінорна і патч версія збігаються, передрелізна версія має менший пріоритет за звичайну версію. Приклад: 1.0.0-alpha < 1.0.0. Пріоритет для двох передрелізних версій з однаковими мажорною, мінорною і патч версіями ПОВИНЕН визначатися шляхом порівняння кожного окремого ідентифікатора, що розділені крапками, зліва направо, поки не буде знайдена різниця, в такому порядку: ідентифікатори, що складаються тільки з цифр, порівнюються чисельно; ідентифікатори з літерами або дефісами порівнюються лексично в порядку сортування ASCII. Числові ідентифікатори завжди мають менший пріоритет за нечислові ідентифікатори. Більший набір передрелізних полів має вищий пріоритет, ніж менший набір, якщо всі попередні ідентифікатори збігаються. Приклад: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Нотація форм Бекуса–Наура для дійсних версій SemVer
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


Навіщо використовувати Семантичне Версіонування?

Це не нова або революційна ідея. Насправді, вже існує багато близького до того. Проблема в тому, що “близького до того” недостатньо. Без відповідності певній формальній специфікації, номери версій є майже непридатними для управління залежностями. Надавши назви та чіткі визначення вищенаведеним ідеям, стає легко повідомляти про свої наміри кінцевим користувачам програмного забезпечення. Після того, як ці наміри стануть зрозумілими, нарешті можуть бути зроблені гнучкі (але не занадто гнучкі) специфікації для ведення залежностей.

Простий приклад продемонструє, як Семантичне Версіонування може залишити “dependency hell” в минулому. Розглянемо бібліотеку під назвою “Firetruck”. Вона залежить від Семантично Версіонованого пакету під назвою “Ladder”. На момент створення Firetruck, Ladder мав версію 3.1.0. Оскільки Firetruck використовує деяку функціональність Ladder, яка вперше була введена у версії 3.1.0, можна сміливо вказати на залежність від версій пакету Ladder, які більші або дорівнюють 3.1.0, але менші за 4.0.0. Тепер, коли версії 3.1.1 та 3.2.0 пакету Ladder стають доступними, їх можна буде опублікувати за допомогою системи управління пакетами і бути певним, що вони будуть сумісні з існуючим залежним від нього програмним забезпеченням.

Відповідальний розробник, звичайно, бажає переконатися, що будь-які оновлення пакета функціонують згідно з документацією. Реальний світ ― це хаотичне місце і ми нічого не можемо зробити, окрім, як бути пильними. Що можна зробити, це використовувати Семантичне Версіонування для випуску та оновлення пакетів без необхідності оновлення залежностей, заощаджуючи час і нерви.

Якщо це звучить цікаво, то все що потрібно зробити ― це почати користуватися Семантичним Версіонуванням, заявити про це, і дотримуватись правил. Додайте посилання на цей веб-сайт у README до проекту, щоб інші мали змогу дізнатись правила та скористатися ними.

FAQ

Як працювати з релізами у початковій фазі розробки 0.y.z?

Найпростіше зробити початковий реліз на рівні 0.1.0, а потім збільшувати мінорну версію для кожного наступного випуску.

Як дізнатися, коли потрібно випустити 1.0.0?

Якщо програмне забезпечення вже знаходиться експлуатації, то вже має бути 1.0.0. Якщо існує стабільний API, від якого залежать користувачі, повинна бути версія 1.0.0. Якщо вже починаються турботи про зворотну сумісність, має бути 1.0.0.

Чи не перешкоджає це стрімкій розробці та швидким ітераціям?

Нульова мажорна версія ― це активна стадія розробки. Якщо API змінюється щодня, треба або залишатись у версії 0.y.z або на окремій гілці розробки, працюючи над наступною мажорною версією.

Якщо навіть найдрібніші зміни, що не сумісні з попередньою версією до публічного API, вимагають збільшення мажорної версії, чи не призведе це до версії 42.0.0 занадто швидко?

Це питання відповідального розвитку і передбачення. Не слід легковажно ставитись до публікації несумісних змін програмного забезпечення, яке має багато залежного від нього коду. Витрати на модернізацію можуть бути дуже значними. Реліз мажорної версії з несумісними змінами означає, що вплив змін детально обдуманий, а співвідношення витрати/користь ― оцінене.

Повне документування публічного API ― це забагато роботи!

Професійний розробник має нести відповідальність за належне документування програмного забезпечення, призначеного для використання іншими користувачами. Управління складністю проекту є надзвичайно важливим фактором його ефективності, і цього важко досяги, якщо ніхто не розуміє, як це програмне забезпечення використовувати, або які методи безпечні для виклику. У довгостроковій перспективі, Семантичне Версіонування та наполягання на чітко визначеному публічному API дозволить всім і всьому працювати безперешкодно.

Що робити, якщо у якості мінорної версії випадково була випущена зміна, що несумісна з попередньою версією?

Як тільки стало відомим, що порушена Специфікація Семантичного Версіонування, треба виправити проблему і випустити нову мінорну версію, яка виправляє проблему і відновлює зворотню сумісність. Та навіть за таких обставин неприпустимо вносити зміни до вже випущених версій коду. Якщо це доречно, є сенс задокументувати версію, що порушує правила, та поінформувати користувачів про проблему, щоб вони знали про версію, яка порушує правила.

Що робити при оновленні внутрішніх залежностей, якщо публічний API не змінений?

Такі зміни вважаються сумісними, оскільки не впливають на публічний API. Програмне забезпечення, яке явно залежить від тих самих залежностей, повинне мати власні специфікації залежностей, і автор помітить будь-які конфлікти. Визначення того, чи є така зміна модифікацією рівня патча або рівня мінорної версії, залежить від того, чи внутрішні залежності були оновлені з метою виправлення помилки або з метою введення нової функціональності. В останньому випадку зазвичай слід очікувати додавання деякої кількості коду, що, вочевидь, є зміною рівня мінорної версії.

Що робити, якщо випадково був змінений публічний API у спосіб, що не відповідає зміненій версії (тобто, код має несумісні зміни у патч-релізі)?

На ваш розсуд. Якщо у вас є величезна аудиторія, на яку буде сильно впливати зміна публічного API, то краще всього зробити реліз мажорної версії, навіть якщо фактичне виправлення всього лише рівня патч-версії. Пам’ятайте, що за Семантичним Версіонуванням зміна версії повинна давати розуміння значущості змін. Якщо ці зміни важливі для користувачів, використовуйте номер версії, щоб повідомити їх.

Як оголосити застарілою (deprecated) деяку функціональність?

Оголошення застарілими існуючих функціональних можливостей є звичайною частиною розробки програмного забезпечення і часто є необхідною умовою прогресу. Коли потрібно оголосити застарілим частину публічного API, слід виконати дві речі: (1) оновити документацію, щоб користувачі могли дізнатися про зміну, (2) випустити мінорний реліз, що містить застарілу функціональність. Перш ніж повністю видалити застарілу функціональність у новому мажорному релізі, має бути принаймні один мінорний реліз, який містить функції, що будуть видалені. Таким чином, користувачі зможуть плавно перейти до нового API.

Чи має semver обмеження на розмір рядка версії?

Ні, але будьте розсудливими. Номер версії з 255 символів ― це, можливо, забагато. До того ж, певні системи можуть накладати свої власні обмеження на розмір рядка.

Чи є “v1.2.3” семантичною версією?

Ні, “v1.2.3” не є семантичною версією. Однак префікс семантичної версії з “v” ― це поширений спосіб (англійською мовою) вказати, що це номер версії. Скорочення “version” як “v” часто зустрічається в системах контролю версій. Наприклад: git tag v1.2.3 -m "Release version 1.2.3", у цьому випадку “v1.2.3” є назвою тегу, а семантична версія ― “1.2.3”.

Чи існує запропонований регулярний вираз (RegEx) для перевірки рядка SemVer?

Є два. Один містить іменовані групи систем, які мають їх підтримку (PCRE [Perl Compatible Regular Expressions, напр. Perl, PHP або R], Python
або Go).

Див.: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Та інший, натомість, із пронумерованими групами захоплення ― capture groups (де cg1 = мажорна, cg2 = мінорна,
cg3 = патч, cg4 = передрелізна та cg5 = метадані збірки) які сумісні із ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
напр. Perl, PHP або R), Python або Go.

Див.: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Про проект

Автором Специфікації Семантичного Версіонування є Том Престон-Вернер, засновник Gravatars та співзасновник GitHub.

Якщо ви бажаєте залишити відгук, відкрийте issue на GitHub.

Ліцензія

Creative Commons ― CC BY 3.0\nСемантичне Версіонування 2.0.0\nУ випадку, коли версія має вигляд МАЖОРНА.МІНОРНА.ПАТЧ, слід збільшувати:\nМАЖОРНУ версію, якщо зроблені зміни API, що несумісні з попередньою версією\nМІНОРНУ версію, якщо додана нова функціональність, що є сумісною з попередньою версією\nПАТЧ версію, якщо були зроблені виправлення помилок, що не впливають на сумісність з попередньою версією\nДодаткові позначки для передрелізних збірок дозволені, як розширення до формату МАЖОРНА.МІНОРНА.ПАТЧ.\nУ світі управління програмним забезпеченням існує таке поняття, як  “dependency hell” (пекло залежностей). Із розростанням системи та інтеграцією в неї великої кількості пакетів дуже ймовірно опинитись у цій ситуації.\nУ системах з багатьма залежностями випуск нових версій пакетів може швидко перетворитись на жах. Якщо специфікації залежностей занадто жорсткі, існує небезпека блокування випуску нової версії (неможливість оновити пакет без випуску нових версій кожного залежного пакета). Якщо ж залежності специфіковані занадто вільно, ви неминуче будете покарані безладом у версіях (припускаючи сумісність з більшою кількістю майбутніх версій, ніж це доцільно). Пекло залежностей ― це ситуація, коли блокування версій та/або несумісність версій заважає легко і безпечно просувати ваш проект вперед.\nВ якості вирішення цієї проблеми пропонується простий набір правил і вимог, які визначають те, як призначаються та збільшуються номери версій. Ці правила ґрунтуються (але цим не обмежуються) на існуючих поширених практиках, що використовуються як в закритому, так і у відкритому програмному забезпеченні. Щоб ця система працювала, спочатку потрібно оголосити публічний API. Він може описуватись в  документації, або ж безпосередньо кодом. Незалежно від форми, важливо, щоб цей API був чітким і точним. Після того, як був визначений публічний API, ви сповіщаєте про його зміни шляхом збільшення певних номерів версії. Розглянемо формат версії X.Y.Z (МАЖОРНА.МІНОРНА.ПАТЧ). Виправлення помилок, які не впливають на API, збільшують ПАТЧ-версію. Розширення/зміни API, що сумісні з попередньою версією, збільшують МІНОРНУ версію. Ті ж зміни API, що несумісні із минулою версією, збільшують МАЖОРНУ версію.\nЦю систему названо “Семантичне Версіонування”. Відповідно до неї, номери версій і спосіб їх зміни передають інформацію про базовий код і про те, що змінено від попередньої до нової версії.\nСпецифікація Семантичного Версіонування (SemVer)\nКлючові слова “ПОВИНЕН” (MUST), “НЕ ПОВИНЕН” (MUST NOT), “ОБОВ’ЯЗКОВО” (REQUIRED), “МАЄ” (SHALL), “НЕ МАЄ” (SHALL NOT), “БАЖАНО” (SHOULD), “НЕ БАЖАНО” (SHOULD NOT), “РЕКОМЕНДОВАНО” (RECOMMENDED), “МОЖЕ” (MAY), та “НЕ ОБОВ’ЯЗКОВО” (OPTIONAL), що використані в цьому документі, повинні бути інтерпретовані за RFC 2119.\nПрограмне забезпечення, що використовує Семантичне Версіонування, ПОВИННЕ оголосити публічний API. Цей API може бути оголошений безпосередньо в коді, або ж існувати лише у вигляді документації. Незалежно від типу оголошення, воно повинне бути точним і всебічним.\nПрограмне забезпечення, що використовує Семантичне Версіонування, ПОВИННЕ оголосити публічний API. Цей API може бути оголошений безпосередньо в коді, або ж існувати лише у вигляді документації. Незалежно від типу оголошення, воно повинне бути точним і всебічним.\nПравильний номер версії ПОВИНЕН мати форму X.Y.Z, де X, Y і Z є невід’ємними цілими числами, і НЕ ПОВИННІ мати нулі на початку. X ― мажорна версія, Y ― мінорна версія, а Z ― патч версія. Кожен елемент повинен збільшуватися чисельно. Наприклад: 1.9.0 -> 1.10.0 -> 1.11.0.\nПравильний номер версії ПОВИНЕН мати форму X.Y.Z, де X, Y і Z є невід’ємними цілими числами, і НЕ ПОВИННІ мати нулі на початку. X ― мажорна версія, Y ― мінорна версія, а Z ― патч версія. Кожен елемент повинен збільшуватися чисельно. Наприклад: 1.9.0 -> 1.10.0 -> 1.11.0.\nПісля випуску пакета конкретної версії, він НЕ ПОВИНЕН змінюватись. Будь-які зміни ПОВИННІ бути випущені, як нова версія.\nПісля випуску пакета конкретної версії, він НЕ ПОВИНЕН змінюватись. Будь-які зміни ПОВИННІ бути випущені, як нова версія.\nНульова мажорна версія (0.y.z) призначена для початкової розробки. Будь-що МОЖЕ змінюватись в будь-який час. Публічний API такої версії не слід вважати стабільним.\nНульова мажорна версія (0.y.z) призначена для початкової розробки. Будь-що МОЖЕ змінюватись в будь-який час. Публічний API такої версії не слід вважати стабільним.\nВерсія 1.0.0 визначає публічний API. Спосіб, яким збільшуються номери версій після цього випуску, залежить від цього публічного API і від того, як він змінюється.\nВерсія 1.0.0 визначає публічний API. Спосіб, яким збільшуються номери версій після цього випуску, залежить від цього публічного API і від того, як він змінюється.\nПатч версія Z (x.y.Z | x > 0) ПОВИННА бути збільшена тільки якщо вона містить лише зворотньосумісні виправлення помилок. Виправленою помилкою називається внутрішня зміна, яка виправляє неправильну поведінку.\nПатч версія Z (x.y.Z | x > 0) ПОВИННА бути збільшена тільки якщо вона містить лише зворотньосумісні виправлення помилок. Виправленою помилкою називається внутрішня зміна, яка виправляє неправильну поведінку.\nМінорна версія Y (x.Y.z | x > 0) ПОВИННА бути збільшена, якщо до публічного API додана нова зворотньосумісна функціональність. Вона ПОВИННА бути збільшена, якщо будь-яка функціональність публічного API позначена, як застаріла (deprecated). Вона МОЖЕ бути збільшена, якщо в приватний код внесені істотні зміни функціональних можливостей або вдосконалення. Вона МОЖЕ включати зміни рівня патчів. Патч версія ПОВИННА бути скинута до 0 при збільшенні мінорної версії.\nМінорна версія Y (x.Y.z | x > 0) ПОВИННА бути збільшена, якщо до публічного API додана нова зворотньосумісна функціональність. Вона ПОВИННА бути збільшена, якщо будь-яка функціональність публічного API позначена, як застаріла (deprecated). Вона МОЖЕ бути збільшена, якщо в приватний код внесені істотні зміни функціональних можливостей або вдосконалення. Вона МОЖЕ включати зміни рівня патчів. Патч версія ПОВИННА бути скинута до 0 при збільшенні мінорної версії.\nМажорна версія X (X.y.z | X > 0) ПОВИННА бути збільшена, якщо до публічного API внесені будь-які зміни, що не сумісні з попередньою версією. Вона може включати зміни рівня мінорної та патч версій. Номери патч версії та мінорної версії ПОВИННІ бути скинуті до 0 при збільшенні мажорної версії.\nМажорна версія X (X.y.z | X > 0) ПОВИННА бути збільшена, якщо до публічного API внесені будь-які зміни, що не сумісні з попередньою версією. Вона може включати зміни рівня мінорної та патч версій. Номери патч версії та мінорної версії ПОВИННІ бути скинуті до 0 при збільшенні мажорної версії.\nПередрелізна версія МОЖЕ бути позначена шляхом додавання безпосередньо після патч версії дефісу і ряду ідентифікаторів, розділених крапками. Ідентифікатори ПОВИННІ містити лише алфавітно-цифрові символи ASCII та дефіс [0-9A-Za-z-]. Ідентифікатори НЕ ПОВИННІ бути порожніми. Числові ідентифікатори НЕ ПОВИННІ мати нулі на початку. Передрелізні версії мають менший пріорітет за відповідні нормальні версії. Передрелізна версія вказує, що версія нестабільна і може не відповідати вимогам сумісності, на які вказує номер пов’язаної із нею нормальної версії. Приклади: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nПередрелізна версія МОЖЕ бути позначена шляхом додавання безпосередньо після патч версії дефісу і ряду ідентифікаторів, розділених крапками. Ідентифікатори ПОВИННІ містити лише алфавітно-цифрові символи ASCII та дефіс [0-9A-Za-z-]. Ідентифікатори НЕ ПОВИННІ бути порожніми. Числові ідентифікатори НЕ ПОВИННІ мати нулі на початку. Передрелізні версії мають менший пріорітет за відповідні нормальні версії. Передрелізна версія вказує, що версія нестабільна і може не відповідати вимогам сумісності, на які вказує номер пов’язаної із нею нормальної версії. Приклади: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nМетадані збірки МОЖНА позначати додаванням знаку плюс і ряду ідентифікаторів, розділених крапками, відразу після номеру патч версії або передрелізної версії. Ідентифікатори ПОВИННІ містити лише алфавітно-цифрові символи ASCII та дефіс [0-9A-Za-z-]. Ідентифікатори НЕ ПОВИННІ бути порожніми. Метадані збірки ПОВИННІ ігноруватися при визначенні пріоритету версії. Таким чином, дві версії, які відрізняються тільки метаданими, мають однаковий пріоритет. Приклади: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nМетадані збірки МОЖНА позначати додаванням знаку плюс і ряду ідентифікаторів, розділених крапками, відразу після номеру патч версії або передрелізної версії. Ідентифікатори ПОВИННІ містити лише алфавітно-цифрові символи ASCII та дефіс [0-9A-Za-z-]. Ідентифікатори НЕ ПОВИННІ бути порожніми. Метадані збірки ПОВИННІ ігноруватися при визначенні пріоритету версії. Таким чином, дві версії, які відрізняються тільки метаданими, мають однаковий пріоритет. Приклади: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nПріоритет визначає, як версії порівнюються одна з одною при упорядкуванні. Пріоритет ПОВИНЕН визначатись шляхом поділу версії на мажорний, мінорний, патч та передрелізний ідентифікатори саме в такому порядку (метадані збірки не впливають на пріоритет). Пріоритет визначається першою відмінністю під час порівняння кожного з цих ідентифікаторів зліва направо наступним чином: мажорні, мінорні та патч версії завжди порівнюються чисельно. Приклад: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Коли мажорна, мінорна і патч версія збігаються, передрелізна версія має менший пріоритет за звичайну версію. Приклад: 1.0.0-alpha < 1.0.0. Пріоритет для двох передрелізних версій з однаковими мажорною, мінорною і патч версіями ПОВИНЕН визначатися шляхом порівняння кожного окремого ідентифікатора, що розділені крапками, зліва направо, поки не буде знайдена різниця, в такому порядку: ідентифікатори, що складаються тільки з цифр, порівнюються чисельно; ідентифікатори з літерами або дефісами порівнюються лексично в порядку сортування ASCII. Числові ідентифікатори завжди мають менший пріоритет за нечислові ідентифікатори. Більший набір передрелізних полів має вищий пріоритет, ніж менший набір, якщо всі попередні ідентифікатори збігаються. Приклад: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nПріоритет визначає, як версії порівнюються одна з одною при упорядкуванні. Пріоритет ПОВИНЕН визначатись шляхом поділу версії на мажорний, мінорний, патч та передрелізний ідентифікатори саме в такому порядку (метадані збірки не впливають на пріоритет). Пріоритет визначається першою відмінністю під час порівняння кожного з цих ідентифікаторів зліва направо наступним чином: мажорні, мінорні та патч версії завжди порівнюються чисельно. Приклад: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Коли мажорна, мінорна і патч версія збігаються, передрелізна версія має менший пріоритет за звичайну версію. Приклад: 1.0.0-alpha < 1.0.0. Пріоритет для двох передрелізних версій з однаковими мажорною, мінорною і патч версіями ПОВИНЕН визначатися шляхом порівняння кожного окремого ідентифікатора, що розділені крапками, зліва направо, поки не буде знайдена різниця, в такому порядку: ідентифікатори, що складаються тільки з цифр, порівнюються чисельно; ідентифікатори з літерами або дефісами порівнюються лексично в порядку сортування ASCII. Числові ідентифікатори завжди мають менший пріоритет за нечислові ідентифікатори. Більший набір передрелізних полів має вищий пріоритет, ніж менший набір, якщо всі попередні ідентифікатори збігаються. Приклад: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nНотація форм Бекуса–Наура для дійсних версій SemVer\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nНавіщо використовувати Семантичне Версіонування?\nЦе не нова або революційна ідея. Насправді, вже існує багато близького до того. Проблема в тому, що “близького до того” недостатньо. Без відповідності певній формальній специфікації, номери версій є майже непридатними для управління залежностями. Надавши назви та чіткі визначення вищенаведеним ідеям, стає легко повідомляти про свої наміри кінцевим користувачам програмного забезпечення. Після того, як ці наміри стануть зрозумілими, нарешті можуть бути зроблені гнучкі (але не занадто гнучкі) специфікації для ведення залежностей.\nПростий приклад продемонструє, як Семантичне Версіонування може залишити “dependency hell” в минулому. Розглянемо бібліотеку під назвою “Firetruck”. Вона залежить від Семантично Версіонованого пакету під назвою “Ladder”. На момент створення Firetruck, Ladder мав версію 3.1.0. Оскільки Firetruck використовує деяку функціональність Ladder, яка вперше була введена у версії 3.1.0, можна сміливо вказати на залежність від версій пакету Ladder, які більші або дорівнюють 3.1.0, але менші за 4.0.0. Тепер, коли версії 3.1.1 та 3.2.0 пакету Ladder стають доступними, їх можна буде опублікувати за допомогою системи управління пакетами і бути певним, що вони будуть сумісні з існуючим залежним від нього програмним забезпеченням.\nВідповідальний розробник, звичайно, бажає переконатися, що будь-які оновлення пакета функціонують згідно з документацією. Реальний світ ― це хаотичне місце і ми нічого не можемо зробити, окрім, як бути пильними. Що можна зробити, це використовувати Семантичне Версіонування для випуску та оновлення пакетів без необхідності оновлення залежностей, заощаджуючи час і нерви.\nЯкщо це звучить цікаво, то все що потрібно зробити ― це почати користуватися Семантичним Версіонуванням, заявити про це, і дотримуватись правил. Додайте посилання на цей веб-сайт у README до проекту, щоб інші мали змогу дізнатись правила та скористатися ними.\nЯк працювати з релізами у початковій фазі розробки 0.y.z?\nНайпростіше зробити початковий реліз на рівні 0.1.0, а потім збільшувати мінорну версію для кожного наступного випуску.\nЯк дізнатися, коли потрібно випустити 1.0.0?\nЯкщо програмне забезпечення вже знаходиться експлуатації, то вже має бути 1.0.0. Якщо існує стабільний API, від якого залежать користувачі, повинна бути версія 1.0.0. Якщо вже починаються турботи про зворотну сумісність, має бути 1.0.0.\nЧи не перешкоджає це стрімкій розробці та швидким ітераціям?\nНульова мажорна версія ― це активна стадія розробки. Якщо API змінюється щодня, треба або залишатись у версії 0.y.z або на окремій гілці розробки, працюючи над наступною мажорною версією.\nЯкщо навіть найдрібніші зміни, що не сумісні з попередньою версією до публічного API, вимагають збільшення мажорної версії, чи не призведе це до версії 42.0.0 занадто швидко?\nЦе питання відповідального розвитку і передбачення. Не слід легковажно ставитись до публікації несумісних змін програмного забезпечення, яке має багато залежного від нього коду. Витрати на модернізацію можуть бути дуже значними. Реліз мажорної версії з несумісними змінами означає, що вплив змін детально обдуманий, а співвідношення витрати/користь ― оцінене.\nПовне документування публічного API ― це забагато роботи!\nПрофесійний розробник має нести відповідальність за належне документування програмного забезпечення, призначеного для використання іншими користувачами. Управління складністю проекту є надзвичайно важливим фактором його ефективності, і цього важко досяги, якщо ніхто не розуміє, як це програмне забезпечення використовувати, або які методи безпечні для виклику. У довгостроковій перспективі, Семантичне Версіонування та наполягання на чітко визначеному публічному API дозволить всім і всьому працювати безперешкодно.\nЩо робити, якщо у якості мінорної версії випадково була випущена зміна, що несумісна з попередньою версією?\nЯк тільки стало відомим, що порушена Специфікація Семантичного Версіонування, треба виправити проблему і випустити нову мінорну версію, яка виправляє проблему і відновлює зворотню сумісність. Та навіть за таких обставин неприпустимо вносити зміни до вже випущених версій коду. Якщо це доречно, є сенс задокументувати версію, що порушує правила, та поінформувати користувачів про проблему, щоб вони знали про версію, яка порушує правила.\nЩо робити при оновленні внутрішніх залежностей, якщо публічний API не змінений?\nТакі зміни вважаються сумісними, оскільки не впливають на публічний API. Програмне забезпечення, яке явно залежить від тих самих залежностей, повинне мати власні специфікації залежностей, і автор помітить будь-які конфлікти. Визначення того, чи є така зміна модифікацією рівня патча або рівня мінорної версії, залежить від того, чи внутрішні залежності були оновлені з метою виправлення помилки або з метою введення нової функціональності. В останньому випадку зазвичай слід очікувати додавання деякої кількості коду, що, вочевидь, є зміною рівня мінорної версії.\nЩо робити, якщо випадково був змінений публічний API у спосіб, що не відповідає зміненій версії (тобто, код має несумісні зміни у патч-релізі)?\nНа ваш розсуд. Якщо у вас є величезна аудиторія, на яку буде сильно впливати зміна публічного API, то краще всього зробити реліз мажорної версії, навіть якщо фактичне виправлення всього лише рівня патч-версії. Пам’ятайте, що за Семантичним Версіонуванням зміна версії повинна давати розуміння значущості змін. Якщо ці зміни важливі для користувачів, використовуйте номер версії, щоб повідомити їх.\nЯк оголосити застарілою (deprecated) деяку функціональність?\nОголошення застарілими існуючих функціональних можливостей є звичайною частиною розробки програмного забезпечення і часто є необхідною умовою прогресу. Коли потрібно оголосити застарілим частину публічного API, слід виконати дві речі: (1) оновити документацію, щоб користувачі могли дізнатися про зміну, (2) випустити мінорний реліз, що містить застарілу функціональність. Перш ніж повністю видалити застарілу функціональність у новому мажорному релізі, має бути принаймні один мінорний реліз, який містить функції, що будуть видалені. Таким чином, користувачі зможуть плавно перейти до нового API.\nЧи має semver обмеження на розмір рядка версії?\nНі, але будьте розсудливими. Номер версії з 255 символів ― це, можливо, забагато. До того ж, певні системи можуть накладати свої власні обмеження на розмір рядка.\nЧи є “v1.2.3” семантичною версією?\nНі, “v1.2.3” не є семантичною версією. Однак префікс семантичної версії з “v” ― це поширений спосіб (англійською мовою) вказати, що це номер версії. Скорочення “version” як “v” часто зустрічається в системах контролю версій. Наприклад: git tag v1.2.3 -m "Release version 1.2.3", у цьому випадку “v1.2.3” є назвою тегу, а семантична версія ― “1.2.3”.\nЧи існує запропонований регулярний вираз (RegEx) для перевірки рядка SemVer?\nЄ два. Один містить іменовані групи систем, які мають їх підтримку (PCRE [Perl Compatible Regular Expressions, напр. Perl, PHP або R], Python
або Go).\nДив.: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nТа інший, натомість, із пронумерованими групами захоплення ― capture groups (де cg1 = мажорна, cg2 = мінорна,
cg3 = патч, cg4 = передрелізна та cg5 = метадані збірки) які сумісні із ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
напр. Perl, PHP або R), Python або Go.\nДив.: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nАвтором Специфікації Семантичного Версіонування є Том Престон-Вернер, засновник Gravatars та співзасновник GitHub.\nЯкщо ви бажаєте залишити відгук, відкрийте issue на GitHub.\nвідкрийте issue на GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSemantic Versioning 2.0.0

Tổng quan

Đưa ra một cấu trúc phiên bản MAJOR.MINOR.PATCH, gia tăng như sau:


  Số phiên bản MAJOR khi bạn có những thay đổi API lớn, không tương thích với phiên bản trước
  Số phiên bản MINOR khi bạn thêm chức năng tương thích ngược với phiên bản trước
  Số phiên bản PATCH khi bạn làm một bản vá lỗi tương thích ngược với phiên bản trước


Các nhãn (labels) bổ sung cho pre-release và các build metadata về quá trình dựng đươc coi là tiện ích mở rộng cho định dạng MAJOR.MINOR.PATCH.

Giới thiệu

Trong thế giới của quản lý phần mềm, ở đó tồn tại một nơi đáng sợ, được gọi là “địa ngục phụ thuộc”. Hệ thống của bạn ngày càng lớn hơn và bạn càng tích hợp nhiều gói vào trong phần mềm của mình hơn, đồng nghĩa với việc bạn càng lún sâu một cách tuyệt vọng vào địa ngục này.

Trong các hệ thống phụ thuộc nhiều vào các yếu tố khác (gói, hệ thống,…), phát hành một phiên bản mới có thể nhanh chóng trở thành một cơn ác mộng. Nếu các thông số kỹ thuật phụ thuộc quá chặt chẽ với nhau, bạn có nguy cơ bị khóa phiên bản (không có khả năng nâng cấp một gói mà không phải phát hành các phiên bản mới của mỗi gói phụ thuộc). Nếu các yếu tố phụ thuộc được chỉ định quá lỏng lẻo, chắc chắn bạn sẽ bị ảnh hưởng bởi tính hỗn tạp của phiên bản (giả định khả năng tương thích với nhiều phiên bản trong tương lai là hợp lý). Cả hai trường hợp này đều đưa bạn đến đích đến là địa ngục phụ thuộc, ngăn dự án của bạn tiếp tục phát triển.

Để giải quyết vấn đề này, chúng tôi đề xuất một bộ quy tắc và quy định để đánh phiên bản. Các quy tắc này không nhất thiết dựa trên các quy tắc đã phổ biến rộng rãi trong cả phần mềm nguồn đóng và nguồn mở. Để bộ quy tắc này hoạt động, đầu tiên bạn cần xác định một tập public API, bao gồm tài liệu mô tả hoặc chính mã nguồn của API. Điều quan trọng là API phải rõ ràng và chính xác. Một khi bạn đã xác định được tập public API, bạn thông báo các thay đổi của API bằng cách đánh các phiên bản tương ứng. Bạn hãy xem lại định dạng phiên bản ban đầu, X.Y.Z (Major.Minor.Patch). Đối với những bản vá lỗi không làm thay đổi API, chúng ta tăng phiên bản Patch (Vá lỗi); với các thay đổi liên quan API, có thể tương thích ngược với phiên bản trước, tăng phiên bản Minor (Phụ); còn lại, đối với các thay đổi API mà không thể tương thích ngược với phiên bản trước, tăng phiên bản Major (Chính).

Chúng tôi gọi hệ thống này là “Sematic Versioning”, hay “Phiên bản ngữ nghĩa”. Theo hệ thống này, số phiên bản và sự thay đổi của chúng truyền đạt lại sự thay đổi của mã nguồn giữa các phiên bản.

Thông số của Sematic Versioning (SemVer)

Các từ khóa “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, và “OPTIONAL” trong tài liệu này được mô tả trong RFC 2119.


  
    Phần mềm sử dụng Semantic Versioning PHẢI công bố một tập public API. API này cần công khai trong mã nguồn hoặc tài liệu mô tả. Tập API này NÊN hoàn chỉnh và chính xác.
  
  
    Một chữ số phiên bản bình thường PHẢI lấy từ mẫu X.Y.Z. X, Y và Z là một số nguyên không âm, và KHÔNG chứa số 0 ở đầu. X là phiên bản chính, Y là phiên bản Minor và Z là phiên bản Patch lỗi. Mỗi phần tử cần PHẢI là một số tăng dần. Cho ví dụ: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Một khi gói đã đánh phiên bản được phát hành, nội dung của phiên bản đó KHÔNG được sửa đổi. Mọi sửa đổi PHẢI được phát hành dưới dạng phiên bản mới.
  
  
    Phiên bản Major zero (0.y.z) dành cho giai đoạn phát triển sơ khai. Mọi thứ CÓ THỂ thay đổi bất cứ lúc nào. Public API KHÔNG NÊN được coi là ổn định.
  
  
    Phiên bản 1.0.0 được xác định public API. Cách tăng số phiên bản sau bản phát hành này phụ thuộc vào sự thay đổi của public API.
  
  
    Phiên bản Patch Z (x.y.Z) PHẢI được tăng dần nếu chỉ các bản vá tương thích ngược được tung ra.Một sửa lỗi được định nghĩa là một thay đổi nội bộ để sửa chửa một hành vi không chính xác.
  
  
    Phiên bản Minor Y (x.Y.z) PHẢI được tăng dần nếu có thêm thay đổi mới và tương thích ngược với phiên bản trước được đưa vào trong public API. Nó PHẢI được tăng dần nếu bất kỳ chức năng API công khai nào đã được đánh dấu là không còn dùng nữa. Nó CÓ THỂ tăng dần nếu chức năng mới hoặc cải tiến mới đáng kể được giới thiệu trong mã đóng. Nó CÓ THỂ bao gồm thay đổi cấp độ bản vá. Phiên bản vá PHẢI được đặt lại về bằng 0 khi tăng phiên bản Minor.
  
  
    
      
        
          Phiên bản Major X (X.y.z
          X > 0) PHẢI được tăng dần nếu bất kỳ một thay đổi không tương thích ngược đưa vào API công khai. Nó CÓ THỂ bao gồm phiên bản Minor và thay đổi cấp độ bản vá. Bản vá và phiên bản Minor PHẢI được đặt lại về số 0 khi phiên bản chính tăng lên.
        
      
    
  
  
    Phiên bản pre-release CÓ THỂ được mô tả bằng cách nối thêm một dấu gạch nối vào một loạt số nhận dạng được phân tách bằng dấu chấm ngay sau phiên bản Patch. Mã định danh PHẢI bao gồm chữ số trong bảng mã ASCII và dấu gạch nối [0-9A-Za-z]. Mã định danh KHÔNG được để trống. Số định danh KHÔNG được bao gồm các chữ số 0 đứng đầu. Các phiên bản pre-release có một độ ưu tiên thấp hơn so với các phiên bản bình thường có liên quan. Một phiên bản pre-release cho biết phiên bản này không ổn định và có thể không đáp ứng các yêu cầu tương thích như dự định giống như là các phiên bản bình thường của nó. Ví dụ: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Build metadata CÓ THỂ được biểu thị bằng cách thêm một dấu cộng và một loạt các tiền tố nhận dạng được phân tách bằng dấu chấm ngay sau phiên bản Patch hoặc phiên bản pre-release. Mỗi định danh PHẢI bao gồm chỉ các chữ số trong bảng mã ASCII và gạch nối [0-9A-Za-z]. Mỗi định danh KHÔNG được rỗng. Build metadata NÊN bỏ qua khi xác định mức độ ưu tiên của phiên bản. Do đó hai phiên bản chỉ khác nhau trong build metadata, có cùng mức độ ưu tiên. Ví dụ: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    Mức độ ưu tiên đề cập đến cách các phiên bản được so sánh với nhau.

    
      
        Mức độ ưu tiên PHẢI được tính bằng cách phiên bản thành các mã định dạng phiên bản Major, phiên bản Minor và phiên bản Patch, theo thứ tự đã nêu. (Build metadata không tính vào mức độ ưu tiên)
      
      
        Mức độ ưu tiên được xác định bởi sự khác biệt đầu tiên khi so sánh từng mã định danh từ trái qua phải: phiên bản Major -> phiên bản Minor -> phiên bản Patch.

        Ví dụ: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Trong trường hợp phiên bản Major, Minor và Patch đều bằng nhau, phiên bản pre-release có mức độ ưu tiên thấp hơn.

        Ví dụ: 1.0.0-alpha < 1.0.0.
      
      
        Mức độ ưu tiên của hai phiên bản pre-release có cùng phiên bản Major, Minor và Patch PHẢI được xác định bằng cách so sánh từng mã định danh phân tách bằng dấu chấm từ trái sang phải cho đến khi tìm thấy sự khác biệt.

        
          
            Các mã định danh chỉ bao gồm các chữ số, được so sánh số học.
          
          
            Các mã định danh bao gồm chữ cái hoặc dấu gạch ngang được so sánh theo thứ tự sắp xếp trong bảng ASCII.
          
          
            Định danh dạng số luôn có mức độ mưu tiên thấp hơn định danh dạng chữ hoặc ký tự đặc biệt.
          
          
            Một tập các phiên bản pre-release lớn hơn có mức độ ưu tiên cao hơn một tập khác nhỏ hơn, nếu tất cả các phiên bản trước đó bằng nhau.

            Ví dụ: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0
          
        
      
    
  


Ngữ pháp Backus-Naur cho các phiên bản SemVer hợp lệ

<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


Tại sao nên sử dụng Sematic Versioning?

Đây không phải là một ý tưởng mới hay mang tính cách mạng. Trong thực tế, bạn có thể làm một cái gì đó gần tương tự rồi. Vấn đề là “gần” cũng có nghĩa nó chưa đủ tốt. Nếu không có tuân thủ một số loại đặc tả chính thức, số phiên bản về cơ bản là vô dụng để việc quản lý phụ thuộc. Bằng cách đặt tên và định nghĩa rõ ràng cho các ý tưởng trên, việc truyền đạt ý định của bạn tới người dùng phần mềm trở nên dễ dàng hơn. Một khi những ý định này đã rõ ràng, các đặc tả phụ thuộc linh hoạt (nhưng không nên quá linh hoạt) có thể được thực hiện.

Một ví dụ đơn giản chứng minh làm thế nào Sematic Versioning có thể biến địa ngục phụ thuộc thành dĩ vãng. Hãy xem xét một thư viện có tên là “Firetruck”. Nó yêu cầu một gói có tên “Ladder”. Tại thời điểm Firetruck được tạo ra, Ladder đang ở phiên bản 3.1.0. Vì Firetruck sử dụng một số tính năng mới được giới thiệu lần đầu trong 3.1.0, bạn hoàn toàn có thể chỉ định một cách an toàn phụ thuộc lớn hơn hoặc bằng 3.1.0 và nhỏ hơn 4.0.0. Giờ đây, khi Ladder phiên bản 3.1.1 và 3.2.0 ra mắt, bạn có thể cập nhật lên các phiên bản này, và bạn biết rằng chúng sẽ tương thích với phần mềm phụ thuộc hiện có.

Tất nhiên, với tư cách là nhà phát triển có trách nhiệm, bạn sẽ muốn xác minh rằng bất kỳ nâng cấp gói đều hoạt động như mong đợi. Thế giới thực là một nơi lộn xộn; không có gì chúng ta không thể làm nhưng hãy cảnh giác. Những gì bạn có thể làm là hãy để Sematic Versioning cung cấp cho bạn cách phát hành và nâng cấp các gói hợp lý, mà không cần phải tung ra các phiên bản mới của các gói phụ thuộc, giúp bạn tiết kiệm thời gian và giảm thiểu rắc rối.

Nếu bạn thấy tất cả những điều này hấp dẫn, hãy bắt đầu sử dụng Sematic Versioning. Liên kết trang web này từ README của bạn để những người khác có thể biết các quy tắc và có thể hưởng lợi từ chúng.

Câu hỏi thường gặp

Tôi nên xử lý các bản sửa đổi trong giai đoạn phát triển ban đầu 0.y.z như thế nào?

Điều đơn giản nhất cần làm là bắt đầu phát hành phiên bản sơ khai của bạn ở 0.1.0 và sau đó tăng phiên bản Minor cho mỗi lần phát hành tiếp theo.

Làm cách nào để biết khi nào phát hành 1.0.0?

Nếu phần mềm của bạn đang được sử dụng thực tế, nó có lẽ đã là 1.0.0. Nếu bạn có một API ổn định mà người dùng phụ thuộc vào, bạn phải là 1.0.0. Nếu bạn lo lắng rất nhiều về khả năng tương thích ngược, bạn có lẽ đã là 1.0.0.

Điều này có cản trở sự phát triển nhanh và lặp đi lặp lại nhanh chóng không?

Phiên bản chính số không (Major version zero) hoàn toàn phù hợp cho giai đoạn phát triển nhanh. Nếu bạn thay đổi API mỗi ngày, bạn nên vẫn ở phiên bản 0.y.z hoặc sử dụng một nhánh phát triển riêng để làm việc trên phiên bản chính tiếp theo.

Nếu ngay cả những thay đổi nhỏ nhất không tương thích ngược với public API đều yêu cầu tăng phiên bản chính, thì chẳng phải tôi sẽ đạt đến phiên bản 42.0.0 rất nhanh sao?

Đây là một câu hỏi về sự phát triển có trách nhiệm và tầm nhìn. Không nên đưa những thay đổi không tương thích vào dự án có quá nhiều phụ thuộc. Những thay đổi không tương thích không nên được đưa vào một cách dễ dàng cho phần mềm có nhiều mã phụ thuộc. Chi phí phải chịu để nâng cấp là đáng kể. Khi bạn phải xử lý các phiên bản chính để phát hành các thay đổi không tương thích có nghĩa là bạn đã suy nghĩ thấu đáo về tác động của các thay đổi và đánh giá tỉ lệ/lợi ích liên quan.

Tài liệu cho toàn bộ API tốn quá nhiều thời gian, công sức!

Với tư cách là một nhà phát triển phần mềm chuyên nghiệp, đây là trách nhiệm của bạn. Quản lý sự phức tạp của phần mềm là một phần cực kỳ quan trọng để giữ cho dự án hoạt động hiệu quả và điều đó khó thực hiện nếu không ai biết cách sử dụng phần mềm của bạn. Về lâu dài, Sematic Versioning và xác định rõ ràng public API có thể giữ cho mọi thứ hoạt động trơn tru.

Tôi phải làm gì nếu vô tình phát hành một phiên bản Minor có thay đổi không tương thích ngược?

Ngay khi bạn nhận ra rằng bạn đã phá vỡ Sematic Versioning, hãy khắc phục sự cố và phát hành một phiên bản Minor mới để khắc phục sự cố và khôi phục tính tương thích ngược. Ngay cả trong trường hợp này, việc sửa đổi các bản phát hành đã đánh phiên bản không thể chấp nhận được. Nếu được, hãy ghi lại phiên bản vi phạm và thông báo người dùng của bạn về vấn đề này để họ biết về phiên bản lỗi.

Tôi nên làm gì nếu tôi cập nhật các gói phụ thuộc mà không thay đổi public API?

Điều đó sẽ được coi là tương thích vì nó không ảnh hưởng đến public API. Bất kỳ phần mềm nào cũng phụ thuộc các gói phụ thuộc, bản thân các gói này cũng có những gói phụ thuộc riêng. Việc xác định thời điểm để thay đổi một phiên bản Patch hay phiên bản Minor tùy thuộc vào thời điểm đó, bạn cập nhật các phụ thuộc để sửa lỗi hay cho một chức năng mới. Nếu bạn xác định tiếp tục phát triển thêm thay đổi đó, đó rõ ràng là thay đổi ở mức phiên bản Minor.

Điều gì sẽ xảy ra nếu tôi vô tình thay đổi public API không tuân theo các quy tắc của Sematic Versioning? (ví dụ, thay đổi không tương thích ngược nhưng lại nằm trong phiên bản Patch)

Hãy thử phán đoán dựa theo tình huống. Nếu sản phẩm của bạn có lượng lớn người dùng, việc bạn cố gắng chuyển về phiên bản cũ hơn sẽ làm ảnh hưởng đến tất cả. Lúc này giải pháp tốt nhất là phát hành một phiên bản chính, nhằm thay thế cho phiên bản không tuân thủ trước đó. Hãy nhớ rằng, Sematic Versioning hướng tới việc truyền đạt đến người dùng về thay đổi của sản phẩm thông qua thay đổi phiên bản.

Tôi nên xử lý các chức năng không dùng nữa như thế nào?

Việc loại bỏ chức năng hiện có là một phần bình thường của quá trình phát triển phần mềm. Khi bạn không còn dùng một phần của public API, bạn nên làm hai việc: (1) cập nhật tài liệu để thông báo cho người dùng về thay đổi, (2) phát hành một phiên bản Minor có chứa phần không dùng nữa. Trước khi bạn loại bỏ hoàn toàn chức năng trong một bản phát hành phiên bản chính, nên có ít nhất một bản phát hành phiên bản Minor chứa phần không dùng nữa, để người dùng có thể chuyển đổi sang API mới.

SemVer có giới hạn kích thước đối với chuỗi phiên bản không?

Không, nhưng xem xét kỹ. Ví dụ, một chuỗi phiên bản 255 ký tự rõ ràng là không cần thiết. Ngoài ra, các hệ thống cụ thể cũng có thể có giới hạn riêng cho kích thước chuỗi phiên bản.

“v1.2.3” có phải là Sematic Versioning không?

Không, “v1.2.3” không phải là Sematic Versioning. Tuy nhiên, tiền tố “v” khá phổ biến (trong tiếng Anh) để cho biết đó là một phiên bản. Trong quản lý phiên bản, “phiên bản” (“version”) thường viết tắt là “v”. Ví dụ: git tag v1.2.3 -m "Release version 1.2.3", trong đó “v1.2.3” là tên tag và Sematic Versioning là “1.2.3”.

Có thể dùng biểu thức chính quy (RegEx) nào để kiểm tra SemVer không?

Chúng ta có hai loại RegEx. Một loại bao gồm các nhóm được đặt tên cho những hệ thống hỗ trợ (PCRE [Perl Compatible Regular Expressions, ví dụ, Perl, PHP và R], Python và Go).

Xem thêm tại: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Loại còn lại gồm các nhóm được đánh số (cg1 = major (chính), cg2 = minor (phụ), cg3 = patch (vá), cg4 = prerelease (pre-release) và cg5 = buildmetadata (build metadata)), PCRE [Perl Compatible Regular Expressions, ví dụ, Perl, PHP và R], Python và Go.

Xem thêm tại: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Về chúng tôi

Đặc tả của Sematic Versioning được viết bởi Tom Preston-Werner, người sáng lập của Gravatars và đồng sáng lập GitHub.

Nếu bạn muốn để lại một phản hồi, vui lòng mở một vấn đề trên GitHub

Giấy phép

Creative Commons ― CC BY 3.0\nSemantic Versioning 2.0.0\nĐưa ra một cấu trúc phiên bản MAJOR.MINOR.PATCH, gia tăng như sau:\nSố phiên bản MAJOR khi bạn có những thay đổi API lớn, không tương thích với phiên bản trước\nSố phiên bản MINOR khi bạn thêm chức năng tương thích ngược với phiên bản trước\nSố phiên bản PATCH khi bạn làm một bản vá lỗi tương thích ngược với phiên bản trước\nCác nhãn (labels) bổ sung cho pre-release và các build metadata về quá trình dựng đươc coi là tiện ích mở rộng cho định dạng MAJOR.MINOR.PATCH.\nTrong thế giới của quản lý phần mềm, ở đó tồn tại một nơi đáng sợ, được gọi là “địa ngục phụ thuộc”. Hệ thống của bạn ngày càng lớn hơn và bạn càng tích hợp nhiều gói vào trong phần mềm của mình hơn, đồng nghĩa với việc bạn càng lún sâu một cách tuyệt vọng vào địa ngục này.\nTrong các hệ thống phụ thuộc nhiều vào các yếu tố khác (gói, hệ thống,…), phát hành một phiên bản mới có thể nhanh chóng trở thành một cơn ác mộng. Nếu các thông số kỹ thuật phụ thuộc quá chặt chẽ với nhau, bạn có nguy cơ bị khóa phiên bản (không có khả năng nâng cấp một gói mà không phải phát hành các phiên bản mới của mỗi gói phụ thuộc). Nếu các yếu tố phụ thuộc được chỉ định quá lỏng lẻo, chắc chắn bạn sẽ bị ảnh hưởng bởi tính hỗn tạp của phiên bản (giả định khả năng tương thích với nhiều phiên bản trong tương lai là hợp lý). Cả hai trường hợp này đều đưa bạn đến đích đến là địa ngục phụ thuộc, ngăn dự án của bạn tiếp tục phát triển.\nĐể giải quyết vấn đề này, chúng tôi đề xuất một bộ quy tắc và quy định để đánh phiên bản. Các quy tắc này không nhất thiết dựa trên các quy tắc đã phổ biến rộng rãi trong cả phần mềm nguồn đóng và nguồn mở. Để bộ quy tắc này hoạt động, đầu tiên bạn cần xác định một tập public API, bao gồm tài liệu mô tả hoặc chính mã nguồn của API. Điều quan trọng là API phải rõ ràng và chính xác. Một khi bạn đã xác định được tập public API, bạn thông báo các thay đổi của API bằng cách đánh các phiên bản tương ứng. Bạn hãy xem lại định dạng phiên bản ban đầu, X.Y.Z (Major.Minor.Patch). Đối với những bản vá lỗi không làm thay đổi API, chúng ta tăng phiên bản Patch (Vá lỗi); với các thay đổi liên quan API, có thể tương thích ngược với phiên bản trước, tăng phiên bản Minor (Phụ); còn lại, đối với các thay đổi API mà không thể tương thích ngược với phiên bản trước, tăng phiên bản Major (Chính).\nChúng tôi gọi hệ thống này là “Sematic Versioning”, hay “Phiên bản ngữ nghĩa”. Theo hệ thống này, số phiên bản và sự thay đổi của chúng truyền đạt lại sự thay đổi của mã nguồn giữa các phiên bản.\nThông số của Sematic Versioning (SemVer)\nCác từ khóa “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, và “OPTIONAL” trong tài liệu này được mô tả trong RFC 2119.\nPhần mềm sử dụng Semantic Versioning PHẢI công bố một tập public API. API này cần công khai trong mã nguồn hoặc tài liệu mô tả. Tập API này NÊN hoàn chỉnh và chính xác.\nPhần mềm sử dụng Semantic Versioning PHẢI công bố một tập public API. API này cần công khai trong mã nguồn hoặc tài liệu mô tả. Tập API này NÊN hoàn chỉnh và chính xác.\nMột chữ số phiên bản bình thường PHẢI lấy từ mẫu X.Y.Z. X, Y và Z là một số nguyên không âm, và KHÔNG chứa số 0 ở đầu. X là phiên bản chính, Y là phiên bản Minor và Z là phiên bản Patch lỗi. Mỗi phần tử cần PHẢI là một số tăng dần. Cho ví dụ: 1.9.0 -> 1.10.0 -> 1.11.0.\nMột chữ số phiên bản bình thường PHẢI lấy từ mẫu X.Y.Z. X, Y và Z là một số nguyên không âm, và KHÔNG chứa số 0 ở đầu. X là phiên bản chính, Y là phiên bản Minor và Z là phiên bản Patch lỗi. Mỗi phần tử cần PHẢI là một số tăng dần. Cho ví dụ: 1.9.0 -> 1.10.0 -> 1.11.0.\nMột khi gói đã đánh phiên bản được phát hành, nội dung của phiên bản đó KHÔNG được sửa đổi. Mọi sửa đổi PHẢI được phát hành dưới dạng phiên bản mới.\nMột khi gói đã đánh phiên bản được phát hành, nội dung của phiên bản đó KHÔNG được sửa đổi. Mọi sửa đổi PHẢI được phát hành dưới dạng phiên bản mới.\nPhiên bản Major zero (0.y.z) dành cho giai đoạn phát triển sơ khai. Mọi thứ CÓ THỂ thay đổi bất cứ lúc nào. Public API KHÔNG NÊN được coi là ổn định.\nPhiên bản Major zero (0.y.z) dành cho giai đoạn phát triển sơ khai. Mọi thứ CÓ THỂ thay đổi bất cứ lúc nào. Public API KHÔNG NÊN được coi là ổn định.\nPhiên bản 1.0.0 được xác định public API. Cách tăng số phiên bản sau bản phát hành này phụ thuộc vào sự thay đổi của public API.\nPhiên bản 1.0.0 được xác định public API. Cách tăng số phiên bản sau bản phát hành này phụ thuộc vào sự thay đổi của public API.\nPhiên bản Patch Z (x.y.Z) PHẢI được tăng dần nếu chỉ các bản vá tương thích ngược được tung ra.Một sửa lỗi được định nghĩa là một thay đổi nội bộ để sửa chửa một hành vi không chính xác.\nPhiên bản Patch Z (x.y.Z) PHẢI được tăng dần nếu chỉ các bản vá tương thích ngược được tung ra.Một sửa lỗi được định nghĩa là một thay đổi nội bộ để sửa chửa một hành vi không chính xác.\nPhiên bản Minor Y (x.Y.z) PHẢI được tăng dần nếu có thêm thay đổi mới và tương thích ngược với phiên bản trước được đưa vào trong public API. Nó PHẢI được tăng dần nếu bất kỳ chức năng API công khai nào đã được đánh dấu là không còn dùng nữa. Nó CÓ THỂ tăng dần nếu chức năng mới hoặc cải tiến mới đáng kể được giới thiệu trong mã đóng. Nó CÓ THỂ bao gồm thay đổi cấp độ bản vá. Phiên bản vá PHẢI được đặt lại về bằng 0 khi tăng phiên bản Minor.\nPhiên bản Minor Y (x.Y.z) PHẢI được tăng dần nếu có thêm thay đổi mới và tương thích ngược với phiên bản trước được đưa vào trong public API. Nó PHẢI được tăng dần nếu bất kỳ chức năng API công khai nào đã được đánh dấu là không còn dùng nữa. Nó CÓ THỂ tăng dần nếu chức năng mới hoặc cải tiến mới đáng kể được giới thiệu trong mã đóng. Nó CÓ THỂ bao gồm thay đổi cấp độ bản vá. Phiên bản vá PHẢI được đặt lại về bằng 0 khi tăng phiên bản Minor.\nPhiên bản Major X (X.y.z
          X > 0) PHẢI được tăng dần nếu bất kỳ một thay đổi không tương thích ngược đưa vào API công khai. Nó CÓ THỂ bao gồm phiên bản Minor và thay đổi cấp độ bản vá. Bản vá và phiên bản Minor PHẢI được đặt lại về số 0 khi phiên bản chính tăng lên.\nPhiên bản Major X (X.y.z\nX > 0) PHẢI được tăng dần nếu bất kỳ một thay đổi không tương thích ngược đưa vào API công khai. Nó CÓ THỂ bao gồm phiên bản Minor và thay đổi cấp độ bản vá. Bản vá và phiên bản Minor PHẢI được đặt lại về số 0 khi phiên bản chính tăng lên.\nPhiên bản pre-release CÓ THỂ được mô tả bằng cách nối thêm một dấu gạch nối vào một loạt số nhận dạng được phân tách bằng dấu chấm ngay sau phiên bản Patch. Mã định danh PHẢI bao gồm chữ số trong bảng mã ASCII và dấu gạch nối [0-9A-Za-z]. Mã định danh KHÔNG được để trống. Số định danh KHÔNG được bao gồm các chữ số 0 đứng đầu. Các phiên bản pre-release có một độ ưu tiên thấp hơn so với các phiên bản bình thường có liên quan. Một phiên bản pre-release cho biết phiên bản này không ổn định và có thể không đáp ứng các yêu cầu tương thích như dự định giống như là các phiên bản bình thường của nó. Ví dụ: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nPhiên bản pre-release CÓ THỂ được mô tả bằng cách nối thêm một dấu gạch nối vào một loạt số nhận dạng được phân tách bằng dấu chấm ngay sau phiên bản Patch. Mã định danh PHẢI bao gồm chữ số trong bảng mã ASCII và dấu gạch nối [0-9A-Za-z]. Mã định danh KHÔNG được để trống. Số định danh KHÔNG được bao gồm các chữ số 0 đứng đầu. Các phiên bản pre-release có một độ ưu tiên thấp hơn so với các phiên bản bình thường có liên quan. Một phiên bản pre-release cho biết phiên bản này không ổn định và có thể không đáp ứng các yêu cầu tương thích như dự định giống như là các phiên bản bình thường của nó. Ví dụ: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nBuild metadata CÓ THỂ được biểu thị bằng cách thêm một dấu cộng và một loạt các tiền tố nhận dạng được phân tách bằng dấu chấm ngay sau phiên bản Patch hoặc phiên bản pre-release. Mỗi định danh PHẢI bao gồm chỉ các chữ số trong bảng mã ASCII và gạch nối [0-9A-Za-z]. Mỗi định danh KHÔNG được rỗng. Build metadata NÊN bỏ qua khi xác định mức độ ưu tiên của phiên bản. Do đó hai phiên bản chỉ khác nhau trong build metadata, có cùng mức độ ưu tiên. Ví dụ: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nBuild metadata CÓ THỂ được biểu thị bằng cách thêm một dấu cộng và một loạt các tiền tố nhận dạng được phân tách bằng dấu chấm ngay sau phiên bản Patch hoặc phiên bản pre-release. Mỗi định danh PHẢI bao gồm chỉ các chữ số trong bảng mã ASCII và gạch nối [0-9A-Za-z]. Mỗi định danh KHÔNG được rỗng. Build metadata NÊN bỏ qua khi xác định mức độ ưu tiên của phiên bản. Do đó hai phiên bản chỉ khác nhau trong build metadata, có cùng mức độ ưu tiên. Ví dụ: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nMức độ ưu tiên đề cập đến cách các phiên bản được so sánh với nhau.

    
      
        Mức độ ưu tiên PHẢI được tính bằng cách phiên bản thành các mã định dạng phiên bản Major, phiên bản Minor và phiên bản Patch, theo thứ tự đã nêu. (Build metadata không tính vào mức độ ưu tiên)
      
      
        Mức độ ưu tiên được xác định bởi sự khác biệt đầu tiên khi so sánh từng mã định danh từ trái qua phải: phiên bản Major -> phiên bản Minor -> phiên bản Patch.

        Ví dụ: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Trong trường hợp phiên bản Major, Minor và Patch đều bằng nhau, phiên bản pre-release có mức độ ưu tiên thấp hơn.

        Ví dụ: 1.0.0-alpha < 1.0.0.
      
      
        Mức độ ưu tiên của hai phiên bản pre-release có cùng phiên bản Major, Minor và Patch PHẢI được xác định bằng cách so sánh từng mã định danh phân tách bằng dấu chấm từ trái sang phải cho đến khi tìm thấy sự khác biệt.

        
          
            Các mã định danh chỉ bao gồm các chữ số, được so sánh số học.
          
          
            Các mã định danh bao gồm chữ cái hoặc dấu gạch ngang được so sánh theo thứ tự sắp xếp trong bảng ASCII.
          
          
            Định danh dạng số luôn có mức độ mưu tiên thấp hơn định danh dạng chữ hoặc ký tự đặc biệt.
          
          
            Một tập các phiên bản pre-release lớn hơn có mức độ ưu tiên cao hơn một tập khác nhỏ hơn, nếu tất cả các phiên bản trước đó bằng nhau.

            Ví dụ: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0\nMức độ ưu tiên đề cập đến cách các phiên bản được so sánh với nhau.\nMức độ ưu tiên PHẢI được tính bằng cách phiên bản thành các mã định dạng phiên bản Major, phiên bản Minor và phiên bản Patch, theo thứ tự đã nêu. (Build metadata không tính vào mức độ ưu tiên)\nMức độ ưu tiên PHẢI được tính bằng cách phiên bản thành các mã định dạng phiên bản Major, phiên bản Minor và phiên bản Patch, theo thứ tự đã nêu. (Build metadata không tính vào mức độ ưu tiên)\nMức độ ưu tiên được xác định bởi sự khác biệt đầu tiên khi so sánh từng mã định danh từ trái qua phải: phiên bản Major -> phiên bản Minor -> phiên bản Patch.

        Ví dụ: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nMức độ ưu tiên được xác định bởi sự khác biệt đầu tiên khi so sánh từng mã định danh từ trái qua phải: phiên bản Major -> phiên bản Minor -> phiên bản Patch.\nVí dụ: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nTrong trường hợp phiên bản Major, Minor và Patch đều bằng nhau, phiên bản pre-release có mức độ ưu tiên thấp hơn.

        Ví dụ: 1.0.0-alpha < 1.0.0.\nTrong trường hợp phiên bản Major, Minor và Patch đều bằng nhau, phiên bản pre-release có mức độ ưu tiên thấp hơn.\nVí dụ: 1.0.0-alpha < 1.0.0.\nMức độ ưu tiên của hai phiên bản pre-release có cùng phiên bản Major, Minor và Patch PHẢI được xác định bằng cách so sánh từng mã định danh phân tách bằng dấu chấm từ trái sang phải cho đến khi tìm thấy sự khác biệt.

        
          
            Các mã định danh chỉ bao gồm các chữ số, được so sánh số học.
          
          
            Các mã định danh bao gồm chữ cái hoặc dấu gạch ngang được so sánh theo thứ tự sắp xếp trong bảng ASCII.
          
          
            Định danh dạng số luôn có mức độ mưu tiên thấp hơn định danh dạng chữ hoặc ký tự đặc biệt.
          
          
            Một tập các phiên bản pre-release lớn hơn có mức độ ưu tiên cao hơn một tập khác nhỏ hơn, nếu tất cả các phiên bản trước đó bằng nhau.

            Ví dụ: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0\nMức độ ưu tiên của hai phiên bản pre-release có cùng phiên bản Major, Minor và Patch PHẢI được xác định bằng cách so sánh từng mã định danh phân tách bằng dấu chấm từ trái sang phải cho đến khi tìm thấy sự khác biệt.\nCác mã định danh chỉ bao gồm các chữ số, được so sánh số học.\nCác mã định danh chỉ bao gồm các chữ số, được so sánh số học.\nCác mã định danh bao gồm chữ cái hoặc dấu gạch ngang được so sánh theo thứ tự sắp xếp trong bảng ASCII.\nCác mã định danh bao gồm chữ cái hoặc dấu gạch ngang được so sánh theo thứ tự sắp xếp trong bảng ASCII.\nĐịnh danh dạng số luôn có mức độ mưu tiên thấp hơn định danh dạng chữ hoặc ký tự đặc biệt.\nĐịnh danh dạng số luôn có mức độ mưu tiên thấp hơn định danh dạng chữ hoặc ký tự đặc biệt.\nMột tập các phiên bản pre-release lớn hơn có mức độ ưu tiên cao hơn một tập khác nhỏ hơn, nếu tất cả các phiên bản trước đó bằng nhau.

            Ví dụ: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0\nMột tập các phiên bản pre-release lớn hơn có mức độ ưu tiên cao hơn một tập khác nhỏ hơn, nếu tất cả các phiên bản trước đó bằng nhau.\nVí dụ: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0\nNgữ pháp Backus-Naur cho các phiên bản SemVer hợp lệ\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nTại sao nên sử dụng Sematic Versioning?\nĐây không phải là một ý tưởng mới hay mang tính cách mạng. Trong thực tế, bạn có thể làm một cái gì đó gần tương tự rồi. Vấn đề là “gần” cũng có nghĩa nó chưa đủ tốt. Nếu không có tuân thủ một số loại đặc tả chính thức, số phiên bản về cơ bản là vô dụng để việc quản lý phụ thuộc. Bằng cách đặt tên và định nghĩa rõ ràng cho các ý tưởng trên, việc truyền đạt ý định của bạn tới người dùng phần mềm trở nên dễ dàng hơn. Một khi những ý định này đã rõ ràng, các đặc tả phụ thuộc linh hoạt (nhưng không nên quá linh hoạt) có thể được thực hiện.\nMột ví dụ đơn giản chứng minh làm thế nào Sematic Versioning có thể biến địa ngục phụ thuộc thành dĩ vãng. Hãy xem xét một thư viện có tên là “Firetruck”. Nó yêu cầu một gói có tên “Ladder”. Tại thời điểm Firetruck được tạo ra, Ladder đang ở phiên bản 3.1.0. Vì Firetruck sử dụng một số tính năng mới được giới thiệu lần đầu trong 3.1.0, bạn hoàn toàn có thể chỉ định một cách an toàn phụ thuộc lớn hơn hoặc bằng 3.1.0 và nhỏ hơn 4.0.0. Giờ đây, khi Ladder phiên bản 3.1.1 và 3.2.0 ra mắt, bạn có thể cập nhật lên các phiên bản này, và bạn biết rằng chúng sẽ tương thích với phần mềm phụ thuộc hiện có.\nTất nhiên, với tư cách là nhà phát triển có trách nhiệm, bạn sẽ muốn xác minh rằng bất kỳ nâng cấp gói đều hoạt động như mong đợi. Thế giới thực là một nơi lộn xộn; không có gì chúng ta không thể làm nhưng hãy cảnh giác. Những gì bạn có thể làm là hãy để Sematic Versioning cung cấp cho bạn cách phát hành và nâng cấp các gói hợp lý, mà không cần phải tung ra các phiên bản mới của các gói phụ thuộc, giúp bạn tiết kiệm thời gian và giảm thiểu rắc rối.\nNếu bạn thấy tất cả những điều này hấp dẫn, hãy bắt đầu sử dụng Sematic Versioning. Liên kết trang web này từ README của bạn để những người khác có thể biết các quy tắc và có thể hưởng lợi từ chúng.\nTôi nên xử lý các bản sửa đổi trong giai đoạn phát triển ban đầu 0.y.z như thế nào?\nĐiều đơn giản nhất cần làm là bắt đầu phát hành phiên bản sơ khai của bạn ở 0.1.0 và sau đó tăng phiên bản Minor cho mỗi lần phát hành tiếp theo.\nLàm cách nào để biết khi nào phát hành 1.0.0?\nNếu phần mềm của bạn đang được sử dụng thực tế, nó có lẽ đã là 1.0.0. Nếu bạn có một API ổn định mà người dùng phụ thuộc vào, bạn phải là 1.0.0. Nếu bạn lo lắng rất nhiều về khả năng tương thích ngược, bạn có lẽ đã là 1.0.0.\nĐiều này có cản trở sự phát triển nhanh và lặp đi lặp lại nhanh chóng không?\nPhiên bản chính số không (Major version zero) hoàn toàn phù hợp cho giai đoạn phát triển nhanh. Nếu bạn thay đổi API mỗi ngày, bạn nên vẫn ở phiên bản 0.y.z hoặc sử dụng một nhánh phát triển riêng để làm việc trên phiên bản chính tiếp theo.\nNếu ngay cả những thay đổi nhỏ nhất không tương thích ngược với public API đều yêu cầu tăng phiên bản chính, thì chẳng phải tôi sẽ đạt đến phiên bản 42.0.0 rất nhanh sao?\nĐây là một câu hỏi về sự phát triển có trách nhiệm và tầm nhìn. Không nên đưa những thay đổi không tương thích vào dự án có quá nhiều phụ thuộc. Những thay đổi không tương thích không nên được đưa vào một cách dễ dàng cho phần mềm có nhiều mã phụ thuộc. Chi phí phải chịu để nâng cấp là đáng kể. Khi bạn phải xử lý các phiên bản chính để phát hành các thay đổi không tương thích có nghĩa là bạn đã suy nghĩ thấu đáo về tác động của các thay đổi và đánh giá tỉ lệ/lợi ích liên quan.\nTài liệu cho toàn bộ API tốn quá nhiều thời gian, công sức!\nVới tư cách là một nhà phát triển phần mềm chuyên nghiệp, đây là trách nhiệm của bạn. Quản lý sự phức tạp của phần mềm là một phần cực kỳ quan trọng để giữ cho dự án hoạt động hiệu quả và điều đó khó thực hiện nếu không ai biết cách sử dụng phần mềm của bạn. Về lâu dài, Sematic Versioning và xác định rõ ràng public API có thể giữ cho mọi thứ hoạt động trơn tru.\nTôi phải làm gì nếu vô tình phát hành một phiên bản Minor có thay đổi không tương thích ngược?\nNgay khi bạn nhận ra rằng bạn đã phá vỡ Sematic Versioning, hãy khắc phục sự cố và phát hành một phiên bản Minor mới để khắc phục sự cố và khôi phục tính tương thích ngược. Ngay cả trong trường hợp này, việc sửa đổi các bản phát hành đã đánh phiên bản không thể chấp nhận được. Nếu được, hãy ghi lại phiên bản vi phạm và thông báo người dùng của bạn về vấn đề này để họ biết về phiên bản lỗi.\nTôi nên làm gì nếu tôi cập nhật các gói phụ thuộc mà không thay đổi public API?\nĐiều đó sẽ được coi là tương thích vì nó không ảnh hưởng đến public API. Bất kỳ phần mềm nào cũng phụ thuộc các gói phụ thuộc, bản thân các gói này cũng có những gói phụ thuộc riêng. Việc xác định thời điểm để thay đổi một phiên bản Patch hay phiên bản Minor tùy thuộc vào thời điểm đó, bạn cập nhật các phụ thuộc để sửa lỗi hay cho một chức năng mới. Nếu bạn xác định tiếp tục phát triển thêm thay đổi đó, đó rõ ràng là thay đổi ở mức phiên bản Minor.\nĐiều gì sẽ xảy ra nếu tôi vô tình thay đổi public API không tuân theo các quy tắc của Sematic Versioning? (ví dụ, thay đổi không tương thích ngược nhưng lại nằm trong phiên bản Patch)\nHãy thử phán đoán dựa theo tình huống. Nếu sản phẩm của bạn có lượng lớn người dùng, việc bạn cố gắng chuyển về phiên bản cũ hơn sẽ làm ảnh hưởng đến tất cả. Lúc này giải pháp tốt nhất là phát hành một phiên bản chính, nhằm thay thế cho phiên bản không tuân thủ trước đó. Hãy nhớ rằng, Sematic Versioning hướng tới việc truyền đạt đến người dùng về thay đổi của sản phẩm thông qua thay đổi phiên bản.\nTôi nên xử lý các chức năng không dùng nữa như thế nào?\nViệc loại bỏ chức năng hiện có là một phần bình thường của quá trình phát triển phần mềm. Khi bạn không còn dùng một phần của public API, bạn nên làm hai việc: (1) cập nhật tài liệu để thông báo cho người dùng về thay đổi, (2) phát hành một phiên bản Minor có chứa phần không dùng nữa. Trước khi bạn loại bỏ hoàn toàn chức năng trong một bản phát hành phiên bản chính, nên có ít nhất một bản phát hành phiên bản Minor chứa phần không dùng nữa, để người dùng có thể chuyển đổi sang API mới.\nSemVer có giới hạn kích thước đối với chuỗi phiên bản không?\nKhông, nhưng xem xét kỹ. Ví dụ, một chuỗi phiên bản 255 ký tự rõ ràng là không cần thiết. Ngoài ra, các hệ thống cụ thể cũng có thể có giới hạn riêng cho kích thước chuỗi phiên bản.\n“v1.2.3” có phải là Sematic Versioning không?\nKhông, “v1.2.3” không phải là Sematic Versioning. Tuy nhiên, tiền tố “v” khá phổ biến (trong tiếng Anh) để cho biết đó là một phiên bản. Trong quản lý phiên bản, “phiên bản” (“version”) thường viết tắt là “v”. Ví dụ: git tag v1.2.3 -m "Release version 1.2.3", trong đó “v1.2.3” là tên tag và Sematic Versioning là “1.2.3”.\nCó thể dùng biểu thức chính quy (RegEx) nào để kiểm tra SemVer không?\nChúng ta có hai loại RegEx. Một loại bao gồm các nhóm được đặt tên cho những hệ thống hỗ trợ (PCRE [Perl Compatible Regular Expressions, ví dụ, Perl, PHP và R], Python và Go).\nXem thêm tại: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nLoại còn lại gồm các nhóm được đánh số (cg1 = major (chính), cg2 = minor (phụ), cg3 = patch (vá), cg4 = prerelease (pre-release) và cg5 = buildmetadata (build metadata)), PCRE [Perl Compatible Regular Expressions, ví dụ, Perl, PHP và R], Python và Go.\nXem thêm tại: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nĐặc tả của Sematic Versioning được viết bởi Tom Preston-Werner, người sáng lập của Gravatars và đồng sáng lập GitHub.\nNếu bạn muốn để lại một phản hồi, vui lòng mở một vấn đề trên GitHub\nmở một vấn đề trên GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\n语义化版本 2.0.0

摘要

版本格式：主版本号.次版本号.修订号，版本号递增规则如下：


  主版本号：当你做了不兼容的 API 修改，
  次版本号：当你做了向下兼容的功能性新增，
  修订号：当你做了向下兼容的问题修正。


先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。

简介

在软件管理的领域里存在着被称作“依赖地狱”的死亡之谷，系统规模越大，加入的包越多，你就越有可能在未来的某一天发现自己已深陷绝望之中。

在依赖高的系统中发布新版本包可能很快会成为噩梦。如果依赖关系过高，可能面临版本控制被锁死的风险（必须对每一个依赖包改版才能完成某次升级）。而如果依赖关系过于松散，又将无法避免版本的混乱（假设兼容于未来的多个版本已超出了合理数量）。当你项目的进展因为版本依赖被锁死或版本混乱变得不够简便和可靠，就意味着你正处于依赖地狱之中。

作为这个问题的解决方案之一，我提议用一组简单的规则及条件来约束版本号的配置和增长。这些规则是根据（但不局限于）已经被各种封闭、开放源码软件所广泛使用的惯例所设计。为了让这套理论运作，你必须先有定义好的公共 API。这可能包括文档或代码的强制要求。无论如何，这套 API 的清楚明了是十分重要的。一旦你定义了公共 API，你就可以透过修改相应的版本号来向大家说明你的修改。考虑使用这样的版本号格式：X.Y.Z（主版本号.次版本号.修订号）修复问题但不影响 API 时，递增修订号；API 保持向下兼容的新增及修改时，递增次版本号；进行不向下兼容的修改时，递增主版本号。

我称这套系统为“语义化的版本控制”，在这套约定下，版本号及其更新方式包含了相邻版本间的底层代码和修改内容的信息。

语义化版本控制规范（SemVer）

以下关键词 MUST、MUST NOT、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD NOT、 RECOMMENDED、MAY、OPTIONAL 依照 RFC 2119 的叙述解读。


  
    使用语义化版本控制的软件必须（MUST）定义公共 API。该 API 可以在代码中被定义或出现于严谨的文档内。无论何种形式都应该力求精确且完整。
  
  
    标准的版本号必须（MUST）采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止（MUST NOT）在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须（MUST）以数值来递增。例如：1.9.1 -> 1.10.0 -> 1.11.0。
  
  
    标记版本号的软件发行后，禁止（MUST NOT）改变该版本软件的内容。任何修改都必须（MUST）以新版本发行。
  
  
    主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。
  
  
    1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。
  
  
    修订号 Z（x.y.Z | x > 0）必须（MUST）在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。
  
  
    次版本号 Y（x.Y.z | x > 0）必须（MUST）在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也必须（MUST）递增。也可以（MAY）在内部程序有大量新功能或改进被加入时递增，其中可以（MAY）包括修订级别的改变。每当次版本号递增时，修订号必须（MUST）归零。
  
  
    主版本号 X（X.y.z | X > 0）必须（MUST）在有任何不兼容的修改被加入公共 API 时递增。其中可以（MAY）包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须（MUST）归零。
  
  
    先行版本号可以（MAY）被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。数字型的标识符禁止（MUST NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。
  
  
    版本编译信息可以（MAY）被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。当判断版本的优先层级时，版本编译信息可（SHOULD）被忽略。因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。
  
  
    版本的优先层级指的是不同版本在排序时如何比较。

    
      
        判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译信息不在这份比较的列表中）。
      
      
        由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较。

        例如：1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。
      
      
        当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。

        例如：1.0.0-alpha < 1.0.0。
      
      
        有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：

        
          
            只有数字的标识符以数值高低比较。
          
          
            有字母或连接号时则逐字以 ASCII 的排序来比较。
          
          
            数字的标识符比非数字的标识符优先层级低。
          
          
            若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。
          
        

        例如：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。
      
    
  


合法语义化版本的巴科斯范式语法
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


为什么要使用语义化的版本控制？

这并不是一个新的或者革命性的想法。实际上，你可能已经在做一些近似的事情了。问题在于只是“近似”还不够。如果没有某个正式的规范可循，版本号对于依赖的管理并无实质意义。将上述的想法命名并给予清楚的定义，让你对软件使用者传达意向变得容易。一旦这些意向变得清楚，弹性（但又不会太弹性）的依赖规范就能达成。

举个简单的例子就可以展示语义化的版本控制如何让依赖地狱成为过去。假设有个名为“救火车”的函数库，它需要另一个名为“梯子”并已经有使用语义化版本控制的包。当救火车创建时，梯子的版本号为 3.1.0。因为救火车使用了一些版本 3.1.0 所新增的功能，你可以放心地指定依赖于梯子的版本号大于等于 3.1.0 但小于 4.0.0。这样，当梯子版本 3.1.1 和 3.2.0 发布时，你可以将直接它们纳入你的包管理系统，因为它们能与原有依赖的软件兼容。

作为一位负责任的开发者，你理当确保每次包升级的运作与版本号的表述一致。现实世界是复杂的，我们除了提高警觉外能做的不多。你所能做的就是让语义化的版本控制为你提供一个健全的方式来发行以及升级包，而无需推出新的依赖包，节省你的时间及烦恼。

如果你对此认同，希望立即开始使用语义化版本控制，你只需声明你的函数库正在使用它并遵循这些规则就可以了。请在你的 README 文件中保留此页链接，让别人也知道这些规则并从中受益。

FAQ

在 0.y.z 初始开发阶段，我该如何进行版本控制？

最简单的做法是以 0.1.0 作为你的初始化开发版本，并在后续的每次发行时递增次版本号。

如何判断发布 1.0.0 版本的时机？

当你的软件被用于正式环境，它应该已经达到了 1.0.0 版。如果你已经有个稳定的 API 被使用者依赖，也会是 1.0.0 版。如果你很担心向下兼容的问题，也应该算是 1.0.0 版了。

这不会阻碍快速开发和迭代吗？

主版本号为零的时候就是为了做快速开发。如果你每天都在改变 API，那么你应该仍在主版本号为零的阶段（0.y.z），或是正在下个主版本的独立开发分支中。

对于公共 API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到 42.0.0 版？

这是开发的责任感和前瞻性的问题。不兼容的改变不应该轻易被加入到有许多依赖代码的软件中。升级所付出的代价可能是巨大的。要递增主版本号来发行不兼容的改版，意味着你必须为这些改变所带来的影响深思熟虑，并且评估所涉及的成本及效益比。

为整个公共 API 写文档太费事了！

为供他人使用的软件编写适当的文档，是你作为一名专业开发者应尽的职责。保持项目高效的一个非常重要的部分是掌控软件的复杂度，如果没有人知道如何使用你的软件或不知道哪些函数的调用是可靠的，要掌控复杂度会是困难的。长远来看，使用语义化版本控制以及对于公共 API 有良好规范的坚持，可以让每个人及每件事都运行顺畅。

万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？

一旦发现自己破坏了语义化版本控制的规范，就要修正这个问题，并发行一个新的次版本号来更正这个问题并且恢复向下兼容。即使是这种情况，也不能去修改已发行的版本。可以的话，将有问题的版本号记录到文档中，告诉使用者问题所在，让他们能够意识到这是有问题的版本。

如果我更新了自己的依赖但没有改变公共 API 该怎么办？

由于没有影响到公共 API，这可以被认定是兼容的。若某个软件和你的包有共同依赖，则它会有自己的依赖规范，作者也会告知可能的冲突。要判断改版是属于修订等级或是次版等级，是依据你更新的依赖关系是为了修复问题或是加入新功能。对于后者，我经常会预期伴随着更多的代码，这显然会是一个次版本号级别的递增。

如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）

自行做最佳的判断。如果你有庞大的使用者群在依照公共 API 的意图而变更行为后会大受影响，那么最好做一次主版本的发布，即使严格来说这个修复仅是修订等级的发布。记住， 语义化的版本控制就是透过版本号的改变来传达意义。若这些改变对你的使用者是重要的，那就透过版本号来向他们说明。

我该如何处理即将弃用的功能？

弃用现存的功能是软件开发中的家常便饭，也通常是向前发展所必须的。当你弃用部分公共 API 时，你应该做两件事：（1）更新你的文档让使用者知道这个改变，（2）在适当的时机将弃用的功能透过新的次版本号发布。在新的主版本完全移除弃用功能前，至少要有一个次版本包含这个弃用信息，这样使用者才能平顺地转移到新版 API。

语义化版本对于版本的字符串长度是否有限制呢？

没有，请自行做适当的判断。举例来说，长到 255 个字符的版本已过度夸张。再者，特定的系统对于字符串长度可能会有他们自己的限制。

“v1.2.3” 是一个语义化版本号吗？

“v1.2.3” 并不是一个语义化的版本号。但是，在语义化版本号之前增加前缀 “v” 是用来表示版本号的常用做法。在版本控制系统中，将 “version” 缩写为 “v” 是很常见的。比如：git tag v1.2.3 -m "Release version 1.2.3" 中，“v1.2.3” 表示标签名称，而 “1.2.3” 是语义化版本号。

是否有推荐的正则表达式用以检查语义化版本号的正确性？

有两个推荐的正则表达式。第一个用于支持按组名称提取的语言（PCRE[Perl 兼容正则表达式，比如 Perl、PHP 和 R]、Python 和 Go）。

参见：https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


第二个用于支持按编号提取的语言（与第一个对应的提取项按顺序分别为：major、minor、patch、prerelease、buildmetadata）。主要包括 ECMA Script（JavaScript）、PCRE（Perl 兼容正则表达式，比如 Perl、PHP 和 R）、Python 和 Go。
参见：https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


关于

语义化版本控制的规范是由 Gravatars 创办者兼 GitHub 共同创办者 Tom Preston-Werner 所建立。

如果您有任何建议，请到 GitHub 上提出您的问题。

许可证

知识共享 署名 3.0 (CC BY 3.0)\n版本格式：主版本号.次版本号.修订号，版本号递增规则如下：\n主版本号：当你做了不兼容的 API 修改，\n先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。\n在软件管理的领域里存在着被称作“依赖地狱”的死亡之谷，系统规模越大，加入的包越多，你就越有可能在未来的某一天发现自己已深陷绝望之中。\n在依赖高的系统中发布新版本包可能很快会成为噩梦。如果依赖关系过高，可能面临版本控制被锁死的风险（必须对每一个依赖包改版才能完成某次升级）。而如果依赖关系过于松散，又将无法避免版本的混乱（假设兼容于未来的多个版本已超出了合理数量）。当你项目的进展因为版本依赖被锁死或版本混乱变得不够简便和可靠，就意味着你正处于依赖地狱之中。\n作为这个问题的解决方案之一，我提议用一组简单的规则及条件来约束版本号的配置和增长。这些规则是根据（但不局限于）已经被各种封闭、开放源码软件所广泛使用的惯例所设计。为了让这套理论运作，你必须先有定义好的公共 API。这可能包括文档或代码的强制要求。无论如何，这套 API 的清楚明了是十分重要的。一旦你定义了公共 API，你就可以透过修改相应的版本号来向大家说明你的修改。考虑使用这样的版本号格式：X.Y.Z（主版本号.次版本号.修订号）修复问题但不影响 API 时，递增修订号；API 保持向下兼容的新增及修改时，递增次版本号；进行不向下兼容的修改时，递增主版本号。\n我称这套系统为“语义化的版本控制”，在这套约定下，版本号及其更新方式包含了相邻版本间的底层代码和修改内容的信息。\n以下关键词 MUST、MUST NOT、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD NOT、 RECOMMENDED、MAY、OPTIONAL 依照 RFC 2119 的叙述解读。\n使用语义化版本控制的软件必须（MUST）定义公共 API。该 API 可以在代码中被定义或出现于严谨的文档内。无论何种形式都应该力求精确且完整。\n使用语义化版本控制的软件必须（MUST）定义公共 API。该 API 可以在代码中被定义或出现于严谨的文档内。无论何种形式都应该力求精确且完整。\n标准的版本号必须（MUST）采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止（MUST NOT）在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须（MUST）以数值来递增。例如：1.9.1 -> 1.10.0 -> 1.11.0。\n标准的版本号必须（MUST）采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止（MUST NOT）在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须（MUST）以数值来递增。例如：1.9.1 -> 1.10.0 -> 1.11.0。\n标记版本号的软件发行后，禁止（MUST NOT）改变该版本软件的内容。任何修改都必须（MUST）以新版本发行。\n标记版本号的软件发行后，禁止（MUST NOT）改变该版本软件的内容。任何修改都必须（MUST）以新版本发行。\n主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。\n主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。\n1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。\n1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。\n修订号 Z（x.y.Z | x > 0）必须（MUST）在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。\n修订号 Z（x.y.Z | x > 0）必须（MUST）在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。\n次版本号 Y（x.Y.z | x > 0）必须（MUST）在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也必须（MUST）递增。也可以（MAY）在内部程序有大量新功能或改进被加入时递增，其中可以（MAY）包括修订级别的改变。每当次版本号递增时，修订号必须（MUST）归零。\n次版本号 Y（x.Y.z | x > 0）必须（MUST）在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也必须（MUST）递增。也可以（MAY）在内部程序有大量新功能或改进被加入时递增，其中可以（MAY）包括修订级别的改变。每当次版本号递增时，修订号必须（MUST）归零。\n主版本号 X（X.y.z | X > 0）必须（MUST）在有任何不兼容的修改被加入公共 API 时递增。其中可以（MAY）包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须（MUST）归零。\n主版本号 X（X.y.z | X > 0）必须（MUST）在有任何不兼容的修改被加入公共 API 时递增。其中可以（MAY）包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须（MUST）归零。\n先行版本号可以（MAY）被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。数字型的标识符禁止（MUST NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。\n先行版本号可以（MAY）被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。数字型的标识符禁止（MUST NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。\n版本编译信息可以（MAY）被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。当判断版本的优先层级时，版本编译信息可（SHOULD）被忽略。因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。\n版本编译信息可以（MAY）被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。当判断版本的优先层级时，版本编译信息可（SHOULD）被忽略。因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。\n版本的优先层级指的是不同版本在排序时如何比较。

    
      
        判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译信息不在这份比较的列表中）。
      
      
        由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较。

        例如：1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。
      
      
        当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。

        例如：1.0.0-alpha < 1.0.0。
      
      
        有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：

        
          
            只有数字的标识符以数值高低比较。
          
          
            有字母或连接号时则逐字以 ASCII 的排序来比较。
          
          
            数字的标识符比非数字的标识符优先层级低。
          
          
            若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。
          
        

        例如：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。\n版本的优先层级指的是不同版本在排序时如何比较。\n判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译信息不在这份比较的列表中）。\n判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译信息不在这份比较的列表中）。\n由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较。

        例如：1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。\n由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较。\n例如：1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。\n当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。

        例如：1.0.0-alpha < 1.0.0。\n当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。\n例如：1.0.0-alpha < 1.0.0。\n有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：

        
          
            只有数字的标识符以数值高低比较。
          
          
            有字母或连接号时则逐字以 ASCII 的排序来比较。
          
          
            数字的标识符比非数字的标识符优先层级低。
          
          
            若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。
          
        

        例如：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。\n有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：\n有字母或连接号时则逐字以 ASCII 的排序来比较。\n有字母或连接号时则逐字以 ASCII 的排序来比较。\n若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。\n若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。\n例如：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n这并不是一个新的或者革命性的想法。实际上，你可能已经在做一些近似的事情了。问题在于只是“近似”还不够。如果没有某个正式的规范可循，版本号对于依赖的管理并无实质意义。将上述的想法命名并给予清楚的定义，让你对软件使用者传达意向变得容易。一旦这些意向变得清楚，弹性（但又不会太弹性）的依赖规范就能达成。\n举个简单的例子就可以展示语义化的版本控制如何让依赖地狱成为过去。假设有个名为“救火车”的函数库，它需要另一个名为“梯子”并已经有使用语义化版本控制的包。当救火车创建时，梯子的版本号为 3.1.0。因为救火车使用了一些版本 3.1.0 所新增的功能，你可以放心地指定依赖于梯子的版本号大于等于 3.1.0 但小于 4.0.0。这样，当梯子版本 3.1.1 和 3.2.0 发布时，你可以将直接它们纳入你的包管理系统，因为它们能与原有依赖的软件兼容。\n作为一位负责任的开发者，你理当确保每次包升级的运作与版本号的表述一致。现实世界是复杂的，我们除了提高警觉外能做的不多。你所能做的就是让语义化的版本控制为你提供一个健全的方式来发行以及升级包，而无需推出新的依赖包，节省你的时间及烦恼。\n如果你对此认同，希望立即开始使用语义化版本控制，你只需声明你的函数库正在使用它并遵循这些规则就可以了。请在你的 README 文件中保留此页链接，让别人也知道这些规则并从中受益。\n在 0.y.z 初始开发阶段，我该如何进行版本控制？\n最简单的做法是以 0.1.0 作为你的初始化开发版本，并在后续的每次发行时递增次版本号。\n当你的软件被用于正式环境，它应该已经达到了 1.0.0 版。如果你已经有个稳定的 API 被使用者依赖，也会是 1.0.0 版。如果你很担心向下兼容的问题，也应该算是 1.0.0 版了。\n主版本号为零的时候就是为了做快速开发。如果你每天都在改变 API，那么你应该仍在主版本号为零的阶段（0.y.z），或是正在下个主版本的独立开发分支中。\n对于公共 API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到 42.0.0 版？\n这是开发的责任感和前瞻性的问题。不兼容的改变不应该轻易被加入到有许多依赖代码的软件中。升级所付出的代价可能是巨大的。要递增主版本号来发行不兼容的改版，意味着你必须为这些改变所带来的影响深思熟虑，并且评估所涉及的成本及效益比。\n为供他人使用的软件编写适当的文档，是你作为一名专业开发者应尽的职责。保持项目高效的一个非常重要的部分是掌控软件的复杂度，如果没有人知道如何使用你的软件或不知道哪些函数的调用是可靠的，要掌控复杂度会是困难的。长远来看，使用语义化版本控制以及对于公共 API 有良好规范的坚持，可以让每个人及每件事都运行顺畅。\n万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？\n一旦发现自己破坏了语义化版本控制的规范，就要修正这个问题，并发行一个新的次版本号来更正这个问题并且恢复向下兼容。即使是这种情况，也不能去修改已发行的版本。可以的话，将有问题的版本号记录到文档中，告诉使用者问题所在，让他们能够意识到这是有问题的版本。\n如果我更新了自己的依赖但没有改变公共 API 该怎么办？\n由于没有影响到公共 API，这可以被认定是兼容的。若某个软件和你的包有共同依赖，则它会有自己的依赖规范，作者也会告知可能的冲突。要判断改版是属于修订等级或是次版等级，是依据你更新的依赖关系是为了修复问题或是加入新功能。对于后者，我经常会预期伴随着更多的代码，这显然会是一个次版本号级别的递增。\n如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）\n自行做最佳的判断。如果你有庞大的使用者群在依照公共 API 的意图而变更行为后会大受影响，那么最好做一次主版本的发布，即使严格来说这个修复仅是修订等级的发布。记住， 语义化的版本控制就是透过版本号的改变来传达意义。若这些改变对你的使用者是重要的，那就透过版本号来向他们说明。\n弃用现存的功能是软件开发中的家常便饭，也通常是向前发展所必须的。当你弃用部分公共 API 时，你应该做两件事：（1）更新你的文档让使用者知道这个改变，（2）在适当的时机将弃用的功能透过新的次版本号发布。在新的主版本完全移除弃用功能前，至少要有一个次版本包含这个弃用信息，这样使用者才能平顺地转移到新版 API。\n语义化版本对于版本的字符串长度是否有限制呢？\n没有，请自行做适当的判断。举例来说，长到 255 个字符的版本已过度夸张。再者，特定的系统对于字符串长度可能会有他们自己的限制。\n“v1.2.3” 并不是一个语义化的版本号。但是，在语义化版本号之前增加前缀 “v” 是用来表示版本号的常用做法。在版本控制系统中，将 “version” 缩写为 “v” 是很常见的。比如：git tag v1.2.3 -m "Release version 1.2.3" 中，“v1.2.3” 表示标签名称，而 “1.2.3” 是语义化版本号。\n是否有推荐的正则表达式用以检查语义化版本号的正确性？\n有两个推荐的正则表达式。第一个用于支持按组名称提取的语言（PCRE[Perl 兼容正则表达式，比如 Perl、PHP 和 R]、Python 和 Go）。\n参见：https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n第二个用于支持按编号提取的语言（与第一个对应的提取项按顺序分别为：major、minor、patch、prerelease、buildmetadata）。主要包括 ECMA Script（JavaScript）、PCRE（Perl 兼容正则表达式，比如 Perl、PHP 和 R）、Python 和 Go。
参见：https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n语义化版本控制的规范是由 Gravatars 创办者兼 GitHub 共同创办者 Tom Preston-Werner 所建立。\n如果您有任何建议，请到 GitHub 上提出您的问题。\n知识共享 署名 3.0 (CC BY 3.0)\n知识共享 署名 3.0 (CC BY 3.0)\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\n語意化版本 2.0.0

摘要

版本格式：主版號.次版號.修訂號，版號遞增規則如下：


  主版號：當你做了不相容的 API 修改，
  次版號：當你做了向下相容的功能性新增，
  修訂號：當你做了向下相容的問題修正。


先行版號及版本編譯資訊可以加到「主版號.次版號.修訂號」的後面，作為延伸。

簡介

在軟體管理的領域裡存在著被稱作「相依性地獄」的死亡之谷，系統規模越大，加入的套件越多，你就越有可能在未來的某一天發現自己已深陷絕望之中。

在相依性高的系統中發佈新版本套件可能很快會成為惡夢。如果相依性關係過高，可能面臨版本控制被鎖死的風險（必須對每一個相依套件改版才能完成某次升級）。而如果相依性關係過於鬆散，又將無法避免版本的混亂（假設相容於未來的多個版本已超出了合理數量）。當你專案的進展因為版本相依被鎖死或版本混亂變得不夠簡便和可靠，就意味著你正處於相依性地獄之中。

作為這個問題的解決方案之一，我提議用一組簡單的規則及條件來約束版號的配置和增長。這些規則是根據（但不局限於）已經被各種封閉、開放源碼軟體所廣泛使用的慣例所設計。為了讓這套理論運作，你必須先有定義好的公共 API。這可以透過文件定義或程式碼強制要求來實現。無論如何，這套 API 的清楚明瞭是十分重要的。一旦你定義了公共 API，你就可以透過修改相應的版號來向大家說明你的修改。考慮使用這樣的版號格式：X.Y.Z（主版號.次版號.修訂號）修復問題但不影響 API 時，遞增修訂號；API 保持向下相容的新增及修改時，遞增次版號；進行不向下相容的修改時，遞增主版號。

我稱這套系統為「語意化的版本控制」，在這套約定下，版號及其更新方式包含了相鄰版本間的底層程式碼和修改內容的訊息。

語意化版本控制規範（SemVer）

以下關鍵詞「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、「OPTIONAL」依照 RFC 2119 的敘述解讀。（譯著：為了保持語句順暢，以下文件遇到的關鍵詞將依照整句語意進行翻譯，在此先不進行個別翻譯。）


  
    使用語意化版本控制的軟體必須（MUST）定義公共 API。該 API 可以在程式碼中被定義或出現於嚴謹的文件內。無論何種形式都應該（SHOULD）力求精確且完整。
  
  
    標準的版號必須（MUST）採用 X.Y.Z 的格式，其中 X、Y 和 Z 為非負的整數，且禁止（MUST NOT）在數字前方補零。X 是主版號、Y 是次版號、而 Z 為修訂號。每個元素必須（MUST）以數值來遞增。例如：1.9.1 -> 1.10.0 -> 1.11.0。
  
  
    標記版號的軟體發行後，禁止（MUST NOT）改變該版本軟體的內容。任何修改都必須（MUST）以新版本發行。
  
  
    主版號為零（0.y.z）的軟體處於開發初始階段，一切都可以（MAY）隨時改變。這樣的公共 API 不應該（SHOULD NOT）被視為穩定版。
  
  
    1.0.0 的版號用於界定公共 API 的形成。這一版本之後所有的版號更新都基於公共 API及其修改內容。
  
  
    修訂號 Z（x.y.Z | x > 0）必須（MUST）在只做了向下相容的修正時才遞增。這裡的修正指的是針對不正確結果而進行的內部修改。
  
  
    次版號 Y（x.Y.z | x > 0）必須（MUST）在有向下相容的新功能出現時遞增。在任何公共 API 的功能被標記為棄用時也必須（MUST）遞增。也可以（MAY）在內部程式有大量新功能或改進被加入時遞增，其中可以（MAY）包括修訂級別的改變。每當次版號遞增時，修訂號必須（MUST）歸零。
  
  
    主版本號 X（X.y.z | X > 0）必須（MUST）在有任何不相容的修改被加入公共 API 時遞增。其中可以（MAY）包括次版號及修訂級別的改變。每當主版號遞增時，次版號和修訂號必須（MUST）歸零。
  
  
    先行版號可以（MAY）被標注在修訂版之後，先加上一個連接號再加上一連串以句點分隔的標識符號來修飾。標識符號必須（MUST）由 ASCII 碼的英數字和連接號[0-9A-Za-z-] 組成，且禁止（MUST NOT）留白。數字型的標識符號禁止（MUST NOT）在前方補零。先行版的優先級低於相關聯的標準版本。被標上先行版號則表示這個版本並非穩定而且可能無法達到相容的需求。範例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92、1.0.0-x-y-z.–。
  
  
    版本編譯資訊可以（MAY）被標注在修訂版或先行版號之後，先加上一個加號再加上一連串以句點分隔的標識符號來修飾。標識符號必須（MUST）由 ASCII 的英數字和連接號 [0-9A-Za-z-]組成，且禁止（MUST NOT）留白。當判斷版本的優先層級時，版本編譯資訊必須（MUST）被忽略。因此當兩個版本只有在版本編譯資訊有差別時，屬於相同的優先層級。範例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85、1.0.0+21AF26D3—-117B344092BD。
  
  
    版本的優先層級指的是不同版本在排序時如何比較。

    
      
        判斷優先層級時，必須（MUST）把版本依序拆分為主版號、次版號、修訂號及先行版號後進行比較（版本編譯資訊不在這份比較的列表中）。
      
      
        由左到右依序比較每個標識符號，第一個差異值用來決定優先層級：主版號、次版號及修訂號以數值比較。

        例如： 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。
      
      
        當主版號、次版號及修訂號都相同時，有先行版號者優先層級較低。

        例如：1.0.0-alpha < 1.0.0。
      
      
        有相同主版號、次版號及修訂號的兩個先行版號，其優先層級必須（MUST）透過由左到右的每個被句點分隔的標識符號來比較，直到找到一個差異值後決定：

        
          
            只有數字的標識符號以數值高低比較。
          
          
            有字母或連接號時則逐字以 ASCII 的排序來比較。
          
          
            數字的標識符號比非數字的標識符號優先層級低。
          
          
            若開頭的標識符號都相同時，欄位比較多的先行版號優先層級比較高。

            範例：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。
          
        
      
    
  


有效語意化版本的 Backus–Naur 範式語法
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


為什麼要使用語意化的版本控制？

這並不是一個新的或者革命性的想法。實際上，你可能已經在做一些近似的事情了。問題在於只是「近似」還不夠。如果沒有某個正式的規範可循，版號對於相依性的管理並無實質意義。將上述的想法命名並給予清楚的定義，讓你對軟體使用者傳達意向變得容易。一旦這些意向變得清楚，彈性（但又不會太彈性）的相依性規範就能達成。

舉個簡單的例子就可以展示語意化的版本控制如何讓相依性地獄成為過去。假設有個名為「消防車」的函式庫，它需要另一個名為「梯子」並已經有使用語意化版本控制的套件。當消防車創建時，梯子的版號為 3.1.0。因為消防車使用了一些版本 3.1.0 所新增的功能，你可以放心地指定相依於梯子的版號大等於 3.1.0 但小於4.0.0。這樣，當梯子版本 3.1.1和 3.2.0 發佈時，你可以將直接它們納入你的套件管理系統，因為它們能與原有相依的軟體相容。

作為一位負責任的開發者，你理當確保每次套件升級的運作與版本號的表述一致。現實世界是複雜的，我們除了提高警覺外能做的不多。你所能做的就是讓語意化的版本控制為你提供一個健全的方式來發行以及升級套件，而無需推出新的相依套件，節省你的時間及煩惱。

如果你對此認同，希望立即開始使用語意化版本控制，你只需聲明你的函式庫正在使用它並遵循這些規則就可以了。請在你的 README 文件中保留此頁連結，讓別人也知道這些規則並從中受益。

FAQ

在 0.y.z 初始開發階段，我該如何進行版本控制？

最簡單的做法是以 0.1.0 作為你的初始化開發版本，並在後續的每次發行時遞增次版號。

如何判斷發佈 1.0.0 版本的時機？

當你的軟體被用於正式環境，它應該已經達到了 1.0.0 版。如果你已經有個穩定的 API 被使用者依賴，也會是 1.0.0 版。如果你很擔心向下相容的問題，也應該算是 1.0.0 版了。

這不會阻礙快速開發和迭代嗎？

主版號為零的時候就是為了做快速開發。如果你每天都在改變 API，那麼你應該仍在主版號為零的階段（0.y.z），或是正在下個主版本的獨立開發分支中。

對於公共 API，若即使是最小但不向下相容的改變都需要產生新的主版號，豈不是很快就達到 42.0.0 版？

這是開發的責任感和前瞻性的問題。不相容的改變不應該輕易被加入到有許多相依性程式碼的軟體中。升級所付出的代價可能是巨大的。要遞增主版號來發行不相容的改版，意味著你必須為這些改變所帶來的影響深思熟慮，並且評估所涉及的成本及效益比。

為整個公共 API 寫文件太費事了！

為供他人使用的軟體編寫適當的文件，是你作為一名專業開發者應盡的職責。保持專案高效一個非常重要的部份是掌控軟體的複雜度，如果沒有人知道如何使用你的軟體或不知道哪些函數的呼叫是可靠的，要掌控複雜度會是困難的。長遠來看，使用語意化版本控制以及對於公共 API 有良好規範的堅持，可以讓每個人及每件事都運行順暢。

萬一不小心把一個不相容的改版當成了次版號發行了該怎麼辦？

一旦發現自己破壞了語意化版本控制的規範，就要修正這個問題，並發行一個新的次版號來更正這個問題並且恢復向下相容。即使是這種情況，也不能去修改已發行的版本。可以的話，將有問題的版號記錄到文件中，告訴使用者問題所在，讓他們能夠意識到這是有問題的版本。

如果我更新了自己的相依性但沒有改變公共 API 該怎麼辦？

由於沒有影響到公共 API，這可以被認定是相容的。若某個軟體和你的套件有共同相依性，則它會有自己的相依性規範，作者也會告知可能的衝突。要判斷改版是屬於修訂等級或是次版等級，是依據你更新的相依性關係是為了修復問題或是加入新功能。對於後者，我經常會預期伴隨著更多的程式碼，這顯然會是一個次版號級別的遞增。

如果我變更了公共 API 但無意中未遵循版號的改動怎麼辦呢？（意即在修訂等級的發佈中，誤將重大且不相容的改變加到程式碼之中）

自行做最佳的判斷。如果你有龐大的使用者群在依照公共 API 的意圖而變更行為後會大受影響，那麼最好做一次主版本的發佈，即使嚴格來說這個修復僅是修訂等級的發佈。記住，語意化的版本控制就是透過版號的改變來傳達意義。若這些改變對你的使用者是重要的，那就透過版號來向他們說明。

我該如何處理即將棄用的功能？

棄用現存的功能是軟體開發中的家常便飯，也通常是向前發展所必須的。當你棄用部份公共 API 時，你應該做兩件事：（1）更新你的文件讓使用者知道這個改變，（2）在適當的時機將棄用的功能透過新的次版號發佈。在新的主版本完全移除棄用功能前，至少要有一個次版本包含這個棄用資訊，這樣使用者才能平順地轉移到新版 API。

語意化版本對於版本的字串長度是否有限制呢？

沒有，請自行做適當的判斷。舉例來說，長到 255 個字元的版本已過度誇張。再者，特定的系統對於字串長度可能會有他們自己的限制。

“v1.2.3” 是語意化版本嗎？

不，”v1.2.3” 不是語意化版本。然而在語意化版本前加上 “v” 表示其為版本號是很常見的做法（就英文而言）。用 “v” 表示 “version” 的縮寫是版本控制的常見做法。例如：git tag v1.2.3 -m "Release version 1.2.3"，此例 “v1.2.3” 是標籤名稱，而語意化版本是 “1.2.3”。

有建議用於檢查語意化版本的正規表示式（RegEx）嗎？

有兩種。一種用命名群組，須在支援的系統上使用（PCRE [Perl Compatible Regular Expressions, i.e. Perl, PHP and R]、Python、以及 Go）。

參見：https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


另一種使用擷取群組編號（組1 = 主版號，組2 = 次版號，組3 = 修訂號，組4 = 先行版號，組5 = 編譯資訊），與 ECMA Script (JavaScript)、PCRE (Perl Compatible Regular Expressions, i.e. Perl, PHP and R)、Python、以及 Go 相容。

參見：https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


關於

語意化版本控制的規範最初是由 Gravatars 創辦者兼 GitHub 共同創辦者 Tom Preston-Werner 建立。

如果您有任何建議，請到 GitHub 上提出問題。

授權

創用 CC 姓名標示 3.0 授權條款\n版本格式：主版號.次版號.修訂號，版號遞增規則如下：\n先行版號及版本編譯資訊可以加到「主版號.次版號.修訂號」的後面，作為延伸。\n在軟體管理的領域裡存在著被稱作「相依性地獄」的死亡之谷，系統規模越大，加入的套件越多，你就越有可能在未來的某一天發現自己已深陷絕望之中。\n在相依性高的系統中發佈新版本套件可能很快會成為惡夢。如果相依性關係過高，可能面臨版本控制被鎖死的風險（必須對每一個相依套件改版才能完成某次升級）。而如果相依性關係過於鬆散，又將無法避免版本的混亂（假設相容於未來的多個版本已超出了合理數量）。當你專案的進展因為版本相依被鎖死或版本混亂變得不夠簡便和可靠，就意味著你正處於相依性地獄之中。\n作為這個問題的解決方案之一，我提議用一組簡單的規則及條件來約束版號的配置和增長。這些規則是根據（但不局限於）已經被各種封閉、開放源碼軟體所廣泛使用的慣例所設計。為了讓這套理論運作，你必須先有定義好的公共 API。這可以透過文件定義或程式碼強制要求來實現。無論如何，這套 API 的清楚明瞭是十分重要的。一旦你定義了公共 API，你就可以透過修改相應的版號來向大家說明你的修改。考慮使用這樣的版號格式：X.Y.Z（主版號.次版號.修訂號）修復問題但不影響 API 時，遞增修訂號；API 保持向下相容的新增及修改時，遞增次版號；進行不向下相容的修改時，遞增主版號。\n我稱這套系統為「語意化的版本控制」，在這套約定下，版號及其更新方式包含了相鄰版本間的底層程式碼和修改內容的訊息。\n以下關鍵詞「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、「OPTIONAL」依照 RFC 2119 的敘述解讀。（譯著：為了保持語句順暢，以下文件遇到的關鍵詞將依照整句語意進行翻譯，在此先不進行個別翻譯。）\n使用語意化版本控制的軟體必須（MUST）定義公共 API。該 API 可以在程式碼中被定義或出現於嚴謹的文件內。無論何種形式都應該（SHOULD）力求精確且完整。\n使用語意化版本控制的軟體必須（MUST）定義公共 API。該 API 可以在程式碼中被定義或出現於嚴謹的文件內。無論何種形式都應該（SHOULD）力求精確且完整。\n標準的版號必須（MUST）採用 X.Y.Z 的格式，其中 X、Y 和 Z 為非負的整數，且禁止（MUST NOT）在數字前方補零。X 是主版號、Y 是次版號、而 Z 為修訂號。每個元素必須（MUST）以數值來遞增。例如：1.9.1 -> 1.10.0 -> 1.11.0。\n標準的版號必須（MUST）採用 X.Y.Z 的格式，其中 X、Y 和 Z 為非負的整數，且禁止（MUST NOT）在數字前方補零。X 是主版號、Y 是次版號、而 Z 為修訂號。每個元素必須（MUST）以數值來遞增。例如：1.9.1 -> 1.10.0 -> 1.11.0。\n標記版號的軟體發行後，禁止（MUST NOT）改變該版本軟體的內容。任何修改都必須（MUST）以新版本發行。\n標記版號的軟體發行後，禁止（MUST NOT）改變該版本軟體的內容。任何修改都必須（MUST）以新版本發行。\n主版號為零（0.y.z）的軟體處於開發初始階段，一切都可以（MAY）隨時改變。這樣的公共 API 不應該（SHOULD NOT）被視為穩定版。\n主版號為零（0.y.z）的軟體處於開發初始階段，一切都可以（MAY）隨時改變。這樣的公共 API 不應該（SHOULD NOT）被視為穩定版。\n1.0.0 的版號用於界定公共 API 的形成。這一版本之後所有的版號更新都基於公共 API及其修改內容。\n1.0.0 的版號用於界定公共 API 的形成。這一版本之後所有的版號更新都基於公共 API及其修改內容。\n修訂號 Z（x.y.Z | x > 0）必須（MUST）在只做了向下相容的修正時才遞增。這裡的修正指的是針對不正確結果而進行的內部修改。\n修訂號 Z（x.y.Z | x > 0）必須（MUST）在只做了向下相容的修正時才遞增。這裡的修正指的是針對不正確結果而進行的內部修改。\n次版號 Y（x.Y.z | x > 0）必須（MUST）在有向下相容的新功能出現時遞增。在任何公共 API 的功能被標記為棄用時也必須（MUST）遞增。也可以（MAY）在內部程式有大量新功能或改進被加入時遞增，其中可以（MAY）包括修訂級別的改變。每當次版號遞增時，修訂號必須（MUST）歸零。\n次版號 Y（x.Y.z | x > 0）必須（MUST）在有向下相容的新功能出現時遞增。在任何公共 API 的功能被標記為棄用時也必須（MUST）遞增。也可以（MAY）在內部程式有大量新功能或改進被加入時遞增，其中可以（MAY）包括修訂級別的改變。每當次版號遞增時，修訂號必須（MUST）歸零。\n主版本號 X（X.y.z | X > 0）必須（MUST）在有任何不相容的修改被加入公共 API 時遞增。其中可以（MAY）包括次版號及修訂級別的改變。每當主版號遞增時，次版號和修訂號必須（MUST）歸零。\n主版本號 X（X.y.z | X > 0）必須（MUST）在有任何不相容的修改被加入公共 API 時遞增。其中可以（MAY）包括次版號及修訂級別的改變。每當主版號遞增時，次版號和修訂號必須（MUST）歸零。\n先行版號可以（MAY）被標注在修訂版之後，先加上一個連接號再加上一連串以句點分隔的標識符號來修飾。標識符號必須（MUST）由 ASCII 碼的英數字和連接號[0-9A-Za-z-] 組成，且禁止（MUST NOT）留白。數字型的標識符號禁止（MUST NOT）在前方補零。先行版的優先級低於相關聯的標準版本。被標上先行版號則表示這個版本並非穩定而且可能無法達到相容的需求。範例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92、1.0.0-x-y-z.–。\n先行版號可以（MAY）被標注在修訂版之後，先加上一個連接號再加上一連串以句點分隔的標識符號來修飾。標識符號必須（MUST）由 ASCII 碼的英數字和連接號[0-9A-Za-z-] 組成，且禁止（MUST NOT）留白。數字型的標識符號禁止（MUST NOT）在前方補零。先行版的優先級低於相關聯的標準版本。被標上先行版號則表示這個版本並非穩定而且可能無法達到相容的需求。範例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92、1.0.0-x-y-z.–。\n版本編譯資訊可以（MAY）被標注在修訂版或先行版號之後，先加上一個加號再加上一連串以句點分隔的標識符號來修飾。標識符號必須（MUST）由 ASCII 的英數字和連接號 [0-9A-Za-z-]組成，且禁止（MUST NOT）留白。當判斷版本的優先層級時，版本編譯資訊必須（MUST）被忽略。因此當兩個版本只有在版本編譯資訊有差別時，屬於相同的優先層級。範例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85、1.0.0+21AF26D3—-117B344092BD。\n版本編譯資訊可以（MAY）被標注在修訂版或先行版號之後，先加上一個加號再加上一連串以句點分隔的標識符號來修飾。標識符號必須（MUST）由 ASCII 的英數字和連接號 [0-9A-Za-z-]組成，且禁止（MUST NOT）留白。當判斷版本的優先層級時，版本編譯資訊必須（MUST）被忽略。因此當兩個版本只有在版本編譯資訊有差別時，屬於相同的優先層級。範例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85、1.0.0+21AF26D3—-117B344092BD。\n版本的優先層級指的是不同版本在排序時如何比較。

    
      
        判斷優先層級時，必須（MUST）把版本依序拆分為主版號、次版號、修訂號及先行版號後進行比較（版本編譯資訊不在這份比較的列表中）。
      
      
        由左到右依序比較每個標識符號，第一個差異值用來決定優先層級：主版號、次版號及修訂號以數值比較。

        例如： 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。
      
      
        當主版號、次版號及修訂號都相同時，有先行版號者優先層級較低。

        例如：1.0.0-alpha < 1.0.0。
      
      
        有相同主版號、次版號及修訂號的兩個先行版號，其優先層級必須（MUST）透過由左到右的每個被句點分隔的標識符號來比較，直到找到一個差異值後決定：

        
          
            只有數字的標識符號以數值高低比較。
          
          
            有字母或連接號時則逐字以 ASCII 的排序來比較。
          
          
            數字的標識符號比非數字的標識符號優先層級低。
          
          
            若開頭的標識符號都相同時，欄位比較多的先行版號優先層級比較高。

            範例：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。\n版本的優先層級指的是不同版本在排序時如何比較。\n判斷優先層級時，必須（MUST）把版本依序拆分為主版號、次版號、修訂號及先行版號後進行比較（版本編譯資訊不在這份比較的列表中）。\n判斷優先層級時，必須（MUST）把版本依序拆分為主版號、次版號、修訂號及先行版號後進行比較（版本編譯資訊不在這份比較的列表中）。\n由左到右依序比較每個標識符號，第一個差異值用來決定優先層級：主版號、次版號及修訂號以數值比較。

        例如： 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。\n由左到右依序比較每個標識符號，第一個差異值用來決定優先層級：主版號、次版號及修訂號以數值比較。\n例如： 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。\n當主版號、次版號及修訂號都相同時，有先行版號者優先層級較低。

        例如：1.0.0-alpha < 1.0.0。\n當主版號、次版號及修訂號都相同時，有先行版號者優先層級較低。\n例如：1.0.0-alpha < 1.0.0。\n有相同主版號、次版號及修訂號的兩個先行版號，其優先層級必須（MUST）透過由左到右的每個被句點分隔的標識符號來比較，直到找到一個差異值後決定：

        
          
            只有數字的標識符號以數值高低比較。
          
          
            有字母或連接號時則逐字以 ASCII 的排序來比較。
          
          
            數字的標識符號比非數字的標識符號優先層級低。
          
          
            若開頭的標識符號都相同時，欄位比較多的先行版號優先層級比較高。

            範例：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。\n有相同主版號、次版號及修訂號的兩個先行版號，其優先層級必須（MUST）透過由左到右的每個被句點分隔的標識符號來比較，直到找到一個差異值後決定：\n有字母或連接號時則逐字以 ASCII 的排序來比較。\n有字母或連接號時則逐字以 ASCII 的排序來比較。\n數字的標識符號比非數字的標識符號優先層級低。\n數字的標識符號比非數字的標識符號優先層級低。\n若開頭的標識符號都相同時，欄位比較多的先行版號優先層級比較高。

            範例：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。\n若開頭的標識符號都相同時，欄位比較多的先行版號優先層級比較高。\n範例：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。\n有效語意化版本的 Backus–Naur 範式語法\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n這並不是一個新的或者革命性的想法。實際上，你可能已經在做一些近似的事情了。問題在於只是「近似」還不夠。如果沒有某個正式的規範可循，版號對於相依性的管理並無實質意義。將上述的想法命名並給予清楚的定義，讓你對軟體使用者傳達意向變得容易。一旦這些意向變得清楚，彈性（但又不會太彈性）的相依性規範就能達成。\n舉個簡單的例子就可以展示語意化的版本控制如何讓相依性地獄成為過去。假設有個名為「消防車」的函式庫，它需要另一個名為「梯子」並已經有使用語意化版本控制的套件。當消防車創建時，梯子的版號為 3.1.0。因為消防車使用了一些版本 3.1.0 所新增的功能，你可以放心地指定相依於梯子的版號大等於 3.1.0 但小於4.0.0。這樣，當梯子版本 3.1.1和 3.2.0 發佈時，你可以將直接它們納入你的套件管理系統，因為它們能與原有相依的軟體相容。\n作為一位負責任的開發者，你理當確保每次套件升級的運作與版本號的表述一致。現實世界是複雜的，我們除了提高警覺外能做的不多。你所能做的就是讓語意化的版本控制為你提供一個健全的方式來發行以及升級套件，而無需推出新的相依套件，節省你的時間及煩惱。\n如果你對此認同，希望立即開始使用語意化版本控制，你只需聲明你的函式庫正在使用它並遵循這些規則就可以了。請在你的 README 文件中保留此頁連結，讓別人也知道這些規則並從中受益。\n在 0.y.z 初始開發階段，我該如何進行版本控制？\n最簡單的做法是以 0.1.0 作為你的初始化開發版本，並在後續的每次發行時遞增次版號。\n當你的軟體被用於正式環境，它應該已經達到了 1.0.0 版。如果你已經有個穩定的 API 被使用者依賴，也會是 1.0.0 版。如果你很擔心向下相容的問題，也應該算是 1.0.0 版了。\n主版號為零的時候就是為了做快速開發。如果你每天都在改變 API，那麼你應該仍在主版號為零的階段（0.y.z），或是正在下個主版本的獨立開發分支中。\n對於公共 API，若即使是最小但不向下相容的改變都需要產生新的主版號，豈不是很快就達到 42.0.0 版？\n這是開發的責任感和前瞻性的問題。不相容的改變不應該輕易被加入到有許多相依性程式碼的軟體中。升級所付出的代價可能是巨大的。要遞增主版號來發行不相容的改版，意味著你必須為這些改變所帶來的影響深思熟慮，並且評估所涉及的成本及效益比。\n為供他人使用的軟體編寫適當的文件，是你作為一名專業開發者應盡的職責。保持專案高效一個非常重要的部份是掌控軟體的複雜度，如果沒有人知道如何使用你的軟體或不知道哪些函數的呼叫是可靠的，要掌控複雜度會是困難的。長遠來看，使用語意化版本控制以及對於公共 API 有良好規範的堅持，可以讓每個人及每件事都運行順暢。\n萬一不小心把一個不相容的改版當成了次版號發行了該怎麼辦？\n一旦發現自己破壞了語意化版本控制的規範，就要修正這個問題，並發行一個新的次版號來更正這個問題並且恢復向下相容。即使是這種情況，也不能去修改已發行的版本。可以的話，將有問題的版號記錄到文件中，告訴使用者問題所在，讓他們能夠意識到這是有問題的版本。\n如果我更新了自己的相依性但沒有改變公共 API 該怎麼辦？\n由於沒有影響到公共 API，這可以被認定是相容的。若某個軟體和你的套件有共同相依性，則它會有自己的相依性規範，作者也會告知可能的衝突。要判斷改版是屬於修訂等級或是次版等級，是依據你更新的相依性關係是為了修復問題或是加入新功能。對於後者，我經常會預期伴隨著更多的程式碼，這顯然會是一個次版號級別的遞增。\n如果我變更了公共 API 但無意中未遵循版號的改動怎麼辦呢？（意即在修訂等級的發佈中，誤將重大且不相容的改變加到程式碼之中）\n自行做最佳的判斷。如果你有龐大的使用者群在依照公共 API 的意圖而變更行為後會大受影響，那麼最好做一次主版本的發佈，即使嚴格來說這個修復僅是修訂等級的發佈。記住，語意化的版本控制就是透過版號的改變來傳達意義。若這些改變對你的使用者是重要的，那就透過版號來向他們說明。\n棄用現存的功能是軟體開發中的家常便飯，也通常是向前發展所必須的。當你棄用部份公共 API 時，你應該做兩件事：（1）更新你的文件讓使用者知道這個改變，（2）在適當的時機將棄用的功能透過新的次版號發佈。在新的主版本完全移除棄用功能前，至少要有一個次版本包含這個棄用資訊，這樣使用者才能平順地轉移到新版 API。\n語意化版本對於版本的字串長度是否有限制呢？\n沒有，請自行做適當的判斷。舉例來說，長到 255 個字元的版本已過度誇張。再者，特定的系統對於字串長度可能會有他們自己的限制。\n不，”v1.2.3” 不是語意化版本。然而在語意化版本前加上 “v” 表示其為版本號是很常見的做法（就英文而言）。用 “v” 表示 “version” 的縮寫是版本控制的常見做法。例如：git tag v1.2.3 -m "Release version 1.2.3"，此例 “v1.2.3” 是標籤名稱，而語意化版本是 “1.2.3”。\n有建議用於檢查語意化版本的正規表示式（RegEx）嗎？\n有兩種。一種用命名群組，須在支援的系統上使用（PCRE [Perl Compatible Regular Expressions, i.e. Perl, PHP and R]、Python、以及 Go）。\n參見：https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n另一種使用擷取群組編號（組1 = 主版號，組2 = 次版號，組3 = 修訂號，組4 = 先行版號，組5 = 編譯資訊），與 ECMA Script (JavaScript)、PCRE (Perl Compatible Regular Expressions, i.e. Perl, PHP and R)、Python、以及 Go 相容。\n參見：https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n語意化版本控制的規範最初是由 Gravatars 創辦者兼 GitHub 共同創辦者 Tom Preston-Werner 建立。\n如果您有任何建議，請到 GitHub 上提出問題。\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSemantic Versioning 2.0.0

Summary

Given a version number MAJOR.MINOR.PATCH, increment the:


  MAJOR version when you make incompatible API changes
  MINOR version when you add functionality in a backward compatible
manner
  PATCH version when you make backward compatible bug fixes


Additional labels for pre-release and build metadata are available as extensions
to the MAJOR.MINOR.PATCH format.

Introduction

In the world of software management there exists a dreaded place called
“dependency hell.” The bigger your system grows and the more packages you
integrate into your software, the more likely you are to find yourself, one
day, in this pit of despair.

In systems with many dependencies, releasing new package versions can quickly
become a nightmare. If the dependency specifications are too tight, you are in
danger of version lock (the inability to upgrade a package without having to
release new versions of every dependent package). If dependencies are
specified too loosely, you will inevitably be bitten by version promiscuity
(assuming compatibility with more future versions than is reasonable).
Dependency hell is where you are when version lock and/or version promiscuity
prevent you from easily and safely moving your project forward.

As a solution to this problem, we propose a simple set of rules and
requirements that dictate how version numbers are assigned and incremented.
These rules are based on but not necessarily limited to pre-existing
widespread common practices in use in both closed and open-source software.
For this system to work, you first need to declare a public API. This may
consist of documentation or be enforced by the code itself. Regardless, it is
important that this API be clear and precise. Once you identify your public
API, you communicate changes to it with specific increments to your version
number. Consider a version format of X.Y.Z (Major.Minor.Patch). Bug fixes not
affecting the API increment the patch version, backward compatible API
additions/changes increment the minor version, and backward incompatible API
changes increment the major version.

We call this system “Semantic Versioning.” Under this scheme, version numbers
and the way they change convey meaning about the underlying code and what has
been modified from one version to the next.

Semantic Versioning Specification (SemVer)

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,
“SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be
interpreted as described in RFC 2119.


  
    Software using Semantic Versioning MUST declare a public API. This API
could be declared in the code itself or exist strictly in documentation.
However it is done, it SHOULD be precise and comprehensive.
  
  
    A normal version number MUST take the form X.Y.Z where X, Y, and Z are
non-negative integers, and MUST NOT contain leading zeroes. X is the
major version, Y is the minor version, and Z is the patch version.
Each element MUST increase numerically. For instance: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Once a versioned package has been released, the contents of that version
MUST NOT be modified. Any modifications MUST be released as a new version.
  
  
    Major version zero (0.y.z) is for initial development. Anything MAY change
at any time. The public API SHOULD NOT be considered stable.
  
  
    Version 1.0.0 defines the public API. The way in which the version number
is incremented after this release is dependent on this public API and how it
changes.
  
  
    Patch version Z (x.y.Z | x > 0) MUST be incremented if only backward
compatible bug fixes are introduced. A bug fix is defined as an internal
change that fixes incorrect behavior.
  
  
    Minor version Y (x.Y.z | x > 0) MUST be incremented if new, backward
compatible functionality is introduced to the public API. It MUST be
incremented if any public API functionality is marked as deprecated. It MAY be
incremented if substantial new functionality or improvements are introduced
within the private code. It MAY include patch level changes. Patch version
MUST be reset to 0 when minor version is incremented.
  
  
    Major version X (X.y.z | X > 0) MUST be incremented if any backward
incompatible changes are introduced to the public API. It MAY also include minor
and patch level changes. Patch and minor versions MUST be reset to 0 when major
version is incremented.
  
  
    A pre-release version MAY be denoted by appending a hyphen and a
series of dot separated identifiers immediately following the patch
version. Identifiers MUST comprise only ASCII alphanumerics and hyphens
[0-9A-Za-z-]. Identifiers MUST NOT be empty. Numeric identifiers MUST
NOT include leading zeroes. Pre-release versions have a lower
precedence than the associated normal version. A pre-release version
indicates that the version is unstable and might not satisfy the
intended compatibility requirements as denoted by its associated
normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.--.
  
  
    Build metadata MAY be denoted by appending a plus sign and a series of dot
separated identifiers immediately following the patch or pre-release version.
Identifiers MUST comprise only ASCII alphanumerics and hyphens [0-9A-Za-z-].
Identifiers MUST NOT be empty. Build metadata MUST be ignored when determining
version precedence. Thus two versions that differ only in the build metadata,
have the same precedence. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3----117B344092BD.
  
  
    Precedence refers to how versions are compared to each other when ordered.

    
      
        Precedence MUST be calculated by separating the version into major,
minor, patch and pre-release identifiers in that order (Build metadata
does not figure into precedence).
      
      
        Precedence is determined by the first difference when comparing each of
these identifiers from left to right as follows: Major, minor, and patch
versions are always compared numerically.

        Example: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        When major, minor, and patch are equal, a pre-release version has lower
precedence than a normal version:

        Example: 1.0.0-alpha < 1.0.0.
      
      
        Precedence for two pre-release versions with the same major, minor, and
patch version MUST be determined by comparing each dot separated identifier
from left to right until a difference is found as follows:

        
          
            Identifiers consisting of only digits are compared numerically.
          
          
            Identifiers with letters or hyphens are compared lexically in ASCII
sort order.
          
          
            Numeric identifiers always have lower precedence than non-numeric
identifiers.
          
          
            A larger set of pre-release fields has a higher precedence than a
smaller set, if all of the preceding identifiers are equal.
          
        

        Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
      
    
  


Backus–Naur Form Grammar for Valid SemVer Versions
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


Why Use Semantic Versioning?

This is not a new or revolutionary idea. In fact, you probably do something
close to this already. The problem is that “close” isn’t good enough. Without
compliance to some sort of formal specification, version numbers are
essentially useless for dependency management. By giving a name and clear
definition to the above ideas, it becomes easy to communicate your intentions
to the users of your software. Once these intentions are clear, flexible (but
not too flexible) dependency specifications can finally be made.

A simple example will demonstrate how Semantic Versioning can make dependency
hell a thing of the past. Consider a library called “Firetruck.” It requires a
Semantically Versioned package named “Ladder.” At the time that Firetruck is
created, Ladder is at version 3.1.0. Since Firetruck uses some functionality
that was first introduced in 3.1.0, you can safely specify the Ladder
dependency as greater than or equal to 3.1.0 but less than 4.0.0. Now, when
Ladder version 3.1.1 and 3.2.0 become available, you can release them to your
package management system and know that they will be compatible with existing
dependent software.

As a responsible developer you will, of course, want to verify that any
package upgrades function as advertised. The real world is a messy place;
there’s nothing we can do about that but be vigilant. What you can do is let
Semantic Versioning provide you with a sane way to release and upgrade
packages without having to roll new versions of dependent packages, saving you
time and hassle.

If all of this sounds desirable, all you need to do to start using Semantic
Versioning is to declare that you are doing so and then follow the rules. Link
to this website from your README so others know the rules and can benefit from
them.

FAQ

How should I deal with revisions in the 0.y.z initial development phase?

The simplest thing to do is start your initial development release at 0.1.0
and then increment the minor version for each subsequent release.

How do I know when to release 1.0.0?

If your software is being used in production, it should probably already be
1.0.0. If you have a stable API on which users have come to depend, you should
be 1.0.0. If you’re worrying a lot about backward compatibility, you should
probably already be 1.0.0.

Doesn’t this discourage rapid development and fast iteration?

Major version zero is all about rapid development. If you’re changing the API
every day you should either still be in version 0.y.z or on a separate
development branch working on the next major version.

If even the tiniest backward incompatible changes to the public API require a major version bump, won’t I end up at version 42.0.0 very rapidly?

This is a question of responsible development and foresight. Incompatible
changes should not be introduced lightly to software that has a lot of
dependent code. The cost that must be incurred to upgrade can be significant.
Having to bump major versions to release incompatible changes means you’ll
think through the impact of your changes, and evaluate the cost/benefit ratio
involved.

Documenting the entire public API is too much work!

It is your responsibility as a professional developer to properly document
software that is intended for use by others. Managing software complexity is a
hugely important part of keeping a project efficient, and that’s hard to do if
nobody knows how to use your software, or what methods are safe to call. In
the long run, Semantic Versioning, and the insistence on a well defined public
API can keep everyone and everything running smoothly.

What do I do if I accidentally release a backward incompatible change as a minor version?

As soon as you realize that you’ve broken the Semantic Versioning spec, fix
the problem and release a new minor version that corrects the problem and
restores backward compatibility. Even under this circumstance, it is
unacceptable to modify versioned releases. If it’s appropriate,
document the offending version and inform your users of the problem so that
they are aware of the offending version.

What should I do if I update my own dependencies without changing the public API?

That would be considered compatible since it does not affect the public API.
Software that explicitly depends on the same dependencies as your package
should have their own dependency specifications and the author will notice any
conflicts. Determining whether the change is a patch level or minor level
modification depends on whether you updated your dependencies in order to fix
a bug or introduce new functionality. We would usually expect additional code
for the latter instance, in which case it’s obviously a minor level increment.

What if I inadvertently alter the public API in a way that is not compliant with the version number change (i.e. the code incorrectly introduces a major breaking change in a patch release)?

Use your best judgment. If you have a huge audience that will be drastically
impacted by changing the behavior back to what the public API intended, then
it may be best to perform a major version release, even though the fix could
strictly be considered a patch release. Remember, Semantic Versioning is all
about conveying meaning by how the version number changes. If these changes
are important to your users, use the version number to inform them.

How should I handle deprecating functionality?

Deprecating existing functionality is a normal part of software development and
is often required to make forward progress. When you deprecate part of your
public API, you should do two things: (1) update your documentation to let
users know about the change, (2) issue a new minor release with the deprecation
in place. Before you completely remove the functionality in a new major release
there should be at least one minor release that contains the deprecation so
that users can smoothly transition to the new API.

Does SemVer have a size limit on the version string?

No, but use good judgment. A 255 character version string is probably overkill,
for example. Also, specific systems may impose their own limits on the size of
the string.

Is “v1.2.3” a semantic version?

No, “v1.2.3” is not a semantic version. However, prefixing a semantic version
with a “v” is a common way (in English) to indicate it is a version number.
Abbreviating “version” as “v” is often seen with version control. Example:
git tag v1.2.3 -m "Release version 1.2.3", in which case “v1.2.3” is a tag
name and the semantic version is “1.2.3”.

Is there a suggested regular expression (RegEx) to check a SemVer string?

There are two. One with named groups for those systems that support them
(PCRE [Perl Compatible Regular Expressions, i.e. Perl, PHP and R], Python
and Go).

See: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


And one with numbered capture groups instead (so cg1 = major, cg2 = minor,
cg3 = patch, cg4 = prerelease and cg5 = buildmetadata) that is compatible
with ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
i.e. Perl, PHP and R), Python and Go.

See: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


About

The Semantic Versioning specification was originally authored by Tom
Preston-Werner, inventor of Gravatar and
cofounder of GitHub.

If you’d like to leave feedback, please open an issue on
GitHub.

License

Creative Commons ― CC BY 3.0\nSemantic Versioning 2.0.0\nGiven a version number MAJOR.MINOR.PATCH, increment the:\nMAJOR version when you make incompatible API changes\nMINOR version when you add functionality in a backward compatible
manner\nPATCH version when you make backward compatible bug fixes\nAdditional labels for pre-release and build metadata are available as extensions
to the MAJOR.MINOR.PATCH format.\nIn the world of software management there exists a dreaded place called
“dependency hell.” The bigger your system grows and the more packages you
integrate into your software, the more likely you are to find yourself, one
day, in this pit of despair.\nIn systems with many dependencies, releasing new package versions can quickly
become a nightmare. If the dependency specifications are too tight, you are in
danger of version lock (the inability to upgrade a package without having to
release new versions of every dependent package). If dependencies are
specified too loosely, you will inevitably be bitten by version promiscuity
(assuming compatibility with more future versions than is reasonable).
Dependency hell is where you are when version lock and/or version promiscuity
prevent you from easily and safely moving your project forward.\nAs a solution to this problem, we propose a simple set of rules and
requirements that dictate how version numbers are assigned and incremented.
These rules are based on but not necessarily limited to pre-existing
widespread common practices in use in both closed and open-source software.
For this system to work, you first need to declare a public API. This may
consist of documentation or be enforced by the code itself. Regardless, it is
important that this API be clear and precise. Once you identify your public
API, you communicate changes to it with specific increments to your version
number. Consider a version format of X.Y.Z (Major.Minor.Patch). Bug fixes not
affecting the API increment the patch version, backward compatible API
additions/changes increment the minor version, and backward incompatible API
changes increment the major version.\nWe call this system “Semantic Versioning.” Under this scheme, version numbers
and the way they change convey meaning about the underlying code and what has
been modified from one version to the next.\nSemantic Versioning Specification (SemVer)\nThe key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,
“SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be
interpreted as described in RFC 2119.\nSoftware using Semantic Versioning MUST declare a public API. This API
could be declared in the code itself or exist strictly in documentation.
However it is done, it SHOULD be precise and comprehensive.\nSoftware using Semantic Versioning MUST declare a public API. This API
could be declared in the code itself or exist strictly in documentation.
However it is done, it SHOULD be precise and comprehensive.\nA normal version number MUST take the form X.Y.Z where X, Y, and Z are
non-negative integers, and MUST NOT contain leading zeroes. X is the
major version, Y is the minor version, and Z is the patch version.
Each element MUST increase numerically. For instance: 1.9.0 -> 1.10.0 -> 1.11.0.\nA normal version number MUST take the form X.Y.Z where X, Y, and Z are
non-negative integers, and MUST NOT contain leading zeroes. X is the
major version, Y is the minor version, and Z is the patch version.
Each element MUST increase numerically. For instance: 1.9.0 -> 1.10.0 -> 1.11.0.\nOnce a versioned package has been released, the contents of that version
MUST NOT be modified. Any modifications MUST be released as a new version.\nOnce a versioned package has been released, the contents of that version
MUST NOT be modified. Any modifications MUST be released as a new version.\nMajor version zero (0.y.z) is for initial development. Anything MAY change
at any time. The public API SHOULD NOT be considered stable.\nMajor version zero (0.y.z) is for initial development. Anything MAY change
at any time. The public API SHOULD NOT be considered stable.\nVersion 1.0.0 defines the public API. The way in which the version number
is incremented after this release is dependent on this public API and how it
changes.\nVersion 1.0.0 defines the public API. The way in which the version number
is incremented after this release is dependent on this public API and how it
changes.\nPatch version Z (x.y.Z | x > 0) MUST be incremented if only backward
compatible bug fixes are introduced. A bug fix is defined as an internal
change that fixes incorrect behavior.\nPatch version Z (x.y.Z | x > 0) MUST be incremented if only backward
compatible bug fixes are introduced. A bug fix is defined as an internal
change that fixes incorrect behavior.\nMinor version Y (x.Y.z | x > 0) MUST be incremented if new, backward
compatible functionality is introduced to the public API. It MUST be
incremented if any public API functionality is marked as deprecated. It MAY be
incremented if substantial new functionality or improvements are introduced
within the private code. It MAY include patch level changes. Patch version
MUST be reset to 0 when minor version is incremented.\nMinor version Y (x.Y.z | x > 0) MUST be incremented if new, backward
compatible functionality is introduced to the public API. It MUST be
incremented if any public API functionality is marked as deprecated. It MAY be
incremented if substantial new functionality or improvements are introduced
within the private code. It MAY include patch level changes. Patch version
MUST be reset to 0 when minor version is incremented.\nMajor version X (X.y.z | X > 0) MUST be incremented if any backward
incompatible changes are introduced to the public API. It MAY also include minor
and patch level changes. Patch and minor versions MUST be reset to 0 when major
version is incremented.\nMajor version X (X.y.z | X > 0) MUST be incremented if any backward
incompatible changes are introduced to the public API. It MAY also include minor
and patch level changes. Patch and minor versions MUST be reset to 0 when major
version is incremented.\nA pre-release version MAY be denoted by appending a hyphen and a
series of dot separated identifiers immediately following the patch
version. Identifiers MUST comprise only ASCII alphanumerics and hyphens
[0-9A-Za-z-]. Identifiers MUST NOT be empty. Numeric identifiers MUST
NOT include leading zeroes. Pre-release versions have a lower
precedence than the associated normal version. A pre-release version
indicates that the version is unstable and might not satisfy the
intended compatibility requirements as denoted by its associated
normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.--.\nA pre-release version MAY be denoted by appending a hyphen and a
series of dot separated identifiers immediately following the patch
version. Identifiers MUST comprise only ASCII alphanumerics and hyphens
[0-9A-Za-z-]. Identifiers MUST NOT be empty. Numeric identifiers MUST
NOT include leading zeroes. Pre-release versions have a lower
precedence than the associated normal version. A pre-release version
indicates that the version is unstable and might not satisfy the
intended compatibility requirements as denoted by its associated
normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.--.\nBuild metadata MAY be denoted by appending a plus sign and a series of dot
separated identifiers immediately following the patch or pre-release version.
Identifiers MUST comprise only ASCII alphanumerics and hyphens [0-9A-Za-z-].
Identifiers MUST NOT be empty. Build metadata MUST be ignored when determining
version precedence. Thus two versions that differ only in the build metadata,
have the same precedence. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3----117B344092BD.\nBuild metadata MAY be denoted by appending a plus sign and a series of dot
separated identifiers immediately following the patch or pre-release version.
Identifiers MUST comprise only ASCII alphanumerics and hyphens [0-9A-Za-z-].
Identifiers MUST NOT be empty. Build metadata MUST be ignored when determining
version precedence. Thus two versions that differ only in the build metadata,
have the same precedence. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3----117B344092BD.\nPrecedence refers to how versions are compared to each other when ordered.

    
      
        Precedence MUST be calculated by separating the version into major,
minor, patch and pre-release identifiers in that order (Build metadata
does not figure into precedence).
      
      
        Precedence is determined by the first difference when comparing each of
these identifiers from left to right as follows: Major, minor, and patch
versions are always compared numerically.

        Example: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        When major, minor, and patch are equal, a pre-release version has lower
precedence than a normal version:

        Example: 1.0.0-alpha < 1.0.0.
      
      
        Precedence for two pre-release versions with the same major, minor, and
patch version MUST be determined by comparing each dot separated identifier
from left to right until a difference is found as follows:

        
          
            Identifiers consisting of only digits are compared numerically.
          
          
            Identifiers with letters or hyphens are compared lexically in ASCII
sort order.
          
          
            Numeric identifiers always have lower precedence than non-numeric
identifiers.
          
          
            A larger set of pre-release fields has a higher precedence than a
smaller set, if all of the preceding identifiers are equal.
          
        

        Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPrecedence refers to how versions are compared to each other when ordered.\nPrecedence MUST be calculated by separating the version into major,
minor, patch and pre-release identifiers in that order (Build metadata
does not figure into precedence).\nPrecedence MUST be calculated by separating the version into major,
minor, patch and pre-release identifiers in that order (Build metadata
does not figure into precedence).\nPrecedence is determined by the first difference when comparing each of
these identifiers from left to right as follows: Major, minor, and patch
versions are always compared numerically.

        Example: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nPrecedence is determined by the first difference when comparing each of
these identifiers from left to right as follows: Major, minor, and patch
versions are always compared numerically.\nExample: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nWhen major, minor, and patch are equal, a pre-release version has lower
precedence than a normal version:

        Example: 1.0.0-alpha < 1.0.0.\nWhen major, minor, and patch are equal, a pre-release version has lower
precedence than a normal version:\nExample: 1.0.0-alpha < 1.0.0.\nPrecedence for two pre-release versions with the same major, minor, and
patch version MUST be determined by comparing each dot separated identifier
from left to right until a difference is found as follows:

        
          
            Identifiers consisting of only digits are compared numerically.
          
          
            Identifiers with letters or hyphens are compared lexically in ASCII
sort order.
          
          
            Numeric identifiers always have lower precedence than non-numeric
identifiers.
          
          
            A larger set of pre-release fields has a higher precedence than a
smaller set, if all of the preceding identifiers are equal.
          
        

        Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPrecedence for two pre-release versions with the same major, minor, and
patch version MUST be determined by comparing each dot separated identifier
from left to right until a difference is found as follows:\nIdentifiers consisting of only digits are compared numerically.\nIdentifiers consisting of only digits are compared numerically.\nIdentifiers with letters or hyphens are compared lexically in ASCII
sort order.\nIdentifiers with letters or hyphens are compared lexically in ASCII
sort order.\nNumeric identifiers always have lower precedence than non-numeric
identifiers.\nNumeric identifiers always have lower precedence than non-numeric
identifiers.\nA larger set of pre-release fields has a higher precedence than a
smaller set, if all of the preceding identifiers are equal.\nA larger set of pre-release fields has a higher precedence than a
smaller set, if all of the preceding identifiers are equal.\nExample: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nBackus–Naur Form Grammar for Valid SemVer Versions\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nWhy Use Semantic Versioning?\nThis is not a new or revolutionary idea. In fact, you probably do something
close to this already. The problem is that “close” isn’t good enough. Without
compliance to some sort of formal specification, version numbers are
essentially useless for dependency management. By giving a name and clear
definition to the above ideas, it becomes easy to communicate your intentions
to the users of your software. Once these intentions are clear, flexible (but
not too flexible) dependency specifications can finally be made.\nA simple example will demonstrate how Semantic Versioning can make dependency
hell a thing of the past. Consider a library called “Firetruck.” It requires a
Semantically Versioned package named “Ladder.” At the time that Firetruck is
created, Ladder is at version 3.1.0. Since Firetruck uses some functionality
that was first introduced in 3.1.0, you can safely specify the Ladder
dependency as greater than or equal to 3.1.0 but less than 4.0.0. Now, when
Ladder version 3.1.1 and 3.2.0 become available, you can release them to your
package management system and know that they will be compatible with existing
dependent software.\nAs a responsible developer you will, of course, want to verify that any
package upgrades function as advertised. The real world is a messy place;
there’s nothing we can do about that but be vigilant. What you can do is let
Semantic Versioning provide you with a sane way to release and upgrade
packages without having to roll new versions of dependent packages, saving you
time and hassle.\nIf all of this sounds desirable, all you need to do to start using Semantic
Versioning is to declare that you are doing so and then follow the rules. Link
to this website from your README so others know the rules and can benefit from
them.\nHow should I deal with revisions in the 0.y.z initial development phase?\nThe simplest thing to do is start your initial development release at 0.1.0
and then increment the minor version for each subsequent release.\nHow do I know when to release 1.0.0?\nIf your software is being used in production, it should probably already be
1.0.0. If you have a stable API on which users have come to depend, you should
be 1.0.0. If you’re worrying a lot about backward compatibility, you should
probably already be 1.0.0.\nDoesn’t this discourage rapid development and fast iteration?\nMajor version zero is all about rapid development. If you’re changing the API
every day you should either still be in version 0.y.z or on a separate
development branch working on the next major version.\nIf even the tiniest backward incompatible changes to the public API require a major version bump, won’t I end up at version 42.0.0 very rapidly?\nThis is a question of responsible development and foresight. Incompatible
changes should not be introduced lightly to software that has a lot of
dependent code. The cost that must be incurred to upgrade can be significant.
Having to bump major versions to release incompatible changes means you’ll
think through the impact of your changes, and evaluate the cost/benefit ratio
involved.\nDocumenting the entire public API is too much work!\nIt is your responsibility as a professional developer to properly document
software that is intended for use by others. Managing software complexity is a
hugely important part of keeping a project efficient, and that’s hard to do if
nobody knows how to use your software, or what methods are safe to call. In
the long run, Semantic Versioning, and the insistence on a well defined public
API can keep everyone and everything running smoothly.\nWhat do I do if I accidentally release a backward incompatible change as a minor version?\nAs soon as you realize that you’ve broken the Semantic Versioning spec, fix
the problem and release a new minor version that corrects the problem and
restores backward compatibility. Even under this circumstance, it is
unacceptable to modify versioned releases. If it’s appropriate,
document the offending version and inform your users of the problem so that
they are aware of the offending version.\nWhat should I do if I update my own dependencies without changing the public API?\nThat would be considered compatible since it does not affect the public API.
Software that explicitly depends on the same dependencies as your package
should have their own dependency specifications and the author will notice any
conflicts. Determining whether the change is a patch level or minor level
modification depends on whether you updated your dependencies in order to fix
a bug or introduce new functionality. We would usually expect additional code
for the latter instance, in which case it’s obviously a minor level increment.\nWhat if I inadvertently alter the public API in a way that is not compliant with the version number change (i.e. the code incorrectly introduces a major breaking change in a patch release)?\nUse your best judgment. If you have a huge audience that will be drastically
impacted by changing the behavior back to what the public API intended, then
it may be best to perform a major version release, even though the fix could
strictly be considered a patch release. Remember, Semantic Versioning is all
about conveying meaning by how the version number changes. If these changes
are important to your users, use the version number to inform them.\nHow should I handle deprecating functionality?\nDeprecating existing functionality is a normal part of software development and
is often required to make forward progress. When you deprecate part of your
public API, you should do two things: (1) update your documentation to let
users know about the change, (2) issue a new minor release with the deprecation
in place. Before you completely remove the functionality in a new major release
there should be at least one minor release that contains the deprecation so
that users can smoothly transition to the new API.\nDoes SemVer have a size limit on the version string?\nNo, but use good judgment. A 255 character version string is probably overkill,
for example. Also, specific systems may impose their own limits on the size of
the string.\nIs “v1.2.3” a semantic version?\nNo, “v1.2.3” is not a semantic version. However, prefixing a semantic version
with a “v” is a common way (in English) to indicate it is a version number.
Abbreviating “version” as “v” is often seen with version control. Example:
git tag v1.2.3 -m "Release version 1.2.3", in which case “v1.2.3” is a tag
name and the semantic version is “1.2.3”.\nIs there a suggested regular expression (RegEx) to check a SemVer string?\nThere are two. One with named groups for those systems that support them
(PCRE [Perl Compatible Regular Expressions, i.e. Perl, PHP and R], Python
and Go).\nSee: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nAnd one with numbered capture groups instead (so cg1 = major, cg2 = minor,
cg3 = patch, cg4 = prerelease and cg5 = buildmetadata) that is compatible
with ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
i.e. Perl, PHP and R), Python and Go.\nSee: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nThe Semantic Versioning specification was originally authored by Tom
Preston-Werner, inventor of Gravatar and
cofounder of GitHub.\nIf you’d like to leave feedback, please open an issue on
GitHub.\nopen an issue on
GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSemantic Versioning 2.0.0-rc.2

In the world of software management there exists a dread place called
“dependency hell.” The bigger your system grows and the more packages you
integrate into your software, the more likely you are to find yourself, one
day, in this pit of despair.

In systems with many dependencies, releasing new package versions can quickly
become a nightmare. If the dependency specifications are too tight, you are in
danger of version lock (the inability to upgrade a package without having to
release new versions of every dependent package). If dependencies are
specified too loosely, you will inevitably be bitten by version promiscuity
(assuming compatibility with more future versions than is reasonable).
Dependency hell is where you are when version lock and/or version promiscuity
prevent you from easily and safely moving your project forward.

As a solution to this problem, I propose a simple set of rules and
requirements that dictate how version numbers are assigned and incremented.
For this system to work, you first need to declare a public API. This may
consist of documentation or be enforced by the code itself. Regardless, it is
important that this API be clear and precise. Once you identify your public
API, you communicate changes to it with specific increments to your version
number. Consider a version format of X.Y.Z (Major.Minor.Patch). Bug fixes not
affecting the API increment the patch version, backwards compatible API
additions/changes increment the minor version, and backwards incompatible API
changes increment the major version.

I call this system “Semantic Versioning.” Under this scheme, version numbers
and the way they change convey meaning about the underlying code and what has
been modified from one version to the next.

Semantic Versioning Specification (SemVer)

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,
“SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be
interpreted as described in RFC 2119.


  
    Software using Semantic Versioning MUST declare a public API. This API
could be declared in the code itself or exist strictly in documentation.
However it is done, it should be precise and comprehensive.
  
  
    A normal version number MUST take the form X.Y.Z where X, Y, and Z are
non-negative integers. X is the major version, Y is the minor version, and Z
is the patch version. Each element MUST increase numerically by increments of
one. For instance: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Once a versioned package has been released, the contents of that version
MUST NOT be modified. Any modifications MUST be released as a new version.
  
  
    Major version zero (0.y.z) is for initial development. Anything may change
at any time. The public API should not be considered stable.
  
  
    Version 1.0.0 defines the public API. The way in which the version number
is incremented after this release is dependent on this public API and how it
changes.
  
  
    Patch version Z (x.y.Z | x > 0) MUST be incremented if only backwards
compatible bug fixes are introduced. A bug fix is defined as an internal
change that fixes incorrect behavior.
  
  
    Minor version Y (x.Y.z | x > 0) MUST be incremented if new, backwards
compatible functionality is introduced to the public API. It MUST be
incremented if any public API functionality is marked as deprecated. It MAY be
incremented if substantial new functionality or improvements are introduced
within the private code. It MAY include patch level changes. Patch version
MUST be reset to 0 when minor version is incremented.
  
  
    Major version X (X.y.z | X > 0) MUST be incremented if any backwards
incompatible changes are introduced to the public API. It MAY include minor
and patch level changes. Patch and minor version MUST be reset to 0 when major
version is incremented.
  
  
    A pre-release version MAY be denoted by appending a hyphen and a series of
dot separated identifiers immediately following the patch version. Identifiers
MUST comprise only ASCII alphanumerics and hyphen [0-9A-Za-z-]. Pre-release
versions satisfy but have a lower precedence than the associated normal
version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Build metadata MAY be denoted by appending a plus sign and a series of dot
separated identifiers immediately following the patch or pre-release version.
Identifiers MUST comprise only ASCII alphanumerics and hyphen [0-9A-Za-z-].
Build metadata SHOULD be ignored when determining version precedence. Thus two
packages with the same version, but different build metadata are considered to
be the same version. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85.
  
  
    Precedence MUST be calculated by separating the version into major, minor,
patch and pre-release identifiers in that order (Build metadata does not figure
into precedence). Major, minor, and patch versions are always compared
numerically. Pre-release precedence MUST be determined by comparing each dot
separated identifier as follows: identifiers consisting of only digits are
compared numerically and identifiers with letters or hyphens are compared
lexically in ASCII sort order. Numeric identifiers always have lower precedence
than non-numeric identifiers. Example: 1.0.0-alpha < 1.0.0-alpha.1 <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Why Use Semantic Versioning?

This is not a new or revolutionary idea. In fact, you probably do something
close to this already. The problem is that “close” isn’t good enough. Without
compliance to some sort of formal specification, version numbers are
essentially useless for dependency management. By giving a name and clear
definition to the above ideas, it becomes easy to communicate your intentions
to the users of your software. Once these intentions are clear, flexible (but
not too flexible) dependency specifications can finally be made.

A simple example will demonstrate how Semantic Versioning can make dependency
hell a thing of the past. Consider a library called “Firetruck.” It requires a
Semantically Versioned package named “Ladder.” At the time that Firetruck is
created, Ladder is at version 3.1.0. Since Firetruck uses some functionality
that was first introduced in 3.1.0, you can safely specify the Ladder
dependency as greater than or equal to 3.1.0 but less than 4.0.0. Now, when
Ladder version 3.1.1 and 3.2.0 become available, you can release them to your
package management system and know that they will be compatible with existing
dependent software.

As a responsible developer you will, of course, want to verify that any
package upgrades function as advertised. The real world is a messy place;
there’s nothing we can do about that but be vigilant. What you can do is let
Semantic Versioning provide you with a sane way to release and upgrade
packages without having to roll new versions of dependent packages, saving you
time and hassle.

If all of this sounds desirable, all you need to do to start using Semantic
Versioning is to declare that you are doing so and then follow the rules. Link
to this website from your README so others know the rules and can benefit from
them.

FAQ

How should I deal with revisions in the 0.y.z initial development phase?

The simplest thing to do is start your initial development release at 0.1.0
and then increment the minor version for each subsequent release.

How do I know when to release 1.0.0?

If your software is being used in production, it should probably already be
1.0.0. If you have a stable API on which users have come to depend, you should
be 1.0.0. If you’re worrying a lot about backwards compatibility, you should
probably already be 1.0.0.

Doesn’t this discourage rapid development and fast iteration?

Major version zero is all about rapid development. If you’re changing the API
every day you should either still be in version 0.y.z or on a separate
development branch working on the next major version.

If even the tiniest backwards incompatible changes to the public API require a major version bump, won’t I end up at version 42.0.0 very rapidly?

This is a question of responsible development and foresight. Incompatible
changes should not be introduced lightly to software that has a lot of
dependent code. The cost that must be incurred to upgrade can be significant.
Having to bump major versions to release incompatible changes means you’ll
think through the impact of your changes, and evaluate the cost/benefit ratio
involved.

Documenting the entire public API is too much work!

It is your responsibility as a professional developer to properly document
software that is intended for use by others. Managing software complexity is a
hugely important part of keeping a project efficient, and that’s hard to do if
nobody knows how to use your software, or what methods are safe to call. In
the long run, Semantic Versioning, and the insistence on a well defined public
API can keep everyone and everything running smoothly.

What do I do if I accidentally release a backwards incompatible change as a minor version?

As soon as you realize that you’ve broken the Semantic Versioning spec, fix
the problem and release a new minor version that corrects the problem and
restores backwards compatibility. Even under this circumstance, it is
unacceptable to modify versioned releases. If it’s appropriate,
document the offending version and inform your users of the problem so that
they are aware of the offending version.

What should I do if I update my own dependencies without changing the public API?

That would be considered compatible since it does not affect the public API.
Software that explicitly depends on the same dependencies as your package
should have their own dependency specifications and the author will notice any
conflicts. Determining whether the change is a patch level or minor level
modification depends on whether you updated your dependencies in order to fix
a bug or introduce new functionality. I would usually expect additional code
for the latter instance, in which case it’s obviously a minor level increment.

What should I do if the bug that is being fixed returns the code to being compliant with the public API (i.e. the code was incorrectly out of sync with the public API documentation)?

Use your best judgment. If you have a huge audience that will be drastically
impacted by changing the behavior back to what the public API intended, then
it may be best to perform a major version release, even though the fix could
strictly be considered a patch release. Remember, Semantic Versioning is all
about conveying meaning by how the version number changes. If these changes
are important to your users, use the version number to inform them.

How should I handle deprecating functionality?

Deprecating existing functionality is a normal part of software development and
is often required to make forward progress. When you deprecate part of your
public API, you should do two things: (1) update your documentation to let
users know about the change, (2) issue a new minor release with the deprecation
in place. Before you completely remove the functionality in a new major release
there should be at least one minor release that contains the deprecation so
that users can smoothly transition to the new API.

About

The Semantic Versioning specification is authored by Tom
Preston-Werner, inventor of Gravatars and
cofounder of GitHub.

If you’d like to leave feedback, please open an issue on
GitHub.

License

Creative Commons ― CC BY 3.0
http://creativecommons.org/licenses/by/3.0/\nSemantic Versioning 2.0.0-rc.2\nIn the world of software management there exists a dread place called
“dependency hell.” The bigger your system grows and the more packages you
integrate into your software, the more likely you are to find yourself, one
day, in this pit of despair.\nIn systems with many dependencies, releasing new package versions can quickly
become a nightmare. If the dependency specifications are too tight, you are in
danger of version lock (the inability to upgrade a package without having to
release new versions of every dependent package). If dependencies are
specified too loosely, you will inevitably be bitten by version promiscuity
(assuming compatibility with more future versions than is reasonable).
Dependency hell is where you are when version lock and/or version promiscuity
prevent you from easily and safely moving your project forward.\nAs a solution to this problem, I propose a simple set of rules and
requirements that dictate how version numbers are assigned and incremented.
For this system to work, you first need to declare a public API. This may
consist of documentation or be enforced by the code itself. Regardless, it is
important that this API be clear and precise. Once you identify your public
API, you communicate changes to it with specific increments to your version
number. Consider a version format of X.Y.Z (Major.Minor.Patch). Bug fixes not
affecting the API increment the patch version, backwards compatible API
additions/changes increment the minor version, and backwards incompatible API
changes increment the major version.\nI call this system “Semantic Versioning.” Under this scheme, version numbers
and the way they change convey meaning about the underlying code and what has
been modified from one version to the next.\nSemantic Versioning Specification (SemVer)\nThe key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,
“SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be
interpreted as described in RFC 2119.\nSoftware using Semantic Versioning MUST declare a public API. This API
could be declared in the code itself or exist strictly in documentation.
However it is done, it should be precise and comprehensive.\nSoftware using Semantic Versioning MUST declare a public API. This API
could be declared in the code itself or exist strictly in documentation.
However it is done, it should be precise and comprehensive.\nA normal version number MUST take the form X.Y.Z where X, Y, and Z are
non-negative integers. X is the major version, Y is the minor version, and Z
is the patch version. Each element MUST increase numerically by increments of
one. For instance: 1.9.0 -> 1.10.0 -> 1.11.0.\nA normal version number MUST take the form X.Y.Z where X, Y, and Z are
non-negative integers. X is the major version, Y is the minor version, and Z
is the patch version. Each element MUST increase numerically by increments of
one. For instance: 1.9.0 -> 1.10.0 -> 1.11.0.\nOnce a versioned package has been released, the contents of that version
MUST NOT be modified. Any modifications MUST be released as a new version.\nOnce a versioned package has been released, the contents of that version
MUST NOT be modified. Any modifications MUST be released as a new version.\nMajor version zero (0.y.z) is for initial development. Anything may change
at any time. The public API should not be considered stable.\nMajor version zero (0.y.z) is for initial development. Anything may change
at any time. The public API should not be considered stable.\nVersion 1.0.0 defines the public API. The way in which the version number
is incremented after this release is dependent on this public API and how it
changes.\nVersion 1.0.0 defines the public API. The way in which the version number
is incremented after this release is dependent on this public API and how it
changes.\nPatch version Z (x.y.Z | x > 0) MUST be incremented if only backwards
compatible bug fixes are introduced. A bug fix is defined as an internal
change that fixes incorrect behavior.\nPatch version Z (x.y.Z | x > 0) MUST be incremented if only backwards
compatible bug fixes are introduced. A bug fix is defined as an internal
change that fixes incorrect behavior.\nMinor version Y (x.Y.z | x > 0) MUST be incremented if new, backwards
compatible functionality is introduced to the public API. It MUST be
incremented if any public API functionality is marked as deprecated. It MAY be
incremented if substantial new functionality or improvements are introduced
within the private code. It MAY include patch level changes. Patch version
MUST be reset to 0 when minor version is incremented.\nMinor version Y (x.Y.z | x > 0) MUST be incremented if new, backwards
compatible functionality is introduced to the public API. It MUST be
incremented if any public API functionality is marked as deprecated. It MAY be
incremented if substantial new functionality or improvements are introduced
within the private code. It MAY include patch level changes. Patch version
MUST be reset to 0 when minor version is incremented.\nMajor version X (X.y.z | X > 0) MUST be incremented if any backwards
incompatible changes are introduced to the public API. It MAY include minor
and patch level changes. Patch and minor version MUST be reset to 0 when major
version is incremented.\nMajor version X (X.y.z | X > 0) MUST be incremented if any backwards
incompatible changes are introduced to the public API. It MAY include minor
and patch level changes. Patch and minor version MUST be reset to 0 when major
version is incremented.\nA pre-release version MAY be denoted by appending a hyphen and a series of
dot separated identifiers immediately following the patch version. Identifiers
MUST comprise only ASCII alphanumerics and hyphen [0-9A-Za-z-]. Pre-release
versions satisfy but have a lower precedence than the associated normal
version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nA pre-release version MAY be denoted by appending a hyphen and a series of
dot separated identifiers immediately following the patch version. Identifiers
MUST comprise only ASCII alphanumerics and hyphen [0-9A-Za-z-]. Pre-release
versions satisfy but have a lower precedence than the associated normal
version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nBuild metadata MAY be denoted by appending a plus sign and a series of dot
separated identifiers immediately following the patch or pre-release version.
Identifiers MUST comprise only ASCII alphanumerics and hyphen [0-9A-Za-z-].
Build metadata SHOULD be ignored when determining version precedence. Thus two
packages with the same version, but different build metadata are considered to
be the same version. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85.\nBuild metadata MAY be denoted by appending a plus sign and a series of dot
separated identifiers immediately following the patch or pre-release version.
Identifiers MUST comprise only ASCII alphanumerics and hyphen [0-9A-Za-z-].
Build metadata SHOULD be ignored when determining version precedence. Thus two
packages with the same version, but different build metadata are considered to
be the same version. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85.\nPrecedence MUST be calculated by separating the version into major, minor,
patch and pre-release identifiers in that order (Build metadata does not figure
into precedence). Major, minor, and patch versions are always compared
numerically. Pre-release precedence MUST be determined by comparing each dot
separated identifier as follows: identifiers consisting of only digits are
compared numerically and identifiers with letters or hyphens are compared
lexically in ASCII sort order. Numeric identifiers always have lower precedence
than non-numeric identifiers. Example: 1.0.0-alpha < 1.0.0-alpha.1 <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPrecedence MUST be calculated by separating the version into major, minor,
patch and pre-release identifiers in that order (Build metadata does not figure
into precedence). Major, minor, and patch versions are always compared
numerically. Pre-release precedence MUST be determined by comparing each dot
separated identifier as follows: identifiers consisting of only digits are
compared numerically and identifiers with letters or hyphens are compared
lexically in ASCII sort order. Numeric identifiers always have lower precedence
than non-numeric identifiers. Example: 1.0.0-alpha < 1.0.0-alpha.1 <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nWhy Use Semantic Versioning?\nThis is not a new or revolutionary idea. In fact, you probably do something
close to this already. The problem is that “close” isn’t good enough. Without
compliance to some sort of formal specification, version numbers are
essentially useless for dependency management. By giving a name and clear
definition to the above ideas, it becomes easy to communicate your intentions
to the users of your software. Once these intentions are clear, flexible (but
not too flexible) dependency specifications can finally be made.\nA simple example will demonstrate how Semantic Versioning can make dependency
hell a thing of the past. Consider a library called “Firetruck.” It requires a
Semantically Versioned package named “Ladder.” At the time that Firetruck is
created, Ladder is at version 3.1.0. Since Firetruck uses some functionality
that was first introduced in 3.1.0, you can safely specify the Ladder
dependency as greater than or equal to 3.1.0 but less than 4.0.0. Now, when
Ladder version 3.1.1 and 3.2.0 become available, you can release them to your
package management system and know that they will be compatible with existing
dependent software.\nAs a responsible developer you will, of course, want to verify that any
package upgrades function as advertised. The real world is a messy place;
there’s nothing we can do about that but be vigilant. What you can do is let
Semantic Versioning provide you with a sane way to release and upgrade
packages without having to roll new versions of dependent packages, saving you
time and hassle.\nIf all of this sounds desirable, all you need to do to start using Semantic
Versioning is to declare that you are doing so and then follow the rules. Link
to this website from your README so others know the rules and can benefit from
them.\nHow should I deal with revisions in the 0.y.z initial development phase?\nThe simplest thing to do is start your initial development release at 0.1.0
and then increment the minor version for each subsequent release.\nHow do I know when to release 1.0.0?\nIf your software is being used in production, it should probably already be
1.0.0. If you have a stable API on which users have come to depend, you should
be 1.0.0. If you’re worrying a lot about backwards compatibility, you should
probably already be 1.0.0.\nDoesn’t this discourage rapid development and fast iteration?\nMajor version zero is all about rapid development. If you’re changing the API
every day you should either still be in version 0.y.z or on a separate
development branch working on the next major version.\nIf even the tiniest backwards incompatible changes to the public API require a major version bump, won’t I end up at version 42.0.0 very rapidly?\nThis is a question of responsible development and foresight. Incompatible
changes should not be introduced lightly to software that has a lot of
dependent code. The cost that must be incurred to upgrade can be significant.
Having to bump major versions to release incompatible changes means you’ll
think through the impact of your changes, and evaluate the cost/benefit ratio
involved.\nDocumenting the entire public API is too much work!\nIt is your responsibility as a professional developer to properly document
software that is intended for use by others. Managing software complexity is a
hugely important part of keeping a project efficient, and that’s hard to do if
nobody knows how to use your software, or what methods are safe to call. In
the long run, Semantic Versioning, and the insistence on a well defined public
API can keep everyone and everything running smoothly.\nWhat do I do if I accidentally release a backwards incompatible change as a minor version?\nAs soon as you realize that you’ve broken the Semantic Versioning spec, fix
the problem and release a new minor version that corrects the problem and
restores backwards compatibility. Even under this circumstance, it is
unacceptable to modify versioned releases. If it’s appropriate,
document the offending version and inform your users of the problem so that
they are aware of the offending version.\nWhat should I do if I update my own dependencies without changing the public API?\nThat would be considered compatible since it does not affect the public API.
Software that explicitly depends on the same dependencies as your package
should have their own dependency specifications and the author will notice any
conflicts. Determining whether the change is a patch level or minor level
modification depends on whether you updated your dependencies in order to fix
a bug or introduce new functionality. I would usually expect additional code
for the latter instance, in which case it’s obviously a minor level increment.\nWhat should I do if the bug that is being fixed returns the code to being compliant with the public API (i.e. the code was incorrectly out of sync with the public API documentation)?\nUse your best judgment. If you have a huge audience that will be drastically
impacted by changing the behavior back to what the public API intended, then
it may be best to perform a major version release, even though the fix could
strictly be considered a patch release. Remember, Semantic Versioning is all
about conveying meaning by how the version number changes. If these changes
are important to your users, use the version number to inform them.\nHow should I handle deprecating functionality?\nDeprecating existing functionality is a normal part of software development and
is often required to make forward progress. When you deprecate part of your
public API, you should do two things: (1) update your documentation to let
users know about the change, (2) issue a new minor release with the deprecation
in place. Before you completely remove the functionality in a new major release
there should be at least one minor release that contains the deprecation so
that users can smoothly transition to the new API.\nThe Semantic Versioning specification is authored by Tom
Preston-Werner, inventor of Gravatars and
cofounder of GitHub.\nIf you’d like to leave feedback, please open an issue on
GitHub.\nopen an issue on
GitHub\nCreative Commons ― CC BY 3.0
http://creativecommons.org/licenses/by/3.0/\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSemantic Versioning 2.0.0-rc.1

In the world of software management there exists a dread place called
“dependency hell.” The bigger your system grows and the more packages you
integrate into your software, the more likely you are to find yourself, one
day, in this pit of despair.

In systems with many dependencies, releasing new package versions can quickly
become a nightmare. If the dependency specifications are too tight, you are in
danger of version lock (the inability to upgrade a package without having to
release new versions of every dependent package). If dependencies are
specified too loosely, you will inevitably be bitten by version promiscuity
(assuming compatibility with more future versions than is reasonable).
Dependency hell is where you are when version lock and/or version promiscuity
prevent you from easily and safely moving your project forward.

As a solution to this problem, I propose a simple set of rules and
requirements that dictate how version numbers are assigned and incremented.
For this system to work, you first need to declare a public API. This may
consist of documentation or be enforced by the code itself. Regardless, it is
important that this API be clear and precise. Once you identify your public
API, you communicate changes to it with specific increments to your version
number. Consider a version format of X.Y.Z (Major.Minor.Patch). Bug fixes not
affecting the API increment the patch version, backwards compatible API
additions/changes increment the minor version, and backwards incompatible API
changes increment the major version.

I call this system “Semantic Versioning.” Under this scheme, version numbers
and the way they change convey meaning about the underlying code and what has
been modified from one version to the next.

Semantic Versioning Specification (SemVer)

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,
“SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be
interpreted as described in RFC 2119.


  
    Software using Semantic Versioning MUST declare a public API. This API
could be declared in the code itself or exist strictly in documentation.
However it is done, it should be precise and comprehensive.
  
  
    A normal version number MUST take the form X.Y.Z where X, Y, and Z are
non-negative integers. X is the major version, Y is the minor version, and Z
is the patch version. Each element MUST increase numerically by increments of
one. For instance: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    When a major version number is incremented, the minor version and patch
version MUST be reset to zero. When a minor version number is incremented, the
patch version MUST be reset to zero. For instance: 1.1.3 -> 2.0.0 and 2.1.7 ->
2.2.0.
  
  
    Once a versioned package has been released, the contents of that version
MUST NOT be modified. Any modifications must be released as a new version.
  
  
    Major version zero (0.y.z) is for initial development. Anything may change
at any time. The public API should not be considered stable.
  
  
    Version 1.0.0 defines the public API. The way in which the version number
is incremented after this release is dependent on this public API and how it
changes.
  
  
    Patch version Z (x.y.Z | x > 0) MUST be incremented if only backwards
compatible bug fixes are introduced. A bug fix is defined as an internal
change that fixes incorrect behavior.
  
  
    Minor version Y (x.Y.z | x > 0) MUST be incremented if new, backwards
compatible functionality is introduced to the public API. It MUST be
incremented if any public API functionality is marked as deprecated. It MAY be
incremented if substantial new functionality or improvements are introduced
within the private code. It MAY include patch level changes. Patch version
MUST be reset to 0 when minor version is incremented.
  
  
    Major version X (X.y.z | X > 0) MUST be incremented if any backwards
incompatible changes are introduced to the public API. It MAY include minor
and patch level changes. Patch and minor version MUST be reset to 0 when major
version is incremented.
  
  
    A pre-release version MAY be denoted by appending a dash and a series of
dot separated identifiers immediately following the patch version. Identifiers
MUST be comprised of only ASCII alphanumerics and dash [0-9A-Za-z-].
Pre-release versions satisfy but have a lower precedence than the associated
normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.
  
  
    A build version MAY be denoted by appending a plus sign and a series of dot
separated identifiers immediately following the patch version or pre-release
version. Identifiers MUST be comprised of only ASCII alphanumerics and dash
[0-9A-Za-z-]. Build versions satisfy and have a higher precedence than the
associated normal version. Examples: 1.0.0+build.1, 1.3.7+build.11.e0f985a.
  
  
    Precedence MUST be calculated by separating the version into major, minor,
patch, pre-release, and build identifiers in that order. Major, minor, and
patch versions are always compared numerically. Pre-release and build version
precedence MUST be determined by comparing each dot separated identifier as
follows: identifiers consisting of only digits are compared numerically and
identifiers with letters or dashes are compared lexically in ASCII sort order.
Numeric identifiers always have lower precedence than non-numeric identifiers.
Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta.2 < 1.0.0-beta.11 <
1.0.0-rc.1 < 1.0.0-rc.1+build.1 < 1.0.0 < 1.0.0+0.3.7 < 1.3.7+build <
1.3.7+build.2.b8f12d7 < 1.3.7+build.11.e0f985a.
  


Why Use Semantic Versioning?

This is not a new or revolutionary idea. In fact, you probably do something
close to this already. The problem is that “close” isn’t good enough. Without
compliance to some sort of formal specification, version numbers are
essentially useless for dependency management. By giving a name and clear
definition to the above ideas, it becomes easy to communicate your intentions
to the users of your software. Once these intentions are clear, flexible (but
not too flexible) dependency specifications can finally be made.

A simple example will demonstrate how Semantic Versioning can make dependency
hell a thing of the past. Consider a library called “Firetruck.” It requires a
Semantically Versioned package named “Ladder.” At the time that Firetruck is
created, Ladder is at version 3.1.0. Since Firetruck uses some functionality
that was first introduced in 3.1.0, you can safely specify the Ladder
dependency as greater than or equal to 3.1.0 but less than 4.0.0. Now, when
Ladder version 3.1.1 and 3.2.0 become available, you can release them to your
package management system and know that they will be compatible with existing
dependent software.

As a responsible developer you will, of course, want to verify that any
package upgrades function as advertised. The real world is a messy place;
there’s nothing we can do about that but be vigilant. What you can do is let
Semantic Versioning provide you with a sane way to release and upgrade
packages without having to roll new versions of dependent packages, saving you
time and hassle.

If all of this sounds desirable, all you need to do to start using Semantic
Versioning is to declare that you are doing so and then follow the rules. Link
to this website from your README so others know the rules and can benefit from
them.

FAQ

How should I deal with revisions in the 0.y.z initial development phase?

The simplest thing to do is start your initial development release at 0.1.0
and then increment the minor version for each subsequent release.

How do I know when to release 1.0.0?

If your software is being used in production, it should probably already be
1.0.0. If you have a stable API on which users have come to depend, you should
be 1.0.0. If you’re worrying a lot about backwards compatibility, you should
probably already be 1.0.0.

Doesn’t this discourage rapid development and fast iteration?

Major version zero is all about rapid development. If you’re changing the API
every day you should either still be in version 0.x.x or on a separate
development branch working on the next major version.

If even the tiniest backwards incompatible changes to the public API require a major version bump, won’t I end up at version 42.0.0 very rapidly?

This is a question of responsible development and foresight. Incompatible
changes should not be introduced lightly to software that has a lot of
dependent code. The cost that must be incurred to upgrade can be significant.
Having to bump major versions to release incompatible changes means you’ll
think through the impact of your changes, and evaluate the cost/benefit ratio
involved.

Documenting the entire public API is too much work!

It is your responsibility as a professional developer to properly document
software that is intended for use by others. Managing software complexity is a
hugely important part of keeping a project efficient, and that’s hard to do if
nobody knows how to use your software, or what methods are safe to call. In
the long run, Semantic Versioning, and the insistence on a well defined public
API can keep everyone and everything running smoothly.

What do I do if I accidentally release a backwards incompatible change as a minor version?

As soon as you realize that you’ve broken the Semantic Versioning spec, fix
the problem and release a new minor version that corrects the problem and
restores backwards compatibility. Remember, it is unacceptable to modify
versioned releases, even under this circumstance. If it’s appropriate,
document the offending version and inform your users of the problem so that
they are aware of the offending version.

What should I do if I update my own dependencies without changing the public API?

That would be considered compatible since it does not affect the public API.
Software that explicitly depends on the same dependencies as your package
should have their own dependency specifications and the author will notice any
conflicts. Determining whether the change is a patch level or minor level
modification depends on whether you updated your dependencies in order to fix
a bug or introduce new functionality. I would usually expect additional code
for the latter instance, in which case it’s obviously a minor level increment.

What should I do if the bug that is being fixed returns the code to being compliant with the public API (i.e. the code was incorrectly out of sync with the public API documentation)?

Use your best judgment. If you have a huge audience that will be drastically
impacted by changing the behavior back to what the public API intended, then
it may be best to perform a major version release, even though the fix could
strictly be considered a patch release. Remember, Semantic Versioning is all
about conveying meaning by how the version number changes. If these changes
are important to your users, use the version number to inform them.

How should I handle deprecating functionality?

Deprecating existing functionality is a normal part of software development and is often required to make forward progress. When you deprecate part of your public API, you should do two things: (1) update your documentation to let users know about the change, (2) issue a new minor release with the deprecation in place. Before you completely remove the functionality in a new major release there should be at least one minor release that contains the deprecation so that users can smoothly transition to the new API.

About

The Semantic Versioning specification is authored by Tom Preston-Werner, inventor of Gravatars and cofounder of GitHub.

If you’d like to leave feedback, please open an issue on GitHub.

License

Creative Commons ― CC BY 3.0
http://creativecommons.org/licenses/by/3.0/\nSemantic Versioning 2.0.0-rc.1\nIn the world of software management there exists a dread place called
“dependency hell.” The bigger your system grows and the more packages you
integrate into your software, the more likely you are to find yourself, one
day, in this pit of despair.\nIn systems with many dependencies, releasing new package versions can quickly
become a nightmare. If the dependency specifications are too tight, you are in
danger of version lock (the inability to upgrade a package without having to
release new versions of every dependent package). If dependencies are
specified too loosely, you will inevitably be bitten by version promiscuity
(assuming compatibility with more future versions than is reasonable).
Dependency hell is where you are when version lock and/or version promiscuity
prevent you from easily and safely moving your project forward.\nAs a solution to this problem, I propose a simple set of rules and
requirements that dictate how version numbers are assigned and incremented.
For this system to work, you first need to declare a public API. This may
consist of documentation or be enforced by the code itself. Regardless, it is
important that this API be clear and precise. Once you identify your public
API, you communicate changes to it with specific increments to your version
number. Consider a version format of X.Y.Z (Major.Minor.Patch). Bug fixes not
affecting the API increment the patch version, backwards compatible API
additions/changes increment the minor version, and backwards incompatible API
changes increment the major version.\nI call this system “Semantic Versioning.” Under this scheme, version numbers
and the way they change convey meaning about the underlying code and what has
been modified from one version to the next.\nSemantic Versioning Specification (SemVer)\nThe key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,
“SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be
interpreted as described in RFC 2119.\nSoftware using Semantic Versioning MUST declare a public API. This API
could be declared in the code itself or exist strictly in documentation.
However it is done, it should be precise and comprehensive.\nSoftware using Semantic Versioning MUST declare a public API. This API
could be declared in the code itself or exist strictly in documentation.
However it is done, it should be precise and comprehensive.\nA normal version number MUST take the form X.Y.Z where X, Y, and Z are
non-negative integers. X is the major version, Y is the minor version, and Z
is the patch version. Each element MUST increase numerically by increments of
one. For instance: 1.9.0 -> 1.10.0 -> 1.11.0.\nA normal version number MUST take the form X.Y.Z where X, Y, and Z are
non-negative integers. X is the major version, Y is the minor version, and Z
is the patch version. Each element MUST increase numerically by increments of
one. For instance: 1.9.0 -> 1.10.0 -> 1.11.0.\nWhen a major version number is incremented, the minor version and patch
version MUST be reset to zero. When a minor version number is incremented, the
patch version MUST be reset to zero. For instance: 1.1.3 -> 2.0.0 and 2.1.7 ->
2.2.0.\nWhen a major version number is incremented, the minor version and patch
version MUST be reset to zero. When a minor version number is incremented, the
patch version MUST be reset to zero. For instance: 1.1.3 -> 2.0.0 and 2.1.7 ->
2.2.0.\nOnce a versioned package has been released, the contents of that version
MUST NOT be modified. Any modifications must be released as a new version.\nOnce a versioned package has been released, the contents of that version
MUST NOT be modified. Any modifications must be released as a new version.\nMajor version zero (0.y.z) is for initial development. Anything may change
at any time. The public API should not be considered stable.\nMajor version zero (0.y.z) is for initial development. Anything may change
at any time. The public API should not be considered stable.\nVersion 1.0.0 defines the public API. The way in which the version number
is incremented after this release is dependent on this public API and how it
changes.\nVersion 1.0.0 defines the public API. The way in which the version number
is incremented after this release is dependent on this public API and how it
changes.\nPatch version Z (x.y.Z | x > 0) MUST be incremented if only backwards
compatible bug fixes are introduced. A bug fix is defined as an internal
change that fixes incorrect behavior.\nPatch version Z (x.y.Z | x > 0) MUST be incremented if only backwards
compatible bug fixes are introduced. A bug fix is defined as an internal
change that fixes incorrect behavior.\nMinor version Y (x.Y.z | x > 0) MUST be incremented if new, backwards
compatible functionality is introduced to the public API. It MUST be
incremented if any public API functionality is marked as deprecated. It MAY be
incremented if substantial new functionality or improvements are introduced
within the private code. It MAY include patch level changes. Patch version
MUST be reset to 0 when minor version is incremented.\nMinor version Y (x.Y.z | x > 0) MUST be incremented if new, backwards
compatible functionality is introduced to the public API. It MUST be
incremented if any public API functionality is marked as deprecated. It MAY be
incremented if substantial new functionality or improvements are introduced
within the private code. It MAY include patch level changes. Patch version
MUST be reset to 0 when minor version is incremented.\nMajor version X (X.y.z | X > 0) MUST be incremented if any backwards
incompatible changes are introduced to the public API. It MAY include minor
and patch level changes. Patch and minor version MUST be reset to 0 when major
version is incremented.\nMajor version X (X.y.z | X > 0) MUST be incremented if any backwards
incompatible changes are introduced to the public API. It MAY include minor
and patch level changes. Patch and minor version MUST be reset to 0 when major
version is incremented.\nA pre-release version MAY be denoted by appending a dash and a series of
dot separated identifiers immediately following the patch version. Identifiers
MUST be comprised of only ASCII alphanumerics and dash [0-9A-Za-z-].
Pre-release versions satisfy but have a lower precedence than the associated
normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.\nA pre-release version MAY be denoted by appending a dash and a series of
dot separated identifiers immediately following the patch version. Identifiers
MUST be comprised of only ASCII alphanumerics and dash [0-9A-Za-z-].
Pre-release versions satisfy but have a lower precedence than the associated
normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.\nA build version MAY be denoted by appending a plus sign and a series of dot
separated identifiers immediately following the patch version or pre-release
version. Identifiers MUST be comprised of only ASCII alphanumerics and dash
[0-9A-Za-z-]. Build versions satisfy and have a higher precedence than the
associated normal version. Examples: 1.0.0+build.1, 1.3.7+build.11.e0f985a.\nA build version MAY be denoted by appending a plus sign and a series of dot
separated identifiers immediately following the patch version or pre-release
version. Identifiers MUST be comprised of only ASCII alphanumerics and dash
[0-9A-Za-z-]. Build versions satisfy and have a higher precedence than the
associated normal version. Examples: 1.0.0+build.1, 1.3.7+build.11.e0f985a.\nPrecedence MUST be calculated by separating the version into major, minor,
patch, pre-release, and build identifiers in that order. Major, minor, and
patch versions are always compared numerically. Pre-release and build version
precedence MUST be determined by comparing each dot separated identifier as
follows: identifiers consisting of only digits are compared numerically and
identifiers with letters or dashes are compared lexically in ASCII sort order.
Numeric identifiers always have lower precedence than non-numeric identifiers.
Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta.2 < 1.0.0-beta.11 <
1.0.0-rc.1 < 1.0.0-rc.1+build.1 < 1.0.0 < 1.0.0+0.3.7 < 1.3.7+build <
1.3.7+build.2.b8f12d7 < 1.3.7+build.11.e0f985a.\nPrecedence MUST be calculated by separating the version into major, minor,
patch, pre-release, and build identifiers in that order. Major, minor, and
patch versions are always compared numerically. Pre-release and build version
precedence MUST be determined by comparing each dot separated identifier as
follows: identifiers consisting of only digits are compared numerically and
identifiers with letters or dashes are compared lexically in ASCII sort order.
Numeric identifiers always have lower precedence than non-numeric identifiers.
Example: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta.2 < 1.0.0-beta.11 <
1.0.0-rc.1 < 1.0.0-rc.1+build.1 < 1.0.0 < 1.0.0+0.3.7 < 1.3.7+build <
1.3.7+build.2.b8f12d7 < 1.3.7+build.11.e0f985a.\nWhy Use Semantic Versioning?\nThis is not a new or revolutionary idea. In fact, you probably do something
close to this already. The problem is that “close” isn’t good enough. Without
compliance to some sort of formal specification, version numbers are
essentially useless for dependency management. By giving a name and clear
definition to the above ideas, it becomes easy to communicate your intentions
to the users of your software. Once these intentions are clear, flexible (but
not too flexible) dependency specifications can finally be made.\nA simple example will demonstrate how Semantic Versioning can make dependency
hell a thing of the past. Consider a library called “Firetruck.” It requires a
Semantically Versioned package named “Ladder.” At the time that Firetruck is
created, Ladder is at version 3.1.0. Since Firetruck uses some functionality
that was first introduced in 3.1.0, you can safely specify the Ladder
dependency as greater than or equal to 3.1.0 but less than 4.0.0. Now, when
Ladder version 3.1.1 and 3.2.0 become available, you can release them to your
package management system and know that they will be compatible with existing
dependent software.\nAs a responsible developer you will, of course, want to verify that any
package upgrades function as advertised. The real world is a messy place;
there’s nothing we can do about that but be vigilant. What you can do is let
Semantic Versioning provide you with a sane way to release and upgrade
packages without having to roll new versions of dependent packages, saving you
time and hassle.\nIf all of this sounds desirable, all you need to do to start using Semantic
Versioning is to declare that you are doing so and then follow the rules. Link
to this website from your README so others know the rules and can benefit from
them.\nHow should I deal with revisions in the 0.y.z initial development phase?\nThe simplest thing to do is start your initial development release at 0.1.0
and then increment the minor version for each subsequent release.\nHow do I know when to release 1.0.0?\nIf your software is being used in production, it should probably already be
1.0.0. If you have a stable API on which users have come to depend, you should
be 1.0.0. If you’re worrying a lot about backwards compatibility, you should
probably already be 1.0.0.\nDoesn’t this discourage rapid development and fast iteration?\nMajor version zero is all about rapid development. If you’re changing the API
every day you should either still be in version 0.x.x or on a separate
development branch working on the next major version.\nIf even the tiniest backwards incompatible changes to the public API require a major version bump, won’t I end up at version 42.0.0 very rapidly?\nThis is a question of responsible development and foresight. Incompatible
changes should not be introduced lightly to software that has a lot of
dependent code. The cost that must be incurred to upgrade can be significant.
Having to bump major versions to release incompatible changes means you’ll
think through the impact of your changes, and evaluate the cost/benefit ratio
involved.\nDocumenting the entire public API is too much work!\nIt is your responsibility as a professional developer to properly document
software that is intended for use by others. Managing software complexity is a
hugely important part of keeping a project efficient, and that’s hard to do if
nobody knows how to use your software, or what methods are safe to call. In
the long run, Semantic Versioning, and the insistence on a well defined public
API can keep everyone and everything running smoothly.\nWhat do I do if I accidentally release a backwards incompatible change as a minor version?\nAs soon as you realize that you’ve broken the Semantic Versioning spec, fix
the problem and release a new minor version that corrects the problem and
restores backwards compatibility. Remember, it is unacceptable to modify
versioned releases, even under this circumstance. If it’s appropriate,
document the offending version and inform your users of the problem so that
they are aware of the offending version.\nWhat should I do if I update my own dependencies without changing the public API?\nThat would be considered compatible since it does not affect the public API.
Software that explicitly depends on the same dependencies as your package
should have their own dependency specifications and the author will notice any
conflicts. Determining whether the change is a patch level or minor level
modification depends on whether you updated your dependencies in order to fix
a bug or introduce new functionality. I would usually expect additional code
for the latter instance, in which case it’s obviously a minor level increment.\nWhat should I do if the bug that is being fixed returns the code to being compliant with the public API (i.e. the code was incorrectly out of sync with the public API documentation)?\nUse your best judgment. If you have a huge audience that will be drastically
impacted by changing the behavior back to what the public API intended, then
it may be best to perform a major version release, even though the fix could
strictly be considered a patch release. Remember, Semantic Versioning is all
about conveying meaning by how the version number changes. If these changes
are important to your users, use the version number to inform them.\nHow should I handle deprecating functionality?\nDeprecating existing functionality is a normal part of software development and is often required to make forward progress. When you deprecate part of your public API, you should do two things: (1) update your documentation to let users know about the change, (2) issue a new minor release with the deprecation in place. Before you completely remove the functionality in a new major release there should be at least one minor release that contains the deprecation so that users can smoothly transition to the new API.\nThe Semantic Versioning specification is authored by Tom Preston-Werner, inventor of Gravatars and cofounder of GitHub.\nIf you’d like to leave feedback, please open an issue on GitHub.\nopen an issue on GitHub\nCreative Commons ― CC BY 3.0
http://creativecommons.org/licenses/by/3.0/\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSemantic Versioning 1.0.0

In the world of software management there exists a dread place called
“dependency hell.” The bigger your system grows and the more packages you
integrate into your software, the more likely you are to find yourself, one
day, in this pit of despair.

In systems with many dependencies, releasing new package versions can quickly
become a nightmare. If the dependency specifications are too tight, you are in
danger of version lock (the inability to upgrade a package without having to
release new versions of every dependent package). If dependencies are
specified too loosely, you will inevitably be bitten by version promiscuity
(assuming compatibility with more future versions than is reasonable).
Dependency hell is where you are when version lock and/or version promiscuity
prevent you from easily and safely moving your project forward.

As a solution to this problem, I propose a simple set of rules and
requirements that dictate how version numbers are assigned and incremented.
For this system to work, you first need to declare a public API. This may
consist of documentation or be enforced by the code itself. Regardless, it is
important that this API be clear and precise. Once you identify your public
API, you communicate changes to it with specific increments to your version
number. Consider a version format of X.Y.Z (Major.Minor.Patch). Bug fixes not
affecting the API increment the patch version, backwards compatible API
additions/changes increment the minor version, and backwards incompatible API
changes increment the major version.

I call this system “Semantic Versioning.” Under this scheme, version numbers
and the way they change convey meaning about the underlying code and what has
been modified from one version to the next.

Semantic Versioning Specification (SemVer)

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,
“SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be
interpreted as described in RFC 2119.


  
    Software using Semantic Versioning MUST declare a public API. This API
could be declared in the code itself or exist strictly in documentation.
However it is done, it should be precise and comprehensive.
  
  
    A normal version number MUST take the form X.Y.Z where X, Y, and Z are
integers. X is the major version, Y is the minor version, and Z is the patch
version. Each element MUST increase numerically by increments of one. For
instance: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    When a major version number is incremented, the minor version and patch
version MUST be reset to zero. When a minor version number is incremented, the
patch version MUST be reset to zero. For instance: 1.1.3 -> 2.0.0 and 2.1.7 ->
2.2.0.
  
  
    A pre-release version number MAY be denoted by appending an arbitrary
string immediately following the patch version and a dash. The string MUST be
comprised of only alphanumerics plus dash [0-9A-Za-z-]. Pre-release versions
satisfy but have a lower precedence than the associated normal version.
Precedence SHOULD be determined by lexicographic ASCII sort order. For
instance: 1.0.0-alpha1 < 1.0.0-beta1 < 1.0.0-beta2 < 1.0.0-rc1 < 1.0.0.
  
  
    Once a versioned package has been released, the contents of that version
MUST NOT be modified. Any modifications must be released as a new version.
  
  
    Major version zero (0.y.z) is for initial development. Anything may change
at any time. The public API should not be considered stable.
  
  
    Version 1.0.0 defines the public API. The way in which the version number
is incremented after this release is dependent on this public API and how it
changes.
  
  
    Patch version Z (x.y.Z | x > 0) MUST be incremented if only backwards
compatible bug fixes are introduced. A bug fix is defined as an internal
change that fixes incorrect behavior.
  
  
    Minor version Y (x.Y.z | x > 0) MUST be incremented if new, backwards
compatible functionality is introduced to the public API. It MAY be
incremented if substantial new functionality or improvements are introduced
within the private code. It MAY include patch level changes. Patch version
MUST be reset to 0 when minor version is incremented.
  
  
    Major version X (X.y.z | X > 0) MUST be incremented if any backwards
incompatible changes are introduced to the public API. It MAY include minor
and patch level changes. Patch and minor version MUST be reset to 0 when major
version is incremented.
  


Tagging Specification (SemVerTag)

This sub-specification SHOULD be used if you use a version control system
(Git, Mercurial, SVN, etc) to store your code. Using this system allows
automated tools to inspect your package and determine SemVer compliance and
released versions.


  
    When tagging releases in a version control system, the tag for a version
MUST be “vX.Y.Z” e.g. “v3.1.0”.
  
  
    The first revision that introduces SemVer compliance SHOULD be tagged
“semver”. This allows pre-existing projects to assume compliance at any
arbitrary point and for automated tools to discover this fact.
  


Why Use Semantic Versioning?

This is not a new or revolutionary idea. In fact, you probably do something
close to this already. The problem is that “close” isn’t good enough. Without
compliance to some sort of formal specification, version numbers are
essentially useless for dependency management. By giving a name and clear
definition to the above ideas, it becomes easy to communicate your intentions
to the users of your software. Once these intentions are clear, flexible (but
not too flexible) dependency specifications can finally be made.

A simple example will demonstrate how Semantic Versioning can make dependency
hell a thing of the past. Consider a library called “Firetruck.” It requires a
Semantically Versioned package named “Ladder.” At the time that Firetruck is
created, Ladder is at version 3.1.0. Since Firetruck uses some functionality
that was first introduced in 3.1.0, you can safely specify the Ladder
dependency as greater than or equal to 3.1.0 but less than 4.0.0. Now, when
Ladder version 3.1.1 and 3.2.0 become available, you can release them to your
package management system and know that they will be compatible with existing
dependent software.

As a responsible developer you will, of course, want to verify that any
package upgrades function as advertised. The real world is a messy place;
there’s nothing we can do about that but be vigilant. What you can do is let
Semantic Versioning provide you with a sane way to release and upgrade
packages without having to roll new versions of dependent packages, saving you
time and hassle.

If all of this sounds desirable, all you need to do to start using Semantic
Versioning is to declare that you are doing so and then follow the rules. Link
to this website from your README so others know the rules and can benefit from
them.

FAQ

How should I deal with revisions in the 0.y.z initial development phase?

The simplest thing to do is start your initial development release at 0.1.0
and then increment the minor version for each subsequent release.

How do I know when to release 1.0.0?

If your software is being used in production, it should probably already be
1.0.0. If you have a stable API on which users have come to depend, you should
be 1.0.0. If you’re worrying a lot about backwards compatibility, you should
probably already be 1.0.0.

Doesn’t this discourage rapid development and fast iteration?

Major version zero is all about rapid development. If you’re changing the API
every day you should either still be in version 0.x.x or on a separate
development branch working on the next major version.

If even the tiniest backwards incompatible changes to the public API require a major version bump, won’t I end up at version 42.0.0 very rapidly?

This is a question of responsible development and foresight. Incompatible
changes should not be introduced lightly to software that has a lot of
dependent code. The cost that must be incurred to upgrade can be significant.
Having to bump major versions to release incompatible changes means you’ll
think through the impact of your changes, and evaluate the cost/benefit ratio
involved.

Documenting the entire public API is too much work!

It is your responsibility as a professional developer to properly document
software that is intended for use by others. Managing software complexity is a
hugely important part of keeping a project efficient, and that’s hard to do if
nobody knows how to use your software, or what methods are safe to call. In
the long run, Semantic Versioning, and the insistence on a well defined public
API can keep everyone and everything running smoothly.

What do I do if I accidentally release a backwards incompatible change as a minor version?

As soon as you realize that you’ve broken the Semantic Versioning spec, fix
the problem and release a new minor version that corrects the problem and
restores backwards compatibility. Remember, it is unacceptable to modify
versioned releases, even under this circumstance. If it’s appropriate,
document the offending version and inform your users of the problem so that
they are aware of the offending version.

What should I do if I update my own dependencies without changing the public API?

That would be considered compatible since it does not affect the public API.
Software that explicitly depends on the same dependencies as your package
should have their own dependency specifications and the author will notice any
conflicts. Determining whether the change is a patch level or minor level
modification depends on whether you updated your dependencies in order to fix
a bug or introduce new functionality. I would usually expect additional code
for the latter instance, in which case it’s obviously a minor level increment.

What should I do if the bug that is being fixed returns the code to being compliant with the public API (i.e. the code was incorrectly out of sync with the public API documentation)?

Use your best judgment. If you have a huge audience that will be drastically
impacted by changing the behavior back to what the public API intended, then
it may be best to perform a major version release, even though the fix could
strictly be considered a patch release. Remember, Semantic Versioning is all
about conveying meaning by how the version number changes. If these changes
are important to your users, use the version number to inform them.

About

The Semantic Versioning specification is authored by Tom Preston-Werner, inventor of Gravatars and cofounder of GitHub.

If you’d like to leave feedback, please open an issue on GitHub.

License

Creative Commons ― CC BY 3.0
http://creativecommons.org/licenses/by/3.0/\nSemantic Versioning 1.0.0\nIn the world of software management there exists a dread place called
“dependency hell.” The bigger your system grows and the more packages you
integrate into your software, the more likely you are to find yourself, one
day, in this pit of despair.\nIn systems with many dependencies, releasing new package versions can quickly
become a nightmare. If the dependency specifications are too tight, you are in
danger of version lock (the inability to upgrade a package without having to
release new versions of every dependent package). If dependencies are
specified too loosely, you will inevitably be bitten by version promiscuity
(assuming compatibility with more future versions than is reasonable).
Dependency hell is where you are when version lock and/or version promiscuity
prevent you from easily and safely moving your project forward.\nAs a solution to this problem, I propose a simple set of rules and
requirements that dictate how version numbers are assigned and incremented.
For this system to work, you first need to declare a public API. This may
consist of documentation or be enforced by the code itself. Regardless, it is
important that this API be clear and precise. Once you identify your public
API, you communicate changes to it with specific increments to your version
number. Consider a version format of X.Y.Z (Major.Minor.Patch). Bug fixes not
affecting the API increment the patch version, backwards compatible API
additions/changes increment the minor version, and backwards incompatible API
changes increment the major version.\nI call this system “Semantic Versioning.” Under this scheme, version numbers
and the way they change convey meaning about the underlying code and what has
been modified from one version to the next.\nSemantic Versioning Specification (SemVer)\nThe key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,
“SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be
interpreted as described in RFC 2119.\nSoftware using Semantic Versioning MUST declare a public API. This API
could be declared in the code itself or exist strictly in documentation.
However it is done, it should be precise and comprehensive.\nSoftware using Semantic Versioning MUST declare a public API. This API
could be declared in the code itself or exist strictly in documentation.
However it is done, it should be precise and comprehensive.\nA normal version number MUST take the form X.Y.Z where X, Y, and Z are
integers. X is the major version, Y is the minor version, and Z is the patch
version. Each element MUST increase numerically by increments of one. For
instance: 1.9.0 -> 1.10.0 -> 1.11.0.\nA normal version number MUST take the form X.Y.Z where X, Y, and Z are
integers. X is the major version, Y is the minor version, and Z is the patch
version. Each element MUST increase numerically by increments of one. For
instance: 1.9.0 -> 1.10.0 -> 1.11.0.\nWhen a major version number is incremented, the minor version and patch
version MUST be reset to zero. When a minor version number is incremented, the
patch version MUST be reset to zero. For instance: 1.1.3 -> 2.0.0 and 2.1.7 ->
2.2.0.\nWhen a major version number is incremented, the minor version and patch
version MUST be reset to zero. When a minor version number is incremented, the
patch version MUST be reset to zero. For instance: 1.1.3 -> 2.0.0 and 2.1.7 ->
2.2.0.\nA pre-release version number MAY be denoted by appending an arbitrary
string immediately following the patch version and a dash. The string MUST be
comprised of only alphanumerics plus dash [0-9A-Za-z-]. Pre-release versions
satisfy but have a lower precedence than the associated normal version.
Precedence SHOULD be determined by lexicographic ASCII sort order. For
instance: 1.0.0-alpha1 < 1.0.0-beta1 < 1.0.0-beta2 < 1.0.0-rc1 < 1.0.0.\nA pre-release version number MAY be denoted by appending an arbitrary
string immediately following the patch version and a dash. The string MUST be
comprised of only alphanumerics plus dash [0-9A-Za-z-]. Pre-release versions
satisfy but have a lower precedence than the associated normal version.
Precedence SHOULD be determined by lexicographic ASCII sort order. For
instance: 1.0.0-alpha1 < 1.0.0-beta1 < 1.0.0-beta2 < 1.0.0-rc1 < 1.0.0.\nOnce a versioned package has been released, the contents of that version
MUST NOT be modified. Any modifications must be released as a new version.\nOnce a versioned package has been released, the contents of that version
MUST NOT be modified. Any modifications must be released as a new version.\nMajor version zero (0.y.z) is for initial development. Anything may change
at any time. The public API should not be considered stable.\nMajor version zero (0.y.z) is for initial development. Anything may change
at any time. The public API should not be considered stable.\nVersion 1.0.0 defines the public API. The way in which the version number
is incremented after this release is dependent on this public API and how it
changes.\nVersion 1.0.0 defines the public API. The way in which the version number
is incremented after this release is dependent on this public API and how it
changes.\nPatch version Z (x.y.Z | x > 0) MUST be incremented if only backwards
compatible bug fixes are introduced. A bug fix is defined as an internal
change that fixes incorrect behavior.\nPatch version Z (x.y.Z | x > 0) MUST be incremented if only backwards
compatible bug fixes are introduced. A bug fix is defined as an internal
change that fixes incorrect behavior.\nMinor version Y (x.Y.z | x > 0) MUST be incremented if new, backwards
compatible functionality is introduced to the public API. It MAY be
incremented if substantial new functionality or improvements are introduced
within the private code. It MAY include patch level changes. Patch version
MUST be reset to 0 when minor version is incremented.\nMinor version Y (x.Y.z | x > 0) MUST be incremented if new, backwards
compatible functionality is introduced to the public API. It MAY be
incremented if substantial new functionality or improvements are introduced
within the private code. It MAY include patch level changes. Patch version
MUST be reset to 0 when minor version is incremented.\nMajor version X (X.y.z | X > 0) MUST be incremented if any backwards
incompatible changes are introduced to the public API. It MAY include minor
and patch level changes. Patch and minor version MUST be reset to 0 when major
version is incremented.\nMajor version X (X.y.z | X > 0) MUST be incremented if any backwards
incompatible changes are introduced to the public API. It MAY include minor
and patch level changes. Patch and minor version MUST be reset to 0 when major
version is incremented.\nTagging Specification (SemVerTag)\nThis sub-specification SHOULD be used if you use a version control system
(Git, Mercurial, SVN, etc) to store your code. Using this system allows
automated tools to inspect your package and determine SemVer compliance and
released versions.\nWhen tagging releases in a version control system, the tag for a version
MUST be “vX.Y.Z” e.g. “v3.1.0”.\nWhen tagging releases in a version control system, the tag for a version
MUST be “vX.Y.Z” e.g. “v3.1.0”.\nThe first revision that introduces SemVer compliance SHOULD be tagged
“semver”. This allows pre-existing projects to assume compliance at any
arbitrary point and for automated tools to discover this fact.\nThe first revision that introduces SemVer compliance SHOULD be tagged
“semver”. This allows pre-existing projects to assume compliance at any
arbitrary point and for automated tools to discover this fact.\nWhy Use Semantic Versioning?\nThis is not a new or revolutionary idea. In fact, you probably do something
close to this already. The problem is that “close” isn’t good enough. Without
compliance to some sort of formal specification, version numbers are
essentially useless for dependency management. By giving a name and clear
definition to the above ideas, it becomes easy to communicate your intentions
to the users of your software. Once these intentions are clear, flexible (but
not too flexible) dependency specifications can finally be made.\nA simple example will demonstrate how Semantic Versioning can make dependency
hell a thing of the past. Consider a library called “Firetruck.” It requires a
Semantically Versioned package named “Ladder.” At the time that Firetruck is
created, Ladder is at version 3.1.0. Since Firetruck uses some functionality
that was first introduced in 3.1.0, you can safely specify the Ladder
dependency as greater than or equal to 3.1.0 but less than 4.0.0. Now, when
Ladder version 3.1.1 and 3.2.0 become available, you can release them to your
package management system and know that they will be compatible with existing
dependent software.\nAs a responsible developer you will, of course, want to verify that any
package upgrades function as advertised. The real world is a messy place;
there’s nothing we can do about that but be vigilant. What you can do is let
Semantic Versioning provide you with a sane way to release and upgrade
packages without having to roll new versions of dependent packages, saving you
time and hassle.\nIf all of this sounds desirable, all you need to do to start using Semantic
Versioning is to declare that you are doing so and then follow the rules. Link
to this website from your README so others know the rules and can benefit from
them.\nHow should I deal with revisions in the 0.y.z initial development phase?\nThe simplest thing to do is start your initial development release at 0.1.0
and then increment the minor version for each subsequent release.\nHow do I know when to release 1.0.0?\nIf your software is being used in production, it should probably already be
1.0.0. If you have a stable API on which users have come to depend, you should
be 1.0.0. If you’re worrying a lot about backwards compatibility, you should
probably already be 1.0.0.\nDoesn’t this discourage rapid development and fast iteration?\nMajor version zero is all about rapid development. If you’re changing the API
every day you should either still be in version 0.x.x or on a separate
development branch working on the next major version.\nIf even the tiniest backwards incompatible changes to the public API require a major version bump, won’t I end up at version 42.0.0 very rapidly?\nThis is a question of responsible development and foresight. Incompatible
changes should not be introduced lightly to software that has a lot of
dependent code. The cost that must be incurred to upgrade can be significant.
Having to bump major versions to release incompatible changes means you’ll
think through the impact of your changes, and evaluate the cost/benefit ratio
involved.\nDocumenting the entire public API is too much work!\nIt is your responsibility as a professional developer to properly document
software that is intended for use by others. Managing software complexity is a
hugely important part of keeping a project efficient, and that’s hard to do if
nobody knows how to use your software, or what methods are safe to call. In
the long run, Semantic Versioning, and the insistence on a well defined public
API can keep everyone and everything running smoothly.\nWhat do I do if I accidentally release a backwards incompatible change as a minor version?\nAs soon as you realize that you’ve broken the Semantic Versioning spec, fix
the problem and release a new minor version that corrects the problem and
restores backwards compatibility. Remember, it is unacceptable to modify
versioned releases, even under this circumstance. If it’s appropriate,
document the offending version and inform your users of the problem so that
they are aware of the offending version.\nWhat should I do if I update my own dependencies without changing the public API?\nThat would be considered compatible since it does not affect the public API.
Software that explicitly depends on the same dependencies as your package
should have their own dependency specifications and the author will notice any
conflicts. Determining whether the change is a patch level or minor level
modification depends on whether you updated your dependencies in order to fix
a bug or introduce new functionality. I would usually expect additional code
for the latter instance, in which case it’s obviously a minor level increment.\nWhat should I do if the bug that is being fixed returns the code to being compliant with the public API (i.e. the code was incorrectly out of sync with the public API documentation)?\nUse your best judgment. If you have a huge audience that will be drastically
impacted by changing the behavior back to what the public API intended, then
it may be best to perform a major version release, even though the fix could
strictly be considered a patch release. Remember, Semantic Versioning is all
about conveying meaning by how the version number changes. If these changes
are important to your users, use the version number to inform them.\nThe Semantic Versioning specification is authored by Tom Preston-Werner, inventor of Gravatars and cofounder of GitHub.\nIf you’d like to leave feedback, please open an issue on GitHub.\nopen an issue on GitHub\nCreative Commons ― CC BY 3.0
http://creativecommons.org/licenses/by/3.0/\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSemantic Versioning 1.0.0-beta

In the world of software management there exists a dread place called
“dependency hell.” The bigger your system grows and the more packages you
integrate into your software, the more likely you are to find yourself, one
day, in this pit of despair.

In systems with many dependencies, releasing new package versions can quickly
become a nightmare. If the dependency specifications are too tight, you are in
danger of version lock (the inability to upgrade a package without having to
release new versions of every dependent package). If dependencies are
specified too loosely, you will inevitably be bitten by version promiscuity
(assuming compatibility with more future versions than is reasonable).
Dependency hell is where you are when version lock and/or version promiscuity
prevent you from easily and safely moving your project forward.

As a solution to this problem, I propose a simple set of rules and
requirements that dictate how version numbers are assigned and incremented.
For this system to work, you first need to declare a public API. This may
consist of documentation or be enforced by the code itself. Regardless, it is
important that this API be clear and precise. Once you identify your public
API, you communicate changes to it with specific increments to your version
number. Consider a version format of X.Y.Z (Major.Minor.Patch). Bug fixes not
affecting the API increment the patch version, backwards compatible API
additions/changes increment the minor version, and backwards incompatible API
changes increment the major version.

I call this system “Semantic Versioning.” Under this scheme, version numbers
and the way they change convey meaning about the underlying code and what has
been modified from one version to the next.

Semantic Versioning Specification (SemVer)

The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,
“SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be
interpreted as described in RFC 2119.


  
    Software using Semantic Versioning MUST declare a public API. This API
could be declared in the code itself or exist strictly in documentation.
However it is done, it should be precise and comprehensive.
  
  
    A normal version number MUST take the form X.Y.Z where X, Y, and Z are
integers. X is the major version, Y is the minor version, and Z is the patch
version. Each element MUST increase numerically by increments of one. For
instance: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    When a major version number is incremented, the minor version and patch
version MUST be reset to zero. When a minor version number is incremented, the
patch version MUST be reset to zero. For instance: 1.1.3 -> 2.0.0 and 2.1.7 ->
2.2.0.
  
  
    A pre-release version number MAY be denoted by appending an arbitrary
string immediately following the patch version and a decimal point. The string
MUST be comprised of only alphanumerics plus dash [0-9A-Za-z-] and MUST begin
with an alpha character [A-Za-z]. Pre-release versions satisfy but have a
lower precedence than the associated normal version. Precedence SHOULD be
determined by lexicographic ASCII sort order. For instance: 1.0.0.alpha1 <
1.0.0.beta1 < 1.0.0.beta2 < 1.0.0.rc1 < 1.0.0.
  
  
    Once a versioned package has been released, the contents of that version
MUST NOT be modified. Any modifications must be released as a new version.
  
  
    Major version zero (0.y.z) is for initial development. Anything may change
at any time. The public API should not be considered stable.
  
  
    Version 1.0.0 defines the public API. The way in which the version number
is incremented after this release is dependent on this public API and how it
changes.
  
  
    Patch version Z (x.y.Z | x > 0) MUST be incremented if only backwards
compatible bug fixes are introduced. A bug fix is defined as an internal
change that fixes incorrect behavior.
  
  
    Minor version Y (x.Y.z | x > 0) MUST be incremented if new, backwards
compatible functionality is introduced to the public API. It MAY be
incremented if substantial new functionality or improvements are introduced
within the private code. It MAY include patch level changes.
  
  
    Major version X (X.y.z | X > 0) MUST be incremented if any backwards
incompatible changes are introduced to the public API. It MAY include minor
and patch level changes.
  


Tagging Specification (SemVerTag)

This sub-specification SHOULD be used if you use a version control system
(Git, Mercurial, SVN, etc) to store your code. Using this system allows
automated tools to inspect your package and determine SemVer compliance and
released versions.


  
    When tagging releases in a version control system, the tag for a version
MUST be “vX.Y.Z” e.g. “v3.1.0”.
  
  
    The first revision that introduces SemVer compliance SHOULD be tagged
“semver”. This allows pre-existing projects to assume compliance at any
arbitrary point and for automated tools to discover this fact.
  


Why Use Semantic Versioning?

This is not a new or revolutionary idea. In fact, you probably do something
close to this already. The problem is that “close” isn’t good enough. Without
compliance to some sort of formal specification, version numbers are
essentially useless for dependency management. By giving a name and clear
definition to the above ideas, it becomes easy to communicate your intentions
to the users of your software. Once these intentions are clear, flexible (but
not too flexible) dependency specifications can finally be made.

A simple example will demonstrate how Semantic Versioning can make dependency
hell a thing of the past. Consider a library called “Firetruck.” It requires a
Semantically Versioned package named “Ladder.” At the time that Firetruck is
created, Ladder is at version 3.1.0. Since Firetruck uses some functionality
that was first introduced in 3.1.0, you can safely specify the Ladder
dependency as greater than or equal to 3.1.0 but less than 4.0.0. Now, when
Ladder version 3.1.1 and 3.2.0 become available, you can release them to your
package management system and know that they will be compatible with existing
dependent software.

As a responsible developer you will, of course, want to verify that any
package upgrades function as advertised. The real world is a messy place;
there’s nothing we can do about that but be vigilant. What you can do is let
Semantic Versioning provide you with a sane way to release and upgrade
packages without having to roll new versions of dependent packages, saving you
time and hassle.

If all of this sounds desirable, all you need to do to start using Semantic
Versioning is to declare that you are doing so and then follow the rules. Link
to this website from your README so others know the rules and can benefit from
them.

FAQ

How do I know when to release 1.0.0?

If your software is being used in production, it should probably already be
1.0.0. If you have a stable API on which users have come to depend, you should
be 1.0.0. If you’re worrying a lot about backwards compatibility, you should
probably already be 1.0.0.

Doesn’t this discourage rapid development and fast iteration?

Major version zero is all about rapid development. If you’re changing the API
every day you should either still be in version 0.x.x or on a separate
development branch working on the next major version.

If even the tiniest backwards incompatible changes to the public API require a major version bump, won’t I end up at version 42.0.0 very rapidly?

This is a question of responsible development and foresight. Incompatible
changes should not be introduced lightly to software that has a lot of
dependent code. The cost that must be incurred to upgrade can be significant.
Having to bump major versions to release incompatible changes means you’ll
think through the impact of your changes, and evaluate the cost/benefit ratio
involved.

Documenting the entire public API is too much work!

It is your responsibility as a professional developer to properly document
software that is intended for use by others. Managing software complexity is a
hugely important part of keeping a project efficient, and that’s hard to do if
nobody knows how to use your software, or what methods are safe to call. In
the long run, Semantic Versioning, and the insistence on a well defined public
API can keep everyone and everything running smoothly.

What do I do if I accidentally release a backwards incompatible change as a minor version?

As soon as you realize that you’ve broken the Semantic Versioning spec, fix
the problem and release a new minor version that corrects the problem and
restores backwards compatibility. Remember, it is unacceptable to modify
versioned releases, even under this circumstance. If it’s appropriate,
document the offending version and inform your users of the problem so that
they are aware of the offending version.

What should I do if I update my own dependencies without changing the public API?

That would be considered compatible since it does not affect the public API.
Software that explicitly depends on the same dependencies as your package
should have their own dependency specifications and the author will notice any
conflicts. Determining whether the change is a patch level or minor level
modification depends on whether you updated your dependencies in order to fix
a bug or introduce new functionality. I would usually expect additional code
for the latter instance, in which case it’s obviously a minor level increment.

About

The Semantic Versioning specification is authored by Tom Preston-Werner, inventor of Gravatars and cofounder of GitHub.

If you’d like to leave feedback, please open an issue on GitHub.

License

Creative Commons ― CC BY 3.0
http://creativecommons.org/licenses/by/3.0/\nSemantic Versioning 1.0.0-beta\nIn the world of software management there exists a dread place called
“dependency hell.” The bigger your system grows and the more packages you
integrate into your software, the more likely you are to find yourself, one
day, in this pit of despair.\nIn systems with many dependencies, releasing new package versions can quickly
become a nightmare. If the dependency specifications are too tight, you are in
danger of version lock (the inability to upgrade a package without having to
release new versions of every dependent package). If dependencies are
specified too loosely, you will inevitably be bitten by version promiscuity
(assuming compatibility with more future versions than is reasonable).
Dependency hell is where you are when version lock and/or version promiscuity
prevent you from easily and safely moving your project forward.\nAs a solution to this problem, I propose a simple set of rules and
requirements that dictate how version numbers are assigned and incremented.
For this system to work, you first need to declare a public API. This may
consist of documentation or be enforced by the code itself. Regardless, it is
important that this API be clear and precise. Once you identify your public
API, you communicate changes to it with specific increments to your version
number. Consider a version format of X.Y.Z (Major.Minor.Patch). Bug fixes not
affecting the API increment the patch version, backwards compatible API
additions/changes increment the minor version, and backwards incompatible API
changes increment the major version.\nI call this system “Semantic Versioning.” Under this scheme, version numbers
and the way they change convey meaning about the underlying code and what has
been modified from one version to the next.\nSemantic Versioning Specification (SemVer)\nThe key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”,
“SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be
interpreted as described in RFC 2119.\nSoftware using Semantic Versioning MUST declare a public API. This API
could be declared in the code itself or exist strictly in documentation.
However it is done, it should be precise and comprehensive.\nSoftware using Semantic Versioning MUST declare a public API. This API
could be declared in the code itself or exist strictly in documentation.
However it is done, it should be precise and comprehensive.\nA normal version number MUST take the form X.Y.Z where X, Y, and Z are
integers. X is the major version, Y is the minor version, and Z is the patch
version. Each element MUST increase numerically by increments of one. For
instance: 1.9.0 -> 1.10.0 -> 1.11.0.\nA normal version number MUST take the form X.Y.Z where X, Y, and Z are
integers. X is the major version, Y is the minor version, and Z is the patch
version. Each element MUST increase numerically by increments of one. For
instance: 1.9.0 -> 1.10.0 -> 1.11.0.\nWhen a major version number is incremented, the minor version and patch
version MUST be reset to zero. When a minor version number is incremented, the
patch version MUST be reset to zero. For instance: 1.1.3 -> 2.0.0 and 2.1.7 ->
2.2.0.\nWhen a major version number is incremented, the minor version and patch
version MUST be reset to zero. When a minor version number is incremented, the
patch version MUST be reset to zero. For instance: 1.1.3 -> 2.0.0 and 2.1.7 ->
2.2.0.\nA pre-release version number MAY be denoted by appending an arbitrary
string immediately following the patch version and a decimal point. The string
MUST be comprised of only alphanumerics plus dash [0-9A-Za-z-] and MUST begin
with an alpha character [A-Za-z]. Pre-release versions satisfy but have a
lower precedence than the associated normal version. Precedence SHOULD be
determined by lexicographic ASCII sort order. For instance: 1.0.0.alpha1 <
1.0.0.beta1 < 1.0.0.beta2 < 1.0.0.rc1 < 1.0.0.\nA pre-release version number MAY be denoted by appending an arbitrary
string immediately following the patch version and a decimal point. The string
MUST be comprised of only alphanumerics plus dash [0-9A-Za-z-] and MUST begin
with an alpha character [A-Za-z]. Pre-release versions satisfy but have a
lower precedence than the associated normal version. Precedence SHOULD be
determined by lexicographic ASCII sort order. For instance: 1.0.0.alpha1 <
1.0.0.beta1 < 1.0.0.beta2 < 1.0.0.rc1 < 1.0.0.\nOnce a versioned package has been released, the contents of that version
MUST NOT be modified. Any modifications must be released as a new version.\nOnce a versioned package has been released, the contents of that version
MUST NOT be modified. Any modifications must be released as a new version.\nMajor version zero (0.y.z) is for initial development. Anything may change
at any time. The public API should not be considered stable.\nMajor version zero (0.y.z) is for initial development. Anything may change
at any time. The public API should not be considered stable.\nVersion 1.0.0 defines the public API. The way in which the version number
is incremented after this release is dependent on this public API and how it
changes.\nVersion 1.0.0 defines the public API. The way in which the version number
is incremented after this release is dependent on this public API and how it
changes.\nPatch version Z (x.y.Z | x > 0) MUST be incremented if only backwards
compatible bug fixes are introduced. A bug fix is defined as an internal
change that fixes incorrect behavior.\nPatch version Z (x.y.Z | x > 0) MUST be incremented if only backwards
compatible bug fixes are introduced. A bug fix is defined as an internal
change that fixes incorrect behavior.\nMinor version Y (x.Y.z | x > 0) MUST be incremented if new, backwards
compatible functionality is introduced to the public API. It MAY be
incremented if substantial new functionality or improvements are introduced
within the private code. It MAY include patch level changes.\nMinor version Y (x.Y.z | x > 0) MUST be incremented if new, backwards
compatible functionality is introduced to the public API. It MAY be
incremented if substantial new functionality or improvements are introduced
within the private code. It MAY include patch level changes.\nMajor version X (X.y.z | X > 0) MUST be incremented if any backwards
incompatible changes are introduced to the public API. It MAY include minor
and patch level changes.\nMajor version X (X.y.z | X > 0) MUST be incremented if any backwards
incompatible changes are introduced to the public API. It MAY include minor
and patch level changes.\nTagging Specification (SemVerTag)\nThis sub-specification SHOULD be used if you use a version control system
(Git, Mercurial, SVN, etc) to store your code. Using this system allows
automated tools to inspect your package and determine SemVer compliance and
released versions.\nWhen tagging releases in a version control system, the tag for a version
MUST be “vX.Y.Z” e.g. “v3.1.0”.\nWhen tagging releases in a version control system, the tag for a version
MUST be “vX.Y.Z” e.g. “v3.1.0”.\nThe first revision that introduces SemVer compliance SHOULD be tagged
“semver”. This allows pre-existing projects to assume compliance at any
arbitrary point and for automated tools to discover this fact.\nThe first revision that introduces SemVer compliance SHOULD be tagged
“semver”. This allows pre-existing projects to assume compliance at any
arbitrary point and for automated tools to discover this fact.\nWhy Use Semantic Versioning?\nThis is not a new or revolutionary idea. In fact, you probably do something
close to this already. The problem is that “close” isn’t good enough. Without
compliance to some sort of formal specification, version numbers are
essentially useless for dependency management. By giving a name and clear
definition to the above ideas, it becomes easy to communicate your intentions
to the users of your software. Once these intentions are clear, flexible (but
not too flexible) dependency specifications can finally be made.\nA simple example will demonstrate how Semantic Versioning can make dependency
hell a thing of the past. Consider a library called “Firetruck.” It requires a
Semantically Versioned package named “Ladder.” At the time that Firetruck is
created, Ladder is at version 3.1.0. Since Firetruck uses some functionality
that was first introduced in 3.1.0, you can safely specify the Ladder
dependency as greater than or equal to 3.1.0 but less than 4.0.0. Now, when
Ladder version 3.1.1 and 3.2.0 become available, you can release them to your
package management system and know that they will be compatible with existing
dependent software.\nAs a responsible developer you will, of course, want to verify that any
package upgrades function as advertised. The real world is a messy place;
there’s nothing we can do about that but be vigilant. What you can do is let
Semantic Versioning provide you with a sane way to release and upgrade
packages without having to roll new versions of dependent packages, saving you
time and hassle.\nIf all of this sounds desirable, all you need to do to start using Semantic
Versioning is to declare that you are doing so and then follow the rules. Link
to this website from your README so others know the rules and can benefit from
them.\nHow do I know when to release 1.0.0?\nIf your software is being used in production, it should probably already be
1.0.0. If you have a stable API on which users have come to depend, you should
be 1.0.0. If you’re worrying a lot about backwards compatibility, you should
probably already be 1.0.0.\nDoesn’t this discourage rapid development and fast iteration?\nMajor version zero is all about rapid development. If you’re changing the API
every day you should either still be in version 0.x.x or on a separate
development branch working on the next major version.\nIf even the tiniest backwards incompatible changes to the public API require a major version bump, won’t I end up at version 42.0.0 very rapidly?\nThis is a question of responsible development and foresight. Incompatible
changes should not be introduced lightly to software that has a lot of
dependent code. The cost that must be incurred to upgrade can be significant.
Having to bump major versions to release incompatible changes means you’ll
think through the impact of your changes, and evaluate the cost/benefit ratio
involved.\nDocumenting the entire public API is too much work!\nIt is your responsibility as a professional developer to properly document
software that is intended for use by others. Managing software complexity is a
hugely important part of keeping a project efficient, and that’s hard to do if
nobody knows how to use your software, or what methods are safe to call. In
the long run, Semantic Versioning, and the insistence on a well defined public
API can keep everyone and everything running smoothly.\nWhat do I do if I accidentally release a backwards incompatible change as a minor version?\nAs soon as you realize that you’ve broken the Semantic Versioning spec, fix
the problem and release a new minor version that corrects the problem and
restores backwards compatibility. Remember, it is unacceptable to modify
versioned releases, even under this circumstance. If it’s appropriate,
document the offending version and inform your users of the problem so that
they are aware of the offending version.\nWhat should I do if I update my own dependencies without changing the public API?\nThat would be considered compatible since it does not affect the public API.
Software that explicitly depends on the same dependencies as your package
should have their own dependency specifications and the author will notice any
conflicts. Determining whether the change is a patch level or minor level
modification depends on whether you updated your dependencies in order to fix
a bug or introduce new functionality. I would usually expect additional code
for the latter instance, in which case it’s obviously a minor level increment.\nThe Semantic Versioning specification is authored by Tom Preston-Werner, inventor of Gravatars and cofounder of GitHub.\nIf you’d like to leave feedback, please open an issue on GitHub.\nopen an issue on GitHub\nCreative Commons ― CC BY 3.0
http://creativecommons.org/licenses/by/3.0/\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nالإدارة الدلالية لنُسخ البرمجيات 2.0.0

باختصار

بإعطاء الترقيم التالي ترقيع.بسيط.جذري أو كما يُعرف MAJOR.MINOR.PATCH لنُسخ البرمجيات، قم برفع درجة:


  ترقيم MAJOR (جذري) عند القيام بتغيرات جذرية غير متوافقة رجعيا للواجهة البرمجية (API)،
  ترقيم MINOR (بسيط) عند إضافة ميزات ووظائف جديدة لكن مُتوافقة رجعيًا، و
  ترقيم PATCH (ترقيع) عند القيام بإصلاحات للعلل والثغرات مُتوافقة رجعيًا.


الأوسمة الإضافية للنُسخ ما قبل النهائية (مثل: beta ،alpha …) والبيانات الوصفية لعمليات البناء والتجميع (build metadata) متوفرة كلواحق لصيغة MAJOR.MINOR.PATCH.

تمهيد

في عالم إدارة البرمجيات يتواجد هناك مكان مُفزع يُعرف بـ “جحيم الاعتماديات (dependency hell)”. كُلما كبُر نظامك وقمت بإدراج المزيد من الحزم في برمجيتك، كلما زاد احتمال أن تجد نفسك، يوما ما، في هاوية اليأس هذه.

في الأنظمة كثيرة الاعتماديات، إصدار نسخة جديدة من حزمة ما قد يتحول بشكل سريع إلى كابوس مُزعج. إذا كان وصف الاعتماديات في تلك الحزمة مُتشدّدًا جدًا، فإنك ستجد نفسك في مُواجهة خطر “قفل النُسخ” (version lock، أي عدم المقدرة على ترقية حزمة ما، دون الحاجة لإصدار نسخة جديدة من كل حزمة تعتمد عليها تلك الحزمة المُتشدّدة). أما في حال ما كان وصف الاعتماديات في تلك الحزمة مُتساهلا جدًا، فستجد نفسك -لا محالة- وقد تم لسعك بمُشكلة “انحلال النُسخ” (version promiscuity، أي فرط الإدّعاء بالتوافقية مع النسخ المُستقبلية بشكل يتجاوز الحد المعقول). جحيم الاعتماديات يكون عندما يمنعك قفل النُّسخ و/أو انحلال النُّسخ من المُضيّ قُدُما في مشروعك بسهولة وأمان.

كحل لهذه المعضلة، أَقترحُ بضعة قواعد ومتطلبات بسيطة من شأنها إملاء كيفية إسناد ترقيم لنُسخ البرمجيات وكيفية رفع درجة الترقيم.

هذه القواعد تعتمد -لكن ليس بالضرورة بشكل حصري- على الممارسات الشائعة الموجودة مُسبقا في كل من البرمجيات المفتوحة ومغلقة المصدر. وحتى يعمل هذا النظام، عليك أولا أن نُفصِح عن واجهة برمجية (API) للعامة (أي أن تقوم بنشرها ظاهرة)، قد تكون هذه الأخيرة عبارة عن مُجرد توثيق أو معززة بالشفرة المصدرية نفسها. أيًا كان الوضع، فإنه من المُهمّ أن تكون هذه الواجهة البرمجية واضحة ودقيقة. بمُجرد تحديد واجهتك البرمجية المٌُوجّهة للعامة (أي الظاهرة للعيان)، ستُشير إلى التغيّيرات التي تحصل عليها عن طريق رفع درجة ترقيم النسخة الحالية منها بشكل معين. تَبنّى صيغة ترقيم من الشكل X.Y.Z (أي Major.Minor.Patch). إصلاحات العِلل التي لا تؤثر على سير عمل الواجهة البرمجية تستوجب رفع درجة ترقيم “ترقيع” (patch)، التعديلات/الإضافات المُتوافقة رجعيًا على الواجهة البرمجية ترفع درجة ترقيم “بسيط” (minor)، أما التعديلات غير المتوافقة رجعيًا على الواجهة البرمجية تستوجب رفع درجة ترقيم “جذري” (major).

أُسمّي هذا الأمر  بـ”الإدارة الدلالية لنُسخ البرمجيات” (Semantic Versioning واختصارًا SemVer). باتّباع هذا النمط، فإن أرقام نُسخ البرمجيات وطريقة الترقيم ستُضفي معنًى يدُلّ على الشفرة المصدرية ومدى التغيرات الحاصلة من نسخة إلى النسخة التي تليها.

مُواصفات الإدارة الدلالية لنُسخ البرمجيات (SemVer)
الكلمات المفتاحية: يجب (MUST)، يجب أن لا (MUST NOT)، يتطلّب (REQUIRED)، ينبغي (SHALL)، ينبغي أن لا (SHALL NOT)، يجدُر (SHOULD)، يجدر أن لا (SHOULD NOT), مُستحسن (RECOMMENDED)، قد (MAY)، و اختياري (OPTIONAL) في هذه الوثيقة تُحمَل على نفس التأويل المُوَضّح في RFC 2119.


  
    البرمجيات التي تعتمد الإدارة الدلالية للنُّسخ يجب أن تُصرّح بواجهة برمجية (API) عامة. قد تكون هذه الواجهة البرمجية عبارة عن الشفرة المصدرية بحد ذاتها، أو أن وجودها محصورٌ في التوثيق. أيًا كان الأمر، فإنه يجدر بها أن تكون دقيقة ومفهومة.
  
  
    الترقيم الطبيعي للنُّسخ يجب أن يكون من الشكل X.Y.Z حيث X ،Y و Z عبارة عن أعداد صحيحة غير سالبة، و يجب أن لا تحتوي على أصفار بادئة. X يُشير إلى ترقيم جذري (Major)، أما Y إلى ترقيم بسيط (Minor)، و Z إلى ترقيم ترقيع. كل جزء من الترقيم يجب أن يتم رفعه عدديا بدرجة. على سبيل المثال: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    بمُجرّد إصدار نسخة جديدة من حزمة مُعيّنة بترقيم مُعيّن، يجب أن لا يُغيَّر محتوى تلك الحزمة. كل تغيير يتم إجراؤه عليها يجب أن يتم تصديره كنُسخة جديدة بترقيم مُغاير ومُناسب.
  
  
    الترقيم الجذري المُصفّر -(Major version zero (0.y.z- يُمثّل مرحلة التطوير الأوّلية. قد يتغير أي شيء في أي وقت. يجب أن لا تُعتبر الواجهة البرمجية (API) العامة-في هذه المرحلة- مُستقرة.
  
  
    النسخة 1.0.0 تُعرّف الواجهة البرمجية العامة. طريقة رفع درجات الترقيم بعد هذه الإصدارة يعتمد على الواجهة البرمجية العامة نفسها وطريقة إجراء التغييرات عليها.
  
  
    ترقيم الترقيع Z (أي x.y.Z بحيث x > 0) يجب أن تُرفع درجته فقط في حالة إدخال إصلاحات للعِلل مُتوافقة رجعيا، والمتمثلة في الإصلاحات الداخلية التي تُصحّح سُلوكًا غيرَ سويّ للبرمجية.
  
  
    ترقيم “بسيط” Y (أي x.Y.z بحيث x > 0) يجب أن تُرفع درجته إذا تم إدخال وظائف جديدة مُتوافقة رجعيًا للواجهة البرمجية العامة. ويجب أيضا رفع درجته في حال تم التخلي عن وظيفة ما (deprecating functionality) في الواجهة البرمجية العامة. قد يتم رفع درجته في حال تم إضافة وظيفية جوهرية أو تحسينات جديدة على نطاق خاص في الشفرة المصدرية. وقد يحتوي على تغييرات ترقيعية (Patch). ترقيم الترقيع (Patch) يجب أن يتم تصفيره (إرجاع قيمته إلى 0) عند رفع درجة ترقيم “بسيط” (Minor).
  
  
    ترقيم “جذري” X (أي X.y.z بحيث X > 0) يجب أن يتم رفع درجته في حال تم إدخال تغييرات غير متوافقة رجعيًا على الواجهة البرمجية العامة. قد يحتوي على تغييرات “ترقيعية” و “بسيطة”. يجب تصفير كل من ترقيم “بسيط” (Minor) وترقيم “ترقيع” (Patch) (أي إرجاع قيمتهما إلى 0) عند رفع درجة ترقيم “جذري” (Major).
  
  
    النُسخ المُعدّة لما قبل الإصدار قد يتم توسيمها بوصلة ‘-‘ تليها نقاط إضافية يُفصل بينها بمُعرّفات، وذلك مباشرة بعد ترقيم الترقيع (patch). يجب على هذه المُعرّفات أن تكون مكوّنة فقط من هجائيات عددية (alphanumerics) ووصلات ‘-‘ من ترميز ASCII وفقط، أي [0-9 A-Z a-z-]. يجب أن لا تكون هذه المُعرّفات فارغة. يجب أن لا تحتوي المعرفات الرقمية على أصفار بادئة. النُّسخ المُعدّة لما قبل الإصدار لها أولوية أقل من النسخ العادية المُصاحبة لها. النُّسخ المُعدّة لما قبل الإصدار تعني أنها نسخة غير مُستقرة وقد لا تُلبي التوافقية المرجوة منها كما هو مُشار إليه في الترقيم الطبيعي للنسخة المصاحبة لها. أمثلة:
1.0.0-alpha,  1.0.0-alpha.1,   1.0.0-0.3.7,   1.0.0-x.7.z.92
  
  
    البيانات الوصفية لعمليات البناء والتجميع (build metadata) قد يتم تعليمها عن طريق إضافة علامة زائد (+) و سلسلة من المُعرّفات مفصول بينها بنقاط، وذلك مُباشرة بعد ترقيم ترقيع (Patch) أو ترقيم النُسخ ما قبل النهائية (مثل: beta ،alpha …). يجب على البيانات الوصفية هذه أن لا تحتوى سوى على هجائيات عددية من ترميز ASCII ووصلة - وفقط، أي: [0-9A-Za-z-]. يجب أن لا تكون هذه المعرّفات فارغة.  يجدر إهمال ترقيم البيانات الوصفية لعميات البناء والتجميع عند تحديد أفضلية النُسخ. بالتالي، يُعتبر وجود نسختين مُختلفتين فقط في ترقيم البيانات الوصفية أن لهما نفس الأفضلية. أمثلة: 1.0.0-alpha+001,  1.0.0+20130313144700,   1.0.0-beta+exp.sha.5114f85
  
  
    الأفضلية تُشير إلى كيفية المُقارنة بين النُسخ عند ترتيبها. يجب أن يتم حساب الأفضلية عن طريق تقسيم ترقيم النُّسخ إلى ترقيع، بسيط، جذري ثم مُعرفات النسخ ما قبل النهائية (alpha, beta) مع احترام هذا الترتيب (البيانات الوصفية لا تظهر في الأفضلية). يتم تحديد الأفضلية عن طريق أول اختلاف يظهر عند المقارنة بين هذه المعرّفات من اليسار إلى اليمين على النحو التالي: تتم دائما المقارنة بين جذري، بسيط وترقيع عدديا، مثال: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. في حال تساوى ترقيم جذري، بسيط وترقيع، يتم احتساب ترقيم النسخ ما قبل النهائية (alpha, beta) على أن لها أفضلية أقل من النسخ العادية، مثال:  1.0.0 > 1.0.0-alpha . في حال تساوت النُسخ ما قبل النهائية بنفس ترقيم جذري، بسيط، ترقيع، يجب حساب الأفضلية عن طريق المقارنة بين المعرفات المفصول بينها بنقاط من اليسار إلى اليمين إلى غاية العثور على اختلاف، وذلك على النحو التالي: المعرفات المُكونة من أرقام فقط تتم مقارنتها عدديا، والمُعرّفات المُكوّنة من أحرف ووصلة (-) تتم مقارنتها أبجديًا وفق ترتيب ASCII. المُعرّفات الرقمية لها دائما أفضلية أقل من المعرفات غير العددية. كلما امتدت حقول النُّسخ ما قبل النهائية كلما زادت أفضليتها عن النّسخ ذوات حقول أقل إذا تساوت جميع المعرفات السابقة. مثال:
1.0.0 > 1.0.0-rc.1 > 1.0.0-beta.11 > 1.0.0-beta.2 > 1.0.0-beta > 1.0.0-alpha.beta > 1.0.0-alpha.1 > 1.0.0-alpha 
  


لماذا يجب استعمال الإدارة الدلالية لنُسخ البرمجيات ؟
هذه ليست فكرة جديدة أو ثورية. في الحقيقة، ربما تقوم حاليًا بشيء مُشابه لهذا الأمر. المُشكل أن هذا “الشبه” ليس جيدًا بما فيه الكفاية. من دون الامتثال إلى نوع من المُواصفات الرسمية، فإن ترقيم النسخ سيكون أساسًا من دون فائدة لإدارة الاعتماديات. بإعطاء اسم وتعريف واضح للأفكار المُقَدَمة أعلاه، سيُصبح من السهل إخطار مستخدمي برمجيتك بنواياك. بمُجرد أن تصبح هذه النوايا واضحة، سيكون من المُمكن أخيرًا وضع مُواصفات مرنة للاعتماديات (لكنها ليست بالغة المرونة).

مثال بسيط سيُوضّح كيف يُمكن للإدارة الدلالية لنُسخ البرمجيات أن تجعل من “جحيم الاعتماديات” شيئًا من الماضي. لنفرض أن هناك مكتبة برمجية تحمل الاسم “شاحنة الإطفاء”. تتطلّب هذه المكتبة حزمة برمجية تحمل الاسم “سُلّم” يتم إدارة نُسخها دلاليًا. في الوقت الذي تم فيه إنشاء مكتبة شاحنة الإطفاء، كانت حزمة سُلّم في نسختها 3.1.0. بما أن شاحنة الإطفاء تستعمل بعض الوظائف التي تم إدخالها أول مرة في النسخة 3.1.0، فإنه بإمكانك أن تُحدّد اعتمادية سُلّم لتكون أكبر من أو تُساوي 3.1.0 وأقل من 4.0.0 بكل أمان. الآن، عند إصدار النُسَخ 3.1.1 و 3.2.0 من حزمة سُلّم، يُمكنك نشرها في نظام إدارة الحزم خاصتك وأنت تعلم أنها مُتوافقة مع البرمجيات الحالية التي تعتمد عليها.

بصفتك مُطورًا مسؤولا، سيتوجّب عليك أن تتحقّق من أن كل عملية ترقية لحزمة مُعيّنة تعمل كما تم الإشهار لها. العالم الحقيقي مكان فوضوي، لا يوجد ما يمكننا فعله حيال ذلك سوى أن نكون يقظين. ما يمكنك فعله هو أن تنتهج طريقا بواسطة الإدارة الدلالية لنُسخ البرمجيات (Semantic Versioning)  يسمح لك بإصدار وترقية الحزم من دون الحاجة لإصدار نُسخ جديدة من الحزم الأخرى المُعتمد عليها بكل رزانة، حافظًا لوقتك ومُتجنبًا لجميع المتاعب.

إذا بدى لك كل هذا الأمر مُحبّذًا، فإن كل ما تحتاج لفعله للبدء في استعمال الإدارة الدلالية لنُسخ البرمجيات هو أن تعلن أنك ستمتثل وتتّبع قواعدها. أشر إلى هذا الموقع في ملف README الخاص بمشروعك حتى يعلم البقية بهذه القواعد وتُمكّنهم من الاستفادة منها.

الأسئلة الأكثر شيوعًا

كيف يجدر بي التعامل مع مُراجعات O.y.z عند بداية مرحلة التطوير الأوّلية؟

أبسط شيء يُمكن القيام به هو أن تستهلّ مرحلة التطوير الأولية بإصدار النسخة 0.1.0 ثم ترفع درجة ترقيم “بسيط” (Minor) بعد كل إصدارة تليها.

متى أعرف أنه حان وقت إصدار النسخة 1.0.0؟

إذا كان يتم استخدام برمجيتك بشكل فعلي في خدمة زبائن حقيقيين من طرف جهة مُعيّنة، فعلى الأرجح أنه قد حان وقت ترقيمها بالنسخة 1.0.0. إذا كنت تملك واجهة برمجية مُستقرة بحيث يجري الاعتماد عليها من طرف مستخدمين لها، فإنه يجب إذًا أن تكون 1.0.0. إذا كنت من الحريصين جدًا على التوافقية الرجعية، فأغلب الظن أنه قد حان فعلا وقت النسخة 1.0.0.

ألا يُثبّط هذا من عمليات التطوير المُتسارعة والتكرارية؟

الغرض من وجود النسخة الجذرية المصفّرة (Major version zero) هو عمليات التطوير السريعة. إذا كنت تغيّر من الواجهة البرمجية كل يوم، فإنه يجدر بك إما أن تبقى عند الترقيم O.y.z أو أن تكون في فرع تطوير مُنفصل (branch) تعمل فيه على النسخة الجذرية القادمة.

إذا كان حتى أصغر تغيير غير مُتوافق رجعيا للواجهة البرمجية العامة يتطلب رفع ترقيم جذري، ألن يقودَني ذلك إلى النسخة 42.0.0 بسرعة فائقة؟

هذا السؤال له علاقة بمسؤولية التطوير وبُعد النظر، لا يجدر بالتغييرات غير المتوافقة رجعيًا أن يتم إدخالها بهذه السرعة على البرمجيات التي يتم الاعتماد على شفرتها. ستكون التكلفة التي تتكبدها عملية الترقية مُعتبرة. وجوب رفع ترقيم النسخ الجذرية لإصدار تغييرات غير متوافقة يعني أنك ستفكر في عواقب هذه التغييرات، وتوزان بين نسبة المصلحة/التكلفة التي تنجرّ عنها.

عملية التوثيق الكامل للواجهة البرمجية (API) تُعتبر عملا مُنهكا!

من مسؤولياتك كمُطور مُحترف أن توثّق بشكل صحيح البرمجية المُوجّهة للاستعمال من قِبَل مُستخدمين آخرين. إدارة تعقيد البرمجيات هو جزء بالغ الأهمية للحفاظ على كفاءة المشروع، وهذا شيء صعبٌ القيامُ به إن لم يكن هناك أي شخص على علم بكيفية استعمال برمجيتك، أو بالوظائف التي يُمكن استدعاؤها بأمان. على المدى البعيد، ستُمكّن الإدارة الدلالية والإصرار على وجود واجهة برمجية عامة واضحة المعالم من الإبقاء على السير الحسن للأمور عند الجميع.

ماذا يتوجب عليَّ فعله عندما أُصدر عن طريق الخطأ نسخةً بتغييرات غير مُتوافقة رجعيًا كنُسخة ترقيعية (Minor version)؟

بمُجرد إدراكك بأنك قمت بنقض مُواصفات الإدارة الدلالية، قم بإصلاح المُشكل ثم قم بإصدار نسخة بسيطة جديدة (Minor) تُصلح العلة وتقوم بإرجاع التوافقية الرجعية. حتى تحت هذا الظرف، فإنه من غير المقبول أن تُغيّر من النُسخ التي تم إصدارها مُسبقا. قم بتوثيق النُسخة المُخالفة إذا كان ذلك مُلائما، وأخبر المُستخدمين بالمُشكلة حتى يكونوا على علم بالنُسخة المُخالفة.

ما يتوجب علي فعله عندما أحدّث الاعتماديات الخاصة بي دون تغيير الواجهة البرمجية العامة.

سيُعتبر هذا على الأرجح أنه تغيير مُتوافق رجعيًا حيث أنه لا يَمَس الواجهة البرمجية العامة. يجدر بالبرمجيات التي تعتمد صراحة على نفس الاعتماديات التي تعتمد عليها حزمتك أن تتبع مُواصفات اعتماديات خاصة بها وأن ينتبه المُؤلف الأصلي لها لأي تضارب قد يحصل. تحديد ما إذا كانت هذه التغيرات بمثابة ترقيع أو بسيط يعتمد على ما إذا قمت بتحديث اعتمادياتك لتصحيح علة مُعيّنة أو لإدخال وظيفة جديدة. غالبًا ما أتوقع إضافة شفرة برمجية بالنسبة للحالة الثانية (إدخال وظيفة جديدة)، وبالتالي سيكون هذا الأمر بطبيعة الحال بمثابة تغيير يتطلب رفع ترقيم بسيط.

ماذا لو قمت عن غير قصد بتغيير الواجهة البرمجية العامة بطريقة لا تتماشى مع ترقيم النسخة (مثال: الشفرة تُدخِل عن طريق الخطأ تغييرات جذرية تكسر التوافقية الرجعية في إصدارة ترقيعية patch)

اجتهد واحكم بنفسك، إذا كنت تملك جمهورًا غفيرًا سيتأثر بشكل كبير لو قمت بإرجاع الواجهة البرمجية العامة إلى سابق حالها كما كان مقصودًا، فسيكون حينئذ من الأفضل إصدار نسخة جذرية جديدة، حتى ولو تم اعتبار الإصلاح على أنه فقط إصدارة ترقيعية. تذكّر دائما أن هدف الإدارة الدلالية هو إضفاء معنىً حول التغييرات الحاصلة عن طريق كيفية تغيير ترقيم النُّسخ. إذا كانت هذه التغييرات ذات أهمية عند مُستخدمي برمجيتك، فاستعمل ترقيم النُسخ لإعلامهم بذلك.

ماذا عن الوظائف المُتخلى عنها (deprecating functionality) ؟

التخلّي عن وظيفة موجودة مُسبقا شيء طبيعي في تطوير البرمجيات، بل يُعتبر أحيانا خطوة لابد منها للمُضي قُدما. عندما تتخلّى عن إحدى الوظائف في الواجهة البرمجية العامة، فإنه يجب عليك القيام بأمرين: (1) قم بتحديث التوثيق حتى يعلم بقية المُستخدمين بهذا التغيير، (2) أصدر نسخة بسيطة (Minor) جديدةً تحتوي على الوظيفة المُتخلى عنها. قبل حذف الوظيفة نهائيًا في نسخة جذرية (Major). يجب على الأقل أن تكون هناك نسخة بسيطة تحتوي على الوظيفة المُتخلى عنها حتى تُمكّن المستخدمين من الانتقال السلِس إلى الواجهة البرمجية الجديدة.

هل يفرض semver حدًا مُعينًا لطول السلسلة النصية عند ترقيم النُّسخ ؟

لا، لكن اجتهد وأحسن التقدير. استعمال 255 حرفا على سبيل المثال في ترقيم نسخة ما قد يكون أمرًا مُبالغًا فيه. تذكّر أيضًا بأن بعض المنصّات تضع حدًا لطول السلسة النصية.

نُبذة

مُواصفات الإدارة الدلالية لنُسخ البرمجيات من تأليف Tom
Preston-Werner, مُبتكر خدمة Gravatars وأحد مؤسسي GitHub.

لديك اقتراح؟ يُرجى فتح “خطب” على
GitHub.

الرُخصة

المشاع الإبداعي ― CC BY 3.0\nالإدارة الدلالية لنُسخ البرمجيات 2.0.0\nبإعطاء الترقيم التالي ترقيع.بسيط.جذري أو كما يُعرف MAJOR.MINOR.PATCH لنُسخ البرمجيات، قم برفع درجة:\nترقيم MAJOR (جذري) عند القيام بتغيرات جذرية غير متوافقة رجعيا للواجهة البرمجية (API)،\nترقيم MINOR (بسيط) عند إضافة ميزات ووظائف جديدة لكن مُتوافقة رجعيًا، و\nترقيم PATCH (ترقيع) عند القيام بإصلاحات للعلل والثغرات مُتوافقة رجعيًا.\nالأوسمة الإضافية للنُسخ ما قبل النهائية (مثل: beta ،alpha …) والبيانات الوصفية لعمليات البناء والتجميع (build metadata) متوفرة كلواحق لصيغة MAJOR.MINOR.PATCH.\nفي عالم إدارة البرمجيات يتواجد هناك مكان مُفزع يُعرف بـ “جحيم الاعتماديات (dependency hell)”. كُلما كبُر نظامك وقمت بإدراج المزيد من الحزم في برمجيتك، كلما زاد احتمال أن تجد نفسك، يوما ما، في هاوية اليأس هذه.\nفي الأنظمة كثيرة الاعتماديات، إصدار نسخة جديدة من حزمة ما قد يتحول بشكل سريع إلى كابوس مُزعج. إذا كان وصف الاعتماديات في تلك الحزمة مُتشدّدًا جدًا، فإنك ستجد نفسك في مُواجهة خطر “قفل النُسخ” (version lock، أي عدم المقدرة على ترقية حزمة ما، دون الحاجة لإصدار نسخة جديدة من كل حزمة تعتمد عليها تلك الحزمة المُتشدّدة). أما في حال ما كان وصف الاعتماديات في تلك الحزمة مُتساهلا جدًا، فستجد نفسك -لا محالة- وقد تم لسعك بمُشكلة “انحلال النُسخ” (version promiscuity، أي فرط الإدّعاء بالتوافقية مع النسخ المُستقبلية بشكل يتجاوز الحد المعقول). جحيم الاعتماديات يكون عندما يمنعك قفل النُّسخ و/أو انحلال النُّسخ من المُضيّ قُدُما في مشروعك بسهولة وأمان.\nكحل لهذه المعضلة، أَقترحُ بضعة قواعد ومتطلبات بسيطة من شأنها إملاء كيفية إسناد ترقيم لنُسخ البرمجيات وكيفية رفع درجة الترقيم.\nهذه القواعد تعتمد -لكن ليس بالضرورة بشكل حصري- على الممارسات الشائعة الموجودة مُسبقا في كل من البرمجيات المفتوحة ومغلقة المصدر. وحتى يعمل هذا النظام، عليك أولا أن نُفصِح عن واجهة برمجية (API) للعامة (أي أن تقوم بنشرها ظاهرة)، قد تكون هذه الأخيرة عبارة عن مُجرد توثيق أو معززة بالشفرة المصدرية نفسها. أيًا كان الوضع، فإنه من المُهمّ أن تكون هذه الواجهة البرمجية واضحة ودقيقة. بمُجرد تحديد واجهتك البرمجية المٌُوجّهة للعامة (أي الظاهرة للعيان)، ستُشير إلى التغيّيرات التي تحصل عليها عن طريق رفع درجة ترقيم النسخة الحالية منها بشكل معين. تَبنّى صيغة ترقيم من الشكل X.Y.Z (أي Major.Minor.Patch). إصلاحات العِلل التي لا تؤثر على سير عمل الواجهة البرمجية تستوجب رفع درجة ترقيم “ترقيع” (patch)، التعديلات/الإضافات المُتوافقة رجعيًا على الواجهة البرمجية ترفع درجة ترقيم “بسيط” (minor)، أما التعديلات غير المتوافقة رجعيًا على الواجهة البرمجية تستوجب رفع درجة ترقيم “جذري” (major).\nأُسمّي هذا الأمر  بـ”الإدارة الدلالية لنُسخ البرمجيات” (Semantic Versioning واختصارًا SemVer). باتّباع هذا النمط، فإن أرقام نُسخ البرمجيات وطريقة الترقيم ستُضفي معنًى يدُلّ على الشفرة المصدرية ومدى التغيرات الحاصلة من نسخة إلى النسخة التي تليها.\nمُواصفات الإدارة الدلالية لنُسخ البرمجيات (SemVer)\nالكلمات المفتاحية: يجب (MUST)، يجب أن لا (MUST NOT)، يتطلّب (REQUIRED)، ينبغي (SHALL)، ينبغي أن لا (SHALL NOT)، يجدُر (SHOULD)، يجدر أن لا (SHOULD NOT), مُستحسن (RECOMMENDED)، قد (MAY)، و اختياري (OPTIONAL) في هذه الوثيقة تُحمَل على نفس التأويل المُوَضّح في RFC 2119.\nالبرمجيات التي تعتمد الإدارة الدلالية للنُّسخ يجب أن تُصرّح بواجهة برمجية (API) عامة. قد تكون هذه الواجهة البرمجية عبارة عن الشفرة المصدرية بحد ذاتها، أو أن وجودها محصورٌ في التوثيق. أيًا كان الأمر، فإنه يجدر بها أن تكون دقيقة ومفهومة.\nالبرمجيات التي تعتمد الإدارة الدلالية للنُّسخ يجب أن تُصرّح بواجهة برمجية (API) عامة. قد تكون هذه الواجهة البرمجية عبارة عن الشفرة المصدرية بحد ذاتها، أو أن وجودها محصورٌ في التوثيق. أيًا كان الأمر، فإنه يجدر بها أن تكون دقيقة ومفهومة.\nالترقيم الطبيعي للنُّسخ يجب أن يكون من الشكل X.Y.Z حيث X ،Y و Z عبارة عن أعداد صحيحة غير سالبة، و يجب أن لا تحتوي على أصفار بادئة. X يُشير إلى ترقيم جذري (Major)، أما Y إلى ترقيم بسيط (Minor)، و Z إلى ترقيم ترقيع. كل جزء من الترقيم يجب أن يتم رفعه عدديا بدرجة. على سبيل المثال: 1.9.0 -> 1.10.0 -> 1.11.0.\nالترقيم الطبيعي للنُّسخ يجب أن يكون من الشكل X.Y.Z حيث X ،Y و Z عبارة عن أعداد صحيحة غير سالبة، و يجب أن لا تحتوي على أصفار بادئة. X يُشير إلى ترقيم جذري (Major)، أما Y إلى ترقيم بسيط (Minor)، و Z إلى ترقيم ترقيع. كل جزء من الترقيم يجب أن يتم رفعه عدديا بدرجة. على سبيل المثال: 1.9.0 -> 1.10.0 -> 1.11.0.\nبمُجرّد إصدار نسخة جديدة من حزمة مُعيّنة بترقيم مُعيّن، يجب أن لا يُغيَّر محتوى تلك الحزمة. كل تغيير يتم إجراؤه عليها يجب أن يتم تصديره كنُسخة جديدة بترقيم مُغاير ومُناسب.\nبمُجرّد إصدار نسخة جديدة من حزمة مُعيّنة بترقيم مُعيّن، يجب أن لا يُغيَّر محتوى تلك الحزمة. كل تغيير يتم إجراؤه عليها يجب أن يتم تصديره كنُسخة جديدة بترقيم مُغاير ومُناسب.\nالترقيم الجذري المُصفّر -(Major version zero (0.y.z- يُمثّل مرحلة التطوير الأوّلية. قد يتغير أي شيء في أي وقت. يجب أن لا تُعتبر الواجهة البرمجية (API) العامة-في هذه المرحلة- مُستقرة.\nالترقيم الجذري المُصفّر -(Major version zero (0.y.z- يُمثّل مرحلة التطوير الأوّلية. قد يتغير أي شيء في أي وقت. يجب أن لا تُعتبر الواجهة البرمجية (API) العامة-في هذه المرحلة- مُستقرة.\nالنسخة 1.0.0 تُعرّف الواجهة البرمجية العامة. طريقة رفع درجات الترقيم بعد هذه الإصدارة يعتمد على الواجهة البرمجية العامة نفسها وطريقة إجراء التغييرات عليها.\nالنسخة 1.0.0 تُعرّف الواجهة البرمجية العامة. طريقة رفع درجات الترقيم بعد هذه الإصدارة يعتمد على الواجهة البرمجية العامة نفسها وطريقة إجراء التغييرات عليها.\nترقيم الترقيع Z (أي x.y.Z بحيث x > 0) يجب أن تُرفع درجته فقط في حالة إدخال إصلاحات للعِلل مُتوافقة رجعيا، والمتمثلة في الإصلاحات الداخلية التي تُصحّح سُلوكًا غيرَ سويّ للبرمجية.\nترقيم الترقيع Z (أي x.y.Z بحيث x > 0) يجب أن تُرفع درجته فقط في حالة إدخال إصلاحات للعِلل مُتوافقة رجعيا، والمتمثلة في الإصلاحات الداخلية التي تُصحّح سُلوكًا غيرَ سويّ للبرمجية.\nترقيم “بسيط” Y (أي x.Y.z بحيث x > 0) يجب أن تُرفع درجته إذا تم إدخال وظائف جديدة مُتوافقة رجعيًا للواجهة البرمجية العامة. ويجب أيضا رفع درجته في حال تم التخلي عن وظيفة ما (deprecating functionality) في الواجهة البرمجية العامة. قد يتم رفع درجته في حال تم إضافة وظيفية جوهرية أو تحسينات جديدة على نطاق خاص في الشفرة المصدرية. وقد يحتوي على تغييرات ترقيعية (Patch). ترقيم الترقيع (Patch) يجب أن يتم تصفيره (إرجاع قيمته إلى 0) عند رفع درجة ترقيم “بسيط” (Minor).\nترقيم “بسيط” Y (أي x.Y.z بحيث x > 0) يجب أن تُرفع درجته إذا تم إدخال وظائف جديدة مُتوافقة رجعيًا للواجهة البرمجية العامة. ويجب أيضا رفع درجته في حال تم التخلي عن وظيفة ما (deprecating functionality) في الواجهة البرمجية العامة. قد يتم رفع درجته في حال تم إضافة وظيفية جوهرية أو تحسينات جديدة على نطاق خاص في الشفرة المصدرية. وقد يحتوي على تغييرات ترقيعية (Patch). ترقيم الترقيع (Patch) يجب أن يتم تصفيره (إرجاع قيمته إلى 0) عند رفع درجة ترقيم “بسيط” (Minor).\nترقيم “جذري” X (أي X.y.z بحيث X > 0) يجب أن يتم رفع درجته في حال تم إدخال تغييرات غير متوافقة رجعيًا على الواجهة البرمجية العامة. قد يحتوي على تغييرات “ترقيعية” و “بسيطة”. يجب تصفير كل من ترقيم “بسيط” (Minor) وترقيم “ترقيع” (Patch) (أي إرجاع قيمتهما إلى 0) عند رفع درجة ترقيم “جذري” (Major).\nترقيم “جذري” X (أي X.y.z بحيث X > 0) يجب أن يتم رفع درجته في حال تم إدخال تغييرات غير متوافقة رجعيًا على الواجهة البرمجية العامة. قد يحتوي على تغييرات “ترقيعية” و “بسيطة”. يجب تصفير كل من ترقيم “بسيط” (Minor) وترقيم “ترقيع” (Patch) (أي إرجاع قيمتهما إلى 0) عند رفع درجة ترقيم “جذري” (Major).\nالنُسخ المُعدّة لما قبل الإصدار قد يتم توسيمها بوصلة ‘-‘ تليها نقاط إضافية يُفصل بينها بمُعرّفات، وذلك مباشرة بعد ترقيم الترقيع (patch). يجب على هذه المُعرّفات أن تكون مكوّنة فقط من هجائيات عددية (alphanumerics) ووصلات ‘-‘ من ترميز ASCII وفقط، أي [0-9 A-Z a-z-]. يجب أن لا تكون هذه المُعرّفات فارغة. يجب أن لا تحتوي المعرفات الرقمية على أصفار بادئة. النُّسخ المُعدّة لما قبل الإصدار لها أولوية أقل من النسخ العادية المُصاحبة لها. النُّسخ المُعدّة لما قبل الإصدار تعني أنها نسخة غير مُستقرة وقد لا تُلبي التوافقية المرجوة منها كما هو مُشار إليه في الترقيم الطبيعي للنسخة المصاحبة لها. أمثلة:
1.0.0-alpha,  1.0.0-alpha.1,   1.0.0-0.3.7,   1.0.0-x.7.z.92\nالنُسخ المُعدّة لما قبل الإصدار قد يتم توسيمها بوصلة ‘-‘ تليها نقاط إضافية يُفصل بينها بمُعرّفات، وذلك مباشرة بعد ترقيم الترقيع (patch). يجب على هذه المُعرّفات أن تكون مكوّنة فقط من هجائيات عددية (alphanumerics) ووصلات ‘-‘ من ترميز ASCII وفقط، أي [0-9 A-Z a-z-]. يجب أن لا تكون هذه المُعرّفات فارغة. يجب أن لا تحتوي المعرفات الرقمية على أصفار بادئة. النُّسخ المُعدّة لما قبل الإصدار لها أولوية أقل من النسخ العادية المُصاحبة لها. النُّسخ المُعدّة لما قبل الإصدار تعني أنها نسخة غير مُستقرة وقد لا تُلبي التوافقية المرجوة منها كما هو مُشار إليه في الترقيم الطبيعي للنسخة المصاحبة لها. أمثلة:
1.0.0-alpha,  1.0.0-alpha.1,   1.0.0-0.3.7,   1.0.0-x.7.z.92\n1.0.0-alpha,  1.0.0-alpha.1,   1.0.0-0.3.7,   1.0.0-x.7.z.92\nالبيانات الوصفية لعمليات البناء والتجميع (build metadata) قد يتم تعليمها عن طريق إضافة علامة زائد (+) و سلسلة من المُعرّفات مفصول بينها بنقاط، وذلك مُباشرة بعد ترقيم ترقيع (Patch) أو ترقيم النُسخ ما قبل النهائية (مثل: beta ،alpha …). يجب على البيانات الوصفية هذه أن لا تحتوى سوى على هجائيات عددية من ترميز ASCII ووصلة - وفقط، أي: [0-9A-Za-z-]. يجب أن لا تكون هذه المعرّفات فارغة.  يجدر إهمال ترقيم البيانات الوصفية لعميات البناء والتجميع عند تحديد أفضلية النُسخ. بالتالي، يُعتبر وجود نسختين مُختلفتين فقط في ترقيم البيانات الوصفية أن لهما نفس الأفضلية. أمثلة: 1.0.0-alpha+001,  1.0.0+20130313144700,   1.0.0-beta+exp.sha.5114f85\nالبيانات الوصفية لعمليات البناء والتجميع (build metadata) قد يتم تعليمها عن طريق إضافة علامة زائد (+) و سلسلة من المُعرّفات مفصول بينها بنقاط، وذلك مُباشرة بعد ترقيم ترقيع (Patch) أو ترقيم النُسخ ما قبل النهائية (مثل: beta ،alpha …). يجب على البيانات الوصفية هذه أن لا تحتوى سوى على هجائيات عددية من ترميز ASCII ووصلة - وفقط، أي: [0-9A-Za-z-]. يجب أن لا تكون هذه المعرّفات فارغة.  يجدر إهمال ترقيم البيانات الوصفية لعميات البناء والتجميع عند تحديد أفضلية النُسخ. بالتالي، يُعتبر وجود نسختين مُختلفتين فقط في ترقيم البيانات الوصفية أن لهما نفس الأفضلية. أمثلة: 1.0.0-alpha+001,  1.0.0+20130313144700,   1.0.0-beta+exp.sha.5114f85\n1.0.0-alpha+001,  1.0.0+20130313144700,   1.0.0-beta+exp.sha.5114f85\nالأفضلية تُشير إلى كيفية المُقارنة بين النُسخ عند ترتيبها. يجب أن يتم حساب الأفضلية عن طريق تقسيم ترقيم النُّسخ إلى ترقيع، بسيط، جذري ثم مُعرفات النسخ ما قبل النهائية (alpha, beta) مع احترام هذا الترتيب (البيانات الوصفية لا تظهر في الأفضلية). يتم تحديد الأفضلية عن طريق أول اختلاف يظهر عند المقارنة بين هذه المعرّفات من اليسار إلى اليمين على النحو التالي: تتم دائما المقارنة بين جذري، بسيط وترقيع عدديا، مثال: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. في حال تساوى ترقيم جذري، بسيط وترقيع، يتم احتساب ترقيم النسخ ما قبل النهائية (alpha, beta) على أن لها أفضلية أقل من النسخ العادية، مثال:  1.0.0 > 1.0.0-alpha . في حال تساوت النُسخ ما قبل النهائية بنفس ترقيم جذري، بسيط، ترقيع، يجب حساب الأفضلية عن طريق المقارنة بين المعرفات المفصول بينها بنقاط من اليسار إلى اليمين إلى غاية العثور على اختلاف، وذلك على النحو التالي: المعرفات المُكونة من أرقام فقط تتم مقارنتها عدديا، والمُعرّفات المُكوّنة من أحرف ووصلة (-) تتم مقارنتها أبجديًا وفق ترتيب ASCII. المُعرّفات الرقمية لها دائما أفضلية أقل من المعرفات غير العددية. كلما امتدت حقول النُّسخ ما قبل النهائية كلما زادت أفضليتها عن النّسخ ذوات حقول أقل إذا تساوت جميع المعرفات السابقة. مثال:
1.0.0 > 1.0.0-rc.1 > 1.0.0-beta.11 > 1.0.0-beta.2 > 1.0.0-beta > 1.0.0-alpha.beta > 1.0.0-alpha.1 > 1.0.0-alpha\nالأفضلية تُشير إلى كيفية المُقارنة بين النُسخ عند ترتيبها. يجب أن يتم حساب الأفضلية عن طريق تقسيم ترقيم النُّسخ إلى ترقيع، بسيط، جذري ثم مُعرفات النسخ ما قبل النهائية (alpha, beta) مع احترام هذا الترتيب (البيانات الوصفية لا تظهر في الأفضلية). يتم تحديد الأفضلية عن طريق أول اختلاف يظهر عند المقارنة بين هذه المعرّفات من اليسار إلى اليمين على النحو التالي: تتم دائما المقارنة بين جذري، بسيط وترقيع عدديا، مثال: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. في حال تساوى ترقيم جذري، بسيط وترقيع، يتم احتساب ترقيم النسخ ما قبل النهائية (alpha, beta) على أن لها أفضلية أقل من النسخ العادية، مثال:  1.0.0 > 1.0.0-alpha . في حال تساوت النُسخ ما قبل النهائية بنفس ترقيم جذري، بسيط، ترقيع، يجب حساب الأفضلية عن طريق المقارنة بين المعرفات المفصول بينها بنقاط من اليسار إلى اليمين إلى غاية العثور على اختلاف، وذلك على النحو التالي: المعرفات المُكونة من أرقام فقط تتم مقارنتها عدديا، والمُعرّفات المُكوّنة من أحرف ووصلة (-) تتم مقارنتها أبجديًا وفق ترتيب ASCII. المُعرّفات الرقمية لها دائما أفضلية أقل من المعرفات غير العددية. كلما امتدت حقول النُّسخ ما قبل النهائية كلما زادت أفضليتها عن النّسخ ذوات حقول أقل إذا تساوت جميع المعرفات السابقة. مثال:
1.0.0 > 1.0.0-rc.1 > 1.0.0-beta.11 > 1.0.0-beta.2 > 1.0.0-beta > 1.0.0-alpha.beta > 1.0.0-alpha.1 > 1.0.0-alpha\n1.0.0 > 1.0.0-rc.1 > 1.0.0-beta.11 > 1.0.0-beta.2 > 1.0.0-beta > 1.0.0-alpha.beta > 1.0.0-alpha.1 > 1.0.0-alpha\nلماذا يجب استعمال الإدارة الدلالية لنُسخ البرمجيات ؟\nهذه ليست فكرة جديدة أو ثورية. في الحقيقة، ربما تقوم حاليًا بشيء مُشابه لهذا الأمر. المُشكل أن هذا “الشبه” ليس جيدًا بما فيه الكفاية. من دون الامتثال إلى نوع من المُواصفات الرسمية، فإن ترقيم النسخ سيكون أساسًا من دون فائدة لإدارة الاعتماديات. بإعطاء اسم وتعريف واضح للأفكار المُقَدَمة أعلاه، سيُصبح من السهل إخطار مستخدمي برمجيتك بنواياك. بمُجرد أن تصبح هذه النوايا واضحة، سيكون من المُمكن أخيرًا وضع مُواصفات مرنة للاعتماديات (لكنها ليست بالغة المرونة).\nمثال بسيط سيُوضّح كيف يُمكن للإدارة الدلالية لنُسخ البرمجيات أن تجعل من “جحيم الاعتماديات” شيئًا من الماضي. لنفرض أن هناك مكتبة برمجية تحمل الاسم “شاحنة الإطفاء”. تتطلّب هذه المكتبة حزمة برمجية تحمل الاسم “سُلّم” يتم إدارة نُسخها دلاليًا. في الوقت الذي تم فيه إنشاء مكتبة شاحنة الإطفاء، كانت حزمة سُلّم في نسختها 3.1.0. بما أن شاحنة الإطفاء تستعمل بعض الوظائف التي تم إدخالها أول مرة في النسخة 3.1.0، فإنه بإمكانك أن تُحدّد اعتمادية سُلّم لتكون أكبر من أو تُساوي 3.1.0 وأقل من 4.0.0 بكل أمان. الآن، عند إصدار النُسَخ 3.1.1 و 3.2.0 من حزمة سُلّم، يُمكنك نشرها في نظام إدارة الحزم خاصتك وأنت تعلم أنها مُتوافقة مع البرمجيات الحالية التي تعتمد عليها.\nبصفتك مُطورًا مسؤولا، سيتوجّب عليك أن تتحقّق من أن كل عملية ترقية لحزمة مُعيّنة تعمل كما تم الإشهار لها. العالم الحقيقي مكان فوضوي، لا يوجد ما يمكننا فعله حيال ذلك سوى أن نكون يقظين. ما يمكنك فعله هو أن تنتهج طريقا بواسطة الإدارة الدلالية لنُسخ البرمجيات (Semantic Versioning)  يسمح لك بإصدار وترقية الحزم من دون الحاجة لإصدار نُسخ جديدة من الحزم الأخرى المُعتمد عليها بكل رزانة، حافظًا لوقتك ومُتجنبًا لجميع المتاعب.\nإذا بدى لك كل هذا الأمر مُحبّذًا، فإن كل ما تحتاج لفعله للبدء في استعمال الإدارة الدلالية لنُسخ البرمجيات هو أن تعلن أنك ستمتثل وتتّبع قواعدها. أشر إلى هذا الموقع في ملف README الخاص بمشروعك حتى يعلم البقية بهذه القواعد وتُمكّنهم من الاستفادة منها.\nالأسئلة الأكثر شيوعًا\nكيف يجدر بي التعامل مع مُراجعات O.y.z عند بداية مرحلة التطوير الأوّلية؟\nأبسط شيء يُمكن القيام به هو أن تستهلّ مرحلة التطوير الأولية بإصدار النسخة 0.1.0 ثم ترفع درجة ترقيم “بسيط” (Minor) بعد كل إصدارة تليها.\nمتى أعرف أنه حان وقت إصدار النسخة 1.0.0؟\nإذا كان يتم استخدام برمجيتك بشكل فعلي في خدمة زبائن حقيقيين من طرف جهة مُعيّنة، فعلى الأرجح أنه قد حان وقت ترقيمها بالنسخة 1.0.0. إذا كنت تملك واجهة برمجية مُستقرة بحيث يجري الاعتماد عليها من طرف مستخدمين لها، فإنه يجب إذًا أن تكون 1.0.0. إذا كنت من الحريصين جدًا على التوافقية الرجعية، فأغلب الظن أنه قد حان فعلا وقت النسخة 1.0.0.\nألا يُثبّط هذا من عمليات التطوير المُتسارعة والتكرارية؟\nالغرض من وجود النسخة الجذرية المصفّرة (Major version zero) هو عمليات التطوير السريعة. إذا كنت تغيّر من الواجهة البرمجية كل يوم، فإنه يجدر بك إما أن تبقى عند الترقيم O.y.z أو أن تكون في فرع تطوير مُنفصل (branch) تعمل فيه على النسخة الجذرية القادمة.\nإذا كان حتى أصغر تغيير غير مُتوافق رجعيا للواجهة البرمجية العامة يتطلب رفع ترقيم جذري، ألن يقودَني ذلك إلى النسخة 42.0.0 بسرعة فائقة؟\nهذا السؤال له علاقة بمسؤولية التطوير وبُعد النظر، لا يجدر بالتغييرات غير المتوافقة رجعيًا أن يتم إدخالها بهذه السرعة على البرمجيات التي يتم الاعتماد على شفرتها. ستكون التكلفة التي تتكبدها عملية الترقية مُعتبرة. وجوب رفع ترقيم النسخ الجذرية لإصدار تغييرات غير متوافقة يعني أنك ستفكر في عواقب هذه التغييرات، وتوزان بين نسبة المصلحة/التكلفة التي تنجرّ عنها.\nعملية التوثيق الكامل للواجهة البرمجية (API) تُعتبر عملا مُنهكا!\nمن مسؤولياتك كمُطور مُحترف أن توثّق بشكل صحيح البرمجية المُوجّهة للاستعمال من قِبَل مُستخدمين آخرين. إدارة تعقيد البرمجيات هو جزء بالغ الأهمية للحفاظ على كفاءة المشروع، وهذا شيء صعبٌ القيامُ به إن لم يكن هناك أي شخص على علم بكيفية استعمال برمجيتك، أو بالوظائف التي يُمكن استدعاؤها بأمان. على المدى البعيد، ستُمكّن الإدارة الدلالية والإصرار على وجود واجهة برمجية عامة واضحة المعالم من الإبقاء على السير الحسن للأمور عند الجميع.\nماذا يتوجب عليَّ فعله عندما أُصدر عن طريق الخطأ نسخةً بتغييرات غير مُتوافقة رجعيًا كنُسخة ترقيعية (Minor version)؟\nبمُجرد إدراكك بأنك قمت بنقض مُواصفات الإدارة الدلالية، قم بإصلاح المُشكل ثم قم بإصدار نسخة بسيطة جديدة (Minor) تُصلح العلة وتقوم بإرجاع التوافقية الرجعية. حتى تحت هذا الظرف، فإنه من غير المقبول أن تُغيّر من النُسخ التي تم إصدارها مُسبقا. قم بتوثيق النُسخة المُخالفة إذا كان ذلك مُلائما، وأخبر المُستخدمين بالمُشكلة حتى يكونوا على علم بالنُسخة المُخالفة.\nما يتوجب علي فعله عندما أحدّث الاعتماديات الخاصة بي دون تغيير الواجهة البرمجية العامة.\nسيُعتبر هذا على الأرجح أنه تغيير مُتوافق رجعيًا حيث أنه لا يَمَس الواجهة البرمجية العامة. يجدر بالبرمجيات التي تعتمد صراحة على نفس الاعتماديات التي تعتمد عليها حزمتك أن تتبع مُواصفات اعتماديات خاصة بها وأن ينتبه المُؤلف الأصلي لها لأي تضارب قد يحصل. تحديد ما إذا كانت هذه التغيرات بمثابة ترقيع أو بسيط يعتمد على ما إذا قمت بتحديث اعتمادياتك لتصحيح علة مُعيّنة أو لإدخال وظيفة جديدة. غالبًا ما أتوقع إضافة شفرة برمجية بالنسبة للحالة الثانية (إدخال وظيفة جديدة)، وبالتالي سيكون هذا الأمر بطبيعة الحال بمثابة تغيير يتطلب رفع ترقيم بسيط.\nماذا لو قمت عن غير قصد بتغيير الواجهة البرمجية العامة بطريقة لا تتماشى مع ترقيم النسخة (مثال: الشفرة تُدخِل عن طريق الخطأ تغييرات جذرية تكسر التوافقية الرجعية في إصدارة ترقيعية patch)\nاجتهد واحكم بنفسك، إذا كنت تملك جمهورًا غفيرًا سيتأثر بشكل كبير لو قمت بإرجاع الواجهة البرمجية العامة إلى سابق حالها كما كان مقصودًا، فسيكون حينئذ من الأفضل إصدار نسخة جذرية جديدة، حتى ولو تم اعتبار الإصلاح على أنه فقط إصدارة ترقيعية. تذكّر دائما أن هدف الإدارة الدلالية هو إضفاء معنىً حول التغييرات الحاصلة عن طريق كيفية تغيير ترقيم النُّسخ. إذا كانت هذه التغييرات ذات أهمية عند مُستخدمي برمجيتك، فاستعمل ترقيم النُسخ لإعلامهم بذلك.\nماذا عن الوظائف المُتخلى عنها (deprecating functionality) ؟\nالتخلّي عن وظيفة موجودة مُسبقا شيء طبيعي في تطوير البرمجيات، بل يُعتبر أحيانا خطوة لابد منها للمُضي قُدما. عندما تتخلّى عن إحدى الوظائف في الواجهة البرمجية العامة، فإنه يجب عليك القيام بأمرين: (1) قم بتحديث التوثيق حتى يعلم بقية المُستخدمين بهذا التغيير، (2) أصدر نسخة بسيطة (Minor) جديدةً تحتوي على الوظيفة المُتخلى عنها. قبل حذف الوظيفة نهائيًا في نسخة جذرية (Major). يجب على الأقل أن تكون هناك نسخة بسيطة تحتوي على الوظيفة المُتخلى عنها حتى تُمكّن المستخدمين من الانتقال السلِس إلى الواجهة البرمجية الجديدة.\nهل يفرض semver حدًا مُعينًا لطول السلسلة النصية عند ترقيم النُّسخ ؟\nلا، لكن اجتهد وأحسن التقدير. استعمال 255 حرفا على سبيل المثال في ترقيم نسخة ما قد يكون أمرًا مُبالغًا فيه. تذكّر أيضًا بأن بعض المنصّات تضع حدًا لطول السلسة النصية.\nمُواصفات الإدارة الدلالية لنُسخ البرمجيات من تأليف Tom
Preston-Werner, مُبتكر خدمة Gravatars وأحد مؤسسي GitHub.\nلديك اقتراح؟ يُرجى فتح “خطب” على
GitHub.\nالمشاع الإبداعي ― CC BY 3.0\nالمشاع الإبداعي ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nСемантично версиониране 2.0.0

Резюме

Използвайки номериране на версиите като ГЛАВНА.ВТОРОСТЕПЕННА.КРЪПКА, трябва да увеличите:


  
    ГЛАВНАта версия, при направени несъвместими промени в
приложно-програмният интерфейс (API).
  
  
    ВТОРОСТЕПЕННАта версия, когато промените са обратно съвместими.
  
  
    КРЪПКА-номера, когато са направени обратно съвместими поправки.
  


Допускат се допълнителни етикети за предварителни издания и билд-метаданни,
като разширения на формата за версия ГЛАВНА.ВТОРОСТЕПЕННА.КРЪПКА.

Въведение

В света на софтуерния мениджмънт съществува страховито място,
наречено „ад на зависимостите“. Колкото по-голяма става вашата система
и колкото повече библиотеки интегрирате в проекта си, толкова по-голяма
е вероятността един ден да се окажете в тази яма на отчаяние.

В системи с множество зависимости пускането на нови версии на някои от тях
може бързо да се превърне в кошмар. Ако спецификациите за зависимост са
твърде стриктни, рискувате да блокирате версията (невъзможността да обновите пакет,
освен ако не пускате нова версия при всяка промяна в библиотека, от която той
зависи). Ако зависимостите са посочени твърде слабо, неизбежно ще ви застигне
несъвместимостта на версиите (поради заявена съвместимост с повече бъдещи версии,
отколкото е разумно). Адът на зависимостта е мястото, където се намирате, когато
блокирането на версията и/или несъвместимостта на версията ви пречат лесно и
безопасно да движите проекта си напред.

За справяне с този проблем предлагам прост набор от правила и изисквания,
които определят как се присвояват и увеличават номерата на версиите. Тези правила
се основават на (но не непременно са ограничени до) съществуващи широко разпространени
общи практики. Те са приложими както в затворени проекти, така и в такива с
отворен код. За да работи тази система, първо трябва да определите публичен API.
Той може да бъде описан в документация или да се определя от самия код. Важното е
този API да бъде ясен и точен. След като идентифицирате публичния си API, вие
съобщавате промените в него с конкретни увеличения в номера на вашата версия.
Нека разгледаме формат на версия X.Y.Z (ГЛАВНА.ВТОРОСТЕПЕННА.КРЪПКА).
Поправки на грешки, които не засягат версията на API увеличават версията на
кръпката. Oбратно съвместими добавки/промени, увеличават второстепенната версия,
а обратно несъвместими промени в API увеличават главната версия.

Аз наричам това „Семантично версиониране“ (Semantic Versioning).
При тази схема, номерата на версиите и начинът, по който се променят,
предават значение за състоянието на изходния код и какво е променено между две версии.

Спецификация на семантичното версиониране (SemVer)

Ключовите думи „ЗАДЪЛЖИТЕЛНО“ (MUST), „ЗАДЪЛЖИТЕЛНО НЕ“ (MUST NOT),
„ИЗИСКВА“ (REQUIRED), „БИ ТРЯБВАЛО“ (SHELL), „НЕ БИ ТРЯБВАЛО“ (SHELL NOT),
„ТРЯБВА“ (SHOULD), „НЕ ТРЯБВА“ (SHOULD NOT), „ПРЕПОРЪЧИТЕЛНО Е“ (RECOMMENDED),
„МОЖЕ“ (MAY) и „НЕЗАДЪЛЖИТЕЛНО“ (OPTIONAL) в този документ се тълкуват,
както е описано в RFC 2119.


  
    Продуктите, използващи „Семантично версиониране“, ЗАДЪЛЖИТЕЛНО декларират
публичен API. Този API може да бъде деклариран в самия код или да съществува
строго в документацията. Независимо от метода, ТРЯБВА да бъде
прецизен и изчерпателен.
  
  
    Нормалният номер на версията ЗАДЪЛЖИТЕЛНО има вид X.Y.Z, където X, Y и Z са
неотрицателни цели числа и ЗАДЪЛЖИТЕЛНО НЕ съдържат водещи нули. X е главната
версия, Y е второстепенната, а Z е версията на кръпката. Всеки елемент
ЗАДЪЛЖИТЕЛНО се увеличава числено. Например: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    След като бъде пусната дадена версия, съдържанието на тази версия
ЗАДЪЛЖИТЕЛНО НЕ се променя. Всякакви модификации е ЗАДЪЛЖИТЕЛНО да бъдат
пуснати като нова версия.
  
  
    Главна версия нула (0.y.z) е за първоначална разработка. Всичко може
да се промени по всяко време. Публичният API НЕ ТРЯБВА да се счита за стабилен.
  
  
    Версия 1.0.0 определя публичния API. Начинът, по който се увеличава номерът
на версията след това издание, зависи от това, как се променя той.
  
  
    Версия на кръпката Z (x.y.Z | x > 0) ЗАДЪЛЖИТЕЛНО се увеличава, ако се правят
само обратно съвместими корекции на грешки. За такива (bug fix) се считат вътрешни
промени, които коригират неправилно поведение.
  
  
    Второстепенната версия Y (x.Y.z | x > 0) ЗАДЪЛЖИТЕЛНО се увеличава, когато
в публичния API се въвежда нова, обратно съвместима функционалност. ЗАДЪЛЖИТЕЛНО
е тя да се увеличи, ако някоя публична API функция е маркирана като
оттеглена (depricated). МОЖЕ да се увеличи, ако се въведе съществена нова
функционалност или подобрения в рамките на не-публичния програмен код.
МОЖЕ да включва промени характерни за кръпка. Версията на кръпката ЗАДЪЛЖИТЕЛНО
се връща на 0, когато второстепенната версия се увеличава.
  
  
    Главната версия X (X.y.z | X > 0) ЗАДЪЛЖИТЕЛНО се увеличава, когато в публичния
API се въведат каквито и да е обратно несъвместими промени. МОЖЕ да включва и
второстепенни промени или кръпки. Версията на кръпката и второстепенната версия
ЗАДЪЛЖИТЕЛНО се нулират (X.0.0), когато основната версия се увеличава.
  
  
    Предварително издание (pre-release) МОЖЕ да бъде обозначено веднага след
версията на кръпката чрез добавяне на тире, следвано от разделени с точки
идентификатори. Те ЗАДЪЛЖИТЕЛНО съдържат само ASCII буквено-цифрови
последователности и тире [0-9A-Za-z-]. Идентификаторите ЗАДЪЛЖИТЕЛНО НЕ
трябва да са празни. Числовите идентификатори ЗАДЪЛЖИТЕЛНО НЕ включват
водещи нули. Предварителните издания имат по-нисък приоритет от свързаната
основна версия. Предварителното издание показва, че версията е нестабилна
и може да не отговаря на предвидените изисквания за съвместимост, заявени
от свързаната с нея нормална версия. Примери:
1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Билд-метаданни МОЖЕ да бъдат обозначени чрез добавяне
на знак плюс и серия от разделени с точка идентификатори непосредствено след
версията на кръпка или на предварителното издание. Идентификаторите ЗАДЪЛЖИТЕЛНО
съдържат само ASCII буквено-цифрови последователности и тире [0-9A-Za-z-].
Идентификаторите ЗАДЪЛЖИТЕЛНО НЕ трябва да са празни. Билд-метаданните
ЗАДЪЛЖИТЕЛНО се игнорират при определяне на приоритета на версията. По
този начин две версии, които се различават само в билд-метаданните са с
еднакъв приоритет. Примери:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    Приоритетът определя как версиите се нареждате една спрямо друга.
При изчисление на приоритетът, версията ЗАДЪЛЖИТЕЛНО се разделя на ГЛАВНА, ВТОРОСТЕПЕННА,
КРЪПКА и идентификатори за предварително издание в този ред (билд-метаданните
се пренебрегват при определянето му). Подредбата се определя от първата разлика
при сравняване на всеки от тези компоненти отляво надясно, както следва:
Главните, второстепенните и версиите на кръпките винаги се сравняват като числа.
Пример: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Когато всички те са еднакви, версията
с предварително издание има по-нисък приоритет от основната версия.
Пример: 1.0.0-alpha < 1.0.0. Приоритет за две версии с предварително издание
(при еднакви ГЛАВНА, ВТОРОСТЕПЕННА и КРЪПКА) ЗАДЪЛЖИТЕЛНО се определя чрез
сравняване на всеки един идентификатор отляво надясно, докато
не се установи разлика, както следва: идентификаторите, състоящи се само от цифри,
се сравняват цифрово, а идентификаторите с букви или тиретата се сравняват
лексикално в ред на сортиране по ASCII. Цифровите идентификатори винаги имат
по-нисък приоритет от текстовите. По-голям набор от полета на предварителното
издание има по-висок приоритет, ако всички предходни идентификатори са равни.
Пример: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Бакус-Наур форма на граматиката за валидни SemVer версии
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


Защо да използвате „Семантично версиониране“

Това не е нова или революционна идея. Всъщност вероятно вече използвате нещо
подобно. Проблемът е, че „подобно“ не е достатъчно еднозначно. Без
съответствие с някаква официална спецификация, номерата на версиите са
по същество безполезни за управление на зависимости. Като бъдат наречени и ясно
определени, става лесно да заявите вашите намерения пред потребителите
на вашия софтуер. След като тези намерения са ясни и гъвкави (но не твърде),
спецификациите за зависимости най-накрая могат да бъдат направени.

Прост пример ще демонстрира как „Семантично версиониране“ може да изпрати „адът
на зависимостите“ в миналото. Представете си библиотека, наречена „Пожарна кола“.
Тя изисква пакет използващ „Семантично версиониране“, наречен „Стълба“. По времето,
когато „Пожарна кола“ е създадена, „Стълба“ е версия 3.1.0. Тъй като „Пожарна кола“
използва известна функционалност, представена за първи път в 3.1.0, можете
спокойно да заявите зависимост от „Стълба“, версия по-голяма или равна на 3.1.0,
но по-малка от 4.0.0. Сега, кога основни версии 3.1.1 и 3.2.0 стават достъпни,
можете да ги интегрирате с вашата система, знаейки, че те ще бъдат съвместими
със текущата функционалност.

Като отговорен разработчик, разбира се, ще искате да проверите, че обновения пакет
се държи според очакванията. Реалният свят е хаотичен; нищо не може да се направи
по въпроса, освен да сме бдителни. Това, което може да се направи, е да оставите
„Семантично версиониране“ да ви предоставя разумен начин за издаване и надграждане на
пакети, без да се налага да го правите при всяка промяна на зависимости,
спестявайки ви време и нерви.

За да се възползвате от описаното до тук, трябва просто да
заявите, че използвате „Семантично версиониране“ и да следвате правилата.
Поставете връзка към този уеб сайт във вашия README файл, така че значението на
промените във версията да бъде ясно за всички.

Често задавани въпроси

Какво да правя с версиите в началната фаза на разработка 0.y.z

Просто започнете първоначалната си версия от 0.1.0 и след това увеличавайте
второстепенната версия за всяко следващо издание.

Как да разбера кога да издам 1.0.0

Ако вашият софтуер се използва в производствена среда, вероятно вече трябва
да бъде 1.0.0. Ако имате стабилен API, от който потребителите зависят,
трябва да е 1.0.0. Ако се притеснявате много за обратната съвместимост, вероятно
вече трябва да е 1.0.0.

Това не възпрепятства ли бързата разработка и кратките итерации

Главната версия 0 е свързана с бързата разработка. Ако променяте API
всеки ден, трябва или да бъдете във версия 0.y.z, или да използвате отделен
клон за работата върху следващото главно издание.

Ако дори и най-малките обратно несъвместими промени в публичния API изискват промяна в главната версия, няма ли много скоро да стигнем 42.0.0

Това е въпрос на отговорно развитие и предвидливост. Несъвместими
промени не трябва да се въвеждат с лека ръка в софтуер, от който зависят
много проекти. Цената на такова надграждане може да бъде значителна.
Това, че трябва да се увеличи главната версия, за да се издадат несъвместими
промени, означава, че ще обмислите последствията от промените
и ще отчетете съотношението цена/полза.

Документирането на целия публичен API е твърде много работа

Ваша отговорност като професионален разработчик е качественото документиране на
софтуера, предназначен за широко използване. Управлението на сложността
на софтуера е изключително важна част от поддържането на ефективен проект.
Това е трудно да се направи, ако никой не знае как се използва вашия
софтуер или какви методи могат да бъдат извиквани безопасно. В дългосрочен план,
„Семантичното версиониране“ и настойчивостта за качествено документиране на публичния
API помага за безпроблемната работа.

Какво да направя, ако случайно пусна обратно несъвместима промяна като второстепенна версия

Веднага щом разберете, че сте нарушили спецификацията на SemVer, поправете
проблема и пуснете нова вторична версия, която коригира проблема и
възстановява обратната съвместимост. Дори и в такава ситуация е неприемливо
да подменяте вече издадена версия. Ако е подходящо, документирайте некоректната
версия и информирайте потребителите си за проблема с обратната съвместимост в нея.

Какво трябва да направя, ако обновя собствените си зависимости, без да променя публичния API

Това може да се разглежда като съвместимо изменение, тъй като не засяга
публичния API. Софтуер, който има същите зависимости като вашия
пакет трябва да има свои спецификации за зависимост и авторът да забележи
евентуални конфликти. За определяне дали промяната е ниво на кръпка или
второстепенна модификация зависи от това дали сте актуализирали зависимостите си,
за да коригирате грешка или да въведете нова функционалност. Обикновено за второто
е очакван допълнителен код, при което следва да се промени второстепенната версия.

Какво става, ако по невнимание променя публичния API по начин, който не е съвместим с промяната на номера на версията (тоест кодът неправилно въвежда голяма промяна в версията на кръпка)

Използвайте най-добрата си преценка. Ако имате огромна публика, която ще бъде драстично
засегната от промяната на поведението към това, което е планирано в публичният API
може би е най-добре да извършите издание на главна версия, въпреки че поправката може
строго погледнато да се счита за издаване на кръпка. Не забравяйте, че „Семантично
версиониране“ се стреми строго да следва спецификациите. Ако тези промени са важни
за вашите потребители, използвайте номера на версията, за да ги информирате.

Как се оттегля функционалност (deprecating)

Оттеглянето на съществуващата функционалност е нормална част от разработката
на софтуер и често се изисква за постигне на напредък. Когато оттегляте част
от вашия обществен API, трябва да направите две неща: (1) обновете документацията
си информирайки потребителите за промяната, (2) направете ново незначително издание
с оттеглянето. Преди да премахнете напълно функционалността в нова главна версия
трябва да има поне едно второстепенно издание, което съдържа оттеглянето, така че
че потребителите могат плавно да преминат към новия API.

Има ли SemVer ограничение на дължината на версията

Не, но използвайте добра преценка. Например, вероятно е излишно версията да е дълга 255
символа. Също така, специфичните системи могат да налагат свои собствени
ограничения за дължината на низа.

„v1.2.3“ семантично-зададена версия ли е

Не, „v1.2.3“ не е семантично-зададена версия. Префиксиране на семантично-зададена
версия с „v“ е често срещан начин (на английски език) да се посочи, че става дума
за номер на версия. Съкращаването „версия“ като „v“ често се наблюдава при
системи за контрол на версиите. Пример:
git tag v1.2.3 -m "Release version 1.2.3", в случая „v1.2.3“ е маркер,
а семантично-зададената версия е „1.2.3“.

Има ли регулярни изрази (RegEx) за проверка на дали даден низ отговаря на SemVer спецификацията

Съществуват два такива израза. Първият е за системи поддържащи PCRE
(Perl Compatible Regular Expressions, тоест Perl, PHP и R), Python и Go.

Вижте: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Другият използва номерирани групи (при него cg1 = ГЛАВНА, cg2 = ВТОРОСТЕПЕННА,
cg3 = КРЪПКА, cg4 = предварително издание и cg5 = билд-метаданни) и е
съвместим с ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
тоест Perl, PHP и R), Python и Go.

Вижте: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


За автора

Автор на спецификацията „Семантично версиониране“ (SemVer) е
Том Престон-Вернер, основател на Gravatars и
съучредител на GitHub.

За обратна връзка, моля създайте запитване в
GitHub.

Лиценз

Creative Commons — CC BY 3.0\nСемантично версиониране 2.0.0\nИзползвайки номериране на версиите като ГЛАВНА.ВТОРОСТЕПЕННА.КРЪПКА, трябва да увеличите:\nГЛАВНАта версия, при направени несъвместими промени в
приложно-програмният интерфейс (API).\nГЛАВНАта версия, при направени несъвместими промени в
приложно-програмният интерфейс (API).\nВТОРОСТЕПЕННАта версия, когато промените са обратно съвместими.\nВТОРОСТЕПЕННАта версия, когато промените са обратно съвместими.\nКРЪПКА-номера, когато са направени обратно съвместими поправки.\nКРЪПКА-номера, когато са направени обратно съвместими поправки.\nДопускат се допълнителни етикети за предварителни издания и билд-метаданни,
като разширения на формата за версия ГЛАВНА.ВТОРОСТЕПЕННА.КРЪПКА.\nВ света на софтуерния мениджмънт съществува страховито място,
наречено „ад на зависимостите“. Колкото по-голяма става вашата система
и колкото повече библиотеки интегрирате в проекта си, толкова по-голяма
е вероятността един ден да се окажете в тази яма на отчаяние.\nВ системи с множество зависимости пускането на нови версии на някои от тях
може бързо да се превърне в кошмар. Ако спецификациите за зависимост са
твърде стриктни, рискувате да блокирате версията (невъзможността да обновите пакет,
освен ако не пускате нова версия при всяка промяна в библиотека, от която той
зависи). Ако зависимостите са посочени твърде слабо, неизбежно ще ви застигне
несъвместимостта на версиите (поради заявена съвместимост с повече бъдещи версии,
отколкото е разумно). Адът на зависимостта е мястото, където се намирате, когато
блокирането на версията и/или несъвместимостта на версията ви пречат лесно и
безопасно да движите проекта си напред.\nЗа справяне с този проблем предлагам прост набор от правила и изисквания,
които определят как се присвояват и увеличават номерата на версиите. Тези правила
се основават на (но не непременно са ограничени до) съществуващи широко разпространени
общи практики. Те са приложими както в затворени проекти, така и в такива с
отворен код. За да работи тази система, първо трябва да определите публичен API.
Той може да бъде описан в документация или да се определя от самия код. Важното е
този API да бъде ясен и точен. След като идентифицирате публичния си API, вие
съобщавате промените в него с конкретни увеличения в номера на вашата версия.
Нека разгледаме формат на версия X.Y.Z (ГЛАВНА.ВТОРОСТЕПЕННА.КРЪПКА).
Поправки на грешки, които не засягат версията на API увеличават версията на
кръпката. Oбратно съвместими добавки/промени, увеличават второстепенната версия,
а обратно несъвместими промени в API увеличават главната версия.\nАз наричам това „Семантично версиониране“ (Semantic Versioning).
При тази схема, номерата на версиите и начинът, по който се променят,
предават значение за състоянието на изходния код и какво е променено между две версии.\nСпецификация на семантичното версиониране (SemVer)\nКлючовите думи „ЗАДЪЛЖИТЕЛНО“ (MUST), „ЗАДЪЛЖИТЕЛНО НЕ“ (MUST NOT),
„ИЗИСКВА“ (REQUIRED), „БИ ТРЯБВАЛО“ (SHELL), „НЕ БИ ТРЯБВАЛО“ (SHELL NOT),
„ТРЯБВА“ (SHOULD), „НЕ ТРЯБВА“ (SHOULD NOT), „ПРЕПОРЪЧИТЕЛНО Е“ (RECOMMENDED),
„МОЖЕ“ (MAY) и „НЕЗАДЪЛЖИТЕЛНО“ (OPTIONAL) в този документ се тълкуват,
както е описано в RFC 2119.\nПродуктите, използващи „Семантично версиониране“, ЗАДЪЛЖИТЕЛНО декларират
публичен API. Този API може да бъде деклариран в самия код или да съществува
строго в документацията. Независимо от метода, ТРЯБВА да бъде
прецизен и изчерпателен.\nПродуктите, използващи „Семантично версиониране“, ЗАДЪЛЖИТЕЛНО декларират
публичен API. Този API може да бъде деклариран в самия код или да съществува
строго в документацията. Независимо от метода, ТРЯБВА да бъде
прецизен и изчерпателен.\nНормалният номер на версията ЗАДЪЛЖИТЕЛНО има вид X.Y.Z, където X, Y и Z са
неотрицателни цели числа и ЗАДЪЛЖИТЕЛНО НЕ съдържат водещи нули. X е главната
версия, Y е второстепенната, а Z е версията на кръпката. Всеки елемент
ЗАДЪЛЖИТЕЛНО се увеличава числено. Например: 1.9.0 -> 1.10.0 -> 1.11.0.\nНормалният номер на версията ЗАДЪЛЖИТЕЛНО има вид X.Y.Z, където X, Y и Z са
неотрицателни цели числа и ЗАДЪЛЖИТЕЛНО НЕ съдържат водещи нули. X е главната
версия, Y е второстепенната, а Z е версията на кръпката. Всеки елемент
ЗАДЪЛЖИТЕЛНО се увеличава числено. Например: 1.9.0 -> 1.10.0 -> 1.11.0.\nСлед като бъде пусната дадена версия, съдържанието на тази версия
ЗАДЪЛЖИТЕЛНО НЕ се променя. Всякакви модификации е ЗАДЪЛЖИТЕЛНО да бъдат
пуснати като нова версия.\nСлед като бъде пусната дадена версия, съдържанието на тази версия
ЗАДЪЛЖИТЕЛНО НЕ се променя. Всякакви модификации е ЗАДЪЛЖИТЕЛНО да бъдат
пуснати като нова версия.\nГлавна версия нула (0.y.z) е за първоначална разработка. Всичко може
да се промени по всяко време. Публичният API НЕ ТРЯБВА да се счита за стабилен.\nГлавна версия нула (0.y.z) е за първоначална разработка. Всичко може
да се промени по всяко време. Публичният API НЕ ТРЯБВА да се счита за стабилен.\nВерсия 1.0.0 определя публичния API. Начинът, по който се увеличава номерът
на версията след това издание, зависи от това, как се променя той.\nВерсия 1.0.0 определя публичния API. Начинът, по който се увеличава номерът
на версията след това издание, зависи от това, как се променя той.\nВерсия на кръпката Z (x.y.Z | x > 0) ЗАДЪЛЖИТЕЛНО се увеличава, ако се правят
само обратно съвместими корекции на грешки. За такива (bug fix) се считат вътрешни
промени, които коригират неправилно поведение.\nВерсия на кръпката Z (x.y.Z | x > 0) ЗАДЪЛЖИТЕЛНО се увеличава, ако се правят
само обратно съвместими корекции на грешки. За такива (bug fix) се считат вътрешни
промени, които коригират неправилно поведение.\nВторостепенната версия Y (x.Y.z | x > 0) ЗАДЪЛЖИТЕЛНО се увеличава, когато
в публичния API се въвежда нова, обратно съвместима функционалност. ЗАДЪЛЖИТЕЛНО
е тя да се увеличи, ако някоя публична API функция е маркирана като
оттеглена (depricated). МОЖЕ да се увеличи, ако се въведе съществена нова
функционалност или подобрения в рамките на не-публичния програмен код.
МОЖЕ да включва промени характерни за кръпка. Версията на кръпката ЗАДЪЛЖИТЕЛНО
се връща на 0, когато второстепенната версия се увеличава.\nВторостепенната версия Y (x.Y.z | x > 0) ЗАДЪЛЖИТЕЛНО се увеличава, когато
в публичния API се въвежда нова, обратно съвместима функционалност. ЗАДЪЛЖИТЕЛНО
е тя да се увеличи, ако някоя публична API функция е маркирана като
оттеглена (depricated). МОЖЕ да се увеличи, ако се въведе съществена нова
функционалност или подобрения в рамките на не-публичния програмен код.
МОЖЕ да включва промени характерни за кръпка. Версията на кръпката ЗАДЪЛЖИТЕЛНО
се връща на 0, когато второстепенната версия се увеличава.\nГлавната версия X (X.y.z | X > 0) ЗАДЪЛЖИТЕЛНО се увеличава, когато в публичния
API се въведат каквито и да е обратно несъвместими промени. МОЖЕ да включва и
второстепенни промени или кръпки. Версията на кръпката и второстепенната версия
ЗАДЪЛЖИТЕЛНО се нулират (X.0.0), когато основната версия се увеличава.\nГлавната версия X (X.y.z | X > 0) ЗАДЪЛЖИТЕЛНО се увеличава, когато в публичния
API се въведат каквито и да е обратно несъвместими промени. МОЖЕ да включва и
второстепенни промени или кръпки. Версията на кръпката и второстепенната версия
ЗАДЪЛЖИТЕЛНО се нулират (X.0.0), когато основната версия се увеличава.\nПредварително издание (pre-release) МОЖЕ да бъде обозначено веднага след
версията на кръпката чрез добавяне на тире, следвано от разделени с точки
идентификатори. Те ЗАДЪЛЖИТЕЛНО съдържат само ASCII буквено-цифрови
последователности и тире [0-9A-Za-z-]. Идентификаторите ЗАДЪЛЖИТЕЛНО НЕ
трябва да са празни. Числовите идентификатори ЗАДЪЛЖИТЕЛНО НЕ включват
водещи нули. Предварителните издания имат по-нисък приоритет от свързаната
основна версия. Предварителното издание показва, че версията е нестабилна
и може да не отговаря на предвидените изисквания за съвместимост, заявени
от свързаната с нея нормална версия. Примери:
1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nПредварително издание (pre-release) МОЖЕ да бъде обозначено веднага след
версията на кръпката чрез добавяне на тире, следвано от разделени с точки
идентификатори. Те ЗАДЪЛЖИТЕЛНО съдържат само ASCII буквено-цифрови
последователности и тире [0-9A-Za-z-]. Идентификаторите ЗАДЪЛЖИТЕЛНО НЕ
трябва да са празни. Числовите идентификатори ЗАДЪЛЖИТЕЛНО НЕ включват
водещи нули. Предварителните издания имат по-нисък приоритет от свързаната
основна версия. Предварителното издание показва, че версията е нестабилна
и може да не отговаря на предвидените изисквания за съвместимост, заявени
от свързаната с нея нормална версия. Примери:
1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nБилд-метаданни МОЖЕ да бъдат обозначени чрез добавяне
на знак плюс и серия от разделени с точка идентификатори непосредствено след
версията на кръпка или на предварителното издание. Идентификаторите ЗАДЪЛЖИТЕЛНО
съдържат само ASCII буквено-цифрови последователности и тире [0-9A-Za-z-].
Идентификаторите ЗАДЪЛЖИТЕЛНО НЕ трябва да са празни. Билд-метаданните
ЗАДЪЛЖИТЕЛНО се игнорират при определяне на приоритета на версията. По
този начин две версии, които се различават само в билд-метаданните са с
еднакъв приоритет. Примери:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nБилд-метаданни МОЖЕ да бъдат обозначени чрез добавяне
на знак плюс и серия от разделени с точка идентификатори непосредствено след
версията на кръпка или на предварителното издание. Идентификаторите ЗАДЪЛЖИТЕЛНО
съдържат само ASCII буквено-цифрови последователности и тире [0-9A-Za-z-].
Идентификаторите ЗАДЪЛЖИТЕЛНО НЕ трябва да са празни. Билд-метаданните
ЗАДЪЛЖИТЕЛНО се игнорират при определяне на приоритета на версията. По
този начин две версии, които се различават само в билд-метаданните са с
еднакъв приоритет. Примери:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nПриоритетът определя как версиите се нареждате една спрямо друга.
При изчисление на приоритетът, версията ЗАДЪЛЖИТЕЛНО се разделя на ГЛАВНА, ВТОРОСТЕПЕННА,
КРЪПКА и идентификатори за предварително издание в този ред (билд-метаданните
се пренебрегват при определянето му). Подредбата се определя от първата разлика
при сравняване на всеки от тези компоненти отляво надясно, както следва:
Главните, второстепенните и версиите на кръпките винаги се сравняват като числа.
Пример: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Когато всички те са еднакви, версията
с предварително издание има по-нисък приоритет от основната версия.
Пример: 1.0.0-alpha < 1.0.0. Приоритет за две версии с предварително издание
(при еднакви ГЛАВНА, ВТОРОСТЕПЕННА и КРЪПКА) ЗАДЪЛЖИТЕЛНО се определя чрез
сравняване на всеки един идентификатор отляво надясно, докато
не се установи разлика, както следва: идентификаторите, състоящи се само от цифри,
се сравняват цифрово, а идентификаторите с букви или тиретата се сравняват
лексикално в ред на сортиране по ASCII. Цифровите идентификатори винаги имат
по-нисък приоритет от текстовите. По-голям набор от полета на предварителното
издание има по-висок приоритет, ако всички предходни идентификатори са равни.
Пример: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nПриоритетът определя как версиите се нареждате една спрямо друга.
При изчисление на приоритетът, версията ЗАДЪЛЖИТЕЛНО се разделя на ГЛАВНА, ВТОРОСТЕПЕННА,
КРЪПКА и идентификатори за предварително издание в този ред (билд-метаданните
се пренебрегват при определянето му). Подредбата се определя от първата разлика
при сравняване на всеки от тези компоненти отляво надясно, както следва:
Главните, второстепенните и версиите на кръпките винаги се сравняват като числа.
Пример: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Когато всички те са еднакви, версията
с предварително издание има по-нисък приоритет от основната версия.
Пример: 1.0.0-alpha < 1.0.0. Приоритет за две версии с предварително издание
(при еднакви ГЛАВНА, ВТОРОСТЕПЕННА и КРЪПКА) ЗАДЪЛЖИТЕЛНО се определя чрез
сравняване на всеки един идентификатор отляво надясно, докато
не се установи разлика, както следва: идентификаторите, състоящи се само от цифри,
се сравняват цифрово, а идентификаторите с букви или тиретата се сравняват
лексикално в ред на сортиране по ASCII. Цифровите идентификатори винаги имат
по-нисък приоритет от текстовите. По-голям набор от полета на предварителното
издание има по-висок приоритет, ако всички предходни идентификатори са равни.
Пример: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nБакус-Наур форма на граматиката за валидни SemVer версии\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nЗащо да използвате „Семантично версиониране“\nТова не е нова или революционна идея. Всъщност вероятно вече използвате нещо
подобно. Проблемът е, че „подобно“ не е достатъчно еднозначно. Без
съответствие с някаква официална спецификация, номерата на версиите са
по същество безполезни за управление на зависимости. Като бъдат наречени и ясно
определени, става лесно да заявите вашите намерения пред потребителите
на вашия софтуер. След като тези намерения са ясни и гъвкави (но не твърде),
спецификациите за зависимости най-накрая могат да бъдат направени.\nПрост пример ще демонстрира как „Семантично версиониране“ може да изпрати „адът
на зависимостите“ в миналото. Представете си библиотека, наречена „Пожарна кола“.
Тя изисква пакет използващ „Семантично версиониране“, наречен „Стълба“. По времето,
когато „Пожарна кола“ е създадена, „Стълба“ е версия 3.1.0. Тъй като „Пожарна кола“
използва известна функционалност, представена за първи път в 3.1.0, можете
спокойно да заявите зависимост от „Стълба“, версия по-голяма или равна на 3.1.0,
но по-малка от 4.0.0. Сега, кога основни версии 3.1.1 и 3.2.0 стават достъпни,
можете да ги интегрирате с вашата система, знаейки, че те ще бъдат съвместими
със текущата функционалност.\nКато отговорен разработчик, разбира се, ще искате да проверите, че обновения пакет
се държи според очакванията. Реалният свят е хаотичен; нищо не може да се направи
по въпроса, освен да сме бдителни. Това, което може да се направи, е да оставите
„Семантично версиониране“ да ви предоставя разумен начин за издаване и надграждане на
пакети, без да се налага да го правите при всяка промяна на зависимости,
спестявайки ви време и нерви.\nЗа да се възползвате от описаното до тук, трябва просто да
заявите, че използвате „Семантично версиониране“ и да следвате правилата.
Поставете връзка към този уеб сайт във вашия README файл, така че значението на
промените във версията да бъде ясно за всички.\nЧесто задавани въпроси\nКакво да правя с версиите в началната фаза на разработка 0.y.z\nПросто започнете първоначалната си версия от 0.1.0 и след това увеличавайте
второстепенната версия за всяко следващо издание.\nКак да разбера кога да издам 1.0.0\nАко вашият софтуер се използва в производствена среда, вероятно вече трябва
да бъде 1.0.0. Ако имате стабилен API, от който потребителите зависят,
трябва да е 1.0.0. Ако се притеснявате много за обратната съвместимост, вероятно
вече трябва да е 1.0.0.\nТова не възпрепятства ли бързата разработка и кратките итерации\nГлавната версия 0 е свързана с бързата разработка. Ако променяте API
всеки ден, трябва или да бъдете във версия 0.y.z, или да използвате отделен
клон за работата върху следващото главно издание.\nАко дори и най-малките обратно несъвместими промени в публичния API изискват промяна в главната версия, няма ли много скоро да стигнем 42.0.0\nТова е въпрос на отговорно развитие и предвидливост. Несъвместими
промени не трябва да се въвеждат с лека ръка в софтуер, от който зависят
много проекти. Цената на такова надграждане може да бъде значителна.
Това, че трябва да се увеличи главната версия, за да се издадат несъвместими
промени, означава, че ще обмислите последствията от промените
и ще отчетете съотношението цена/полза.\nДокументирането на целия публичен API е твърде много работа\nВаша отговорност като професионален разработчик е качественото документиране на
софтуера, предназначен за широко използване. Управлението на сложността
на софтуера е изключително важна част от поддържането на ефективен проект.
Това е трудно да се направи, ако никой не знае как се използва вашия
софтуер или какви методи могат да бъдат извиквани безопасно. В дългосрочен план,
„Семантичното версиониране“ и настойчивостта за качествено документиране на публичния
API помага за безпроблемната работа.\nКакво да направя, ако случайно пусна обратно несъвместима промяна като второстепенна версия\nВеднага щом разберете, че сте нарушили спецификацията на SemVer, поправете
проблема и пуснете нова вторична версия, която коригира проблема и
възстановява обратната съвместимост. Дори и в такава ситуация е неприемливо
да подменяте вече издадена версия. Ако е подходящо, документирайте некоректната
версия и информирайте потребителите си за проблема с обратната съвместимост в нея.\nКакво трябва да направя, ако обновя собствените си зависимости, без да променя публичния API\nТова може да се разглежда като съвместимо изменение, тъй като не засяга
публичния API. Софтуер, който има същите зависимости като вашия
пакет трябва да има свои спецификации за зависимост и авторът да забележи
евентуални конфликти. За определяне дали промяната е ниво на кръпка или
второстепенна модификация зависи от това дали сте актуализирали зависимостите си,
за да коригирате грешка или да въведете нова функционалност. Обикновено за второто
е очакван допълнителен код, при което следва да се промени второстепенната версия.\nКакво става, ако по невнимание променя публичния API по начин, който не е съвместим с промяната на номера на версията (тоест кодът неправилно въвежда голяма промяна в версията на кръпка)\nИзползвайте най-добрата си преценка. Ако имате огромна публика, която ще бъде драстично
засегната от промяната на поведението към това, което е планирано в публичният API
може би е най-добре да извършите издание на главна версия, въпреки че поправката може
строго погледнато да се счита за издаване на кръпка. Не забравяйте, че „Семантично
версиониране“ се стреми строго да следва спецификациите. Ако тези промени са важни
за вашите потребители, използвайте номера на версията, за да ги информирате.\nКак се оттегля функционалност (deprecating)\nОттеглянето на съществуващата функционалност е нормална част от разработката
на софтуер и често се изисква за постигне на напредък. Когато оттегляте част
от вашия обществен API, трябва да направите две неща: (1) обновете документацията
си информирайки потребителите за промяната, (2) направете ново незначително издание
с оттеглянето. Преди да премахнете напълно функционалността в нова главна версия
трябва да има поне едно второстепенно издание, което съдържа оттеглянето, така че
че потребителите могат плавно да преминат към новия API.\nИма ли SemVer ограничение на дължината на версията\nНе, но използвайте добра преценка. Например, вероятно е излишно версията да е дълга 255
символа. Също така, специфичните системи могат да налагат свои собствени
ограничения за дължината на низа.\n„v1.2.3“ семантично-зададена версия ли е\nНе, „v1.2.3“ не е семантично-зададена версия. Префиксиране на семантично-зададена
версия с „v“ е често срещан начин (на английски език) да се посочи, че става дума
за номер на версия. Съкращаването „версия“ като „v“ често се наблюдава при
системи за контрол на версиите. Пример:
git tag v1.2.3 -m "Release version 1.2.3", в случая „v1.2.3“ е маркер,
а семантично-зададената версия е „1.2.3“.\nИма ли регулярни изрази (RegEx) за проверка на дали даден низ отговаря на SemVer спецификацията\nСъществуват два такива израза. Първият е за системи поддържащи PCRE
(Perl Compatible Regular Expressions, тоест Perl, PHP и R), Python и Go.\nВижте: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nДругият използва номерирани групи (при него cg1 = ГЛАВНА, cg2 = ВТОРОСТЕПЕННА,
cg3 = КРЪПКА, cg4 = предварително издание и cg5 = билд-метаданни) и е
съвместим с ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
тоест Perl, PHP и R), Python и Go.\nВижте: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nАвтор на спецификацията „Семантично версиониране“ (SemVer) е
Том Престон-Вернер, основател на Gravatars и
съучредител на GitHub.\nЗа обратна връзка, моля създайте запитване в
GitHub.\nсъздайте запитване в
GitHub\nCreative Commons — CC BY 3.0\nCreative Commons — CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nGestió semàntica de versions 2.0.0

Sumari

Donat un nombre de versió MAJOR.MINOR.PATCH, heu d’incrementar:


  el nombre de versió MAJOR quan hi hagi canvis incompatibles a l’API,
  el nombre de versió MINOR quan hi hagi canvis compatibles amb versions anteriors, i
  el nombre de versió PATCH quan hi hagi correccions o pedaços compatibles amb versions anteriors.


Es poden afegir etiquetes addicionals per a versions preliminars i metadades de compilació com a extensió del format MAJOR.MINOR.PATCH.

Introducció

Al món de la gestió del programari hi ha un lloc temut anomenat “l’infern de
les dependències” (de l’anglès “dependency hell”). Com més gran creixi el vostre
sistema i més components hi integreu, més probable serà que us trobeu, algun
dia, en aquest abisme de desesperació.

En sistemes amb moltes dependències, publicar la versió d’un nou component pot
esdevenir ràpidament un malson. Si les regles de dependència són massa
estrictes, us podeu trobar en el perill de blocar les vostres versions, (la
incapacitat d’actualitzar un component sense haver de publicar una nova
versió de cada component que en depèn d’ell). En canvi, si les regles de
dependència són massa toves, inevitablement patireu la promiscuïtat de versions
(mantenir una compatibilitat amb més versions futures del que seria raonable).
L’infern de les dependències és quan el bloqueig o la promiscuïtat de versions
us impedeixen avançar el vostre projecte de manera fàcil i sense riscos.

Com a solució a aquest problema, proposo un conjunt de regles i requisits
senzills que dicten com s’assignen i incrementen els nombres de versions.
Aquestes regles es basen, però no es limiten necessàriament, en pràctiques
generalitzades en programari privat i lliure. Perquè aquest sistema funcioni,
primer heu de declarar una API pública. Pot consistir en un document o en les
normes imposades pel propi codi. Tanmateix, és important que aquesta API
sigui clara i precisa. Un cop l’hàgiu enllestida, comuniqueu els canvis que
hi feu amb increments específics en el nombre de versió. Considerant el format
de la versió X.Y.Z (Major.Minor.Patch): quan les correccions o pedaços no
afectin l’API s’ha d’incrementar la versió de correcció (‘patch’), quan s’hi
afegeixin canvis i/o millores que tampoc afectin l’API s’ha d’incrementar la versió
menor (‘minor’), i quan els canvis afectin la compatibilitat de l’API amb versions
anteriors s’ha d’incrementar la versió principal (‘major’).

Jo anomeno aquest sistema “gestió semàntica de versions”. Amb aquest sistema,
els nombres de versió i la manera com canvien donen sentit al codi subjacent
i a tot allò que s’ha modificat d’una versió a una altra.

Especificació de la gestió semàntica de versions (SemVer)

Les paraules clau “HA DE” (“MUST”, “REQUIRED” i “SHALL”), “NO HA DE” (“MUST
NOT” i “SHALL NOT”), “HAURIA DE” (“SHOULD” i “RECOMMENDED”) i “POT” (“MAY i
“OPTIONAL”) d’aquest document han de ser interpretades tal i com es descriuen
en el document RFC 2119.


  
    Tot programari que utilitzi la gestió semàntica de versions HA DE declarar
una API pública. Aquesta API es pot declarar en el mateix codi o en un document.
En qualsevol cas, ha de ser precisa i comprensible.
  
  
    Un nombre de versió normal HA DE tenir la forma X.Y.Z on X, Y i Z representen
nombres enters no negatius, i NO HAN DE ser prefixats amb zeros. X representa
l’identificador de versió principal (‘major’), Y representa l’identificador de
versió menor (‘minor’) i Z l’identificador de versió de correcció (‘patch’). Cada
element HA DE ser augmentat numèricament. Per exemple: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Un cop es publica una nova versió d’un component, el contingut d’aquesta versió
NO HA DE ser modificat. Qualsevol canvi HA DE ser publicat en una nova versió.
  
  
    L’identificador de versió principal (‘major’) a zero (0.y.z) és per al
desenvolupament inicial. Vol dir que qualsevol cosa pot canviar en qualsevol
moment. En aquest punt, l’API pública no hauria de considerar-se estable.
  
  
    La versió 1.0.0 defineix l’API pública. La forma en què el nombre de versió
s’incrementi després d’aquesta publicació dependrà d’aquesta API pública i
de les seves evolucions.
  
  
    L’identificador de versió de correcció (‘patch’) Z (x.y.Z | x > 0) HA DE ser
incrementat si només s’introdueixen correccions compatibles amb les versions
anteriors. Una correcció es defineix com un canvi intern que corregeix un
comportament incorrecte.
  
  
    L’identificador de versió menor (‘minor’) Y (x.Y.z | x > 0) HA DE ser
incrementat si s’introdueixen a l’API pública noves funcionalitats compatibles
amb versions anteriors. També HA DE ser incrementat si es tracta d’una funcionalitat
marcada com a obsoleta a l’API pública. Es POT incrementar si s’introdueixen noves
funcionalitats o millores substancials en el codi privat. POT incloure alhora
petites correccions. L’identificador de versió de correcció (‘patch’)
s’HA DE posar a 0 quan s’incrementi l’identificador de versió menor (‘minor’).
  
  
    L’identificador de versió principal (‘major’) X (X.y.z | X > 0) HA DE ser
incrementat si s’introdueixen canvis no compatibles amb versions anteriors de
l’API pública. POT incloure alhora petits canvis i correccions. Els identificadors
de versió menor (‘minor’) i de correcció (‘patch’) s’HAN DE posar a 0 quan
s’incrementi l’identificador de versió principal (‘major’).
  
  
    Es POT marcar una versió de pre-llançament afegint un guió i una sèrie
d’identificadors separats per punts immediatament després de l’identificador
de versió de correcció (‘patch’). Aquests identificadors HAN DE consistir
únicament en guions i caràcters ASCII alfanumèrics [0-9A-Za-z-]. Aquests
identificadors NO HAN D’estar buits. Els identificadors numèrics NO HAN DE
ser prefixats amb zeros. Les versions de pre-llançament precedeixen la versió
normal associada. Una versió de pre-llançament indica que la versió
no és estable i no necessàriament compleix els requisits de compatibilitat
associat a una versió normal. Exemples: 1.0.0-alpha, 1.0.0-alpha.1,
1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Les metadades de compilació es PODEN marcar afegint un signe més i una sèrie
d’identificadors separats per punts immediatament després de l’identificador
de versió de correcció (‘patch’) o de pre-llançament. Aquests identificadors HAN DE
consistir únicament en guions i caràcters ASCII alfanumèrics [0-9A-Za-z-]. Aquests
identificadors NO HAN D’estar buits. Les metadades de la compilació HAURIEN DE ser
ignorades quan es determini l’ordre de les versions. Per tant, dues versions que
difereixen només per la seva informació de compilació tenen la mateixa prioritat.
Exemples: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    La prioritat o precedència defineix com s’ordenen les versions entre sí. La
prioritat HA DE ser calculada separant els identificadors de la versió entre
principal, menor, correcció i pre-llançament, seguint aquest ordre. (La informació
de compilació no compta durant la comparació). La prioritat es determina per la
primera diferència que apareix a la comparació de cadascun d’aquests identificadors
en l’ordre: principal, menor i correcció. Aquests identificadors sempre es comparen
numèricament. Exemple: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Quan els identificadors
principal, menor i correcció són idèntics, una versió de pre-llançament té menor
prioritat que una versió normal. Exemple: 1.0.0-alpha < 1.0.0. La prioritat de
dues versions de pre-llançament amb els mateixos identificadors principal, menor
i correcció HA DE ser determinada mitjançant la comparació de cadascun dels
identificadors separats per un punt, d’esquerra a dreta fins que es trobi la
diferència, de la següent manera: els identificadors compostos només de nombres
es comparen numèricament, i els identificadors que contenen lletres o guions es
comparen en ordre ASCII. Els identificadors numèrics sempre són menys importants
que els identificadors no numèrics. Un conjunt més llarg d’identificadors de
pre-llançament té major prioritat sobre un conjunt més curt, si tots els identificadors
anteriors són idèntics. Exemple: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta <
1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Per què utilitzar la gestió semàntica de versions?

No és pas una idea nova o revolucionària. De fet, probablement ja esteu fent
alguna cosa semblant. El problema és que això ‘semblant’ no és prou bo. Sense
el compliment d’un mètode els nombres de versió no es poden utilitzar per la
gestió de dependències. Pel sol fet de donar un nom i una definició clares a
les idees que s’han mostrat a dalt, es fa fàcil comunicar les vostres
intencions als usuaris del vostre programari. Un cop aquestes intencions són
clares i flexibles (però no gaire flexibles) es pot dur a terme l’especificació
de dependències.

Un senzill exemple pot mostrar com la gestió semàntica de versions pot fer que
l’infern de les dependències sigui una cosa del passat. Considera una llibreria
anomenada “CamióDeBombers”. Requereix un component anomenat “Escala”, el qual
tracte les versions de forma semàntica. Quan es crea la llibreria CamióDeBombers,
l’Escala és a la versió 3.1.0. Atès que CamióDeBombers utilitza funcions que es
van introduir a la versió 3.1.0, podeu especificar, sense cap risc, una
dependència de l’Escala superior o igual a 3.1.0 però inferior a 4.0.0. Ara,
quan les versions 3.1.1 i 3.2.0 de l’Escala estan disponibles, podeu publicar-les
al vostre sistema de gestió de dependències i sabreu que seran compatibles amb
el programari existent que en depèn d’elles.

Com a desenvolupador responsable, voldreu verificar evidentment que qualsevol
actualització del component funciona tal i com s’anuncia. El món real és un
merder; no hi ha res que puguem fer excepte estar a l’aguait. El que podeu fer,
però, és deixar que la gestió semàntica de versions us proporcioni una manera
saludable de publicar i actualitzar els vostres components, sense haver
d’implementar noves versions de components dependents, estalviant-vos temps i
esforç.

Si tot això us sona bé, tot el que heu de fer per començar a utilitzar la gestió
semàntica de la versions és declarar que ho feu i llavors seguiu les regles.
Afegiu un enllaç a aquest lloc web al vostre fitxer README i així altres podran
conèixer les regles i beneficiar-se’n.

FAQ

Com hauria de gestionar les revisions en la fase inicial de desenvolupament 0.y.z?

El més fàcil de fer és començar els teus desenvolupaments amb la versió 0.1.0 i,
a continuació, incrementar l’identificador de versió menor a cada nova publicació.

Com sé quan he de llançar la versió 1.0.0?

Si el vostre programari s’utilitza en un entorn de producció, ja hauríeu d’estar
a la versió 1.0.0. Si teniu una API estable a partir de la qual els usuaris han
començat a dependre’n, ja hauríeu d’estar a la versió 1.0.0. Si us amoïna molt la
compatibilitat amb versions anteriors, ja hauríeu d’estar a la versió 1.0.0.

No desincentiva tot això el ràpid desenvolupament i les iteracions curtes?

La versió principal (‘major’) a 0 es fa precisament per tenir un desenvolupament
ràpid. Si canvieu l’API cada dia hauríeu de ser a la versió 0.y.z o en una branca
de desenvolupament independent que acabarà sent la nova versió principal.

Si fins i tot el canvi més petit a l’API pública no compatible amb versions anteriors requereix augmentar l’identificador de versió principal, no arribaré a la versió 42.0.0 massa ràpidament?

Es tracta d’un desenvolupament responsable i d’una anticipació. Els canvis
incompatibles no s’han d’introduir a la lleugera en un programari amb un
gran nombre de codi font depenent. El cost d’una actualització a una nova versió
pot ser important. La necessitat d’augmentar la versió principal per publicar
els canvis que no siguin compatibles amb versions anteriors, significa que
haureu mesurat les implicacions dels canvis i avaluada la relació entre el seu
cost i els seus beneficis.

Documentar tota l’API pública demana massa feina!

És la vostra responsabilitat com a desenvolupador professional documentar
correctament el programari que altres usuaris pensen utilitzar. Gestionar la
complexitat d’un programari és una part immensament important per mantenir
un projecte eficient, i es fa difícil de fer quan ningú no sap com utilitzar
el vostre programari, o quins són els mètodes adequats per cridar. A la llarga
la gestió semàntica de versions, i els esforços en la conservació d’una
API pública ben definida permetrà que tots puguem avançar sense problemes.

Què he de fer si accidentalment publico un canvi no compatible amb versions anteriors com una versió menor?

Tan bon punt us adoneu que heu trencat la gestió semàntica de la vostra versió,
corregiu el problema i publiqueu una nova versió menor que restauri la
compatibilitat amb versions anteriors. Fins i tot en aquestes circumstàncies,
és inacceptable modificar una versió ja publicada. Actualitzeu, si cal, la
documentació informant sobre la versió defectuosa i informeu als vostres usuaris
d’aquest problema.

Què he de fer si actualitzo les meves pròpies dependències sense canviar l’API pública?

Això es pot considerar compatible ja que no afecta l’API pública. El programari
que depèn de les mateixes dependències que el vostre component hauria de tenir
la seva pròpia especificació de dependència i l’autor també s’adonarà de
qualsevol conflicte. Per determinar si el canvi és una correcció o un canvi
menor, heu de preguntar-vos si heu actualitzat les vostres dependències per
corregir un error o per introduir una nova característica. En general, esperaria
afegir codi nou en la segona opció, cosa que implica òbviament un increment de
l’identificador de versió menor.

Què passa si canvio l’API pública de forma involuntària de manera que no coincideix amb el canvi de nombre de versió (per exemple: el codi introdueix per error un canvi que trenca la versió major en un llançament de versió de correcció)?

Feu servir el seny. Si teniu un gran públic que es veurà afectat dràsticament pel
canvi de comportament de l’API pública respecte el que hauria de fer, llavors pot
ser preferible llançar una nova versió principal (‘major’), encara que aquesta
versió es pugui considerar una versió de correcció. Recordeu, la gestió semàntica
de versions és bàsicament per transmetre significats en la forma en què canvia el
nombre de versió. Si aquests canvis són importants per als vostres usuaris,
utilitzeu els nombres de versió per informar-los.

Com he de gestionar les funcionalitats obsoletes?

La obsolescència de funcionalitats existents és una part normal del desenvolupament
del programari i molt sovint es fa necessari per avançar. Quan desaproveu
una part de la vostra API pública, heu de fer dues coses: (1) actualitzar la
documentació per informar els usuaris del canvi, (2) publicar una nova versió
menor amb la part desaprovada. Abans d’eliminar completament la funcionalitat
en un nou llançament de versió important (‘major’), hauria d’haver almenys una
versió menor que contingui la desaprovació perquè els usuaris puguin transitar
sense problemes cap a la nova API.

La gestió semàntica de versions especifica un límit màxim per a la cadena del nombre de versió?

No, però feu servir el sentit comú. Per exemple, un nombre de versió de 255 caràcters
probablement sigui excessiu. A més, alguns sistemes poden imposar les seves pròpies
limitacions en aquesta mida.

Quant a

L’especificació de la gestió semàntica de versions està escrita per [Tom
Preston-Werner] (http://tom.preston-werner.com), inventor de Gravatars i
cofundador de GitHub.

Traducció d’aquest document a càrrec de:

  Jordi Sanfeliu


Si voleu deixar comentaris, si us plau [obre un tiquet a
GitHub] (https://github.com/semver/semver/issues).

Llicència

Creative Commons ― CC BY 3.0\nGestió semàntica de versions 2.0.0\nDonat un nombre de versió MAJOR.MINOR.PATCH, heu d’incrementar:\nel nombre de versió MAJOR quan hi hagi canvis incompatibles a l’API,\nel nombre de versió MINOR quan hi hagi canvis compatibles amb versions anteriors, i\nel nombre de versió PATCH quan hi hagi correccions o pedaços compatibles amb versions anteriors.\nEs poden afegir etiquetes addicionals per a versions preliminars i metadades de compilació com a extensió del format MAJOR.MINOR.PATCH.\nAl món de la gestió del programari hi ha un lloc temut anomenat “l’infern de
les dependències” (de l’anglès “dependency hell”). Com més gran creixi el vostre
sistema i més components hi integreu, més probable serà que us trobeu, algun
dia, en aquest abisme de desesperació.\nEn sistemes amb moltes dependències, publicar la versió d’un nou component pot
esdevenir ràpidament un malson. Si les regles de dependència són massa
estrictes, us podeu trobar en el perill de blocar les vostres versions, (la
incapacitat d’actualitzar un component sense haver de publicar una nova
versió de cada component que en depèn d’ell). En canvi, si les regles de
dependència són massa toves, inevitablement patireu la promiscuïtat de versions
(mantenir una compatibilitat amb més versions futures del que seria raonable).
L’infern de les dependències és quan el bloqueig o la promiscuïtat de versions
us impedeixen avançar el vostre projecte de manera fàcil i sense riscos.\nCom a solució a aquest problema, proposo un conjunt de regles i requisits
senzills que dicten com s’assignen i incrementen els nombres de versions.
Aquestes regles es basen, però no es limiten necessàriament, en pràctiques
generalitzades en programari privat i lliure. Perquè aquest sistema funcioni,
primer heu de declarar una API pública. Pot consistir en un document o en les
normes imposades pel propi codi. Tanmateix, és important que aquesta API
sigui clara i precisa. Un cop l’hàgiu enllestida, comuniqueu els canvis que
hi feu amb increments específics en el nombre de versió. Considerant el format
de la versió X.Y.Z (Major.Minor.Patch): quan les correccions o pedaços no
afectin l’API s’ha d’incrementar la versió de correcció (‘patch’), quan s’hi
afegeixin canvis i/o millores que tampoc afectin l’API s’ha d’incrementar la versió
menor (‘minor’), i quan els canvis afectin la compatibilitat de l’API amb versions
anteriors s’ha d’incrementar la versió principal (‘major’).\nJo anomeno aquest sistema “gestió semàntica de versions”. Amb aquest sistema,
els nombres de versió i la manera com canvien donen sentit al codi subjacent
i a tot allò que s’ha modificat d’una versió a una altra.\nEspecificació de la gestió semàntica de versions (SemVer)\nLes paraules clau “HA DE” (“MUST”, “REQUIRED” i “SHALL”), “NO HA DE” (“MUST
NOT” i “SHALL NOT”), “HAURIA DE” (“SHOULD” i “RECOMMENDED”) i “POT” (“MAY i
“OPTIONAL”) d’aquest document han de ser interpretades tal i com es descriuen
en el document RFC 2119.\nTot programari que utilitzi la gestió semàntica de versions HA DE declarar
una API pública. Aquesta API es pot declarar en el mateix codi o en un document.
En qualsevol cas, ha de ser precisa i comprensible.\nTot programari que utilitzi la gestió semàntica de versions HA DE declarar
una API pública. Aquesta API es pot declarar en el mateix codi o en un document.
En qualsevol cas, ha de ser precisa i comprensible.\nUn nombre de versió normal HA DE tenir la forma X.Y.Z on X, Y i Z representen
nombres enters no negatius, i NO HAN DE ser prefixats amb zeros. X representa
l’identificador de versió principal (‘major’), Y representa l’identificador de
versió menor (‘minor’) i Z l’identificador de versió de correcció (‘patch’). Cada
element HA DE ser augmentat numèricament. Per exemple: 1.9.0 -> 1.10.0 -> 1.11.0.\nUn nombre de versió normal HA DE tenir la forma X.Y.Z on X, Y i Z representen
nombres enters no negatius, i NO HAN DE ser prefixats amb zeros. X representa
l’identificador de versió principal (‘major’), Y representa l’identificador de
versió menor (‘minor’) i Z l’identificador de versió de correcció (‘patch’). Cada
element HA DE ser augmentat numèricament. Per exemple: 1.9.0 -> 1.10.0 -> 1.11.0.\nUn cop es publica una nova versió d’un component, el contingut d’aquesta versió
NO HA DE ser modificat. Qualsevol canvi HA DE ser publicat en una nova versió.\nUn cop es publica una nova versió d’un component, el contingut d’aquesta versió
NO HA DE ser modificat. Qualsevol canvi HA DE ser publicat en una nova versió.\nL’identificador de versió principal (‘major’) a zero (0.y.z) és per al
desenvolupament inicial. Vol dir que qualsevol cosa pot canviar en qualsevol
moment. En aquest punt, l’API pública no hauria de considerar-se estable.\nL’identificador de versió principal (‘major’) a zero (0.y.z) és per al
desenvolupament inicial. Vol dir que qualsevol cosa pot canviar en qualsevol
moment. En aquest punt, l’API pública no hauria de considerar-se estable.\nLa versió 1.0.0 defineix l’API pública. La forma en què el nombre de versió
s’incrementi després d’aquesta publicació dependrà d’aquesta API pública i
de les seves evolucions.\nLa versió 1.0.0 defineix l’API pública. La forma en què el nombre de versió
s’incrementi després d’aquesta publicació dependrà d’aquesta API pública i
de les seves evolucions.\nL’identificador de versió de correcció (‘patch’) Z (x.y.Z | x > 0) HA DE ser
incrementat si només s’introdueixen correccions compatibles amb les versions
anteriors. Una correcció es defineix com un canvi intern que corregeix un
comportament incorrecte.\nL’identificador de versió de correcció (‘patch’) Z (x.y.Z | x > 0) HA DE ser
incrementat si només s’introdueixen correccions compatibles amb les versions
anteriors. Una correcció es defineix com un canvi intern que corregeix un
comportament incorrecte.\nL’identificador de versió menor (‘minor’) Y (x.Y.z | x > 0) HA DE ser
incrementat si s’introdueixen a l’API pública noves funcionalitats compatibles
amb versions anteriors. També HA DE ser incrementat si es tracta d’una funcionalitat
marcada com a obsoleta a l’API pública. Es POT incrementar si s’introdueixen noves
funcionalitats o millores substancials en el codi privat. POT incloure alhora
petites correccions. L’identificador de versió de correcció (‘patch’)
s’HA DE posar a 0 quan s’incrementi l’identificador de versió menor (‘minor’).\nL’identificador de versió menor (‘minor’) Y (x.Y.z | x > 0) HA DE ser
incrementat si s’introdueixen a l’API pública noves funcionalitats compatibles
amb versions anteriors. També HA DE ser incrementat si es tracta d’una funcionalitat
marcada com a obsoleta a l’API pública. Es POT incrementar si s’introdueixen noves
funcionalitats o millores substancials en el codi privat. POT incloure alhora
petites correccions. L’identificador de versió de correcció (‘patch’)
s’HA DE posar a 0 quan s’incrementi l’identificador de versió menor (‘minor’).\nL’identificador de versió principal (‘major’) X (X.y.z | X > 0) HA DE ser
incrementat si s’introdueixen canvis no compatibles amb versions anteriors de
l’API pública. POT incloure alhora petits canvis i correccions. Els identificadors
de versió menor (‘minor’) i de correcció (‘patch’) s’HAN DE posar a 0 quan
s’incrementi l’identificador de versió principal (‘major’).\nL’identificador de versió principal (‘major’) X (X.y.z | X > 0) HA DE ser
incrementat si s’introdueixen canvis no compatibles amb versions anteriors de
l’API pública. POT incloure alhora petits canvis i correccions. Els identificadors
de versió menor (‘minor’) i de correcció (‘patch’) s’HAN DE posar a 0 quan
s’incrementi l’identificador de versió principal (‘major’).\nEs POT marcar una versió de pre-llançament afegint un guió i una sèrie
d’identificadors separats per punts immediatament després de l’identificador
de versió de correcció (‘patch’). Aquests identificadors HAN DE consistir
únicament en guions i caràcters ASCII alfanumèrics [0-9A-Za-z-]. Aquests
identificadors NO HAN D’estar buits. Els identificadors numèrics NO HAN DE
ser prefixats amb zeros. Les versions de pre-llançament precedeixen la versió
normal associada. Una versió de pre-llançament indica que la versió
no és estable i no necessàriament compleix els requisits de compatibilitat
associat a una versió normal. Exemples: 1.0.0-alpha, 1.0.0-alpha.1,
1.0.0-0.3.7, 1.0.0-x.7.z.92.\nEs POT marcar una versió de pre-llançament afegint un guió i una sèrie
d’identificadors separats per punts immediatament després de l’identificador
de versió de correcció (‘patch’). Aquests identificadors HAN DE consistir
únicament en guions i caràcters ASCII alfanumèrics [0-9A-Za-z-]. Aquests
identificadors NO HAN D’estar buits. Els identificadors numèrics NO HAN DE
ser prefixats amb zeros. Les versions de pre-llançament precedeixen la versió
normal associada. Una versió de pre-llançament indica que la versió
no és estable i no necessàriament compleix els requisits de compatibilitat
associat a una versió normal. Exemples: 1.0.0-alpha, 1.0.0-alpha.1,
1.0.0-0.3.7, 1.0.0-x.7.z.92.\nLes metadades de compilació es PODEN marcar afegint un signe més i una sèrie
d’identificadors separats per punts immediatament després de l’identificador
de versió de correcció (‘patch’) o de pre-llançament. Aquests identificadors HAN DE
consistir únicament en guions i caràcters ASCII alfanumèrics [0-9A-Za-z-]. Aquests
identificadors NO HAN D’estar buits. Les metadades de la compilació HAURIEN DE ser
ignorades quan es determini l’ordre de les versions. Per tant, dues versions que
difereixen només per la seva informació de compilació tenen la mateixa prioritat.
Exemples: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nLes metadades de compilació es PODEN marcar afegint un signe més i una sèrie
d’identificadors separats per punts immediatament després de l’identificador
de versió de correcció (‘patch’) o de pre-llançament. Aquests identificadors HAN DE
consistir únicament en guions i caràcters ASCII alfanumèrics [0-9A-Za-z-]. Aquests
identificadors NO HAN D’estar buits. Les metadades de la compilació HAURIEN DE ser
ignorades quan es determini l’ordre de les versions. Per tant, dues versions que
difereixen només per la seva informació de compilació tenen la mateixa prioritat.
Exemples: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nLa prioritat o precedència defineix com s’ordenen les versions entre sí. La
prioritat HA DE ser calculada separant els identificadors de la versió entre
principal, menor, correcció i pre-llançament, seguint aquest ordre. (La informació
de compilació no compta durant la comparació). La prioritat es determina per la
primera diferència que apareix a la comparació de cadascun d’aquests identificadors
en l’ordre: principal, menor i correcció. Aquests identificadors sempre es comparen
numèricament. Exemple: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Quan els identificadors
principal, menor i correcció són idèntics, una versió de pre-llançament té menor
prioritat que una versió normal. Exemple: 1.0.0-alpha < 1.0.0. La prioritat de
dues versions de pre-llançament amb els mateixos identificadors principal, menor
i correcció HA DE ser determinada mitjançant la comparació de cadascun dels
identificadors separats per un punt, d’esquerra a dreta fins que es trobi la
diferència, de la següent manera: els identificadors compostos només de nombres
es comparen numèricament, i els identificadors que contenen lletres o guions es
comparen en ordre ASCII. Els identificadors numèrics sempre són menys importants
que els identificadors no numèrics. Un conjunt més llarg d’identificadors de
pre-llançament té major prioritat sobre un conjunt més curt, si tots els identificadors
anteriors són idèntics. Exemple: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta <
1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nLa prioritat o precedència defineix com s’ordenen les versions entre sí. La
prioritat HA DE ser calculada separant els identificadors de la versió entre
principal, menor, correcció i pre-llançament, seguint aquest ordre. (La informació
de compilació no compta durant la comparació). La prioritat es determina per la
primera diferència que apareix a la comparació de cadascun d’aquests identificadors
en l’ordre: principal, menor i correcció. Aquests identificadors sempre es comparen
numèricament. Exemple: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Quan els identificadors
principal, menor i correcció són idèntics, una versió de pre-llançament té menor
prioritat que una versió normal. Exemple: 1.0.0-alpha < 1.0.0. La prioritat de
dues versions de pre-llançament amb els mateixos identificadors principal, menor
i correcció HA DE ser determinada mitjançant la comparació de cadascun dels
identificadors separats per un punt, d’esquerra a dreta fins que es trobi la
diferència, de la següent manera: els identificadors compostos només de nombres
es comparen numèricament, i els identificadors que contenen lletres o guions es
comparen en ordre ASCII. Els identificadors numèrics sempre són menys importants
que els identificadors no numèrics. Un conjunt més llarg d’identificadors de
pre-llançament té major prioritat sobre un conjunt més curt, si tots els identificadors
anteriors són idèntics. Exemple: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta <
1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPer què utilitzar la gestió semàntica de versions?\nNo és pas una idea nova o revolucionària. De fet, probablement ja esteu fent
alguna cosa semblant. El problema és que això ‘semblant’ no és prou bo. Sense
el compliment d’un mètode els nombres de versió no es poden utilitzar per la
gestió de dependències. Pel sol fet de donar un nom i una definició clares a
les idees que s’han mostrat a dalt, es fa fàcil comunicar les vostres
intencions als usuaris del vostre programari. Un cop aquestes intencions són
clares i flexibles (però no gaire flexibles) es pot dur a terme l’especificació
de dependències.\nUn senzill exemple pot mostrar com la gestió semàntica de versions pot fer que
l’infern de les dependències sigui una cosa del passat. Considera una llibreria
anomenada “CamióDeBombers”. Requereix un component anomenat “Escala”, el qual
tracte les versions de forma semàntica. Quan es crea la llibreria CamióDeBombers,
l’Escala és a la versió 3.1.0. Atès que CamióDeBombers utilitza funcions que es
van introduir a la versió 3.1.0, podeu especificar, sense cap risc, una
dependència de l’Escala superior o igual a 3.1.0 però inferior a 4.0.0. Ara,
quan les versions 3.1.1 i 3.2.0 de l’Escala estan disponibles, podeu publicar-les
al vostre sistema de gestió de dependències i sabreu que seran compatibles amb
el programari existent que en depèn d’elles.\nCom a desenvolupador responsable, voldreu verificar evidentment que qualsevol
actualització del component funciona tal i com s’anuncia. El món real és un
merder; no hi ha res que puguem fer excepte estar a l’aguait. El que podeu fer,
però, és deixar que la gestió semàntica de versions us proporcioni una manera
saludable de publicar i actualitzar els vostres components, sense haver
d’implementar noves versions de components dependents, estalviant-vos temps i
esforç.\nSi tot això us sona bé, tot el que heu de fer per començar a utilitzar la gestió
semàntica de la versions és declarar que ho feu i llavors seguiu les regles.
Afegiu un enllaç a aquest lloc web al vostre fitxer README i així altres podran
conèixer les regles i beneficiar-se’n.\nCom hauria de gestionar les revisions en la fase inicial de desenvolupament 0.y.z?\nEl més fàcil de fer és començar els teus desenvolupaments amb la versió 0.1.0 i,
a continuació, incrementar l’identificador de versió menor a cada nova publicació.\nCom sé quan he de llançar la versió 1.0.0?\nSi el vostre programari s’utilitza en un entorn de producció, ja hauríeu d’estar
a la versió 1.0.0. Si teniu una API estable a partir de la qual els usuaris han
començat a dependre’n, ja hauríeu d’estar a la versió 1.0.0. Si us amoïna molt la
compatibilitat amb versions anteriors, ja hauríeu d’estar a la versió 1.0.0.\nNo desincentiva tot això el ràpid desenvolupament i les iteracions curtes?\nLa versió principal (‘major’) a 0 es fa precisament per tenir un desenvolupament
ràpid. Si canvieu l’API cada dia hauríeu de ser a la versió 0.y.z o en una branca
de desenvolupament independent que acabarà sent la nova versió principal.\nSi fins i tot el canvi més petit a l’API pública no compatible amb versions anteriors requereix augmentar l’identificador de versió principal, no arribaré a la versió 42.0.0 massa ràpidament?\nEs tracta d’un desenvolupament responsable i d’una anticipació. Els canvis
incompatibles no s’han d’introduir a la lleugera en un programari amb un
gran nombre de codi font depenent. El cost d’una actualització a una nova versió
pot ser important. La necessitat d’augmentar la versió principal per publicar
els canvis que no siguin compatibles amb versions anteriors, significa que
haureu mesurat les implicacions dels canvis i avaluada la relació entre el seu
cost i els seus beneficis.\nDocumentar tota l’API pública demana massa feina!\nÉs la vostra responsabilitat com a desenvolupador professional documentar
correctament el programari que altres usuaris pensen utilitzar. Gestionar la
complexitat d’un programari és una part immensament important per mantenir
un projecte eficient, i es fa difícil de fer quan ningú no sap com utilitzar
el vostre programari, o quins són els mètodes adequats per cridar. A la llarga
la gestió semàntica de versions, i els esforços en la conservació d’una
API pública ben definida permetrà que tots puguem avançar sense problemes.\nQuè he de fer si accidentalment publico un canvi no compatible amb versions anteriors com una versió menor?\nTan bon punt us adoneu que heu trencat la gestió semàntica de la vostra versió,
corregiu el problema i publiqueu una nova versió menor que restauri la
compatibilitat amb versions anteriors. Fins i tot en aquestes circumstàncies,
és inacceptable modificar una versió ja publicada. Actualitzeu, si cal, la
documentació informant sobre la versió defectuosa i informeu als vostres usuaris
d’aquest problema.\nQuè he de fer si actualitzo les meves pròpies dependències sense canviar l’API pública?\nAixò es pot considerar compatible ja que no afecta l’API pública. El programari
que depèn de les mateixes dependències que el vostre component hauria de tenir
la seva pròpia especificació de dependència i l’autor també s’adonarà de
qualsevol conflicte. Per determinar si el canvi és una correcció o un canvi
menor, heu de preguntar-vos si heu actualitzat les vostres dependències per
corregir un error o per introduir una nova característica. En general, esperaria
afegir codi nou en la segona opció, cosa que implica òbviament un increment de
l’identificador de versió menor.\nQuè passa si canvio l’API pública de forma involuntària de manera que no coincideix amb el canvi de nombre de versió (per exemple: el codi introdueix per error un canvi que trenca la versió major en un llançament de versió de correcció)?\nFeu servir el seny. Si teniu un gran públic que es veurà afectat dràsticament pel
canvi de comportament de l’API pública respecte el que hauria de fer, llavors pot
ser preferible llançar una nova versió principal (‘major’), encara que aquesta
versió es pugui considerar una versió de correcció. Recordeu, la gestió semàntica
de versions és bàsicament per transmetre significats en la forma en què canvia el
nombre de versió. Si aquests canvis són importants per als vostres usuaris,
utilitzeu els nombres de versió per informar-los.\nCom he de gestionar les funcionalitats obsoletes?\nLa obsolescència de funcionalitats existents és una part normal del desenvolupament
del programari i molt sovint es fa necessari per avançar. Quan desaproveu
una part de la vostra API pública, heu de fer dues coses: (1) actualitzar la
documentació per informar els usuaris del canvi, (2) publicar una nova versió
menor amb la part desaprovada. Abans d’eliminar completament la funcionalitat
en un nou llançament de versió important (‘major’), hauria d’haver almenys una
versió menor que contingui la desaprovació perquè els usuaris puguin transitar
sense problemes cap a la nova API.\nLa gestió semàntica de versions especifica un límit màxim per a la cadena del nombre de versió?\nNo, però feu servir el sentit comú. Per exemple, un nombre de versió de 255 caràcters
probablement sigui excessiu. A més, alguns sistemes poden imposar les seves pròpies
limitacions en aquesta mida.\nL’especificació de la gestió semàntica de versions està escrita per [Tom
Preston-Werner] (http://tom.preston-werner.com), inventor de Gravatars i
cofundador de GitHub.\nTraducció d’aquest document a càrrec de:\nSi voleu deixar comentaris, si us plau [obre un tiquet a
GitHub] (https://github.com/semver/semver/issues).\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSémantické verzování 2.0.0

Shrnutí

Číslo verzí zapisujeme ve formátu MAJOR.MINOR.PATCH
Navyšování jednotlivých čísel verzí probíhá následovně:


  MAJOR ― když nastala změna, která není zpětně kompatibilní s ostatními (API)
  MINOR ― když se přidá funkcionalita se zachováním zpětné kompatibility
  PATCH ― když se opravila chyba a zůstala kompatibilita


Pomocí předběžných verzí a přidáváním metadat je možné upřesnit informace. Např.: 1.0.0-alfa, 1.0.1-beta+2

Úvod

Ve světě softwaru, jeho vývoje a správy existuje děsivé místo, kterému anglicky říkáme “dependency hell” (v překladu “peklo závislostí”). Čím vetší a komplexnější váš projekt je, tím je větší šance, že se na tomto místě jednou ocitnete.

Když mají systémy mnoho závislostí, může se stát, že vydání nové verze je noční můrou pro obě strany. Pokud je specifikovaná závislost příliš striktní, hrozí, že zůstanete na jedné verzi (angl. “version lock”) a nebudete mít možnost přejít na další verzi bez toho, abyste vydali další verze všech balíčků nebo knihoven, na kterých projekt stojí. Na druhou stranu, když je specifikovaná závislost příliš volná, přijdete na to, že váš program je kompatibilní s více verzemi než je nutné a potřebné. V pekle závislostí se nacházíte, jakmile jste vázaný určitou verzí nebo v případně, že není přesně specifikován rozsah verzí, které máte použít. Taková situace brání v bezpečném vývoji kupředu.

Řešením tohoto problému je jednoduchý sled pravidel, které určují, jak budou čísla verzí přiřazována a navyšována. Tyto pravidla jsou založené (ale nikoliv omezeny) na již ověřené praxi a to ve vývoji otevřeného i uzavřeného softwaru. Pro správné fungování systému, si musíte nejdříve nadefinovat způsob, jakým se bude komunikovat s Vaší aplikací (dále API). Toto API může být nadefinované pomocí rozsáhlé dokumentace nebo zapsané přímo ve zdrojovém kódu. Nezáleží na způsobu zápisu, je důležité, aby bylo srozumitelné a snadno čitelné. Je třeba mít kompletní dokumentaci, způsob oznamovaní a čitelné rozdíly v nových verzích. Zápis verzí je ve formátu MAJOR.MINOR.PATCH. Opravy chyb, které nezměnily Vaše API, zvyšují číslo PATCH verze. Zpětně kompatibilní změny v API zvyšují hodnotu MINOR verze a rozdílné verze API, které nejsou zpětně kompatibilní, zvyšují číslo MAJOR verze.
Tímto způsobem je nastavený systém Sémantického verzování.

Specifikace Sémantického verzování (SemVer)

“MUSÍ” (angl. MUST, REQUIRED, SHALL)
“NESMÍ” (angl. MUST NOT, SHALL NOT)
“MĚLO BY” (angl. SHOULD, RECOMMENDED)
“NEMĚLO BY” (angl. SHOULD NOT)
“MŮŽE” (angl. MAY, OPTIONAL)
(výrazy jsou interpretované z dokumentu: RFC 2119)


  
    Software používající Sémantické verzování, MUSÍ mít nadefinované API, buďto přímo ve zdrojovém kódu a nebo v externí dokumentaci. V obou případech to musí být hlavně přesné a komplexní.
  
  
    Číslo verzí MUSÍ být ve formátu X, Y, Z. Jedná se o celá nezáporná čísla, přičemž X se NESMÍ rovnat hodnotě nula. Může se rovnat nule jen v případě, kdy se jedná o počáteční vývoj. X je číslo MAJOR verze, Y je číslem MINOR verze a Z je číslem PATCH verze, přičemž každé číslo má svoji hodnotu a navyšují se zvlášť a standardně, např.1.9.0 => 1.10.0 => 1.11.0.
  
  
    Jakmile se vydá očíslovaná verze programu, NESMÍ se měnit a každá další úprava nebo oprava je vydána pod novou verzí.
  
  
    MAJOR verze s hodnotou 0 (0.y.z.) je určena pro počáteční vývoj. Cokoliv se může změnit a API v tomto formátu by NEMĚLO být považováno za stabilní.
  
  
    Verze 1.0.0 definuje veřejně vydané API. Způsob, jakým se dále navyšuje číslo verze je ovlivněné tímto API a jeho změnami.
  
  
    Číslo PATCH (Z) MUSÍ být navýšené jenom pokud byly implentované zpětně kompatibilní opravy chyb. Oprava chyb je definována jako interní změna opravující nežádoucí chování programu.
  
  
    Číslo MINOR (Y) MUSÍ být zvýšené, když byla do API přidána nová, zpětně kompatibilní funkcionalita nebo pokud byla jakákoliv funkcionalita odebrána (jako zastaralá) i pokud neovlivňuje samotný API kód. MŮŽE zahrnout i změnu PATCH verze. Číslo PATCH verze se musí vynulovat vždy, když se změní MINOR verze.
  
  
    Číslo MAJOR (X) MUSÍ být zvýšené, když byly přidané změny, které způsobily zpětnou nekompatibilitu. MŮŽE zahrnout i změny v rámci MINOR a PATCH verze. Číslo MINOR i PATCH se MUSÍ vynulovat vždy, když se změní MAJOR verze.
  
  
    Předběžné verze (angl. pre-release) MOHOU být označeny přidáním pomlčky a sérií identifikátorů oddělených tečkou hned za číslo PATCH verze. Identifikátory MUSÍ obsahovat pouze ASCII alfanumerické znaky a pomlčku [0-9A-Za-z-], NESMÍ být prázdné a číselné identifikátory NESMÍ obsahovat úvodní nulu. Předběžné verze mají nižší prioritu jako související normální verze. Předběžná verze je nestabilní a nemusí splňovat požadavky a závislosti jako normální verze. Např.: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Metadata MOHOU být označené ve verzi přidáním znaku plus (+) a sérií identifikátorů oddělených tečkou hned za číslo PATCH a nebo pomocí předběžné verze. Identifikátory MUSÍ obsahovat pouze ASCII alfanumerické znaky a pomlčku [0-9A-Za-z-], NESMÍ být prázdné a číselné identifikátory NESMÍ obsahovat úvodní nulu. Metadata by NEMĚLY hrát roli při volbě priority verze. Např.: verze 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85 mají všechny stejnou prioritu.
  
  
    Priorita se vztahuje na to, jak jsou verze navzájem porovnávané. Priorita MUSÍ být určována rozdělením verze na MAJOR, MINOR, PATCH a identifikátory předběžných verzí ― přesně v tomto pořadí (s metadaty se nepočítá). Priorita je daná prvním rozdílem při porovnání zleva doprava přičemž čísla MAJOR, MINOR a PATCH jsou vždy porovnávané jako čísla. Např.: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Pokud jsou čísla MAJOR, MINOR a PATCH stejné, předběžná verze má menší prioritu, než normální. Např.: 1.0.0-alpha < 1.0.0. Priorita pro dvě předběžné verze, které se shodují v číslech MAJOR, MINOR a PATCH musí být počítaná zleva doprava od tečky oddělených identifikátorů a to do doby, dokud se nenajde rozdíl a to následujícím způsobem: (1) Identifikátory obsahující pouze číslice, jsou porovnané číselně a identifikátory s písmeny nebo pomlčkami jsou porovnávané lexikálně, zařazené podle ASCII. (2) Číselné identifikátory mají vždy nižší prioritu jak nečíslené. (3) Jsou-li všechny předchozí identifikátory v předběžné verzi stejné, tak větší množství identifikátorů značí vyšší prioritu, než s menším počtem. Např.: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beřta.11 < 1.0.0-rc.1 < 1.0.0.
  


Proč používat Sémantické verzování?

Sémantické verzování není revoluční myšlenka a když vydáváte software, tak už pravděpodobně děláte něco podobného. Problém je, že “něco podobného” nestačí. Bez dodržování daných formálních specifikací jsou čísla pro managment závislostí v podstatě na nic. Tím, že výše uvedeným myšlenkám dáváme přesnou a jasnou definici, je lehčí komunikovat záměry Vašeho softwaru jeho uživatelům. Jakmile jsou záměry jasné a flexibilní (ale ne příliš), specifikace závislostí může začít.

Následující příklad ilustruje, jak se díky Sémantickému verzování můžete snadno vyhnout problémům se závislostmi (tzv. “dependency hell”). Mějme knihovnou “Firetruck” (česky požární vůz). Ta závisí na Sémanticky verzované knihovně “Ladder” (česky žebřík). Ve době vzniku knihovny Firetruck je aktuální verze knihovny Ladder 3.1.0. Protože Firetruck využívá některé funkce knihovny Ladder, které do ni byly přidány až ve verzi 3.1.0, můžete bez rizika nadefinovat závislost na knihovně Ladder ve verzi vyšší nebo rovno 3.1.0 a menší než 4.0.0. Jakmile bude vydána verze Ladder 3.2.0, můžete se spolehnout na to, že s ní bude knihovna Firetruck kompatibilní.

Jako zodpovědní vývojáři určitě budete chtít kontrolovat, že všechno funguje podle Vašich předpokladů. Sématické verzování vám umožní rozumný způsob, jak vydávat a aktualizovat knihovny tak, abyste nemuseli řešit nové verze závislostí, ušetřili si čas a vyhnuli se zmatkům.

Pokud vám tyto argumenty připadají rozumné, všechno co potřebujete udělat pro začátek používání Sémantického verzování je dát vědět, že to děláte, a následně dodržovali stanovená pravidla. Odkazem ze souboru README z vaší aplikace/softwaru na tyto stránky dejte ostatním vědět, jaká pravidla používáte. Přinese to užitek vám i uživatelům vašeho software nebo aplikace.

Často kladené otázky (FAQ)

Jak si poradit s verzemi 0.y.z. na začátku vývoje?

Nejjednodušším způsobem je začít vývoj na verzi 0.1.0. a potom zvyšovat MINOR verzi při každém dalším vydání softwaru.

Jak poznat, kdy vydat verzi 1.0.0?

Pokud se váš software již používá v produkci, už by pravděpodobně měl mít verzi 1.0.0. Jestli máte stabilní API, které už uživatelé mají mezi svými závislostmi, měli byste mít už verzi 1.0.0. Taktéž, když se obáváte o zpětnou kompatibilitu.

Neodrazuje to od rychlého vývoje?

MAJOR verze nula je o rychlém vývoji. Když každý den měníte API, stále byste měli být někde ve fázi 0.y.z nebo na separátní vývojové větvi, kde se připravuje následující MAJOR verze.

Pokud ty nejmenší zpětně nekompatibilní změny v API znamenají navýšení MAJOR verze, neskončíme poměrně rychle někde ve verzi 42.0.0?

To je otázka zodpovědného vývoje a prognóz. Nekompatibilní změny by neměly být v softwaru, který má mnoho závislostí, zavedeny jen tak. Náklady vynaložené na aktualizaci mohou být dost vysoké. To, že musíte vydat novou verzi MAJOR znamená, že jste si dobře promysleli dopad všech změn, výhody i následky.

Zdokumentovat celé API je strašně moc práce!

Je Vaší zodpovědností jako profesionálních vývojářů správně dokumentovat software, který je určený i pro ostatní. Spravování složitosti softwaru je velmi důležitá část, pokud chcete váš projekt udržovat efektivní. A to nebude možné, když nikdo nebude vědět, jak váš software používat nebo které metody je bezpečné volat. Z dlouhodobého hlediska se Sématické verzování a důraz na dobře definované API ukázaly jako správná volba, umožňující hladké i dlouhodobé fungování.

Co dělat, když vydám zpětně nekompatibilní verzi MINOR?

Jakmile zjistíte, že jste porušili pravidla Sémantického verzování, opravte problém a vydejte další MINOR verzi, která opět vrátí zpětnou kompatibilitu. I vzhledem na vzniklou situaci je nepřípustné, abyste měnili už vydanou verzi. Pokud je to možné a vhodné, informujte uživatele o špatné verzi, aby věděli, že se jedná o chybu a dané verzi se vyhnuli.

Co dělat, když jsem aktualizoval vlastní závislosti bez toho, aby se změnilo API?

Můžeme to považovat za kompatibilní, když to nijak neovlivnilo API. Software, který přesně závisí na balíčcích jako váš, by měl mít vlastní definici závislostí a jeho autor si všimne jakýchkoliv konfliktů. Rozhodnutí, zda se jedná o MINOR nebo PATCH závisí od toho, jestli jste upravili své závislosti kvůli nějaké chybě nebo proto, že jste přidali novou funkcionalitu. Pokud se jedná o druhý případ, očekává se, že přibude i nějaký kód a tím pádem se jedná o zvýšení MINOR verze.

Co když jsem nechtěně změnil API, způsobem, který není v souladě se změnou čísla verze (například jsem udělal MAJOR změnu v PATCH verzi)

Posuďte, co je nejlepší. Jestli máte velkou skupinu uživatelů, která by byla ovlivněna změnou zpět, tak asi bude nejlepší vydat MAJOR verzi i na úkor toho, že oprava zpět by měla být součástí PATCH verze. Pamatujte, že Sémantické verzování je o tom, jak se verze mění. Jestli jsou změny pro Vaše uživatele důležité, použijte také číslo verze, abyste je informovali.

Jak se vypořádat se zastaralými funkcionalitami?

Označení funkcionality jako zastaralé je standardní část softwarového vývoje a většinou je to potřeba k tomu, aby šel vývoj kupředu. Když zestárne část API, měli by jste udělat dvě věci: (1) upravit dokumentaci, aby uživatelé věděli o změně, (2) vydat další MINOR verzi, která funkcionalitu “zestárne”. Předtím, než funkcionalitu kompletně odstraníte v další MAJOR verzi, měli byste vytvořit alespoň jednu MINOR verzi, která obsahuje “zestárnutí”. To umožní uživatelům hladký a snadný přechod nebo převod na nové API.

Má Sémantické verzování nějaký limit délky označení verzí?
Ne, nemá. Limit ASCII je 255 znaků ale to je na verzování už asi moc.

O specifikaci

Autorem Specifikace sémantického verzování je
Tom Preston-Werner, autor projektu Gravatar a spolu-zakladatel projektu Github.

Pokud chcete zanechat zpětnou vazbu, prosím
přes GitHub.

Český překlad

Jakub Křižka (autor),
Zuzana Bertová (korektor)
Aleš Pařízek (korektor)

Licence

Creative Commons ― CC BY 3.0\nSémantické verzování 2.0.0\nČíslo verzí zapisujeme ve formátu MAJOR.MINOR.PATCH
Navyšování jednotlivých čísel verzí probíhá následovně:\nMAJOR ― když nastala změna, která není zpětně kompatibilní s ostatními (API)\nMINOR ― když se přidá funkcionalita se zachováním zpětné kompatibility\nPATCH ― když se opravila chyba a zůstala kompatibilita\nPomocí předběžných verzí a přidáváním metadat je možné upřesnit informace. Např.: 1.0.0-alfa, 1.0.1-beta+2\nVe světě softwaru, jeho vývoje a správy existuje děsivé místo, kterému anglicky říkáme “dependency hell” (v překladu “peklo závislostí”). Čím vetší a komplexnější váš projekt je, tím je větší šance, že se na tomto místě jednou ocitnete.\nKdyž mají systémy mnoho závislostí, může se stát, že vydání nové verze je noční můrou pro obě strany. Pokud je specifikovaná závislost příliš striktní, hrozí, že zůstanete na jedné verzi (angl. “version lock”) a nebudete mít možnost přejít na další verzi bez toho, abyste vydali další verze všech balíčků nebo knihoven, na kterých projekt stojí. Na druhou stranu, když je specifikovaná závislost příliš volná, přijdete na to, že váš program je kompatibilní s více verzemi než je nutné a potřebné. V pekle závislostí se nacházíte, jakmile jste vázaný určitou verzí nebo v případně, že není přesně specifikován rozsah verzí, které máte použít. Taková situace brání v bezpečném vývoji kupředu.\nŘešením tohoto problému je jednoduchý sled pravidel, které určují, jak budou čísla verzí přiřazována a navyšována. Tyto pravidla jsou založené (ale nikoliv omezeny) na již ověřené praxi a to ve vývoji otevřeného i uzavřeného softwaru. Pro správné fungování systému, si musíte nejdříve nadefinovat způsob, jakým se bude komunikovat s Vaší aplikací (dále API). Toto API může být nadefinované pomocí rozsáhlé dokumentace nebo zapsané přímo ve zdrojovém kódu. Nezáleží na způsobu zápisu, je důležité, aby bylo srozumitelné a snadno čitelné. Je třeba mít kompletní dokumentaci, způsob oznamovaní a čitelné rozdíly v nových verzích. Zápis verzí je ve formátu MAJOR.MINOR.PATCH. Opravy chyb, které nezměnily Vaše API, zvyšují číslo PATCH verze. Zpětně kompatibilní změny v API zvyšují hodnotu MINOR verze a rozdílné verze API, které nejsou zpětně kompatibilní, zvyšují číslo MAJOR verze.
Tímto způsobem je nastavený systém Sémantického verzování.\nSpecifikace Sémantického verzování (SemVer)\n“MUSÍ” (angl. MUST, REQUIRED, SHALL)
“NESMÍ” (angl. MUST NOT, SHALL NOT)
“MĚLO BY” (angl. SHOULD, RECOMMENDED)
“NEMĚLO BY” (angl. SHOULD NOT)
“MŮŽE” (angl. MAY, OPTIONAL)
(výrazy jsou interpretované z dokumentu: RFC 2119)\nSoftware používající Sémantické verzování, MUSÍ mít nadefinované API, buďto přímo ve zdrojovém kódu a nebo v externí dokumentaci. V obou případech to musí být hlavně přesné a komplexní.\nSoftware používající Sémantické verzování, MUSÍ mít nadefinované API, buďto přímo ve zdrojovém kódu a nebo v externí dokumentaci. V obou případech to musí být hlavně přesné a komplexní.\nČíslo verzí MUSÍ být ve formátu X, Y, Z. Jedná se o celá nezáporná čísla, přičemž X se NESMÍ rovnat hodnotě nula. Může se rovnat nule jen v případě, kdy se jedná o počáteční vývoj. X je číslo MAJOR verze, Y je číslem MINOR verze a Z je číslem PATCH verze, přičemž každé číslo má svoji hodnotu a navyšují se zvlášť a standardně, např.1.9.0 => 1.10.0 => 1.11.0.\nČíslo verzí MUSÍ být ve formátu X, Y, Z. Jedná se o celá nezáporná čísla, přičemž X se NESMÍ rovnat hodnotě nula. Může se rovnat nule jen v případě, kdy se jedná o počáteční vývoj. X je číslo MAJOR verze, Y je číslem MINOR verze a Z je číslem PATCH verze, přičemž každé číslo má svoji hodnotu a navyšují se zvlášť a standardně, např.1.9.0 => 1.10.0 => 1.11.0.\nJakmile se vydá očíslovaná verze programu, NESMÍ se měnit a každá další úprava nebo oprava je vydána pod novou verzí.\nJakmile se vydá očíslovaná verze programu, NESMÍ se měnit a každá další úprava nebo oprava je vydána pod novou verzí.\nMAJOR verze s hodnotou 0 (0.y.z.) je určena pro počáteční vývoj. Cokoliv se může změnit a API v tomto formátu by NEMĚLO být považováno za stabilní.\nMAJOR verze s hodnotou 0 (0.y.z.) je určena pro počáteční vývoj. Cokoliv se může změnit a API v tomto formátu by NEMĚLO být považováno za stabilní.\nVerze 1.0.0 definuje veřejně vydané API. Způsob, jakým se dále navyšuje číslo verze je ovlivněné tímto API a jeho změnami.\nVerze 1.0.0 definuje veřejně vydané API. Způsob, jakým se dále navyšuje číslo verze je ovlivněné tímto API a jeho změnami.\nČíslo PATCH (Z) MUSÍ být navýšené jenom pokud byly implentované zpětně kompatibilní opravy chyb. Oprava chyb je definována jako interní změna opravující nežádoucí chování programu.\nČíslo PATCH (Z) MUSÍ být navýšené jenom pokud byly implentované zpětně kompatibilní opravy chyb. Oprava chyb je definována jako interní změna opravující nežádoucí chování programu.\nČíslo MINOR (Y) MUSÍ být zvýšené, když byla do API přidána nová, zpětně kompatibilní funkcionalita nebo pokud byla jakákoliv funkcionalita odebrána (jako zastaralá) i pokud neovlivňuje samotný API kód. MŮŽE zahrnout i změnu PATCH verze. Číslo PATCH verze se musí vynulovat vždy, když se změní MINOR verze.\nČíslo MINOR (Y) MUSÍ být zvýšené, když byla do API přidána nová, zpětně kompatibilní funkcionalita nebo pokud byla jakákoliv funkcionalita odebrána (jako zastaralá) i pokud neovlivňuje samotný API kód. MŮŽE zahrnout i změnu PATCH verze. Číslo PATCH verze se musí vynulovat vždy, když se změní MINOR verze.\nČíslo MAJOR (X) MUSÍ být zvýšené, když byly přidané změny, které způsobily zpětnou nekompatibilitu. MŮŽE zahrnout i změny v rámci MINOR a PATCH verze. Číslo MINOR i PATCH se MUSÍ vynulovat vždy, když se změní MAJOR verze.\nČíslo MAJOR (X) MUSÍ být zvýšené, když byly přidané změny, které způsobily zpětnou nekompatibilitu. MŮŽE zahrnout i změny v rámci MINOR a PATCH verze. Číslo MINOR i PATCH se MUSÍ vynulovat vždy, když se změní MAJOR verze.\nPředběžné verze (angl. pre-release) MOHOU být označeny přidáním pomlčky a sérií identifikátorů oddělených tečkou hned za číslo PATCH verze. Identifikátory MUSÍ obsahovat pouze ASCII alfanumerické znaky a pomlčku [0-9A-Za-z-], NESMÍ být prázdné a číselné identifikátory NESMÍ obsahovat úvodní nulu. Předběžné verze mají nižší prioritu jako související normální verze. Předběžná verze je nestabilní a nemusí splňovat požadavky a závislosti jako normální verze. Např.: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nPředběžné verze (angl. pre-release) MOHOU být označeny přidáním pomlčky a sérií identifikátorů oddělených tečkou hned za číslo PATCH verze. Identifikátory MUSÍ obsahovat pouze ASCII alfanumerické znaky a pomlčku [0-9A-Za-z-], NESMÍ být prázdné a číselné identifikátory NESMÍ obsahovat úvodní nulu. Předběžné verze mají nižší prioritu jako související normální verze. Předběžná verze je nestabilní a nemusí splňovat požadavky a závislosti jako normální verze. Např.: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nMetadata MOHOU být označené ve verzi přidáním znaku plus (+) a sérií identifikátorů oddělených tečkou hned za číslo PATCH a nebo pomocí předběžné verze. Identifikátory MUSÍ obsahovat pouze ASCII alfanumerické znaky a pomlčku [0-9A-Za-z-], NESMÍ být prázdné a číselné identifikátory NESMÍ obsahovat úvodní nulu. Metadata by NEMĚLY hrát roli při volbě priority verze. Např.: verze 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85 mají všechny stejnou prioritu.\nMetadata MOHOU být označené ve verzi přidáním znaku plus (+) a sérií identifikátorů oddělených tečkou hned za číslo PATCH a nebo pomocí předběžné verze. Identifikátory MUSÍ obsahovat pouze ASCII alfanumerické znaky a pomlčku [0-9A-Za-z-], NESMÍ být prázdné a číselné identifikátory NESMÍ obsahovat úvodní nulu. Metadata by NEMĚLY hrát roli při volbě priority verze. Např.: verze 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85 mají všechny stejnou prioritu.\nPriorita se vztahuje na to, jak jsou verze navzájem porovnávané. Priorita MUSÍ být určována rozdělením verze na MAJOR, MINOR, PATCH a identifikátory předběžných verzí ― přesně v tomto pořadí (s metadaty se nepočítá). Priorita je daná prvním rozdílem při porovnání zleva doprava přičemž čísla MAJOR, MINOR a PATCH jsou vždy porovnávané jako čísla. Např.: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Pokud jsou čísla MAJOR, MINOR a PATCH stejné, předběžná verze má menší prioritu, než normální. Např.: 1.0.0-alpha < 1.0.0. Priorita pro dvě předběžné verze, které se shodují v číslech MAJOR, MINOR a PATCH musí být počítaná zleva doprava od tečky oddělených identifikátorů a to do doby, dokud se nenajde rozdíl a to následujícím způsobem: (1) Identifikátory obsahující pouze číslice, jsou porovnané číselně a identifikátory s písmeny nebo pomlčkami jsou porovnávané lexikálně, zařazené podle ASCII. (2) Číselné identifikátory mají vždy nižší prioritu jak nečíslené. (3) Jsou-li všechny předchozí identifikátory v předběžné verzi stejné, tak větší množství identifikátorů značí vyšší prioritu, než s menším počtem. Např.: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beřta.11 < 1.0.0-rc.1 < 1.0.0.\nPriorita se vztahuje na to, jak jsou verze navzájem porovnávané. Priorita MUSÍ být určována rozdělením verze na MAJOR, MINOR, PATCH a identifikátory předběžných verzí ― přesně v tomto pořadí (s metadaty se nepočítá). Priorita je daná prvním rozdílem při porovnání zleva doprava přičemž čísla MAJOR, MINOR a PATCH jsou vždy porovnávané jako čísla. Např.: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Pokud jsou čísla MAJOR, MINOR a PATCH stejné, předběžná verze má menší prioritu, než normální. Např.: 1.0.0-alpha < 1.0.0. Priorita pro dvě předběžné verze, které se shodují v číslech MAJOR, MINOR a PATCH musí být počítaná zleva doprava od tečky oddělených identifikátorů a to do doby, dokud se nenajde rozdíl a to následujícím způsobem: (1) Identifikátory obsahující pouze číslice, jsou porovnané číselně a identifikátory s písmeny nebo pomlčkami jsou porovnávané lexikálně, zařazené podle ASCII. (2) Číselné identifikátory mají vždy nižší prioritu jak nečíslené. (3) Jsou-li všechny předchozí identifikátory v předběžné verzi stejné, tak větší množství identifikátorů značí vyšší prioritu, než s menším počtem. Např.: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beřta.11 < 1.0.0-rc.1 < 1.0.0.\nProč používat Sémantické verzování?\nSémantické verzování není revoluční myšlenka a když vydáváte software, tak už pravděpodobně děláte něco podobného. Problém je, že “něco podobného” nestačí. Bez dodržování daných formálních specifikací jsou čísla pro managment závislostí v podstatě na nic. Tím, že výše uvedeným myšlenkám dáváme přesnou a jasnou definici, je lehčí komunikovat záměry Vašeho softwaru jeho uživatelům. Jakmile jsou záměry jasné a flexibilní (ale ne příliš), specifikace závislostí může začít.\nNásledující příklad ilustruje, jak se díky Sémantickému verzování můžete snadno vyhnout problémům se závislostmi (tzv. “dependency hell”). Mějme knihovnou “Firetruck” (česky požární vůz). Ta závisí na Sémanticky verzované knihovně “Ladder” (česky žebřík). Ve době vzniku knihovny Firetruck je aktuální verze knihovny Ladder 3.1.0. Protože Firetruck využívá některé funkce knihovny Ladder, které do ni byly přidány až ve verzi 3.1.0, můžete bez rizika nadefinovat závislost na knihovně Ladder ve verzi vyšší nebo rovno 3.1.0 a menší než 4.0.0. Jakmile bude vydána verze Ladder 3.2.0, můžete se spolehnout na to, že s ní bude knihovna Firetruck kompatibilní.\nJako zodpovědní vývojáři určitě budete chtít kontrolovat, že všechno funguje podle Vašich předpokladů. Sématické verzování vám umožní rozumný způsob, jak vydávat a aktualizovat knihovny tak, abyste nemuseli řešit nové verze závislostí, ušetřili si čas a vyhnuli se zmatkům.\nPokud vám tyto argumenty připadají rozumné, všechno co potřebujete udělat pro začátek používání Sémantického verzování je dát vědět, že to děláte, a následně dodržovali stanovená pravidla. Odkazem ze souboru README z vaší aplikace/softwaru na tyto stránky dejte ostatním vědět, jaká pravidla používáte. Přinese to užitek vám i uživatelům vašeho software nebo aplikace.\nČasto kladené otázky (FAQ)\nJak si poradit s verzemi 0.y.z. na začátku vývoje?\nNejjednodušším způsobem je začít vývoj na verzi 0.1.0. a potom zvyšovat MINOR verzi při každém dalším vydání softwaru.\nJak poznat, kdy vydat verzi 1.0.0?\nPokud se váš software již používá v produkci, už by pravděpodobně měl mít verzi 1.0.0. Jestli máte stabilní API, které už uživatelé mají mezi svými závislostmi, měli byste mít už verzi 1.0.0. Taktéž, když se obáváte o zpětnou kompatibilitu.\nNeodrazuje to od rychlého vývoje?\nMAJOR verze nula je o rychlém vývoji. Když každý den měníte API, stále byste měli být někde ve fázi 0.y.z nebo na separátní vývojové větvi, kde se připravuje následující MAJOR verze.\nPokud ty nejmenší zpětně nekompatibilní změny v API znamenají navýšení MAJOR verze, neskončíme poměrně rychle někde ve verzi 42.0.0?\nTo je otázka zodpovědného vývoje a prognóz. Nekompatibilní změny by neměly být v softwaru, který má mnoho závislostí, zavedeny jen tak. Náklady vynaložené na aktualizaci mohou být dost vysoké. To, že musíte vydat novou verzi MAJOR znamená, že jste si dobře promysleli dopad všech změn, výhody i následky.\nZdokumentovat celé API je strašně moc práce!\nJe Vaší zodpovědností jako profesionálních vývojářů správně dokumentovat software, který je určený i pro ostatní. Spravování složitosti softwaru je velmi důležitá část, pokud chcete váš projekt udržovat efektivní. A to nebude možné, když nikdo nebude vědět, jak váš software používat nebo které metody je bezpečné volat. Z dlouhodobého hlediska se Sématické verzování a důraz na dobře definované API ukázaly jako správná volba, umožňující hladké i dlouhodobé fungování.\nCo dělat, když vydám zpětně nekompatibilní verzi MINOR?\nJakmile zjistíte, že jste porušili pravidla Sémantického verzování, opravte problém a vydejte další MINOR verzi, která opět vrátí zpětnou kompatibilitu. I vzhledem na vzniklou situaci je nepřípustné, abyste měnili už vydanou verzi. Pokud je to možné a vhodné, informujte uživatele o špatné verzi, aby věděli, že se jedná o chybu a dané verzi se vyhnuli.\nCo dělat, když jsem aktualizoval vlastní závislosti bez toho, aby se změnilo API?\nMůžeme to považovat za kompatibilní, když to nijak neovlivnilo API. Software, který přesně závisí na balíčcích jako váš, by měl mít vlastní definici závislostí a jeho autor si všimne jakýchkoliv konfliktů. Rozhodnutí, zda se jedná o MINOR nebo PATCH závisí od toho, jestli jste upravili své závislosti kvůli nějaké chybě nebo proto, že jste přidali novou funkcionalitu. Pokud se jedná o druhý případ, očekává se, že přibude i nějaký kód a tím pádem se jedná o zvýšení MINOR verze.\nCo když jsem nechtěně změnil API, způsobem, který není v souladě se změnou čísla verze (například jsem udělal MAJOR změnu v PATCH verzi)\nPosuďte, co je nejlepší. Jestli máte velkou skupinu uživatelů, která by byla ovlivněna změnou zpět, tak asi bude nejlepší vydat MAJOR verzi i na úkor toho, že oprava zpět by měla být součástí PATCH verze. Pamatujte, že Sémantické verzování je o tom, jak se verze mění. Jestli jsou změny pro Vaše uživatele důležité, použijte také číslo verze, abyste je informovali.\nJak se vypořádat se zastaralými funkcionalitami?\nOznačení funkcionality jako zastaralé je standardní část softwarového vývoje a většinou je to potřeba k tomu, aby šel vývoj kupředu. Když zestárne část API, měli by jste udělat dvě věci: (1) upravit dokumentaci, aby uživatelé věděli o změně, (2) vydat další MINOR verzi, která funkcionalitu “zestárne”. Předtím, než funkcionalitu kompletně odstraníte v další MAJOR verzi, měli byste vytvořit alespoň jednu MINOR verzi, která obsahuje “zestárnutí”. To umožní uživatelům hladký a snadný přechod nebo převod na nové API.\nMá Sémantické verzování nějaký limit délky označení verzí?\nNe, nemá. Limit ASCII je 255 znaků ale to je na verzování už asi moc.\nAutorem Specifikace sémantického verzování je
Tom Preston-Werner, autor projektu Gravatar a spolu-zakladatel projektu Github.\nPokud chcete zanechat zpětnou vazbu, prosím
přes GitHub.\nJakub Křižka (autor),
Zuzana Bertová (korektor)
Aleš Pařízek (korektor)\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSemantisk version 2.0.0

Resumé

Givet et versionsnummer MAJOR.MINOR.PATCH, skal du øge:


  STOR version, når du foretager inkompatible API-ændringer,
  MINOR version, når du tilføjer funktionalitet i en bagudkompatibel
måde, og
  PATCH-version, når du laver bagudkompatible fejlrettelser.


Yderligere etiketter til pre-release og build-metadata er tilgængelige som udvidelser
til MAJOR.MINOR.PATCH-formatet.

Introduktion

I verden af ​​software management findes der et frygtet sted kaldet
“afhængighedshelvede.” Jo større dit system vokser, og jo flere pakker du
integreres i din software, jo større sandsynlighed er der for, at du finder dig selv, en
dag, i denne fortvivlelses hule.

I systemer med mange afhængigheder kan frigivelse af nye pakkeversioner hurtigt
blive et mareridt. Hvis afhængighedsspecifikationerne er for stramme, er du med
fare for versionslås (manglende evne til at opgradere en pakke uden at skulle
frigive nye versioner af hver afhængig pakke). Hvis afhængigheder er
specificeret for løst, vil du uundgåeligt blive bidt af versionspromiskuitet
(forudsat kompatibilitet med flere fremtidige versioner end rimeligt).
Afhængighedshelvede er, når versionslås og/eller versionspromiskuitet
forhindrer dig i nemt og sikkert at komme videre med dit projekt.

Som en løsning på dette problem foreslår vi et simpelt sæt regler og
krav, der dikterer, hvordan versionsnumre tildeles og øges.
Disse regler er baseret på, men ikke nødvendigvis begrænset til, allerede eksisterende
udbredt almindelig praksis i brug i både lukket og open source-software.
For at dette system skal fungere, skal du først erklære en offentlig API. Dette kan evt
bestå af dokumentation eller håndhæves af selve koden. Uanset hvad er det
vigtigt, at dette API er klar og præcis. Når du identificerer dit offentlige
API, kommunikerer du ændringer til det med specifikke ændringer til dit versionsnummer.
Overvej et versionsformat af X.Y.Z (Major.Minor.Patch). Fejlrettelser der ikke
påvirker API’et øger patchversionen (Z), bagudkompatibelt API
med tilføjelser/ændringer øger den mindre version (Y) og bagud inkompatible API
ændringer øger hovedversionen (X).

Vi kalder dette system “Semantisk versionering.” Under denne ordning, formidler versionsnumrene mening om den underliggende kode og hvad der har blevet ændret fra den ene version til den næste.

Semantisk versionsspecifikation (SemVer)

Nøgleordene “MÅ”, “MÅ IKKE”, “PÅKRÆVET”, “SKAL”, “MÅ IKKE”, “BØR”,
“BØR IKKE”, “ANBEFALET”, “KAN” og “VALGFRI” i dette dokument skal være
fortolket som beskrevet i RFC 2119.


  
    Software, der bruger semantisk versionering SKAL erklære et offentlig API. Dette API
kan være erklæret i selve koden eller udelukkende eksistere i dokumentationen.
Uanset hvordan det gøres, SKAL det være præcist og omfattende.
  
  
    Et normalt versionsnummer SKAL have formen X.Y.Z, hvor X, Y og Z er
ikke-negative heltal og MÅ IKKE indeholde indledende nuller. X er
større version, Y er den mindre version, og Z er patch-versionen.
Hvert element SKAL øges numerisk. For eksempel: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Når en versioneret pakke er blevet frigivet, MÅ indholdet IKKE ændres i den version.
Eventuelle ændringer SKAL frigives som en ny version.
  
  
    Større version nul (0.y.z) er til indledende udvikling. Alt KAN ændre sig
når som helst. Det offentlige API BØR IKKE betragtes som stabilt.
  
  
    Version 1.0.0 definerer det offentlige API. Den måde, hvorpå versionsnummeret
øges efter denne udgivelse er afhængig af dette offentlige API og hvordan den
ændrer sig.
  
  
    Patchversion Z (x.y.Z | x > 0) SKAL øges, hvis kun baglæns
kompatible fejlrettelser introduceres. En fejlrettelse er defineret som en intern
ændring, der retter ukorrekt adfærd.
  
  
    Mindre version Y (x.Y.z | x > 0) SKAL øges, hvis ny, baglæns
kompatibel funktionalitet introduceres til det offentlige API. Det må 
øges, hvis noget offentlig API-funktionalitet er markeret som forældet. Det BØR øges,
hvis der indføres væsentlig ny funktionalitet eller forbedringer inden for den private kode. Det KAN omfatte ændringer af patch-niveau. Patch version SKAL nulstilles til 0, når mindre version øges.
  
  
    Større version X (X.y.z | X > 0) SKAL øges, hvis der er nogen baglæns
inkompatible ændringer der introduceres til det offentlige API. Det MÅ også omfatte mindre 
ændringer i patch-niveau. Patch og mindre versioner SKAL nulstilles til 0, når de er større
version er øget.
  
  
    En pre-release version KAN angives ved at tilføje en bindestreg og en
serie af punktseparerede identifikatorer umiddelbart efter patchen
version. Identifikatorer SKAL kun omfatte ASCII alfanumeriske tegn og bindestreger
[0-9A-Za-z-]. Identifikatorer MÅ IKKE være tomme. Numeriske identifikatorer SKAL
Inkluder IKKE foranstillede nuller. Pre-release versioner har en lavere
forrang end den tilhørende normale version. En pre-release version
angiver, at versionen er ustabil og muligvis ikke opfylder
tilsigtede kompatibilitetskrav som angivet af dets tilknyttede
normal version. Eksempler: 1.0.0-alfa, 1.0.0-alfa.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.–.
  
  
    Byggemetadata KAN angives ved at tilføje et plustegn og en række prikker
adskilte identifikatorer umiddelbart efter patchen eller pre-release-versionen.
Identifikatorer SKAL kun omfatte ASCII alfanumeriske tegn og bindestreger [0-9A-Za-z-].
Identifikatorer MÅ IKKE være tomme. Byggemetadata SKAL ignoreres ved bestemmelse
versions forrang. Således to versioner, der kun adskiller sig i byggemetadataene,
har samme forrang. Eksempler: 1.0.0-alfa+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3—-117B344092BD.
  
  
    Forrang henviser til, hvordan versioner sammenlignes med hinanden, når de bestilles.

    
      
        Forrang SKAL beregnes ved at adskille versionen i større,
mindre, patch og pre-release identifikatorer i den rækkefølge (Byggemetadata
har ikke forrang).
      
      
        Forrang bestemmes af den første forskel, når man sammenligner hver af
disse identifikatorer fra venstre mod højre som følger: Større, mindre og patch
versioner sammenlignes altid numerisk.

        Eksempel: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Når større, mindre og patch er ens, har en pre-release version lavere
forrang end en normal version:

        Eksempel: 1.0.0-alfa < 1.0.0.
      
      
        Forrang for to pre-release versioner med samme større, mindre og
patch-version SKAL bestemmes ved at sammenligne hver punktsepareret identifikator
fra venstre mod højre, indtil en forskel er fundet som følger:

        
          
            Identifikatorer, der kun består af cifre, sammenlignes numerisk.
          
          
            Identifikatorer med bogstaver eller bindestreger sammenlignes leksikalsk i ASCII
sorteringsrækkefølge.
          
          
            Numeriske identifikatorer har altid lavere forrang end ikke-numeriske
identifikatorer.
          
          
            Et større sæt præ-udgivelsesfelter har en højere prioritet end en
mindre sæt, hvis alle de foregående identifikatorer er ens.
          
        

        Eksempel: 1.0.0-alfa < 1.0.0-alfa.1 < 1.0.0-alfa.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
      
    
  


Hvorfor bruge semantisk versionering?

Dette er ikke en ny eller revolutionær idé. Faktisk gør du sikkert noget
tæt på dette allerede. Problemet er, at “tæt” ikke er godt nok. Uden
overensstemmelse med en form for formel specifikation, versionsnumre er
i det væsentlige ubrugelig til afhængighedsstyring. Ved at give et navn og klart
definition til ovenstående ideer, bliver det nemt at kommunikere dine hensigter
til brugerne af din software. Når først disse intentioner er klare, fleksible (men
ikke for fleksible) kan der endelig laves afhængighedsspecifikationer.

Et simpelt eksempel vil vise, hvordan semantisk versionering kan gøre afhængighed
helvede hører fortiden til. Overvej et bibliotek kaldet “Brandbil.” Det kræver en
Semantisk versioneret pakke med navnet “Ladder.” På det tidspunkt, hvor Firetruck er
oprettet, er Ladder i version 3.1.0. Da Firetruck bruger nogle funktioner
som først blev introduceret i 3.1.0, kan du roligt angive stigen
afhængighed som større end eller lig med 3.1.0, men mindre end 4.0.0. Nu, hvornår
Ladder version 3.1.1 og 3.2.0 bliver tilgængelige, du kan frigive dem til din
pakkestyringssystem og ved, at de vil være kompatible med eksisterende
afhængig software.

Som ansvarlig udvikler vil du naturligvis gerne verificere, at evt
pakkeopgraderinger fungerer som annonceret. Den virkelige verden er et rodet sted;
der er ikke noget, vi kan gøre ved det, end at være årvågne. Hvad du kan gøre er at lade
Semantisk versionering giver dig en fornuftig måde at frigive og opgradere
pakker uden at skulle rulle nye versioner af afhængige pakker, hvilket sparer dig
tid og bøvl.

Hvis alt dette lyder ønskeligt, er alt hvad du skal gøre for at begynde at bruge Semantic
Versionering er at erklære, at du gør det og derefter følge reglerne. Link
til denne hjemmeside fra din README, så andre kender reglerne og kan drage fordel af
dem.

FAQ

Hvordan skal jeg håndtere revisioner i 0.y.z indledende udviklingsfase?

Den enkleste ting at gøre er at starte din første udviklingsudgivelse på 0.1.0
og øg derefter den mindre version for hver efterfølgende udgivelse.

Hvordan ved jeg, hvornår jeg skal udgive 1.0.0?

Hvis din software bliver brugt i produktionen, burde den sandsynligvis allerede være det
1.0.0. Hvis du har et stabilt API, som brugerne er blevet afhængige af, bør du
være 1.0.0. Hvis du bekymrer dig meget om bagudkompatibilitet, bør du
sandsynligvis allerede være 1.0.0.

Afskrækker dette ikke hurtig udvikling og hurtig iteration?

Større version nul handler om hurtig udvikling. Hvis du ændrer API
hver dag bør du enten stadig være i version 0.y.z eller på en separat
udviklingsgren arbejder på den næste store version.

Hvis selv de mindste bagud-inkompatible ændringer af det offentlige API kræver et større versionsbump, vil jeg så ikke ende med version 42.0.0 meget hurtigt?

Dette er et spørgsmål om ansvarlig udvikling og fremsyn. Uforenelig
ændringer bør ikke introduceres let til software, der har en masse
afhængig kode. De omkostninger, der skal afholdes for at opgradere, kan være betydelige.
At skulle bumpe større versioner for at frigive inkompatible ændringer betyder, at du vil
gennemtænk virkningen af ​​dine ændringer, og evaluer cost/benefit-forholdet
involveret.

Det er for meget arbejde at dokumentere hele det offentlige API!

Det er dit ansvar som professionel udvikler at dokumentere ordentligt
software, der er beregnet til brug af andre. Håndtering af softwarekompleksitet er en
enormt vigtig del af at holde et projekt effektivt, og det er svært at gøre hvis
ingen ved, hvordan man bruger din software, eller hvilke metoder der er sikre at kalde. I
på lang sigt, semantisk versionering og insisteren på en veldefineret offentlighed
API kan holde alle og alt kørende.

Hvad gør jeg, hvis jeg ved et uheld frigiver en bagudinkompatibel ændring som en mindre version?

Så snart du indser, at du har brudt Semantic Versioning-specifikationen, skal du rette det
problemet og frigive en ny mindre version, der retter problemet og
genopretter bagudkompatibilitet. Selv under denne omstændighed er det
uacceptabelt at ændre versionerede udgivelser. Hvis det er passende,
dokumentere den krænkende version og informere dine brugere om problemet, således at
de er opmærksomme på den krænkende version.

Hvad skal jeg gøre, hvis jeg opdaterer mine egne afhængigheder uden at ændre det offentlige API?

Det ville blive betragtet som kompatibelt, da det ikke påvirker der offentlige API.
Software, der eksplicit afhænger af de samme afhængigheder som din pakke
bør have deres egne afhængighedsspecifikationer, og forfatteren vil bemærke evt
konflikter. Afgør, om ændringen er et patch-niveau eller et mindre niveau
ændring afhænger af, om du har opdateret dine afhængigheder for at rette
en fejl eller introducere ny funktionalitet. Vi ville normalt forvente yderligere kode
i sidstnævnte tilfælde, i hvilket tilfælde det åbenbart er en mindre niveaustigning.

Hvad hvis jeg utilsigtet ændrer den offentlige API på en måde, der ikke er i overensstemmelse med ændringen af ​​versionsnummeret (dvs. at koden fejlagtigt introducerer en større brydende ændring i en patch-udgivelse)?

Brug din bedste dømmekraft. Hvis du har et stort publikum, vil det være drastisk
påvirket af at ændre adfærden tilbage til, hvad den offentlige API havde til hensigt
det kan være bedst at udføre en større versionsudgivelse, selvom rettelsen kunne
strengt taget betragtes som en patch-udgivelse. Husk, Semantisk versionering er alt
om at formidle mening ved, hvordan versionsnummeret ændres. Hvis disse ændringer
er vigtige for dine brugere, skal du bruge versionsnummeret til at informere dem.

Hvordan skal jeg håndtere udfasning af funktionalitet?

Forringelse af eksisterende funktionalitet er en normal del af softwareudvikling og
er ofte påkrævet for at gøre fremskridt. Når du fraskriver en del af din
offentlige API, bør du gøre to ting: (1) opdatere din dokumentation for at lade
brugere kender til ændringen, (2) udsteder en ny mindre udgivelse med afskrivningen
på plads. Før du helt fjerner funktionaliteten i en ny større udgivelse
der bør være mindst én mindre udgivelse, der indeholder udfasningen så
at brugerne problemfrit kan skifte til den nye API.

Har SemVer en størrelsesbegrænsning på versionsstrengen?

Nej, men brug god dømmekraft. En version på 255 tegn er sandsynligvis overkill,
for eksempel. Også specifikke systemer kan pålægge deres egne grænser for størrelsen af
strengen.

Er “v1.2.3” en semantisk version?

Nej, “v1.2.3” er ikke en semantisk version. Dog foran en semantisk version
med et “v” er en almindelig måde (på engelsk) at angive, at det er et versionsnummer.
At forkorte “version” som “v” ses ofte med versionskontrol. Eksempel:
git tag v1.2.3 -m "Release version 1.2.3", i hvilket tilfælde “v1.2.3” er et tag
navn og den semantiske version er “1.2.3”.

Er der et foreslået regulært udtryk (RegEx) til at kontrollere en SemVer-streng?

Der er to. En med navngivne grupper for de systemer, der understøtter dem
(PCRE [Perl-kompatible regulære udtryk, dvs. Perl, PHP og R], Python
og gå).

Se: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))$


Og en med nummererede optagelsesgrupper i stedet (så cg1 = større, cg2 = mindre,
cg3 = patch, cg4 = prerelease og cg5 = byggemetadata), der er kompatibel
med ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
dvs. Perl, PHP og R), Python og Go.

Se: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0 |[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d *|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?: \.[0-9a-zA-Z-]+)*))?$


Om

Den semantiske versionsspecifikation blev oprindeligt skrevet af Tom
Preston-Werner, opfinder af Gravatar og
medstifter af GitHub.

Hvis du gerne vil give feedback, bedes du åbn et issue på
GitHub.

Licens

Creative Commons ― CC BY 3.0\nSemantisk version 2.0.0\nGivet et versionsnummer MAJOR.MINOR.PATCH, skal du øge:\nSTOR version, når du foretager inkompatible API-ændringer,\nMINOR version, når du tilføjer funktionalitet i en bagudkompatibel
måde, og\nPATCH-version, når du laver bagudkompatible fejlrettelser.\nYderligere etiketter til pre-release og build-metadata er tilgængelige som udvidelser
til MAJOR.MINOR.PATCH-formatet.\nI verden af ​​software management findes der et frygtet sted kaldet
“afhængighedshelvede.” Jo større dit system vokser, og jo flere pakker du
integreres i din software, jo større sandsynlighed er der for, at du finder dig selv, en
dag, i denne fortvivlelses hule.\nI systemer med mange afhængigheder kan frigivelse af nye pakkeversioner hurtigt
blive et mareridt. Hvis afhængighedsspecifikationerne er for stramme, er du med
fare for versionslås (manglende evne til at opgradere en pakke uden at skulle
frigive nye versioner af hver afhængig pakke). Hvis afhængigheder er
specificeret for løst, vil du uundgåeligt blive bidt af versionspromiskuitet
(forudsat kompatibilitet med flere fremtidige versioner end rimeligt).
Afhængighedshelvede er, når versionslås og/eller versionspromiskuitet
forhindrer dig i nemt og sikkert at komme videre med dit projekt.\nSom en løsning på dette problem foreslår vi et simpelt sæt regler og
krav, der dikterer, hvordan versionsnumre tildeles og øges.
Disse regler er baseret på, men ikke nødvendigvis begrænset til, allerede eksisterende
udbredt almindelig praksis i brug i både lukket og open source-software.
For at dette system skal fungere, skal du først erklære en offentlig API. Dette kan evt
bestå af dokumentation eller håndhæves af selve koden. Uanset hvad er det
vigtigt, at dette API er klar og præcis. Når du identificerer dit offentlige
API, kommunikerer du ændringer til det med specifikke ændringer til dit versionsnummer.
Overvej et versionsformat af X.Y.Z (Major.Minor.Patch). Fejlrettelser der ikke
påvirker API’et øger patchversionen (Z), bagudkompatibelt API
med tilføjelser/ændringer øger den mindre version (Y) og bagud inkompatible API
ændringer øger hovedversionen (X).\nVi kalder dette system “Semantisk versionering.” Under denne ordning, formidler versionsnumrene mening om den underliggende kode og hvad der har blevet ændret fra den ene version til den næste.\nSemantisk versionsspecifikation (SemVer)\nNøgleordene “MÅ”, “MÅ IKKE”, “PÅKRÆVET”, “SKAL”, “MÅ IKKE”, “BØR”,
“BØR IKKE”, “ANBEFALET”, “KAN” og “VALGFRI” i dette dokument skal være
fortolket som beskrevet i RFC 2119.\nSoftware, der bruger semantisk versionering SKAL erklære et offentlig API. Dette API
kan være erklæret i selve koden eller udelukkende eksistere i dokumentationen.
Uanset hvordan det gøres, SKAL det være præcist og omfattende.\nSoftware, der bruger semantisk versionering SKAL erklære et offentlig API. Dette API
kan være erklæret i selve koden eller udelukkende eksistere i dokumentationen.
Uanset hvordan det gøres, SKAL det være præcist og omfattende.\nEt normalt versionsnummer SKAL have formen X.Y.Z, hvor X, Y og Z er
ikke-negative heltal og MÅ IKKE indeholde indledende nuller. X er
større version, Y er den mindre version, og Z er patch-versionen.
Hvert element SKAL øges numerisk. For eksempel: 1.9.0 -> 1.10.0 -> 1.11.0.\nEt normalt versionsnummer SKAL have formen X.Y.Z, hvor X, Y og Z er
ikke-negative heltal og MÅ IKKE indeholde indledende nuller. X er
større version, Y er den mindre version, og Z er patch-versionen.
Hvert element SKAL øges numerisk. For eksempel: 1.9.0 -> 1.10.0 -> 1.11.0.\nNår en versioneret pakke er blevet frigivet, MÅ indholdet IKKE ændres i den version.
Eventuelle ændringer SKAL frigives som en ny version.\nNår en versioneret pakke er blevet frigivet, MÅ indholdet IKKE ændres i den version.
Eventuelle ændringer SKAL frigives som en ny version.\nStørre version nul (0.y.z) er til indledende udvikling. Alt KAN ændre sig
når som helst. Det offentlige API BØR IKKE betragtes som stabilt.\nStørre version nul (0.y.z) er til indledende udvikling. Alt KAN ændre sig
når som helst. Det offentlige API BØR IKKE betragtes som stabilt.\nVersion 1.0.0 definerer det offentlige API. Den måde, hvorpå versionsnummeret
øges efter denne udgivelse er afhængig af dette offentlige API og hvordan den
ændrer sig.\nVersion 1.0.0 definerer det offentlige API. Den måde, hvorpå versionsnummeret
øges efter denne udgivelse er afhængig af dette offentlige API og hvordan den
ændrer sig.\nPatchversion Z (x.y.Z | x > 0) SKAL øges, hvis kun baglæns
kompatible fejlrettelser introduceres. En fejlrettelse er defineret som en intern
ændring, der retter ukorrekt adfærd.\nPatchversion Z (x.y.Z | x > 0) SKAL øges, hvis kun baglæns
kompatible fejlrettelser introduceres. En fejlrettelse er defineret som en intern
ændring, der retter ukorrekt adfærd.\nMindre version Y (x.Y.z | x > 0) SKAL øges, hvis ny, baglæns
kompatibel funktionalitet introduceres til det offentlige API. Det må 
øges, hvis noget offentlig API-funktionalitet er markeret som forældet. Det BØR øges,
hvis der indføres væsentlig ny funktionalitet eller forbedringer inden for den private kode. Det KAN omfatte ændringer af patch-niveau. Patch version SKAL nulstilles til 0, når mindre version øges.\nMindre version Y (x.Y.z | x > 0) SKAL øges, hvis ny, baglæns
kompatibel funktionalitet introduceres til det offentlige API. Det må 
øges, hvis noget offentlig API-funktionalitet er markeret som forældet. Det BØR øges,
hvis der indføres væsentlig ny funktionalitet eller forbedringer inden for den private kode. Det KAN omfatte ændringer af patch-niveau. Patch version SKAL nulstilles til 0, når mindre version øges.\nStørre version X (X.y.z | X > 0) SKAL øges, hvis der er nogen baglæns
inkompatible ændringer der introduceres til det offentlige API. Det MÅ også omfatte mindre 
ændringer i patch-niveau. Patch og mindre versioner SKAL nulstilles til 0, når de er større
version er øget.\nStørre version X (X.y.z | X > 0) SKAL øges, hvis der er nogen baglæns
inkompatible ændringer der introduceres til det offentlige API. Det MÅ også omfatte mindre 
ændringer i patch-niveau. Patch og mindre versioner SKAL nulstilles til 0, når de er større
version er øget.\nEn pre-release version KAN angives ved at tilføje en bindestreg og en
serie af punktseparerede identifikatorer umiddelbart efter patchen
version. Identifikatorer SKAL kun omfatte ASCII alfanumeriske tegn og bindestreger
[0-9A-Za-z-]. Identifikatorer MÅ IKKE være tomme. Numeriske identifikatorer SKAL
Inkluder IKKE foranstillede nuller. Pre-release versioner har en lavere
forrang end den tilhørende normale version. En pre-release version
angiver, at versionen er ustabil og muligvis ikke opfylder
tilsigtede kompatibilitetskrav som angivet af dets tilknyttede
normal version. Eksempler: 1.0.0-alfa, 1.0.0-alfa.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.–.\nEn pre-release version KAN angives ved at tilføje en bindestreg og en
serie af punktseparerede identifikatorer umiddelbart efter patchen
version. Identifikatorer SKAL kun omfatte ASCII alfanumeriske tegn og bindestreger
[0-9A-Za-z-]. Identifikatorer MÅ IKKE være tomme. Numeriske identifikatorer SKAL
Inkluder IKKE foranstillede nuller. Pre-release versioner har en lavere
forrang end den tilhørende normale version. En pre-release version
angiver, at versionen er ustabil og muligvis ikke opfylder
tilsigtede kompatibilitetskrav som angivet af dets tilknyttede
normal version. Eksempler: 1.0.0-alfa, 1.0.0-alfa.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.–.\nByggemetadata KAN angives ved at tilføje et plustegn og en række prikker
adskilte identifikatorer umiddelbart efter patchen eller pre-release-versionen.
Identifikatorer SKAL kun omfatte ASCII alfanumeriske tegn og bindestreger [0-9A-Za-z-].
Identifikatorer MÅ IKKE være tomme. Byggemetadata SKAL ignoreres ved bestemmelse
versions forrang. Således to versioner, der kun adskiller sig i byggemetadataene,
har samme forrang. Eksempler: 1.0.0-alfa+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3—-117B344092BD.\nByggemetadata KAN angives ved at tilføje et plustegn og en række prikker
adskilte identifikatorer umiddelbart efter patchen eller pre-release-versionen.
Identifikatorer SKAL kun omfatte ASCII alfanumeriske tegn og bindestreger [0-9A-Za-z-].
Identifikatorer MÅ IKKE være tomme. Byggemetadata SKAL ignoreres ved bestemmelse
versions forrang. Således to versioner, der kun adskiller sig i byggemetadataene,
har samme forrang. Eksempler: 1.0.0-alfa+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3—-117B344092BD.\nForrang henviser til, hvordan versioner sammenlignes med hinanden, når de bestilles.

    
      
        Forrang SKAL beregnes ved at adskille versionen i større,
mindre, patch og pre-release identifikatorer i den rækkefølge (Byggemetadata
har ikke forrang).
      
      
        Forrang bestemmes af den første forskel, når man sammenligner hver af
disse identifikatorer fra venstre mod højre som følger: Større, mindre og patch
versioner sammenlignes altid numerisk.

        Eksempel: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Når større, mindre og patch er ens, har en pre-release version lavere
forrang end en normal version:

        Eksempel: 1.0.0-alfa < 1.0.0.
      
      
        Forrang for to pre-release versioner med samme større, mindre og
patch-version SKAL bestemmes ved at sammenligne hver punktsepareret identifikator
fra venstre mod højre, indtil en forskel er fundet som følger:

        
          
            Identifikatorer, der kun består af cifre, sammenlignes numerisk.
          
          
            Identifikatorer med bogstaver eller bindestreger sammenlignes leksikalsk i ASCII
sorteringsrækkefølge.
          
          
            Numeriske identifikatorer har altid lavere forrang end ikke-numeriske
identifikatorer.
          
          
            Et større sæt præ-udgivelsesfelter har en højere prioritet end en
mindre sæt, hvis alle de foregående identifikatorer er ens.
          
        

        Eksempel: 1.0.0-alfa < 1.0.0-alfa.1 < 1.0.0-alfa.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nForrang henviser til, hvordan versioner sammenlignes med hinanden, når de bestilles.\nForrang SKAL beregnes ved at adskille versionen i større,
mindre, patch og pre-release identifikatorer i den rækkefølge (Byggemetadata
har ikke forrang).\nForrang SKAL beregnes ved at adskille versionen i større,
mindre, patch og pre-release identifikatorer i den rækkefølge (Byggemetadata
har ikke forrang).\nForrang bestemmes af den første forskel, når man sammenligner hver af
disse identifikatorer fra venstre mod højre som følger: Større, mindre og patch
versioner sammenlignes altid numerisk.

        Eksempel: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nForrang bestemmes af den første forskel, når man sammenligner hver af
disse identifikatorer fra venstre mod højre som følger: Større, mindre og patch
versioner sammenlignes altid numerisk.\nEksempel: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nNår større, mindre og patch er ens, har en pre-release version lavere
forrang end en normal version:

        Eksempel: 1.0.0-alfa < 1.0.0.\nNår større, mindre og patch er ens, har en pre-release version lavere
forrang end en normal version:\nEksempel: 1.0.0-alfa < 1.0.0.\nForrang for to pre-release versioner med samme større, mindre og
patch-version SKAL bestemmes ved at sammenligne hver punktsepareret identifikator
fra venstre mod højre, indtil en forskel er fundet som følger:

        
          
            Identifikatorer, der kun består af cifre, sammenlignes numerisk.
          
          
            Identifikatorer med bogstaver eller bindestreger sammenlignes leksikalsk i ASCII
sorteringsrækkefølge.
          
          
            Numeriske identifikatorer har altid lavere forrang end ikke-numeriske
identifikatorer.
          
          
            Et større sæt præ-udgivelsesfelter har en højere prioritet end en
mindre sæt, hvis alle de foregående identifikatorer er ens.
          
        

        Eksempel: 1.0.0-alfa < 1.0.0-alfa.1 < 1.0.0-alfa.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nForrang for to pre-release versioner med samme større, mindre og
patch-version SKAL bestemmes ved at sammenligne hver punktsepareret identifikator
fra venstre mod højre, indtil en forskel er fundet som følger:\nIdentifikatorer, der kun består af cifre, sammenlignes numerisk.\nIdentifikatorer, der kun består af cifre, sammenlignes numerisk.\nIdentifikatorer med bogstaver eller bindestreger sammenlignes leksikalsk i ASCII
sorteringsrækkefølge.\nIdentifikatorer med bogstaver eller bindestreger sammenlignes leksikalsk i ASCII
sorteringsrækkefølge.\nNumeriske identifikatorer har altid lavere forrang end ikke-numeriske
identifikatorer.\nNumeriske identifikatorer har altid lavere forrang end ikke-numeriske
identifikatorer.\nEt større sæt præ-udgivelsesfelter har en højere prioritet end en
mindre sæt, hvis alle de foregående identifikatorer er ens.\nEt større sæt præ-udgivelsesfelter har en højere prioritet end en
mindre sæt, hvis alle de foregående identifikatorer er ens.\nEksempel: 1.0.0-alfa < 1.0.0-alfa.1 < 1.0.0-alfa.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nHvorfor bruge semantisk versionering?\nDette er ikke en ny eller revolutionær idé. Faktisk gør du sikkert noget
tæt på dette allerede. Problemet er, at “tæt” ikke er godt nok. Uden
overensstemmelse med en form for formel specifikation, versionsnumre er
i det væsentlige ubrugelig til afhængighedsstyring. Ved at give et navn og klart
definition til ovenstående ideer, bliver det nemt at kommunikere dine hensigter
til brugerne af din software. Når først disse intentioner er klare, fleksible (men
ikke for fleksible) kan der endelig laves afhængighedsspecifikationer.\nEt simpelt eksempel vil vise, hvordan semantisk versionering kan gøre afhængighed
helvede hører fortiden til. Overvej et bibliotek kaldet “Brandbil.” Det kræver en
Semantisk versioneret pakke med navnet “Ladder.” På det tidspunkt, hvor Firetruck er
oprettet, er Ladder i version 3.1.0. Da Firetruck bruger nogle funktioner
som først blev introduceret i 3.1.0, kan du roligt angive stigen
afhængighed som større end eller lig med 3.1.0, men mindre end 4.0.0. Nu, hvornår
Ladder version 3.1.1 og 3.2.0 bliver tilgængelige, du kan frigive dem til din
pakkestyringssystem og ved, at de vil være kompatible med eksisterende
afhængig software.\nSom ansvarlig udvikler vil du naturligvis gerne verificere, at evt
pakkeopgraderinger fungerer som annonceret. Den virkelige verden er et rodet sted;
der er ikke noget, vi kan gøre ved det, end at være årvågne. Hvad du kan gøre er at lade
Semantisk versionering giver dig en fornuftig måde at frigive og opgradere
pakker uden at skulle rulle nye versioner af afhængige pakker, hvilket sparer dig
tid og bøvl.\nHvis alt dette lyder ønskeligt, er alt hvad du skal gøre for at begynde at bruge Semantic
Versionering er at erklære, at du gør det og derefter følge reglerne. Link
til denne hjemmeside fra din README, så andre kender reglerne og kan drage fordel af
dem.\nHvordan skal jeg håndtere revisioner i 0.y.z indledende udviklingsfase?\nDen enkleste ting at gøre er at starte din første udviklingsudgivelse på 0.1.0
og øg derefter den mindre version for hver efterfølgende udgivelse.\nHvordan ved jeg, hvornår jeg skal udgive 1.0.0?\nHvis din software bliver brugt i produktionen, burde den sandsynligvis allerede være det
1.0.0. Hvis du har et stabilt API, som brugerne er blevet afhængige af, bør du
være 1.0.0. Hvis du bekymrer dig meget om bagudkompatibilitet, bør du
sandsynligvis allerede være 1.0.0.\nAfskrækker dette ikke hurtig udvikling og hurtig iteration?\nStørre version nul handler om hurtig udvikling. Hvis du ændrer API
hver dag bør du enten stadig være i version 0.y.z eller på en separat
udviklingsgren arbejder på den næste store version.\nHvis selv de mindste bagud-inkompatible ændringer af det offentlige API kræver et større versionsbump, vil jeg så ikke ende med version 42.0.0 meget hurtigt?\nDette er et spørgsmål om ansvarlig udvikling og fremsyn. Uforenelig
ændringer bør ikke introduceres let til software, der har en masse
afhængig kode. De omkostninger, der skal afholdes for at opgradere, kan være betydelige.
At skulle bumpe større versioner for at frigive inkompatible ændringer betyder, at du vil
gennemtænk virkningen af ​​dine ændringer, og evaluer cost/benefit-forholdet
involveret.\nDet er for meget arbejde at dokumentere hele det offentlige API!\nDet er dit ansvar som professionel udvikler at dokumentere ordentligt
software, der er beregnet til brug af andre. Håndtering af softwarekompleksitet er en
enormt vigtig del af at holde et projekt effektivt, og det er svært at gøre hvis
ingen ved, hvordan man bruger din software, eller hvilke metoder der er sikre at kalde. I
på lang sigt, semantisk versionering og insisteren på en veldefineret offentlighed
API kan holde alle og alt kørende.\nHvad gør jeg, hvis jeg ved et uheld frigiver en bagudinkompatibel ændring som en mindre version?\nSå snart du indser, at du har brudt Semantic Versioning-specifikationen, skal du rette det
problemet og frigive en ny mindre version, der retter problemet og
genopretter bagudkompatibilitet. Selv under denne omstændighed er det
uacceptabelt at ændre versionerede udgivelser. Hvis det er passende,
dokumentere den krænkende version og informere dine brugere om problemet, således at
de er opmærksomme på den krænkende version.\nHvad skal jeg gøre, hvis jeg opdaterer mine egne afhængigheder uden at ændre det offentlige API?\nDet ville blive betragtet som kompatibelt, da det ikke påvirker der offentlige API.
Software, der eksplicit afhænger af de samme afhængigheder som din pakke
bør have deres egne afhængighedsspecifikationer, og forfatteren vil bemærke evt
konflikter. Afgør, om ændringen er et patch-niveau eller et mindre niveau
ændring afhænger af, om du har opdateret dine afhængigheder for at rette
en fejl eller introducere ny funktionalitet. Vi ville normalt forvente yderligere kode
i sidstnævnte tilfælde, i hvilket tilfælde det åbenbart er en mindre niveaustigning.\nHvad hvis jeg utilsigtet ændrer den offentlige API på en måde, der ikke er i overensstemmelse med ændringen af ​​versionsnummeret (dvs. at koden fejlagtigt introducerer en større brydende ændring i en patch-udgivelse)?\nBrug din bedste dømmekraft. Hvis du har et stort publikum, vil det være drastisk
påvirket af at ændre adfærden tilbage til, hvad den offentlige API havde til hensigt
det kan være bedst at udføre en større versionsudgivelse, selvom rettelsen kunne
strengt taget betragtes som en patch-udgivelse. Husk, Semantisk versionering er alt
om at formidle mening ved, hvordan versionsnummeret ændres. Hvis disse ændringer
er vigtige for dine brugere, skal du bruge versionsnummeret til at informere dem.\nHvordan skal jeg håndtere udfasning af funktionalitet?\nForringelse af eksisterende funktionalitet er en normal del af softwareudvikling og
er ofte påkrævet for at gøre fremskridt. Når du fraskriver en del af din
offentlige API, bør du gøre to ting: (1) opdatere din dokumentation for at lade
brugere kender til ændringen, (2) udsteder en ny mindre udgivelse med afskrivningen
på plads. Før du helt fjerner funktionaliteten i en ny større udgivelse
der bør være mindst én mindre udgivelse, der indeholder udfasningen så
at brugerne problemfrit kan skifte til den nye API.\nHar SemVer en størrelsesbegrænsning på versionsstrengen?\nNej, men brug god dømmekraft. En version på 255 tegn er sandsynligvis overkill,
for eksempel. Også specifikke systemer kan pålægge deres egne grænser for størrelsen af
strengen.\nEr “v1.2.3” en semantisk version?\nNej, “v1.2.3” er ikke en semantisk version. Dog foran en semantisk version
med et “v” er en almindelig måde (på engelsk) at angive, at det er et versionsnummer.
At forkorte “version” som “v” ses ofte med versionskontrol. Eksempel:
git tag v1.2.3 -m "Release version 1.2.3", i hvilket tilfælde “v1.2.3” er et tag
navn og den semantiske version er “1.2.3”.\nEr der et foreslået regulært udtryk (RegEx) til at kontrollere en SemVer-streng?\nDer er to. En med navngivne grupper for de systemer, der understøtter dem
(PCRE [Perl-kompatible regulære udtryk, dvs. Perl, PHP og R], Python
og gå).\nSe: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))$\nOg en med nummererede optagelsesgrupper i stedet (så cg1 = større, cg2 = mindre,
cg3 = patch, cg4 = prerelease og cg5 = byggemetadata), der er kompatibel
med ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
dvs. Perl, PHP og R), Python og Go.\nSe: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0 |[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d *|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?: \.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0 |[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d *|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?: \.[0-9a-zA-Z-]+)*))?$\nDen semantiske versionsspecifikation blev oprindeligt skrevet af Tom
Preston-Werner, opfinder af Gravatar og
medstifter af GitHub.\nHvis du gerne vil give feedback, bedes du åbn et issue på
GitHub.\nåbn et issue på
GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSemantic Versioning 2.0.0

Zusammenfassung

Auf Grundlage einer Versionsnummer von MAJOR.MINOR.PATCH werden die einzelnen Elemente folgendermaßen erhöht:


  MAJOR wird erhöht, wenn API-inkompatible Änderungen veröffentlicht werden,
  MINOR wird erhöht, wenn neue Funktionalitäten, die kompatibel zur bisherigen API sind, veröffentlicht werden, und
  PATCH wird erhöht, wenn die Änderungen ausschließlich API-kompatible Bugfixes umfassen.


Außerdem sind Bezeichner für Vorveröffentlichungen und Build-Metadaten als Erweiterungen zum MAJOR.MINOR.PATCH-Format verfügbar.

Einführung

In der Welt der Softwareentwicklung existiert ein grauenhafter Ort namens „Dependency Hell“. Um so größer ein Projekt wird und je mehr Pakete in die Software integriert werden, desto wahrscheinlicher ist es, dass dieser fürchterliche Ort eines Tages betreten wird.

In Projekten mit vielen Abhängigkeiten kann das Aktualisieren abhängiger Pakete schnell zum Albtraum werden. Sind die Abhängigkeitsspezifikationen des Pakets zu strikt, besteht die Gefahr des „Version Lock“ (die Unfähigkeit, ein Paket zu aktualisieren, ohne, dass alle abhängigen Pakete dieses Pakets ebenfalls aktualisiert werden müssen). Wenn die Abhängigkeiten des Pakets allerdings zu lasch definiert sind, wird sehr wahrscheinlich ein Problem, das sich „Version Promiscuity“ nennt (das Paket gibt vor, mit mehr zukünftigen Versionen seiner abhängigen Pakete kompatibel zu sein, als angemessen ist), eintreten. Dependency Hell bezeichnet die Situation, in der entweder Version Lock oder Version Promiscuity, oder beides den Entwicklungsprozess des Projekts beeinträchtigt.

Als Lösung für dieses Problem schlage ich ein einfaches Regelwerk vor, das definiert, wie Versionsnummern gewählt und erhöht werden. Diese Regeln basieren auf bereits existierenden und weit verbreiteten Verfahren, die sowohl bei der Entwicklung von Closed- als auch von Open-Source-Software verwendet werden, aber beschränken sich nicht zwingend auf diese. Um dieses System nutzen zu können, muss zuerst eine öffentliche API definiert werden. Diese kann entweder in Form einer Dokumentation existieren oder durch den Code selbst erzwungen werden. Egal auf welche Art und Weise die API umgesetzt wird, es ist wichtig, dass sie übersichtlich und präzise ist. Sobald die öffentliche API erstellt wurde, werden Änderungen an dieser durch bestimmte Veränderungen an der Versionsnummer vermittelt. Nimm ein Versionsnummernformat von X.Y.Z (Major.Minor.Patch) an. Bei Einführung von Bugfixes, die die öffentliche API nicht beeinflussen, wird die Patch-Version erhöht, API-kompatible Ergänzungen oder Änderungen erhöhen die Minor Versionsnummer, und Änderungen, die nicht kompatibel zur aktuellen öffentlichen API sind, erhöhen die Major Version.

Ich nenne dieses System „Semantic Versioning“. Versionsnummern, die nach diesem Schema gewählt und erhöht werden, geben direkten Aufschluss über den entsprechenden Code und was sich von einer zur anderen Version verändert hat.

Semantic-Versioning-Spezifikation (SemVer)

Die Terme „MUST“, „MUST NOT“, „REQUIRED“, „SHALL“, „SHALL NOT“, „SHOULD“, „SHOULD NOT“, „RECOMMENDED“, „MAY“ und „OPTIONAL“ in diesem Dokument sind, wie in RFC 2119 beschrieben, zu interpretieren.


  
    Software, die Semantic Versioning nutzt, muss (MUST) eine öffentliche API definieren. Die API kann entweder im Code selbst deklariert werden oder in einer Dokumentation enthalten sein. Wie auch immer sie umgesetzt wird, es ist wichtig, dass sie präzise und ausführlich ist.
  
  
    Eine gewöhnliche Versionsnummer muss (MUST) dem Format X.Y.Z entsprechen, wobei X, Y und Z Ganzzahlen größer oder gleich Null sind und eine Zahl größer als Null keine führenden Nullen enthalten darf. X ist die Major-Version, Y ist die Minor-Version und Z ist die Patch-Version. Jedes Element muss (MUST) auf numerische Art und Weise erhöht werden. Zum Beispiel: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Sobald eine Version eines Projektes veröffentlicht wurde, darf (MUST NOT) der Inhalt dieser Version nicht mehr verändert werden. Eine Änderung am Inhalt muss (MUST) als eine neue Version veröffentlicht werden.
  
  
    Versionsnummern mit einer Major Version von 0 (0.y.z) sind für die initiale Entwicklungsphase gedacht. Änderungen können in jeder denkbaren Form und zu jeder Zeit auftreten. Die öffentliche API sollte nicht als stable betrachtet werden.
  
  
    Die Version 1.0.0 definiert die öffentliche API. Ab dieser Veröffentlichung hängt die Art und Weise, wie die Versionsnummer erhöht und verändert wird, von der öffentlichen API und den Änderungen, die an ihr vollzogen werden, ab.
  
  
    Die Patch-Version Z (x.y.Z | x > 0) muss (MUST) erhöht werden, wenn ausschließlich API-kompatible Bugfixes eingeführt werden. Ein Bugfix ist als eine interne Änderung, die ein fehlerhaftes Verhalten korrigiert, definiert.
  
  
    Die Minor-Version Y (x.Y.z | x > 0) muss (MUST) erhöht werden, wenn neue Funktionalitäten, die kompatibel zur bisherigen API sind, veröffentlicht werden. Sie muss (MUST) außerdem erhöht werden, wenn eine Funktion der öffentlichen API als deprecated markiert wird. Wenn umfangreiche Änderungen an internem Code eingeführt werden, darf (MAY) die Minor-Version ebenfalls erhöht werden. Wenn diese Versionsnummer erhöht wird, muss (MUST) die Patch-Version auf Null zurückgesetzt werden.
  
  
    Die Major-Version X (X.y.z | X > 0) muss (MUST) immer dann erhöht werden, wenn API-inkompatible Änderungen in die öffentlichen API eingeführt werden. Die Änderungen dürfen (MAY) auch Änderungen umfassen, die ansonsten die Minor-Version oder die Patch-Version erhöht hätten. Wenn diese Versionsnummer erhöht wird, muss (MUST) sowohl die Minor-Version als auch die Patch-Version auf Null zurückgesetzt werden.
  
  
    Eine Vorveröffentlichung kann (MAY) gekennzeichnet werden, indem ein Bindestrich, gefolgt von dem Vorveröffentlichungs-Bezeichner, dessen Elemente durch Punkte voneinander getrennt werden, an die Patch-Version angehängt wird. Die Elemente des Bezeichners dürfen (MUST) nur aus alphanumerischen ASCII-Zeichen und dem Bindestrich ([0-9A-Za-z-]) bestehen. Sie dürfen (MUST NOT) außerdem nicht leer sein. Wenn ein Element ausschließlich aus Ziffern besteht, darf (MUST NOT) es keine führenden Nullen enthalten. Eine Vorveröffentlichungs-Version hat einen niedrigeren Rang als die entsprechende reguläre Version. Ein Vorveröffentlichungs-Bezeichner kennzeichnet, dass die Version als unstable zu betrachten ist und dass sie unter Umständen nicht den Kompatibilitätsanforderungen, die für die entsprechende reguläre Version bestimmt wurden, entspricht. Beispiele: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Build-Metadaten können (MAY) ausgezeichnet werden, indem ein Plus-Symbol, gefolgt von den Metadaten, deren Elemente durch Punkte voneinander getrennt werden, an die Patch-Version oder den Vorveröffentlichungs-Bezeichner angehängt wird. Die Elemente der Metadaten dürfen (MUST) nur aus alphanumerischen ASCII-Zeichen und dem Bindestrich ([0-9A-Za-z-]) bestehen. Sie dürfen (MUST NOT) außerdem nicht leer sein. Die Build-Metadaten haben keinerlei Einfluss auf den Rang einer Version, sodass zwei Versionen, deren Versionsnummern sich nur in den Build-Metadaten unterscheiden, denselben Rang einnehmen. Beispiele: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    Der Rang einer Version bestimmt, welche Versionsnummer einer anderen übergeordnet ist, wenn diese bei einer Sortierung miteinander verglichen werden. Der Rang wird (MUST) aus der Major-, Minor- und Patch-Version sowie dem Vorveröffentlichungs-Bezeichner berechnet (die Build-Metadaten haben keinerlei Einfluss auf den Rang einer Version). Er wird bestimmt, indem der erste Unterschied zwischen den oben aufgeführten Elementen ermittelt wird. Dabei wird von links nach rechts, in der oben genannten Reihenfolge vorgegangen. Die Major-, Minor- und Patch-Versionen werden numerisch miteinander verglichen. Beispiel: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Beim Vergleich von zwei Versionsnummern, deren Major-, Minor- und Patch-Versionen gleich sind, nimmt eine Vorveröffentlichung einen niedrigeren Rang als die reguläre Version ein. Beispiel: 1.0.0-alpha < 1.0.0. Sind beide dieser Versionen Vorveröffentlichungen, wird (MUST) der Rang ermittelt, indem jedes Element eines Vorveröffentlichungs-Bezeichners (durch Punkte voneinander getrennt) mit dem der anderen Version verglichen wird, bis ein Unterschied festgestellt wird. Auch hierbei wird von links nach rechts vorgegangen. Elemente, die ausschließlich aus Ziffern bestehen, werden numerisch miteinander verglichen. Der Vergleich aller anderen Elemente erfolgt auf Basis der ASCII-Stellenwerte ihrer Zeichen. Numerische Elemente haben immer einen niedrigeren Rang als solche, die auch andere Zeichen enthalten. Falls alle Elemente identisch sind, nimmt der Bezeichner mit den meisten Elementen den höheren Rang ein. Beispiel: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Backus–Naur Form Grammatik für valide SemVer Versionen
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


Weshalb sollte man Semantic Versioning nutzen?

Dieses System ist keine neue oder revolutionäre Idee. Tatsächlich hast du wahrscheinlich bereits ein ähnliches System genutzt. Das Problem ist, dass „ähnlich“ nicht ausreichend ist. Ohne Einhaltung irgendeiner Art von offizieller Spezifikation, sind Versionsnummern nicht besonders hilfreich beim Verwalten von Abhängigkeiten. Durch das Benennen und Aufstellen von Regeln für die am Anfang dieses Dokuments angesprochenen Ideen, wird es einfach, Nutzer der Software über die Art und den Umfang der Änderungen zu informieren. Sobald diese Informationen ersichtlich sind, können endlich flexible (aber nicht zu flexible) Abhängigkeitsangaben gemacht werden.

Wie Semantic Versioning die Dependency Hell ein Problem der Vergangenheit werden lassen kann, wird hier an einem einfachen Beispiel veranschaulicht. Geh von einer Library namens „Firetruck“ aus. Sie ist abhängig von einem Semantically versioned Paket namens „Ladder“. Zum Zeitpunkt der Erstellung von Firetruck befindet sich Ladder in Version 3.1.0. Da Firetruck eine Funktion von Ladder verwendet, die erst ab Version 3.1.0 verfügbar ist, kann die Abhängigkeit als größer oder gleich 3.1.0, aber kleiner als 4.0.0 definiert werden. Wenn also jetzt Version 3.1.1 oder 3.2.0 von Ladder veröffentlicht wird, kann diese einfach im Package-Management-System freigeschaltet werden, mit der Gewissheit, dass sie mit der abhängigen Software (Firetruck) kompatibel ist.

Als ein verantwortungsbewusster Programmierer will man natürlich prüfen, ob die aktualisierten Pakete wie beschrieben funktionieren. Die richtige Welt ist ein chaotischer Ort; es gibt nichts, was wir tun können, um dies sicherstellen, aber sei wachsam! Was wir tun können, ist, Semantic Versioning zu nutzen, um auf eine angemessen einfache Art und Weise Pakete zu aktualisieren, ohne auch deren abhängige Pakete aktualisieren zu müssen und damit Zeit und Aufwand zu sparen.

Wenn das alles wünschenswert klingt und von den Vorteilen profitiert werden soll, muss nichts Weiteres getan werden, als anzugeben, dass ein Projekt Semantic Versioning verwendet und anschließend den oben genannten Regeln Folge zu leisten. Verweise in der README auf diese Webseite, sodass auch andere über die Regeln Bescheid wissen und von ihnen profitieren können.

FAQ

Wie soll ich bei der Versionierung in der initialen Entwicklungsphase (0.y.z) verfahren?

Das Einfachste ist, die Versionierung bei 0.1.0 zu beginnen und dann bei jeder folgenden Veröffentlichung die Minor-Version zu erhöhen.

Woher weiß ich, wann es Zeit ist, Version 1.0.0 zu veröffentlichen?

Wenn die Software schon in der Produktion verwendet wird, sollte sie bereits in Version 1.0.0 vorliegen. Falls eine stable API existiert, auf die sich Nutzer bereits verlassen, sollte es ebenfalls die Version 1.0.0 sein. Auch wenn Kompatibilität zu vorherigen Versionen bereits eine wichtige Rolle spielt, ist Version 1.0.0 angebracht.

Hält das nicht von Rapid Development und Fast Iteration ab?

In Versionen mit einer Major-Version von Null dreht sich alles um Rapid Development. Wenn sich die API tagtäglich verändert, sollte sich das Projekt entweder noch in Version 0.y.z befinden oder es sollte auf einem separaten Entwicklungs-Branch an der nächsten Major-Veröffentlichung gearbeitet werden.

Wenn schon die kleinsten API-inkompatiblen Änderungen an der öffentlichen API eine Anhebung der Major-Version erfordern, wird eine Version wie 42.0.0 nicht sehr schnell erreicht werden?

Das ist eine Frage von verantwortungsbewusster Entwicklung und Weitsicht. API-inkompatible Änderungen sollten nicht leichtfertig eingeführt werden, da das Aktualisieren des Pakets in Software von Dritten, die eine große Menge an API-spezifischem Code enthalten, mit drastischem Aufwand verbunden sein kann. Die Tatsache, dass die Major-Version beim Einführen von API-inkompatiblen Änderungen angehoben werden muss, drängt einen dazu, die Auswirkungen der Änderungen noch einmal zu überdenken und das Kosten-Nutzen-Verhältnis abzuwägen.

Die gesamte öffentliche API zu dokumentieren, ist viel zu viel Arbeit!

Es ist die Aufgabe eines professionellen Entwicklers, Software, die für die Verwendung durch andere bestimmt ist, ordentlich zu dokumentieren. Das Verwalten der Komplexität einer Software ist ein enorm wichtiger Teil, wenn es darum geht, ein Projekt erfolgreich zu betreiben, was schwer ist, wenn niemand weiß, wie eine Software zu verwenden ist oder welche Funktionen sie anbietet. Langfristig gesehen, werden Semantic Versioning und eine gut definierte öffentliche API ein System sicherstellen, in dem alles reibungslos ineinandergreift.

Was soll ich tun, wenn ich versehentlich eine API-inkompatible Änderung in einer Minor-Version veröffentlicht habe?

Sobald du feststellst, dass du die Semantic Versioning Spezifikation nicht befolgt hast, korrigiere den Fehler, indem du eine neue Minor-Version veröffentlichst, die das Problem behebt und die Kompatibilität zur API wiederherstellt. Selbst unter diesen Umständen ist es nicht erlaubt, eine bereits veröffentlichte Version zu verändern. Falls es angemessen ist, dokumentiere, welche Version problematisch ist, sodass die Nutzer über diese Version Bescheid wissen.

Was soll ich tun, wenn ich die Abhängigkeitsangaben meines Projekts ändere, aber keine Änderungen an der öffentlichen API einführe?

Dies würde als kompatibel angesehen werden, da es die öffentliche API nicht beeinflusst. Eine Software, die ausdrücklich dieselben Abhängigkeiten wie das Paket hat, sollte seine eigenen Abhängigkeitsangaben haben, und der Autor der Software wird mögliche Konflikte selbstständig feststellen. Ob nun die Minor-Version oder aber die Patch-Version erhöht wird, hängt davon ab, ob die Abhängigkeiten aktualisiert wurden, um einen Bug zu beseitigen oder um eine neue Funktionalität zu ergänzen. Normalerweise geschieht dies aus letzterem Grund, bei dem natürlich die Minor-Version angehoben werden müsste.

Was soll ich tun, wenn ich die öffentliche API versehentlich derartig verändert habe, dass sie nicht mit der Änderung an der Versionsnummer harmoniert (das heißt, der Code zerstört fälschlicherweise in einer Patch-Version die API-Konformität)?

Entscheide nach deinem eigenen Ermessen. Wenn du eine große Nutzergemeinde hast, die von der aktuellen API stark abhängt, dann wäre es wahrscheinlich das Beste, die Veröffentlichung als eine Major-Version zu publizieren, auch wenn die Änderungen eigentlich nur einen Patch darstellen sollten. Denk dran, bei Semantic Versioning dreht sich alles darum, die Art und den Umfang der Änderungen am Code durch die Änderungen an der Versionsnummer zu vermitteln.

Wie soll ich mit deprecated Funktionen verfahren?

Funktionalitäten als deprecated zu markieren, ist ein gewöhnlicher Teil von Softwareentwicklung und ist häufig notwendig, um mit der Entwicklung voranzuschreiten. Wenn etwas in der öffentlichen API als deprecated markiert wird, sollte erstens, die Dokumentation bezüglich der Änderungen angepasst werden, und zweitens, eine neue Minor-Version mit der deprecated Funktionalität veröffentlicht werden. Bevor die Funktionalität in einer Major-Veröffentlichung vollständig entfernt wird, sollte mindestens eine Minor-Version, die die Deprecation enthält, veröffentlicht werden, sodass Nutzer einfach zur neuen API migrieren können.

Ist die Länge eines SemVer-Version-Strings limitiert?

Nein, aber sei vernünftig. Zum Beispiel wäre ein 255 Zeichen langer Version-String wahrscheinlich ein wenig übertrieben. Außerdem könnten bestimmte Systeme ihre eigenen Limits definieren.

Über

Die Semantic-Versioning-Spezifikation wurde von Tom Preston-Werner, Erfinder von Gravatars und Mitbegründer von GitHub, erstellt.

Für Feedback, eröffne bitte ein Issue auf GitHub.

Lizenz

Creative Commons ― CC BY 3.0\nSemantic Versioning 2.0.0\nAuf Grundlage einer Versionsnummer von MAJOR.MINOR.PATCH werden die einzelnen Elemente folgendermaßen erhöht:\nMAJOR wird erhöht, wenn API-inkompatible Änderungen veröffentlicht werden,\nMINOR wird erhöht, wenn neue Funktionalitäten, die kompatibel zur bisherigen API sind, veröffentlicht werden, und\nPATCH wird erhöht, wenn die Änderungen ausschließlich API-kompatible Bugfixes umfassen.\nAußerdem sind Bezeichner für Vorveröffentlichungen und Build-Metadaten als Erweiterungen zum MAJOR.MINOR.PATCH-Format verfügbar.\nIn der Welt der Softwareentwicklung existiert ein grauenhafter Ort namens „Dependency Hell“. Um so größer ein Projekt wird und je mehr Pakete in die Software integriert werden, desto wahrscheinlicher ist es, dass dieser fürchterliche Ort eines Tages betreten wird.\nIn Projekten mit vielen Abhängigkeiten kann das Aktualisieren abhängiger Pakete schnell zum Albtraum werden. Sind die Abhängigkeitsspezifikationen des Pakets zu strikt, besteht die Gefahr des „Version Lock“ (die Unfähigkeit, ein Paket zu aktualisieren, ohne, dass alle abhängigen Pakete dieses Pakets ebenfalls aktualisiert werden müssen). Wenn die Abhängigkeiten des Pakets allerdings zu lasch definiert sind, wird sehr wahrscheinlich ein Problem, das sich „Version Promiscuity“ nennt (das Paket gibt vor, mit mehr zukünftigen Versionen seiner abhängigen Pakete kompatibel zu sein, als angemessen ist), eintreten. Dependency Hell bezeichnet die Situation, in der entweder Version Lock oder Version Promiscuity, oder beides den Entwicklungsprozess des Projekts beeinträchtigt.\nAls Lösung für dieses Problem schlage ich ein einfaches Regelwerk vor, das definiert, wie Versionsnummern gewählt und erhöht werden. Diese Regeln basieren auf bereits existierenden und weit verbreiteten Verfahren, die sowohl bei der Entwicklung von Closed- als auch von Open-Source-Software verwendet werden, aber beschränken sich nicht zwingend auf diese. Um dieses System nutzen zu können, muss zuerst eine öffentliche API definiert werden. Diese kann entweder in Form einer Dokumentation existieren oder durch den Code selbst erzwungen werden. Egal auf welche Art und Weise die API umgesetzt wird, es ist wichtig, dass sie übersichtlich und präzise ist. Sobald die öffentliche API erstellt wurde, werden Änderungen an dieser durch bestimmte Veränderungen an der Versionsnummer vermittelt. Nimm ein Versionsnummernformat von X.Y.Z (Major.Minor.Patch) an. Bei Einführung von Bugfixes, die die öffentliche API nicht beeinflussen, wird die Patch-Version erhöht, API-kompatible Ergänzungen oder Änderungen erhöhen die Minor Versionsnummer, und Änderungen, die nicht kompatibel zur aktuellen öffentlichen API sind, erhöhen die Major Version.\nIch nenne dieses System „Semantic Versioning“. Versionsnummern, die nach diesem Schema gewählt und erhöht werden, geben direkten Aufschluss über den entsprechenden Code und was sich von einer zur anderen Version verändert hat.\nSemantic-Versioning-Spezifikation (SemVer)\nDie Terme „MUST“, „MUST NOT“, „REQUIRED“, „SHALL“, „SHALL NOT“, „SHOULD“, „SHOULD NOT“, „RECOMMENDED“, „MAY“ und „OPTIONAL“ in diesem Dokument sind, wie in RFC 2119 beschrieben, zu interpretieren.\nSoftware, die Semantic Versioning nutzt, muss (MUST) eine öffentliche API definieren. Die API kann entweder im Code selbst deklariert werden oder in einer Dokumentation enthalten sein. Wie auch immer sie umgesetzt wird, es ist wichtig, dass sie präzise und ausführlich ist.\nSoftware, die Semantic Versioning nutzt, muss (MUST) eine öffentliche API definieren. Die API kann entweder im Code selbst deklariert werden oder in einer Dokumentation enthalten sein. Wie auch immer sie umgesetzt wird, es ist wichtig, dass sie präzise und ausführlich ist.\nEine gewöhnliche Versionsnummer muss (MUST) dem Format X.Y.Z entsprechen, wobei X, Y und Z Ganzzahlen größer oder gleich Null sind und eine Zahl größer als Null keine führenden Nullen enthalten darf. X ist die Major-Version, Y ist die Minor-Version und Z ist die Patch-Version. Jedes Element muss (MUST) auf numerische Art und Weise erhöht werden. Zum Beispiel: 1.9.0 -> 1.10.0 -> 1.11.0.\nEine gewöhnliche Versionsnummer muss (MUST) dem Format X.Y.Z entsprechen, wobei X, Y und Z Ganzzahlen größer oder gleich Null sind und eine Zahl größer als Null keine führenden Nullen enthalten darf. X ist die Major-Version, Y ist die Minor-Version und Z ist die Patch-Version. Jedes Element muss (MUST) auf numerische Art und Weise erhöht werden. Zum Beispiel: 1.9.0 -> 1.10.0 -> 1.11.0.\nSobald eine Version eines Projektes veröffentlicht wurde, darf (MUST NOT) der Inhalt dieser Version nicht mehr verändert werden. Eine Änderung am Inhalt muss (MUST) als eine neue Version veröffentlicht werden.\nSobald eine Version eines Projektes veröffentlicht wurde, darf (MUST NOT) der Inhalt dieser Version nicht mehr verändert werden. Eine Änderung am Inhalt muss (MUST) als eine neue Version veröffentlicht werden.\nVersionsnummern mit einer Major Version von 0 (0.y.z) sind für die initiale Entwicklungsphase gedacht. Änderungen können in jeder denkbaren Form und zu jeder Zeit auftreten. Die öffentliche API sollte nicht als stable betrachtet werden.\nVersionsnummern mit einer Major Version von 0 (0.y.z) sind für die initiale Entwicklungsphase gedacht. Änderungen können in jeder denkbaren Form und zu jeder Zeit auftreten. Die öffentliche API sollte nicht als stable betrachtet werden.\nDie Version 1.0.0 definiert die öffentliche API. Ab dieser Veröffentlichung hängt die Art und Weise, wie die Versionsnummer erhöht und verändert wird, von der öffentlichen API und den Änderungen, die an ihr vollzogen werden, ab.\nDie Version 1.0.0 definiert die öffentliche API. Ab dieser Veröffentlichung hängt die Art und Weise, wie die Versionsnummer erhöht und verändert wird, von der öffentlichen API und den Änderungen, die an ihr vollzogen werden, ab.\nDie Patch-Version Z (x.y.Z | x > 0) muss (MUST) erhöht werden, wenn ausschließlich API-kompatible Bugfixes eingeführt werden. Ein Bugfix ist als eine interne Änderung, die ein fehlerhaftes Verhalten korrigiert, definiert.\nDie Patch-Version Z (x.y.Z | x > 0) muss (MUST) erhöht werden, wenn ausschließlich API-kompatible Bugfixes eingeführt werden. Ein Bugfix ist als eine interne Änderung, die ein fehlerhaftes Verhalten korrigiert, definiert.\nDie Minor-Version Y (x.Y.z | x > 0) muss (MUST) erhöht werden, wenn neue Funktionalitäten, die kompatibel zur bisherigen API sind, veröffentlicht werden. Sie muss (MUST) außerdem erhöht werden, wenn eine Funktion der öffentlichen API als deprecated markiert wird. Wenn umfangreiche Änderungen an internem Code eingeführt werden, darf (MAY) die Minor-Version ebenfalls erhöht werden. Wenn diese Versionsnummer erhöht wird, muss (MUST) die Patch-Version auf Null zurückgesetzt werden.\nDie Minor-Version Y (x.Y.z | x > 0) muss (MUST) erhöht werden, wenn neue Funktionalitäten, die kompatibel zur bisherigen API sind, veröffentlicht werden. Sie muss (MUST) außerdem erhöht werden, wenn eine Funktion der öffentlichen API als deprecated markiert wird. Wenn umfangreiche Änderungen an internem Code eingeführt werden, darf (MAY) die Minor-Version ebenfalls erhöht werden. Wenn diese Versionsnummer erhöht wird, muss (MUST) die Patch-Version auf Null zurückgesetzt werden.\nDie Major-Version X (X.y.z | X > 0) muss (MUST) immer dann erhöht werden, wenn API-inkompatible Änderungen in die öffentlichen API eingeführt werden. Die Änderungen dürfen (MAY) auch Änderungen umfassen, die ansonsten die Minor-Version oder die Patch-Version erhöht hätten. Wenn diese Versionsnummer erhöht wird, muss (MUST) sowohl die Minor-Version als auch die Patch-Version auf Null zurückgesetzt werden.\nDie Major-Version X (X.y.z | X > 0) muss (MUST) immer dann erhöht werden, wenn API-inkompatible Änderungen in die öffentlichen API eingeführt werden. Die Änderungen dürfen (MAY) auch Änderungen umfassen, die ansonsten die Minor-Version oder die Patch-Version erhöht hätten. Wenn diese Versionsnummer erhöht wird, muss (MUST) sowohl die Minor-Version als auch die Patch-Version auf Null zurückgesetzt werden.\nEine Vorveröffentlichung kann (MAY) gekennzeichnet werden, indem ein Bindestrich, gefolgt von dem Vorveröffentlichungs-Bezeichner, dessen Elemente durch Punkte voneinander getrennt werden, an die Patch-Version angehängt wird. Die Elemente des Bezeichners dürfen (MUST) nur aus alphanumerischen ASCII-Zeichen und dem Bindestrich ([0-9A-Za-z-]) bestehen. Sie dürfen (MUST NOT) außerdem nicht leer sein. Wenn ein Element ausschließlich aus Ziffern besteht, darf (MUST NOT) es keine führenden Nullen enthalten. Eine Vorveröffentlichungs-Version hat einen niedrigeren Rang als die entsprechende reguläre Version. Ein Vorveröffentlichungs-Bezeichner kennzeichnet, dass die Version als unstable zu betrachten ist und dass sie unter Umständen nicht den Kompatibilitätsanforderungen, die für die entsprechende reguläre Version bestimmt wurden, entspricht. Beispiele: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nEine Vorveröffentlichung kann (MAY) gekennzeichnet werden, indem ein Bindestrich, gefolgt von dem Vorveröffentlichungs-Bezeichner, dessen Elemente durch Punkte voneinander getrennt werden, an die Patch-Version angehängt wird. Die Elemente des Bezeichners dürfen (MUST) nur aus alphanumerischen ASCII-Zeichen und dem Bindestrich ([0-9A-Za-z-]) bestehen. Sie dürfen (MUST NOT) außerdem nicht leer sein. Wenn ein Element ausschließlich aus Ziffern besteht, darf (MUST NOT) es keine führenden Nullen enthalten. Eine Vorveröffentlichungs-Version hat einen niedrigeren Rang als die entsprechende reguläre Version. Ein Vorveröffentlichungs-Bezeichner kennzeichnet, dass die Version als unstable zu betrachten ist und dass sie unter Umständen nicht den Kompatibilitätsanforderungen, die für die entsprechende reguläre Version bestimmt wurden, entspricht. Beispiele: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nBuild-Metadaten können (MAY) ausgezeichnet werden, indem ein Plus-Symbol, gefolgt von den Metadaten, deren Elemente durch Punkte voneinander getrennt werden, an die Patch-Version oder den Vorveröffentlichungs-Bezeichner angehängt wird. Die Elemente der Metadaten dürfen (MUST) nur aus alphanumerischen ASCII-Zeichen und dem Bindestrich ([0-9A-Za-z-]) bestehen. Sie dürfen (MUST NOT) außerdem nicht leer sein. Die Build-Metadaten haben keinerlei Einfluss auf den Rang einer Version, sodass zwei Versionen, deren Versionsnummern sich nur in den Build-Metadaten unterscheiden, denselben Rang einnehmen. Beispiele: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nBuild-Metadaten können (MAY) ausgezeichnet werden, indem ein Plus-Symbol, gefolgt von den Metadaten, deren Elemente durch Punkte voneinander getrennt werden, an die Patch-Version oder den Vorveröffentlichungs-Bezeichner angehängt wird. Die Elemente der Metadaten dürfen (MUST) nur aus alphanumerischen ASCII-Zeichen und dem Bindestrich ([0-9A-Za-z-]) bestehen. Sie dürfen (MUST NOT) außerdem nicht leer sein. Die Build-Metadaten haben keinerlei Einfluss auf den Rang einer Version, sodass zwei Versionen, deren Versionsnummern sich nur in den Build-Metadaten unterscheiden, denselben Rang einnehmen. Beispiele: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nDer Rang einer Version bestimmt, welche Versionsnummer einer anderen übergeordnet ist, wenn diese bei einer Sortierung miteinander verglichen werden. Der Rang wird (MUST) aus der Major-, Minor- und Patch-Version sowie dem Vorveröffentlichungs-Bezeichner berechnet (die Build-Metadaten haben keinerlei Einfluss auf den Rang einer Version). Er wird bestimmt, indem der erste Unterschied zwischen den oben aufgeführten Elementen ermittelt wird. Dabei wird von links nach rechts, in der oben genannten Reihenfolge vorgegangen. Die Major-, Minor- und Patch-Versionen werden numerisch miteinander verglichen. Beispiel: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Beim Vergleich von zwei Versionsnummern, deren Major-, Minor- und Patch-Versionen gleich sind, nimmt eine Vorveröffentlichung einen niedrigeren Rang als die reguläre Version ein. Beispiel: 1.0.0-alpha < 1.0.0. Sind beide dieser Versionen Vorveröffentlichungen, wird (MUST) der Rang ermittelt, indem jedes Element eines Vorveröffentlichungs-Bezeichners (durch Punkte voneinander getrennt) mit dem der anderen Version verglichen wird, bis ein Unterschied festgestellt wird. Auch hierbei wird von links nach rechts vorgegangen. Elemente, die ausschließlich aus Ziffern bestehen, werden numerisch miteinander verglichen. Der Vergleich aller anderen Elemente erfolgt auf Basis der ASCII-Stellenwerte ihrer Zeichen. Numerische Elemente haben immer einen niedrigeren Rang als solche, die auch andere Zeichen enthalten. Falls alle Elemente identisch sind, nimmt der Bezeichner mit den meisten Elementen den höheren Rang ein. Beispiel: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nDer Rang einer Version bestimmt, welche Versionsnummer einer anderen übergeordnet ist, wenn diese bei einer Sortierung miteinander verglichen werden. Der Rang wird (MUST) aus der Major-, Minor- und Patch-Version sowie dem Vorveröffentlichungs-Bezeichner berechnet (die Build-Metadaten haben keinerlei Einfluss auf den Rang einer Version). Er wird bestimmt, indem der erste Unterschied zwischen den oben aufgeführten Elementen ermittelt wird. Dabei wird von links nach rechts, in der oben genannten Reihenfolge vorgegangen. Die Major-, Minor- und Patch-Versionen werden numerisch miteinander verglichen. Beispiel: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Beim Vergleich von zwei Versionsnummern, deren Major-, Minor- und Patch-Versionen gleich sind, nimmt eine Vorveröffentlichung einen niedrigeren Rang als die reguläre Version ein. Beispiel: 1.0.0-alpha < 1.0.0. Sind beide dieser Versionen Vorveröffentlichungen, wird (MUST) der Rang ermittelt, indem jedes Element eines Vorveröffentlichungs-Bezeichners (durch Punkte voneinander getrennt) mit dem der anderen Version verglichen wird, bis ein Unterschied festgestellt wird. Auch hierbei wird von links nach rechts vorgegangen. Elemente, die ausschließlich aus Ziffern bestehen, werden numerisch miteinander verglichen. Der Vergleich aller anderen Elemente erfolgt auf Basis der ASCII-Stellenwerte ihrer Zeichen. Numerische Elemente haben immer einen niedrigeren Rang als solche, die auch andere Zeichen enthalten. Falls alle Elemente identisch sind, nimmt der Bezeichner mit den meisten Elementen den höheren Rang ein. Beispiel: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nBackus–Naur Form Grammatik für valide SemVer Versionen\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nWeshalb sollte man Semantic Versioning nutzen?\nDieses System ist keine neue oder revolutionäre Idee. Tatsächlich hast du wahrscheinlich bereits ein ähnliches System genutzt. Das Problem ist, dass „ähnlich“ nicht ausreichend ist. Ohne Einhaltung irgendeiner Art von offizieller Spezifikation, sind Versionsnummern nicht besonders hilfreich beim Verwalten von Abhängigkeiten. Durch das Benennen und Aufstellen von Regeln für die am Anfang dieses Dokuments angesprochenen Ideen, wird es einfach, Nutzer der Software über die Art und den Umfang der Änderungen zu informieren. Sobald diese Informationen ersichtlich sind, können endlich flexible (aber nicht zu flexible) Abhängigkeitsangaben gemacht werden.\nWie Semantic Versioning die Dependency Hell ein Problem der Vergangenheit werden lassen kann, wird hier an einem einfachen Beispiel veranschaulicht. Geh von einer Library namens „Firetruck“ aus. Sie ist abhängig von einem Semantically versioned Paket namens „Ladder“. Zum Zeitpunkt der Erstellung von Firetruck befindet sich Ladder in Version 3.1.0. Da Firetruck eine Funktion von Ladder verwendet, die erst ab Version 3.1.0 verfügbar ist, kann die Abhängigkeit als größer oder gleich 3.1.0, aber kleiner als 4.0.0 definiert werden. Wenn also jetzt Version 3.1.1 oder 3.2.0 von Ladder veröffentlicht wird, kann diese einfach im Package-Management-System freigeschaltet werden, mit der Gewissheit, dass sie mit der abhängigen Software (Firetruck) kompatibel ist.\nAls ein verantwortungsbewusster Programmierer will man natürlich prüfen, ob die aktualisierten Pakete wie beschrieben funktionieren. Die richtige Welt ist ein chaotischer Ort; es gibt nichts, was wir tun können, um dies sicherstellen, aber sei wachsam! Was wir tun können, ist, Semantic Versioning zu nutzen, um auf eine angemessen einfache Art und Weise Pakete zu aktualisieren, ohne auch deren abhängige Pakete aktualisieren zu müssen und damit Zeit und Aufwand zu sparen.\nWenn das alles wünschenswert klingt und von den Vorteilen profitiert werden soll, muss nichts Weiteres getan werden, als anzugeben, dass ein Projekt Semantic Versioning verwendet und anschließend den oben genannten Regeln Folge zu leisten. Verweise in der README auf diese Webseite, sodass auch andere über die Regeln Bescheid wissen und von ihnen profitieren können.\nWie soll ich bei der Versionierung in der initialen Entwicklungsphase (0.y.z) verfahren?\nDas Einfachste ist, die Versionierung bei 0.1.0 zu beginnen und dann bei jeder folgenden Veröffentlichung die Minor-Version zu erhöhen.\nWoher weiß ich, wann es Zeit ist, Version 1.0.0 zu veröffentlichen?\nWenn die Software schon in der Produktion verwendet wird, sollte sie bereits in Version 1.0.0 vorliegen. Falls eine stable API existiert, auf die sich Nutzer bereits verlassen, sollte es ebenfalls die Version 1.0.0 sein. Auch wenn Kompatibilität zu vorherigen Versionen bereits eine wichtige Rolle spielt, ist Version 1.0.0 angebracht.\nHält das nicht von Rapid Development und Fast Iteration ab?\nIn Versionen mit einer Major-Version von Null dreht sich alles um Rapid Development. Wenn sich die API tagtäglich verändert, sollte sich das Projekt entweder noch in Version 0.y.z befinden oder es sollte auf einem separaten Entwicklungs-Branch an der nächsten Major-Veröffentlichung gearbeitet werden.\nWenn schon die kleinsten API-inkompatiblen Änderungen an der öffentlichen API eine Anhebung der Major-Version erfordern, wird eine Version wie 42.0.0 nicht sehr schnell erreicht werden?\nDas ist eine Frage von verantwortungsbewusster Entwicklung und Weitsicht. API-inkompatible Änderungen sollten nicht leichtfertig eingeführt werden, da das Aktualisieren des Pakets in Software von Dritten, die eine große Menge an API-spezifischem Code enthalten, mit drastischem Aufwand verbunden sein kann. Die Tatsache, dass die Major-Version beim Einführen von API-inkompatiblen Änderungen angehoben werden muss, drängt einen dazu, die Auswirkungen der Änderungen noch einmal zu überdenken und das Kosten-Nutzen-Verhältnis abzuwägen.\nDie gesamte öffentliche API zu dokumentieren, ist viel zu viel Arbeit!\nEs ist die Aufgabe eines professionellen Entwicklers, Software, die für die Verwendung durch andere bestimmt ist, ordentlich zu dokumentieren. Das Verwalten der Komplexität einer Software ist ein enorm wichtiger Teil, wenn es darum geht, ein Projekt erfolgreich zu betreiben, was schwer ist, wenn niemand weiß, wie eine Software zu verwenden ist oder welche Funktionen sie anbietet. Langfristig gesehen, werden Semantic Versioning und eine gut definierte öffentliche API ein System sicherstellen, in dem alles reibungslos ineinandergreift.\nWas soll ich tun, wenn ich versehentlich eine API-inkompatible Änderung in einer Minor-Version veröffentlicht habe?\nSobald du feststellst, dass du die Semantic Versioning Spezifikation nicht befolgt hast, korrigiere den Fehler, indem du eine neue Minor-Version veröffentlichst, die das Problem behebt und die Kompatibilität zur API wiederherstellt. Selbst unter diesen Umständen ist es nicht erlaubt, eine bereits veröffentlichte Version zu verändern. Falls es angemessen ist, dokumentiere, welche Version problematisch ist, sodass die Nutzer über diese Version Bescheid wissen.\nWas soll ich tun, wenn ich die Abhängigkeitsangaben meines Projekts ändere, aber keine Änderungen an der öffentlichen API einführe?\nDies würde als kompatibel angesehen werden, da es die öffentliche API nicht beeinflusst. Eine Software, die ausdrücklich dieselben Abhängigkeiten wie das Paket hat, sollte seine eigenen Abhängigkeitsangaben haben, und der Autor der Software wird mögliche Konflikte selbstständig feststellen. Ob nun die Minor-Version oder aber die Patch-Version erhöht wird, hängt davon ab, ob die Abhängigkeiten aktualisiert wurden, um einen Bug zu beseitigen oder um eine neue Funktionalität zu ergänzen. Normalerweise geschieht dies aus letzterem Grund, bei dem natürlich die Minor-Version angehoben werden müsste.\nWas soll ich tun, wenn ich die öffentliche API versehentlich derartig verändert habe, dass sie nicht mit der Änderung an der Versionsnummer harmoniert (das heißt, der Code zerstört fälschlicherweise in einer Patch-Version die API-Konformität)?\nEntscheide nach deinem eigenen Ermessen. Wenn du eine große Nutzergemeinde hast, die von der aktuellen API stark abhängt, dann wäre es wahrscheinlich das Beste, die Veröffentlichung als eine Major-Version zu publizieren, auch wenn die Änderungen eigentlich nur einen Patch darstellen sollten. Denk dran, bei Semantic Versioning dreht sich alles darum, die Art und den Umfang der Änderungen am Code durch die Änderungen an der Versionsnummer zu vermitteln.\nWie soll ich mit deprecated Funktionen verfahren?\nFunktionalitäten als deprecated zu markieren, ist ein gewöhnlicher Teil von Softwareentwicklung und ist häufig notwendig, um mit der Entwicklung voranzuschreiten. Wenn etwas in der öffentlichen API als deprecated markiert wird, sollte erstens, die Dokumentation bezüglich der Änderungen angepasst werden, und zweitens, eine neue Minor-Version mit der deprecated Funktionalität veröffentlicht werden. Bevor die Funktionalität in einer Major-Veröffentlichung vollständig entfernt wird, sollte mindestens eine Minor-Version, die die Deprecation enthält, veröffentlicht werden, sodass Nutzer einfach zur neuen API migrieren können.\nIst die Länge eines SemVer-Version-Strings limitiert?\nNein, aber sei vernünftig. Zum Beispiel wäre ein 255 Zeichen langer Version-String wahrscheinlich ein wenig übertrieben. Außerdem könnten bestimmte Systeme ihre eigenen Limits definieren.\nDie Semantic-Versioning-Spezifikation wurde von Tom Preston-Werner, Erfinder von Gravatars und Mitbegründer von GitHub, erstellt.\nFür Feedback, eröffne bitte ein Issue auf GitHub.\neröffne bitte ein Issue auf GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nΣημασιολογική Δημιουργία Εκδόσεων 2.0.0 (Semantic Versioning)

Περίληψη

Δοθέντος ενός αριθμού έκδοσης ΚΥΡΙΑ.ΔΕΥΤΕΡΕΥΟΥΣΑ.ΔΙΟΡΘΩΣΗ (MAJOR.MINOR.PATCH), αυξήστε την:


  ΚΥΡΙΑ έκδοση, όταν κάνετε ασύμβατες αλλαγές στο API
  ΔΕΥΤΕΡΕΥΟΥΣΑ έκδοση, όταν προσθέτετε λειτουργικότητα με τρόπο συμβατό προς τα πίσω
  ΔΙΟΡΘΩΤΙΚΗ έκδοση, όταν κάνετε επιδιορθώσεις σφαλμάτων με τρόπο συμβατό προς τα πίσω


Πρόσθετες ετικέτες για μεταδεδομένα προ-κυκλοφορίας και χτισίματος, είναι διαθέσιμες ως επεκτάσεις
στη μορφή ΚΥΡΙΑ.ΔΕΥΤΕΡΕΥΟΥΣΑ.ΔΙΟΡΘΩΣΗ.

Εισαγωγή

Στον κόσμο της διαχείρισης λογισμικού υπάρχει ένα διαβόητο μέρος που ονομάζεται 
«κόλαση εξαρτήσεων». Όσο περισσότερο μεγαλώνει το σύστημά σας και όσο περισσότερα
πακέτα ενσωματώνετε στο λογισμικό σας, τόσο πιο πιθανό είναι να βρεθείτε μια μέρα
σε απόγνωση.

Σε συστήματα με πολλές εξαρτήσεις, η κυκλοφορία νέων εκδόσεων πακέτων μπορεί να γίνει 
πολύ γρήγορα ένας εφιάλτης. Αν οι προδιαγραφές της εξάρτησης είναι πολύ αυστηρές, είστε
σε κίνδυνο κλειδώματος έκδοσης (σε αδυναμία αναβάθμισης ενός πακέτου χωρίς να πρέπει να
κυκλοφορήσουν νέες εκδόσεις από κάθε εξαρτώμενο πακέτο). Αν οι εξαρτήσεις ορίζονται πολύ
χαλαρά, αναπόφευκτα θα επηρεαστείτε από την αναμικτικότητα έκδοσης (υποθέτοντας συμβατότητα 
με περισσότερες μελλοντικές εκδόσεις απ’ ότι είναι λογικό). Η κόλαση εξαρτήσεων είναι εκεί
που το κλείδωμα έκδοσης ή/και η αναμικτικότητα έκδοσης, σας αποτρέπουν από το να προωθήσετε
εύκολα και με ασφάλεια το έργο σας.

Ως μια λύση σ’ αυτό το πρόβλημα, προτείνουμε ένα απλό σετ κανόνων και
απαιτήσεων που υπαγορεύουν το πως οι αριθμοί εκδόσεων καθορίζονται και αυξάνονται.
Αυτοί οι κανόνες βασίζονται, αλλά δεν περιορίζονται απαραίτητα, σε προϋπάρχουσες
διαδεδομένες κοινές πρακτικές σε χρήση τόσο σε κλειστό όσο και σε λογισμικό
ανοιχτού κώδικα. Για να λειτουργήσει αυτό το σύστημα, πρώτα πρέπει να δηλώσετε
ένα δημόσιο API. Αυτό μπορεί να αποτελείται από τεκμηρίωση ή να επιβάλλεται από
τον ίδιο τον κώδικα. Όπως και να ‘χει είναι σημαντικό αυτό το API να είναι
ξεκάθαρο και συγκεκριμένο. Μόλις ταυτοποιήσετε το δημόσιο API, κοινοποιείτε τις
αλλαγές σ’ αυτό με συγκεκριμένες αυξήσεις στον αριθμό έκδοσης. Σκεφτείτε μία
έκδοση της μορφής X.Y.Z (Κύρια.Δευτερεύουσα.Διόρθωση). Διορθώσεις σφαλμάτων που
δεν επηρεάζουν το API αυξάνουν την έκδοση διόρθωσης, προσθήκες/αλλαγές στο API
οι οποίες είναι συμβατές προς τα πίσω αυξάνουν τη δευτερεύουσα έκδοση, και 
αλλαγές ασύμβατες με το API αυξάνουν την κύρια έκδοση.

Ονομάζουμε αυτό το σύστημα «Σημασιολογική δημιουργία εκδόσεων».
Με αυτό το σχήμα, οι αριθμοί εκδόσεων και ο τρόπος που αλλάζουν, εκφράζουν
κάποιο νόημα σχετικά με τον υποκείμενο κώδικα και το τι έχει τροποποιηθεί
από τη μία έκδοση στην επόμενη.

Προδιαγραφή της Σημασιολογικής Δημιουργίας Εκδόσεων (SemVer)

Οι λέξεις κλειδιά «ΠΡΕΠΕΙ» (MUST), «ΔΕΝ ΠΡΕΠΕΙ» (MUST NOT), «ΑΠΑΙΤΕΙΤΑΙ» (REQUIRED),
«ΠΡΕΠΕΙ» (SHALL), «ΔΕΝ ΠΡΕΠΕΙ» (SHALL NOT), «ΣΥΝΙΣΤΆΤΑΙ» (SHOULD), «ΔΕ ΣΥΝΙΣΤΆΤΑΙ»
(SHOULD NOT), «ΣΥΝΙΣΤΆΤΑΙ» (RECOMMENDED), «ΜΠΟΡΕΙ» (MAY), και «ΠΡΟΑΙΡΕΤΙΚΑ» (OPTIONAL)
σε αυτό το έγγραφο, πρέπει να ερμηνεύονται όπως περιγράφεται στο
RFC 2119.


  
    Λογισμικό που χρησιμοποιεί Σημασιολογική δημιουργία εκδόσεων ΠΡΕΠΕΙ να δηλώνει
ένα δημόσιο API. Αυτό το API μπορεί να δηλωθεί στον ίδιο τον κώδικα του ή να υπάρχει
αποκλειστικά στην τεκμηρίωση. Όπως και αν γίνει, ΣΥΝΙΣΤΆΤΑΙ να είναι ακριβές και
εμπεριστατωμένο.
  
  
    Ένας φυσιολογικός αριθμός έκδοσης ΠΡΕΠΕΙ να έχει τη μορφή X.Y.Z όπου X, Y, και Z
είναι μη-αρνητικοί ακέραιοι, που ΔΕΝ ΠΡΕΠΕΙ να περιέχουν προπορευόμενα μηδενικά.
Το Χ είναι η κύρια έκδοση, το Υ είναι η δευτερεύουσα έκδοση, και το Ζ είναι η
έκδοση διόρθωσης. Κάθε στοιχείο ΠΡΕΠΕΙ να αυξάνεται αριθμητικά.
Για παράδειγμα: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Μόλις ένα πακέτο με έκδοση κυκλοφορήσει, τα περιεχόμενα αυτής της έκδοσης
ΔΕΝ ΠΡΕΠΕΙ να τροποποιηθούν. Κάθε τροποποίηση ΠΡΕΠΕΙ να κυκλοφορεί με νέα έκδοση.
  
  
    Ο αριθμός κύριας έκδοσης μηδέν (0.y.z) είναι για την αρχική ανάπτυξη.
Οτιδήποτε ΜΠΟΡΕΙ να αλλάξει οποιαδήποτε στιγμή. Το δημόσιο API ΔΕ ΣΥΝΙΣΤΆΤΑΙ
να θεωρείται σταθερό.
  
  
    Η έκδοση 1.0.0 ορίζει το δημόσιο API. Ο τρόπος με τον οποίο ο αριθμός έκδοσης
αυξάνεται μετά από κάθε κυκλοφορία, εξαρτάται από αυτό το δημόσιο API και το
πως αλλάζει.
  
  
    Η Διορθωτική έκδοση Z (x.y.Z | x > 0) ΠΡΕΠΕΙ να αυξάνεται μόνο αν εισάγονται
διορθώσεις σφαλμάτων συμβατές προς τα πίσω. Μία διόρθωση σφάλματος ορίζεται
ως μια εσωτερική αλλαγή που διορθώνει μια εσφαλμένη συμπεριφορά.
  
  
    Η Δευτερεύουσα έκδοση Y (x.Y.z | x > 0) ΠΡΕΠΕΙ να αυξάνεται αν μια νέα,
συμβατή προς τα πίσω, λειτουργικότητα, εισάγεται στο δημόσιο API. ΠΡΕΠΕΙ να
αυξάνεται αν κάποια λειτουργικότητα, οποιουδήποτε δημόσιου API, χαρακτηρίζεται
ως καταργημένη. ΜΠΟΡΕΙ να αυξηθεί αν σημαντική νέα λειτουργικότητα ή βελτιώσεις
εισάγονται μαζί με τον ιδιωτικό κώδικα. ΜΠΟΡΕΙ να περιλαμβάνει αλλαγές επιπέδου
διόρθωσης. Η έκδοση διόρθωσης ΠΡΕΠΕΙ να επανέλθει στο 0 όταν μία δευτερεύουσα
έκδοση αυξάνεται.
  
  
    Η Κύρια έκδοση X (X.y.z | X > 0) ΠΡΕΠΕΙ να αυξάνεται αν εισάγονται στο δημόσιο
API οποιεσδήποτε αλλαγές που είναι ασύμβατες προς τα πίσω. ΜΠΟΡΕΙ επίσης να
συμπεριλαμβάνει δευτερεύουσες και διορθωτικές αλλαγές. Οι διορθωτικές και οι
δευτερεύουσες εκδόσεις ΠΡΕΠΕΙ να επανέρχονται στο 0 όταν η κύρια έκδοση αυξάνεται.
  
  
    Μια έκδοση προ-κυκλοφορίας ΜΠΟΡΕΙ να επισημαίνεται επισυνάπτοντας μία παύλα
και μία σειρά από αναγνωριστικά διαχωρισμένα με τελεία, αμέσως μετά την έκδοση
διόρθωσης. Τα αναγνωριστικά ΠΡΕΠΕΙ να αποτελούνται μόνο από αλφαριθμητικούς
χαρακτήρες ASCII και παύλες [0-9A-Za-z-]. Τα αναγνωριστικά ΔΕΝ ΠΡΕΠΕΙ να είναι
κενά. Τα αριθμητικά αναγνωριστικά ΔΕΝ ΠΡΕΠΕΙ να περιλαμβάνουν προπορευόμενα
μηδενικά. Οι εκδόσεις προ-κυκλοφορίας έχουν χαμηλότερη προτεραιότητα από
τη συσχετιζόμενη φυσιολογική έκδοση. Μία έκδοση προ-κυκλοφορίας υποδεικνύει
ότι η έκδοση είναι ασταθής και μπορεί να μην ικανοποιεί τις επιθυμητές απαιτήσεις
συμβατότητας όπως επισημαίνεται από τη συσχετιζόμενη φυσιολογική έκδοση.
Παραδείγματα: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.--.
  
  
    Μεταδεδομένα χτισίματος ΜΠΟΡΕΙ να επισημαίνονται επισυνάπτοντας το σύμβολο
της πρόσθεσης και μία σειρά από αναγνωριστικά διαχωρισμένα με τελεία, αμέσως
μετά τη διόρθωση ή την έκδοση προ-κυκλοφορίας. Τα αναγνωριστικά ΠΡΕΠΕΙ να
αποτελούνται μόνο από αλφαριθμητικούς χαρακτήρες ASCII και παύλες [0-9A-Za-z-].
Τα αναγνωριστικά ΔΕΝ ΠΡΕΠΕΙ να είναι κενά. Τα μεταδεδομένα χτισίματος ΠΡΕΠΕΙ να
αγνοούνται όταν αποφασίζεται η προτεραιότητα έκδοσης. Συνεπώς, όταν δύο
εκδόσεις διαφέρουν μόνο στα μεταδεδομένα χτισίματος, τότε έχουν την ίδια
προτεραιότητα. Παραδείγματα: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3----117B344092BD.
  
  
    Ως προτεραιότητα αναφέρεται το πως δύο εκδόσεις συγκρίνονται μεταξύ τους
όταν ταξινομούνται.

    
      
        Η προτεραιότητα ΠΡΕΠΕΙ να υπολογίζεται διαχωρίζοντας την έκδοση στα
επιμέρους κύρια, δευτερεύοντα, διορθωτικά και προ-κυκλοφορίας
αναγνωριστικά, με αυτή τη σειρά (Τα μεταδεδομένα χτισίματος δε 
λαμβάνονται υπόψη στην προτεραιότητα).
      
      
        Η προτεραιότητα αποφασίζεται από την πρώτη διαφορά όταν συγκρίνεται το
καθένα από αυτά τα αναγνωριστικά, από αριστερά προς τα δεξιά ως εξής:
Κύριες, δευτερεύουσες, και διορθωτικές εκδόσεις συγκρίνονται πάντα
αριθμητικά.

        Παράδειγμα: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Όταν κύρια, δευτερεύουσα και διορθωτική είναι ίσα, η έκδοση 
προ-κυκλοφορίας έχει χαμηλότερη προτεραιότητα από μία φυσιολογική έκδοση:

        Παράδειγμα: 1.0.0-alpha < 1.0.0.
      
      
        Η προτεραιότητα για δύο εκδόσεις προ-κυκλοφορίας, με ίδια κύρια, 
δευτερεύουσα, και διορθωτική έκδοση, ΠΡΕΠΕΙ να αποφασίζεται συγκρίνοντας
κάθε αναγνωριστικό διαχωρισμένο με τελεία, από αριστερά προς δεξιά,
μέχρι να βρεθεί διαφορά ως εξής:

        
          
            Αναγνωριστικά που αποτελούνται μόνο από ψηφία συγκρίνονται αριθμητικά.
          
          
            Αναγνωριστικά με γράμματα ή παύλες συγκρίνονται λεξιλογικά με
σειρά ταξινόμησης ASCII.
          
          
            Τα αριθμητικά αναγνωριστικά πάντα έχουν χαμηλότερη προτεραιότητα
από τα μη-αριθμητικά αναγνωριστικά.
          
          
            Ένα μεγαλύτερο σετ από πεδία προ-κυκλοφορίας έχει υψηλότερη
προτεραιότητα από ένα μικρότερο σετ, αν όλα τα προηγούμενα
αναγνωριστικά είναι ίσα.
          
        

        Παράδειγμα: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
      
    
  


Γραμματική της Μορφής Μπάκους-Νάουρ για έγκυρες εκδόσεις SemVer
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


Γιατί να χρησιμοποιήσετε Σημασιολογική Δημιουργία Εκδόσεων;

Αυτή δεν είναι μια νέα ή επαναστατική ιδέα. Στην πραγματικότητα, πιθανά ήδη
κάνετε κάτι κοντινό σ’ αυτό. Το πρόβλημα είναι ότι το «κοντινό» δεν είναι 
αρκετά καλό. Χωρίς συμμόρφωση σε κάποια μορφή επίσημης προδιαγραφής, οι
αριθμοί εκδόσεων είναι ουσιαστικά ανώφελοι στη διαχείριση εξαρτήσεων.
Δίνοντας ένα όνομα και ξεκάθαρη ερμηνεία στις παραπάνω ιδέες, γίνεται εύκολο
να κοινοποιήσετε τις προθέσεις σας στους χρήστες του λογισμικού σας.
Μόλις αυτές οι προθέσεις ξεκαθαριστούν, μπορούν τελικά να κατασκευαστούν
ευέλικτες (αλλά όχι πολύ ευέλικτες) προδιαγραφές εξαρτήσεων.

Ένα απλό παράδειγμα θα επιδείξει πως η Σημασιολογική Δημιουργία Εκδόσεων
μπορεί να κάνει την κόλαση εξαρτήσεων παρελθόν.
Σκεφτείτε μια βιβλιοθήκη που ονομάζεται «Πυροσβεστικό». Αυτή χρειάζεται
ένα πακέτο που χρησιμοποιεί Σημασιολογική Δημιουργία Εκδόσεων και ονομάζεται
«Σκάλα». Κατά τη χρονική στιγμή που το Πυροσβεστικό δημιουργείται, η Σκάλα
είναι στην έκδοση 3.1.0. Επειδή το Πυροσβεστικό χρησιμοποιεί κάποια 
λειτουργικότητα που πρωτοεισάχθηκε στην 3.1.0, μπορείτε με ασφάλεια να
ορίσετε την εξάρτηση από την Σκάλα ως μεγαλύτερη ή ίση με 3.1.0, αλλά
μικρότερη από 4.0.0. Τώρα, όταν γίνει διαθέσιμη η έκδοση 3.1.1 και 3.2.0
της Σκάλας, μπορείτε να τις κυκλοφορήσετε στο δικό σας σύστημα διαχείρισης
πακέτων, και να γνωρίζετε ότι θα είναι συμβατές με το υπάρχον εξαρτημένο
λογισμικό.

Ως ένας υπεύθυνος προγραμματιστής, φυσικά θα θέλετε να επαληθεύσετε ότι
οποιεσδήποτε αναβαθμίσεις πακέτων, λειτουργούν όπως διαφημίζονται.
Ο πραγματικός κόσμος είναι ένα ακατάστατο μέρος και δεν μπορούμε να κάνουμε
τίποτα άλλο εκτός από το να είμαστε σε εγρήγορση. Αυτό που μπορείτε να
κάνετε είναι να επιτρέψετε στη Σημασιολογική Δημιουργία Εκδόσεων να
σας παρέχει έναν λογικό τρόπο να κυκλοφορείτε και να αναβαθμίζετε πακέτα
χωρίς να πρέπει να κυκλοφορείτε νέες εκδόσεις για τα εξαρτημένα πακέτα,
εξοικονομώντας έτσι χρόνο και ταλαιπωρία.

Αν όλα αυτά ακούγονται επιθυμητά, όλα όσα πρέπει να κάνετε για να αρχίσετε
να χρησιμοποιείτε τη Σημασιολογική Δημιουργία Εκδόσεων, είναι να δηλώσετε
ότι πρόκειται να το κάνετε και να ακολουθήσετε τους κανόνες. Δημιουργήστε ένα
σύνδεσμο από το README προς αυτό τον ιστότοπο, ώστε οι άλλοι να γνωρίζουν
τους κανόνες και να μπορούν να επωφεληθούν από αυτούς.

Συχνές Ερωτήσεις

Πώς να χειριστώ τις αλλαγές στη φάση της αρχικής ανάπτυξης 0.y.z;

Το απλούστερο πράγμα που μπορείτε να κάνετε, είναι να ξεκινήσετε την αρχική
σας κυκλοφορία ανάπτυξης στο 0.1.0 και μετά να αυξάνετε τη δευτερεύουσα
έκδοση με κάθε επακόλουθη κυκλοφορία.

Πώς μπορώ να γνωρίζω πότε να κυκλοφορήσω την 1.0.0;

Αν το λογισμικό σας χρησιμοποιείται στην παραγωγή, πιθανά πρέπει ήδη να
είναι 1.0.0. Αν έχετε ένα σταθερό API στο οποίο οι χρήστες βασίζονται,
πρέπει να είναι 1.0.0. Αν ανησυχείτε πολύ σχετικά με τη συμβατότητα
προς τα πίσω, πιθανά πρέπει ήδη να είναι 1.0.0.

Μήπως αυτό αποθαρρύνει την ταχεία ανάπτυξη και τη γρήγορη επανάληψη;

Η κύρια έκδοση μηδέν είναι για την ταχεία ανάπτυξη. Αν αλλάζετε το API
κάθε μέρα, είτε παραμείνετε στην έκδοση 0.y.z, είτε μεταβείτε σε ένα
διαφορετικό κλάδο ανάπτυξης, καθώς εργάζεστε για την επόμενη κύρια έκδοση.

Αν ακόμη και η μικρότερη αλλαγή στο δημόσιο API, που είναι ασύμβατη προς τα πίσω, απαιτεί αύξηση της κύριας έκδοσης, δε θα καταλήξω στην έκδοση 42.0.0 πολύ γρήγορα;

Αυτή είναι μια ερώτηση υπεύθυνης ανάπτυξης και προνοητικότητας. Ασύμβατες
αλλαγές δε θα πρέπει να εισάγονται εύκολα σε λογισμικό που έχει πολύ
εξαρτώμενο κώδικα. Το κόστος που πρέπει να πραγματοποιηθεί για την αναβάθμιση
μπορεί να είναι σημαντικό. Το να χρειάζεται να προσαρμόσετε τις κύριες εκδόσεις
για να κυκλοφορήσετε μη συμβατές αλλαγές σημαίνει ότι θα σκεφτείτε τον αντίκτυπο
των αλλαγών σας και θα αξιολογήσετε την αναλογία κόστους/οφέλους.

Η πλήρης τεκμηρίωση του δημόσιου API είναι πολύ δουλειά!

Είναι δική σας ευθύνη ως επαγγελματίας προγραμματιστής να τεκμηριώσετε σωστά
το λογισμικό που προορίζεται για χρήση από άλλους. Η διαχείριση της πολυπλοκότητας
του λογισμικού είναι ένα εξαιρετικά σημαντικό μέρος για τη διατήρηση της
αποτελεσματικότητας ενός εγχειρήματος και αυτό είναι δύσκολο να γίνει εάν κανείς
δεν ξέρει πώς να χρησιμοποιεί το λογισμικό σας ή ποιες μεθόδους είναι ασφαλείς να
καλέσει. Μακροπρόθεσμα, η Σημασιολογική Δημιουργία Εκδόσεων και η επιμονή σε ένα
καλά καθορισμένο δημόσιο API μπορούν να διατηρήσουν όλους και όλα σε ομαλή λειτουργία.

Τι κάνω εάν κατά λάθος κυκλοφορήσω μια μη συμβατή αλλαγή ως δευτερεύουσα έκδοση;

Μόλις συνειδητοποιήσετε ότι έχετε παραβιάσει την προδιαγραφή της Σημασιολογικής
Δημιουργίας Εκδόσεων, διορθώστε το πρόβλημα και κυκλοφορήστε μια νέα δευτερεύουσα
έκδοση που διορθώνει το πρόβλημα και αποκαθιστά τη συμβατότητα προς τα πίσω.
Ακόμη και υπό αυτές τις συνθήκες, είναι απαράδεκτη η τροποποίηση των κυκλοφορημένων
εκδόσεων. Εάν είναι κατάλληλο, τεκμηριώστε την ανάρμοστη έκδοση και ενημερώστε
τους χρήστες σας για το πρόβλημα, ώστε να γνωρίζουν ποια είναι η ανάρμοστη έκδοση.

Τι πρέπει να κάνω αν ενημερώσω τις δικές μου εξαρτήσεις χωρίς να αλλάξω το δημόσιο API;

Αυτό θα θεωρηθεί συμβατό, καθώς δεν επηρεάζει το δημόσιο API. Το λογισμικό
που εξαρτάται ρητά από τις ίδιες εξαρτήσεις με το πακέτο σας θα πρέπει να έχει
τις δικές του προδιαγραφές εξάρτησης και ο συγγραφέας θα παρατηρήσει τυχόν
διενέξεις. Ο προσδιορισμός εάν η αλλαγή είναι επίπεδο διόρθωσης ή 
δευτερεύουσας τροποποίησης, εξαρτάται από το αν ενημερώσατε τις εξαρτήσεις σας
για να διορθώσετε ένα σφάλμα ή να εισαγάγετε νέα λειτουργικότητα. Συνήθως θα
περιμέναμε πρόσθετο κώδικα για την τελευταία περίπτωση, η οποία προφανώς 
είναι μια αύξηση δευτερεύοντος επιπέδου.

Τι θα συμβεί αν κατά λάθος αλλάξω το δημόσιο API με τρόπο που δε συμμορφώνεται με την αλλαγή του αριθμού έκδοσης (δηλαδή ο κώδικας εισάγει εσφαλμένα μια κύρια ασύμβατη αλλαγή, σε μια διορθωτική κυκλοφορία);

Χρησιμοποιήστε την καλύτερη κρίση σας. Εάν έχετε τεράστιο κοινό που θα επηρεαστεί
δραστικά με την αλλαγή της συμπεριφοράς, πίσω σε αυτό που προόριζε το δημόσιο API,
τότε ίσως είναι καλύτερο να εκτελέσετε μια κυκλοφορία κύριας έκδοσης, παρόλο που
η επισκευή θα μπορούσε να θεωρηθεί αυστηρά ως διορθωτική κυκλοφορία. Θυμηθείτε,
η Σημασιολογική Δημιουργία Εκδόσεων έχει να κάνει με τη μετάδοση νοήματος με τον
τρόπο που αλλάζει ο αριθμός έκδοσης. Εάν αυτές οι αλλαγές είναι σημαντικές για
τους χρήστες σας, χρησιμοποιήστε τον αριθμό έκδοσης για να τους ενημερώσετε.

Πώς πρέπει να χειριστώ τη λειτουργικότητα που καταργείται;

Η κατάργηση υπάρχουσας λειτουργικότητας είναι φυσιολογικό μέρος της ανάπτυξης
λογισμικού και συχνά απαιτείται για να σημειωθεί πρόοδος. Όταν καταργείτε μέρος
του δημόσιου API σας, θα πρέπει να κάνετε δύο πράγματα: (1) να ενημερώσετε την
τεκμηρίωσή για να μάθουν οι χρήστες σχετικά με την αλλαγή, (2) να εκδώσετε μια
νέα δευτερεύουσα κυκλοφορία με την κατάργηση. Προτού αφαιρέσετε εντελώς τη
λειτουργικότητα σε μια νέα κύρια κυκλοφορία, θα πρέπει να υπάρχει τουλάχιστον
μία δευτερεύουσα κυκλοφορία που να περιέχει την κατάργηση, ώστε οι χρήστες να
μπορούν να μεταβούν ομαλά στο νέο API.

Έχει το SemVer όριο μεγέθους στη συμβολοσειρά έκδοσης;

Όχι, αλλά χρησιμοποιήστε καλή κρίση. Μια συμβολοσειρά έκδοσης 255 χαρακτήρων
για παράδειγμα, είναι πιθανώς υπερβολική. Επίσης, συγκεκριμένα συστήματα μπορεί
να επιβάλλουν τα δικά τους όρια στο μέγεθος της συμβολοσειράς.

Είναι το «v1.2.3» μια σημασιολογική έκδοση;

Όχι, το «v1.2.3» δεν είναι σημασιολογική έκδοση. Ωστόσο, το πρόθεμα μιας
σημασιολογικής έκδοσης με ένα «v», είναι ένας συνηθισμένος τρόπος (στα Αγγλικά)
για να δηλωθεί ότι είναι αριθμός έκδοσης. Η συντομογραφία του «version» ως «v»
εμφανίζεται συχνά με τον έλεγχο εκδόσεων. Παράδειγμα:
git tag v1.2.3 -m "Έκδοση κυκλοφορίας 1.2.3", στην περίπτωση αυτή το «v1.2.3»
είναι το όνομα μιας ετικέτας και η σημασιολογική έκδοση είναι «1.2.3».

Υπάρχει μια προτεινόμενη κανονική έκφραση (RegEx) για τον έλεγχο μιας συμβολοσειράς SemVer;

Υπάρχουν δύο. Μία με ονοματισμένες ομάδες, named groups, για εκείνα τα συστήματα
που τα υποστηρίζουν (PCRE [Perl Compatible Regular Expressions, δηλ. Perl, PHP και R], Python και Go).

Δείτε: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Και μία με αριθμημένες ομάδες σύληψης, capture groups, (έτσι cg1 = κύρια,
cg2 = δευτερεύουσα, cg3 = διορθωτική, cg4 = προκυκλοφορία και 
cg5 = μεταδεδομέναχτισίματος) που είναι συμβατή με ECMA Script (JavaScript),
PCRE (Perl Compatible Regular Expressions, δηλαδή Perl, PHP και R), Python και Go.

Δείτε: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Περί

Η προδιαγραφή Σημασιολογικής Δημιουργίας Εκδόσεων συγγράφηκε αρχικά από
τον Tom Preston-Werner, δημιουργό του Gravatar
και συνιδρυτή του GitHub.

Την αρχική μετάφραση στα Ελληνικά έκανε ο Ευάγγελος Σκαρμούτσος

Αν θέλετε να αφήσετε τα σχόλιά σας, παρακαλώ ανοίξτε ένα issue στο
GitHub.

Άδεια

Creative Commons ― CC BY 3.0\nΣημασιολογική Δημιουργία Εκδόσεων 2.0.0 (Semantic Versioning)\nΔοθέντος ενός αριθμού έκδοσης ΚΥΡΙΑ.ΔΕΥΤΕΡΕΥΟΥΣΑ.ΔΙΟΡΘΩΣΗ (MAJOR.MINOR.PATCH), αυξήστε την:\nΚΥΡΙΑ έκδοση, όταν κάνετε ασύμβατες αλλαγές στο API\nΔΕΥΤΕΡΕΥΟΥΣΑ έκδοση, όταν προσθέτετε λειτουργικότητα με τρόπο συμβατό προς τα πίσω\nΔΙΟΡΘΩΤΙΚΗ έκδοση, όταν κάνετε επιδιορθώσεις σφαλμάτων με τρόπο συμβατό προς τα πίσω\nΠρόσθετες ετικέτες για μεταδεδομένα προ-κυκλοφορίας και χτισίματος, είναι διαθέσιμες ως επεκτάσεις
στη μορφή ΚΥΡΙΑ.ΔΕΥΤΕΡΕΥΟΥΣΑ.ΔΙΟΡΘΩΣΗ.\nΣτον κόσμο της διαχείρισης λογισμικού υπάρχει ένα διαβόητο μέρος που ονομάζεται 
«κόλαση εξαρτήσεων». Όσο περισσότερο μεγαλώνει το σύστημά σας και όσο περισσότερα
πακέτα ενσωματώνετε στο λογισμικό σας, τόσο πιο πιθανό είναι να βρεθείτε μια μέρα
σε απόγνωση.\nΣε συστήματα με πολλές εξαρτήσεις, η κυκλοφορία νέων εκδόσεων πακέτων μπορεί να γίνει 
πολύ γρήγορα ένας εφιάλτης. Αν οι προδιαγραφές της εξάρτησης είναι πολύ αυστηρές, είστε
σε κίνδυνο κλειδώματος έκδοσης (σε αδυναμία αναβάθμισης ενός πακέτου χωρίς να πρέπει να
κυκλοφορήσουν νέες εκδόσεις από κάθε εξαρτώμενο πακέτο). Αν οι εξαρτήσεις ορίζονται πολύ
χαλαρά, αναπόφευκτα θα επηρεαστείτε από την αναμικτικότητα έκδοσης (υποθέτοντας συμβατότητα 
με περισσότερες μελλοντικές εκδόσεις απ’ ότι είναι λογικό). Η κόλαση εξαρτήσεων είναι εκεί
που το κλείδωμα έκδοσης ή/και η αναμικτικότητα έκδοσης, σας αποτρέπουν από το να προωθήσετε
εύκολα και με ασφάλεια το έργο σας.\nΩς μια λύση σ’ αυτό το πρόβλημα, προτείνουμε ένα απλό σετ κανόνων και
απαιτήσεων που υπαγορεύουν το πως οι αριθμοί εκδόσεων καθορίζονται και αυξάνονται.
Αυτοί οι κανόνες βασίζονται, αλλά δεν περιορίζονται απαραίτητα, σε προϋπάρχουσες
διαδεδομένες κοινές πρακτικές σε χρήση τόσο σε κλειστό όσο και σε λογισμικό
ανοιχτού κώδικα. Για να λειτουργήσει αυτό το σύστημα, πρώτα πρέπει να δηλώσετε
ένα δημόσιο API. Αυτό μπορεί να αποτελείται από τεκμηρίωση ή να επιβάλλεται από
τον ίδιο τον κώδικα. Όπως και να ‘χει είναι σημαντικό αυτό το API να είναι
ξεκάθαρο και συγκεκριμένο. Μόλις ταυτοποιήσετε το δημόσιο API, κοινοποιείτε τις
αλλαγές σ’ αυτό με συγκεκριμένες αυξήσεις στον αριθμό έκδοσης. Σκεφτείτε μία
έκδοση της μορφής X.Y.Z (Κύρια.Δευτερεύουσα.Διόρθωση). Διορθώσεις σφαλμάτων που
δεν επηρεάζουν το API αυξάνουν την έκδοση διόρθωσης, προσθήκες/αλλαγές στο API
οι οποίες είναι συμβατές προς τα πίσω αυξάνουν τη δευτερεύουσα έκδοση, και 
αλλαγές ασύμβατες με το API αυξάνουν την κύρια έκδοση.\nΟνομάζουμε αυτό το σύστημα «Σημασιολογική δημιουργία εκδόσεων».
Με αυτό το σχήμα, οι αριθμοί εκδόσεων και ο τρόπος που αλλάζουν, εκφράζουν
κάποιο νόημα σχετικά με τον υποκείμενο κώδικα και το τι έχει τροποποιηθεί
από τη μία έκδοση στην επόμενη.\nΠροδιαγραφή της Σημασιολογικής Δημιουργίας Εκδόσεων (SemVer)\nΟι λέξεις κλειδιά «ΠΡΕΠΕΙ» (MUST), «ΔΕΝ ΠΡΕΠΕΙ» (MUST NOT), «ΑΠΑΙΤΕΙΤΑΙ» (REQUIRED),
«ΠΡΕΠΕΙ» (SHALL), «ΔΕΝ ΠΡΕΠΕΙ» (SHALL NOT), «ΣΥΝΙΣΤΆΤΑΙ» (SHOULD), «ΔΕ ΣΥΝΙΣΤΆΤΑΙ»
(SHOULD NOT), «ΣΥΝΙΣΤΆΤΑΙ» (RECOMMENDED), «ΜΠΟΡΕΙ» (MAY), και «ΠΡΟΑΙΡΕΤΙΚΑ» (OPTIONAL)
σε αυτό το έγγραφο, πρέπει να ερμηνεύονται όπως περιγράφεται στο
RFC 2119.\nΛογισμικό που χρησιμοποιεί Σημασιολογική δημιουργία εκδόσεων ΠΡΕΠΕΙ να δηλώνει
ένα δημόσιο API. Αυτό το API μπορεί να δηλωθεί στον ίδιο τον κώδικα του ή να υπάρχει
αποκλειστικά στην τεκμηρίωση. Όπως και αν γίνει, ΣΥΝΙΣΤΆΤΑΙ να είναι ακριβές και
εμπεριστατωμένο.\nΛογισμικό που χρησιμοποιεί Σημασιολογική δημιουργία εκδόσεων ΠΡΕΠΕΙ να δηλώνει
ένα δημόσιο API. Αυτό το API μπορεί να δηλωθεί στον ίδιο τον κώδικα του ή να υπάρχει
αποκλειστικά στην τεκμηρίωση. Όπως και αν γίνει, ΣΥΝΙΣΤΆΤΑΙ να είναι ακριβές και
εμπεριστατωμένο.\nΈνας φυσιολογικός αριθμός έκδοσης ΠΡΕΠΕΙ να έχει τη μορφή X.Y.Z όπου X, Y, και Z
είναι μη-αρνητικοί ακέραιοι, που ΔΕΝ ΠΡΕΠΕΙ να περιέχουν προπορευόμενα μηδενικά.
Το Χ είναι η κύρια έκδοση, το Υ είναι η δευτερεύουσα έκδοση, και το Ζ είναι η
έκδοση διόρθωσης. Κάθε στοιχείο ΠΡΕΠΕΙ να αυξάνεται αριθμητικά.
Για παράδειγμα: 1.9.0 -> 1.10.0 -> 1.11.0.\nΈνας φυσιολογικός αριθμός έκδοσης ΠΡΕΠΕΙ να έχει τη μορφή X.Y.Z όπου X, Y, και Z
είναι μη-αρνητικοί ακέραιοι, που ΔΕΝ ΠΡΕΠΕΙ να περιέχουν προπορευόμενα μηδενικά.
Το Χ είναι η κύρια έκδοση, το Υ είναι η δευτερεύουσα έκδοση, και το Ζ είναι η
έκδοση διόρθωσης. Κάθε στοιχείο ΠΡΕΠΕΙ να αυξάνεται αριθμητικά.
Για παράδειγμα: 1.9.0 -> 1.10.0 -> 1.11.0.\nΜόλις ένα πακέτο με έκδοση κυκλοφορήσει, τα περιεχόμενα αυτής της έκδοσης
ΔΕΝ ΠΡΕΠΕΙ να τροποποιηθούν. Κάθε τροποποίηση ΠΡΕΠΕΙ να κυκλοφορεί με νέα έκδοση.\nΜόλις ένα πακέτο με έκδοση κυκλοφορήσει, τα περιεχόμενα αυτής της έκδοσης
ΔΕΝ ΠΡΕΠΕΙ να τροποποιηθούν. Κάθε τροποποίηση ΠΡΕΠΕΙ να κυκλοφορεί με νέα έκδοση.\nΟ αριθμός κύριας έκδοσης μηδέν (0.y.z) είναι για την αρχική ανάπτυξη.
Οτιδήποτε ΜΠΟΡΕΙ να αλλάξει οποιαδήποτε στιγμή. Το δημόσιο API ΔΕ ΣΥΝΙΣΤΆΤΑΙ
να θεωρείται σταθερό.\nΟ αριθμός κύριας έκδοσης μηδέν (0.y.z) είναι για την αρχική ανάπτυξη.
Οτιδήποτε ΜΠΟΡΕΙ να αλλάξει οποιαδήποτε στιγμή. Το δημόσιο API ΔΕ ΣΥΝΙΣΤΆΤΑΙ
να θεωρείται σταθερό.\nΗ έκδοση 1.0.0 ορίζει το δημόσιο API. Ο τρόπος με τον οποίο ο αριθμός έκδοσης
αυξάνεται μετά από κάθε κυκλοφορία, εξαρτάται από αυτό το δημόσιο API και το
πως αλλάζει.\nΗ έκδοση 1.0.0 ορίζει το δημόσιο API. Ο τρόπος με τον οποίο ο αριθμός έκδοσης
αυξάνεται μετά από κάθε κυκλοφορία, εξαρτάται από αυτό το δημόσιο API και το
πως αλλάζει.\nΗ Διορθωτική έκδοση Z (x.y.Z | x > 0) ΠΡΕΠΕΙ να αυξάνεται μόνο αν εισάγονται
διορθώσεις σφαλμάτων συμβατές προς τα πίσω. Μία διόρθωση σφάλματος ορίζεται
ως μια εσωτερική αλλαγή που διορθώνει μια εσφαλμένη συμπεριφορά.\nΗ Διορθωτική έκδοση Z (x.y.Z | x > 0) ΠΡΕΠΕΙ να αυξάνεται μόνο αν εισάγονται
διορθώσεις σφαλμάτων συμβατές προς τα πίσω. Μία διόρθωση σφάλματος ορίζεται
ως μια εσωτερική αλλαγή που διορθώνει μια εσφαλμένη συμπεριφορά.\nΗ Δευτερεύουσα έκδοση Y (x.Y.z | x > 0) ΠΡΕΠΕΙ να αυξάνεται αν μια νέα,
συμβατή προς τα πίσω, λειτουργικότητα, εισάγεται στο δημόσιο API. ΠΡΕΠΕΙ να
αυξάνεται αν κάποια λειτουργικότητα, οποιουδήποτε δημόσιου API, χαρακτηρίζεται
ως καταργημένη. ΜΠΟΡΕΙ να αυξηθεί αν σημαντική νέα λειτουργικότητα ή βελτιώσεις
εισάγονται μαζί με τον ιδιωτικό κώδικα. ΜΠΟΡΕΙ να περιλαμβάνει αλλαγές επιπέδου
διόρθωσης. Η έκδοση διόρθωσης ΠΡΕΠΕΙ να επανέλθει στο 0 όταν μία δευτερεύουσα
έκδοση αυξάνεται.\nΗ Δευτερεύουσα έκδοση Y (x.Y.z | x > 0) ΠΡΕΠΕΙ να αυξάνεται αν μια νέα,
συμβατή προς τα πίσω, λειτουργικότητα, εισάγεται στο δημόσιο API. ΠΡΕΠΕΙ να
αυξάνεται αν κάποια λειτουργικότητα, οποιουδήποτε δημόσιου API, χαρακτηρίζεται
ως καταργημένη. ΜΠΟΡΕΙ να αυξηθεί αν σημαντική νέα λειτουργικότητα ή βελτιώσεις
εισάγονται μαζί με τον ιδιωτικό κώδικα. ΜΠΟΡΕΙ να περιλαμβάνει αλλαγές επιπέδου
διόρθωσης. Η έκδοση διόρθωσης ΠΡΕΠΕΙ να επανέλθει στο 0 όταν μία δευτερεύουσα
έκδοση αυξάνεται.\nΗ Κύρια έκδοση X (X.y.z | X > 0) ΠΡΕΠΕΙ να αυξάνεται αν εισάγονται στο δημόσιο
API οποιεσδήποτε αλλαγές που είναι ασύμβατες προς τα πίσω. ΜΠΟΡΕΙ επίσης να
συμπεριλαμβάνει δευτερεύουσες και διορθωτικές αλλαγές. Οι διορθωτικές και οι
δευτερεύουσες εκδόσεις ΠΡΕΠΕΙ να επανέρχονται στο 0 όταν η κύρια έκδοση αυξάνεται.\nΗ Κύρια έκδοση X (X.y.z | X > 0) ΠΡΕΠΕΙ να αυξάνεται αν εισάγονται στο δημόσιο
API οποιεσδήποτε αλλαγές που είναι ασύμβατες προς τα πίσω. ΜΠΟΡΕΙ επίσης να
συμπεριλαμβάνει δευτερεύουσες και διορθωτικές αλλαγές. Οι διορθωτικές και οι
δευτερεύουσες εκδόσεις ΠΡΕΠΕΙ να επανέρχονται στο 0 όταν η κύρια έκδοση αυξάνεται.\nΜια έκδοση προ-κυκλοφορίας ΜΠΟΡΕΙ να επισημαίνεται επισυνάπτοντας μία παύλα
και μία σειρά από αναγνωριστικά διαχωρισμένα με τελεία, αμέσως μετά την έκδοση
διόρθωσης. Τα αναγνωριστικά ΠΡΕΠΕΙ να αποτελούνται μόνο από αλφαριθμητικούς
χαρακτήρες ASCII και παύλες [0-9A-Za-z-]. Τα αναγνωριστικά ΔΕΝ ΠΡΕΠΕΙ να είναι
κενά. Τα αριθμητικά αναγνωριστικά ΔΕΝ ΠΡΕΠΕΙ να περιλαμβάνουν προπορευόμενα
μηδενικά. Οι εκδόσεις προ-κυκλοφορίας έχουν χαμηλότερη προτεραιότητα από
τη συσχετιζόμενη φυσιολογική έκδοση. Μία έκδοση προ-κυκλοφορίας υποδεικνύει
ότι η έκδοση είναι ασταθής και μπορεί να μην ικανοποιεί τις επιθυμητές απαιτήσεις
συμβατότητας όπως επισημαίνεται από τη συσχετιζόμενη φυσιολογική έκδοση.
Παραδείγματα: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.--.\nΜια έκδοση προ-κυκλοφορίας ΜΠΟΡΕΙ να επισημαίνεται επισυνάπτοντας μία παύλα
και μία σειρά από αναγνωριστικά διαχωρισμένα με τελεία, αμέσως μετά την έκδοση
διόρθωσης. Τα αναγνωριστικά ΠΡΕΠΕΙ να αποτελούνται μόνο από αλφαριθμητικούς
χαρακτήρες ASCII και παύλες [0-9A-Za-z-]. Τα αναγνωριστικά ΔΕΝ ΠΡΕΠΕΙ να είναι
κενά. Τα αριθμητικά αναγνωριστικά ΔΕΝ ΠΡΕΠΕΙ να περιλαμβάνουν προπορευόμενα
μηδενικά. Οι εκδόσεις προ-κυκλοφορίας έχουν χαμηλότερη προτεραιότητα από
τη συσχετιζόμενη φυσιολογική έκδοση. Μία έκδοση προ-κυκλοφορίας υποδεικνύει
ότι η έκδοση είναι ασταθής και μπορεί να μην ικανοποιεί τις επιθυμητές απαιτήσεις
συμβατότητας όπως επισημαίνεται από τη συσχετιζόμενη φυσιολογική έκδοση.
Παραδείγματα: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.--.\nΜεταδεδομένα χτισίματος ΜΠΟΡΕΙ να επισημαίνονται επισυνάπτοντας το σύμβολο
της πρόσθεσης και μία σειρά από αναγνωριστικά διαχωρισμένα με τελεία, αμέσως
μετά τη διόρθωση ή την έκδοση προ-κυκλοφορίας. Τα αναγνωριστικά ΠΡΕΠΕΙ να
αποτελούνται μόνο από αλφαριθμητικούς χαρακτήρες ASCII και παύλες [0-9A-Za-z-].
Τα αναγνωριστικά ΔΕΝ ΠΡΕΠΕΙ να είναι κενά. Τα μεταδεδομένα χτισίματος ΠΡΕΠΕΙ να
αγνοούνται όταν αποφασίζεται η προτεραιότητα έκδοσης. Συνεπώς, όταν δύο
εκδόσεις διαφέρουν μόνο στα μεταδεδομένα χτισίματος, τότε έχουν την ίδια
προτεραιότητα. Παραδείγματα: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3----117B344092BD.\nΜεταδεδομένα χτισίματος ΜΠΟΡΕΙ να επισημαίνονται επισυνάπτοντας το σύμβολο
της πρόσθεσης και μία σειρά από αναγνωριστικά διαχωρισμένα με τελεία, αμέσως
μετά τη διόρθωση ή την έκδοση προ-κυκλοφορίας. Τα αναγνωριστικά ΠΡΕΠΕΙ να
αποτελούνται μόνο από αλφαριθμητικούς χαρακτήρες ASCII και παύλες [0-9A-Za-z-].
Τα αναγνωριστικά ΔΕΝ ΠΡΕΠΕΙ να είναι κενά. Τα μεταδεδομένα χτισίματος ΠΡΕΠΕΙ να
αγνοούνται όταν αποφασίζεται η προτεραιότητα έκδοσης. Συνεπώς, όταν δύο
εκδόσεις διαφέρουν μόνο στα μεταδεδομένα χτισίματος, τότε έχουν την ίδια
προτεραιότητα. Παραδείγματα: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3----117B344092BD.\nΩς προτεραιότητα αναφέρεται το πως δύο εκδόσεις συγκρίνονται μεταξύ τους
όταν ταξινομούνται.

    
      
        Η προτεραιότητα ΠΡΕΠΕΙ να υπολογίζεται διαχωρίζοντας την έκδοση στα
επιμέρους κύρια, δευτερεύοντα, διορθωτικά και προ-κυκλοφορίας
αναγνωριστικά, με αυτή τη σειρά (Τα μεταδεδομένα χτισίματος δε 
λαμβάνονται υπόψη στην προτεραιότητα).
      
      
        Η προτεραιότητα αποφασίζεται από την πρώτη διαφορά όταν συγκρίνεται το
καθένα από αυτά τα αναγνωριστικά, από αριστερά προς τα δεξιά ως εξής:
Κύριες, δευτερεύουσες, και διορθωτικές εκδόσεις συγκρίνονται πάντα
αριθμητικά.

        Παράδειγμα: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Όταν κύρια, δευτερεύουσα και διορθωτική είναι ίσα, η έκδοση 
προ-κυκλοφορίας έχει χαμηλότερη προτεραιότητα από μία φυσιολογική έκδοση:

        Παράδειγμα: 1.0.0-alpha < 1.0.0.
      
      
        Η προτεραιότητα για δύο εκδόσεις προ-κυκλοφορίας, με ίδια κύρια, 
δευτερεύουσα, και διορθωτική έκδοση, ΠΡΕΠΕΙ να αποφασίζεται συγκρίνοντας
κάθε αναγνωριστικό διαχωρισμένο με τελεία, από αριστερά προς δεξιά,
μέχρι να βρεθεί διαφορά ως εξής:

        
          
            Αναγνωριστικά που αποτελούνται μόνο από ψηφία συγκρίνονται αριθμητικά.
          
          
            Αναγνωριστικά με γράμματα ή παύλες συγκρίνονται λεξιλογικά με
σειρά ταξινόμησης ASCII.
          
          
            Τα αριθμητικά αναγνωριστικά πάντα έχουν χαμηλότερη προτεραιότητα
από τα μη-αριθμητικά αναγνωριστικά.
          
          
            Ένα μεγαλύτερο σετ από πεδία προ-κυκλοφορίας έχει υψηλότερη
προτεραιότητα από ένα μικρότερο σετ, αν όλα τα προηγούμενα
αναγνωριστικά είναι ίσα.
          
        

        Παράδειγμα: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nΩς προτεραιότητα αναφέρεται το πως δύο εκδόσεις συγκρίνονται μεταξύ τους
όταν ταξινομούνται.\nΗ προτεραιότητα ΠΡΕΠΕΙ να υπολογίζεται διαχωρίζοντας την έκδοση στα
επιμέρους κύρια, δευτερεύοντα, διορθωτικά και προ-κυκλοφορίας
αναγνωριστικά, με αυτή τη σειρά (Τα μεταδεδομένα χτισίματος δε 
λαμβάνονται υπόψη στην προτεραιότητα).\nΗ προτεραιότητα ΠΡΕΠΕΙ να υπολογίζεται διαχωρίζοντας την έκδοση στα
επιμέρους κύρια, δευτερεύοντα, διορθωτικά και προ-κυκλοφορίας
αναγνωριστικά, με αυτή τη σειρά (Τα μεταδεδομένα χτισίματος δε 
λαμβάνονται υπόψη στην προτεραιότητα).\nΗ προτεραιότητα αποφασίζεται από την πρώτη διαφορά όταν συγκρίνεται το
καθένα από αυτά τα αναγνωριστικά, από αριστερά προς τα δεξιά ως εξής:
Κύριες, δευτερεύουσες, και διορθωτικές εκδόσεις συγκρίνονται πάντα
αριθμητικά.

        Παράδειγμα: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nΗ προτεραιότητα αποφασίζεται από την πρώτη διαφορά όταν συγκρίνεται το
καθένα από αυτά τα αναγνωριστικά, από αριστερά προς τα δεξιά ως εξής:
Κύριες, δευτερεύουσες, και διορθωτικές εκδόσεις συγκρίνονται πάντα
αριθμητικά.\nΠαράδειγμα: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nΌταν κύρια, δευτερεύουσα και διορθωτική είναι ίσα, η έκδοση 
προ-κυκλοφορίας έχει χαμηλότερη προτεραιότητα από μία φυσιολογική έκδοση:

        Παράδειγμα: 1.0.0-alpha < 1.0.0.\nΌταν κύρια, δευτερεύουσα και διορθωτική είναι ίσα, η έκδοση 
προ-κυκλοφορίας έχει χαμηλότερη προτεραιότητα από μία φυσιολογική έκδοση:\nΠαράδειγμα: 1.0.0-alpha < 1.0.0.\nΗ προτεραιότητα για δύο εκδόσεις προ-κυκλοφορίας, με ίδια κύρια, 
δευτερεύουσα, και διορθωτική έκδοση, ΠΡΕΠΕΙ να αποφασίζεται συγκρίνοντας
κάθε αναγνωριστικό διαχωρισμένο με τελεία, από αριστερά προς δεξιά,
μέχρι να βρεθεί διαφορά ως εξής:

        
          
            Αναγνωριστικά που αποτελούνται μόνο από ψηφία συγκρίνονται αριθμητικά.
          
          
            Αναγνωριστικά με γράμματα ή παύλες συγκρίνονται λεξιλογικά με
σειρά ταξινόμησης ASCII.
          
          
            Τα αριθμητικά αναγνωριστικά πάντα έχουν χαμηλότερη προτεραιότητα
από τα μη-αριθμητικά αναγνωριστικά.
          
          
            Ένα μεγαλύτερο σετ από πεδία προ-κυκλοφορίας έχει υψηλότερη
προτεραιότητα από ένα μικρότερο σετ, αν όλα τα προηγούμενα
αναγνωριστικά είναι ίσα.
          
        

        Παράδειγμα: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nΗ προτεραιότητα για δύο εκδόσεις προ-κυκλοφορίας, με ίδια κύρια, 
δευτερεύουσα, και διορθωτική έκδοση, ΠΡΕΠΕΙ να αποφασίζεται συγκρίνοντας
κάθε αναγνωριστικό διαχωρισμένο με τελεία, από αριστερά προς δεξιά,
μέχρι να βρεθεί διαφορά ως εξής:\nΑναγνωριστικά που αποτελούνται μόνο από ψηφία συγκρίνονται αριθμητικά.\nΑναγνωριστικά που αποτελούνται μόνο από ψηφία συγκρίνονται αριθμητικά.\nΑναγνωριστικά με γράμματα ή παύλες συγκρίνονται λεξιλογικά με
σειρά ταξινόμησης ASCII.\nΑναγνωριστικά με γράμματα ή παύλες συγκρίνονται λεξιλογικά με
σειρά ταξινόμησης ASCII.\nΤα αριθμητικά αναγνωριστικά πάντα έχουν χαμηλότερη προτεραιότητα
από τα μη-αριθμητικά αναγνωριστικά.\nΤα αριθμητικά αναγνωριστικά πάντα έχουν χαμηλότερη προτεραιότητα
από τα μη-αριθμητικά αναγνωριστικά.\nΈνα μεγαλύτερο σετ από πεδία προ-κυκλοφορίας έχει υψηλότερη
προτεραιότητα από ένα μικρότερο σετ, αν όλα τα προηγούμενα
αναγνωριστικά είναι ίσα.\nΈνα μεγαλύτερο σετ από πεδία προ-κυκλοφορίας έχει υψηλότερη
προτεραιότητα από ένα μικρότερο σετ, αν όλα τα προηγούμενα
αναγνωριστικά είναι ίσα.\nΠαράδειγμα: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nΓραμματική της Μορφής Μπάκους-Νάουρ για έγκυρες εκδόσεις SemVer\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nΓιατί να χρησιμοποιήσετε Σημασιολογική Δημιουργία Εκδόσεων;\nΑυτή δεν είναι μια νέα ή επαναστατική ιδέα. Στην πραγματικότητα, πιθανά ήδη
κάνετε κάτι κοντινό σ’ αυτό. Το πρόβλημα είναι ότι το «κοντινό» δεν είναι 
αρκετά καλό. Χωρίς συμμόρφωση σε κάποια μορφή επίσημης προδιαγραφής, οι
αριθμοί εκδόσεων είναι ουσιαστικά ανώφελοι στη διαχείριση εξαρτήσεων.
Δίνοντας ένα όνομα και ξεκάθαρη ερμηνεία στις παραπάνω ιδέες, γίνεται εύκολο
να κοινοποιήσετε τις προθέσεις σας στους χρήστες του λογισμικού σας.
Μόλις αυτές οι προθέσεις ξεκαθαριστούν, μπορούν τελικά να κατασκευαστούν
ευέλικτες (αλλά όχι πολύ ευέλικτες) προδιαγραφές εξαρτήσεων.\nΈνα απλό παράδειγμα θα επιδείξει πως η Σημασιολογική Δημιουργία Εκδόσεων
μπορεί να κάνει την κόλαση εξαρτήσεων παρελθόν.
Σκεφτείτε μια βιβλιοθήκη που ονομάζεται «Πυροσβεστικό». Αυτή χρειάζεται
ένα πακέτο που χρησιμοποιεί Σημασιολογική Δημιουργία Εκδόσεων και ονομάζεται
«Σκάλα». Κατά τη χρονική στιγμή που το Πυροσβεστικό δημιουργείται, η Σκάλα
είναι στην έκδοση 3.1.0. Επειδή το Πυροσβεστικό χρησιμοποιεί κάποια 
λειτουργικότητα που πρωτοεισάχθηκε στην 3.1.0, μπορείτε με ασφάλεια να
ορίσετε την εξάρτηση από την Σκάλα ως μεγαλύτερη ή ίση με 3.1.0, αλλά
μικρότερη από 4.0.0. Τώρα, όταν γίνει διαθέσιμη η έκδοση 3.1.1 και 3.2.0
της Σκάλας, μπορείτε να τις κυκλοφορήσετε στο δικό σας σύστημα διαχείρισης
πακέτων, και να γνωρίζετε ότι θα είναι συμβατές με το υπάρχον εξαρτημένο
λογισμικό.\nΩς ένας υπεύθυνος προγραμματιστής, φυσικά θα θέλετε να επαληθεύσετε ότι
οποιεσδήποτε αναβαθμίσεις πακέτων, λειτουργούν όπως διαφημίζονται.
Ο πραγματικός κόσμος είναι ένα ακατάστατο μέρος και δεν μπορούμε να κάνουμε
τίποτα άλλο εκτός από το να είμαστε σε εγρήγορση. Αυτό που μπορείτε να
κάνετε είναι να επιτρέψετε στη Σημασιολογική Δημιουργία Εκδόσεων να
σας παρέχει έναν λογικό τρόπο να κυκλοφορείτε και να αναβαθμίζετε πακέτα
χωρίς να πρέπει να κυκλοφορείτε νέες εκδόσεις για τα εξαρτημένα πακέτα,
εξοικονομώντας έτσι χρόνο και ταλαιπωρία.\nΑν όλα αυτά ακούγονται επιθυμητά, όλα όσα πρέπει να κάνετε για να αρχίσετε
να χρησιμοποιείτε τη Σημασιολογική Δημιουργία Εκδόσεων, είναι να δηλώσετε
ότι πρόκειται να το κάνετε και να ακολουθήσετε τους κανόνες. Δημιουργήστε ένα
σύνδεσμο από το README προς αυτό τον ιστότοπο, ώστε οι άλλοι να γνωρίζουν
τους κανόνες και να μπορούν να επωφεληθούν από αυτούς.\nΠώς να χειριστώ τις αλλαγές στη φάση της αρχικής ανάπτυξης 0.y.z;\nΤο απλούστερο πράγμα που μπορείτε να κάνετε, είναι να ξεκινήσετε την αρχική
σας κυκλοφορία ανάπτυξης στο 0.1.0 και μετά να αυξάνετε τη δευτερεύουσα
έκδοση με κάθε επακόλουθη κυκλοφορία.\nΠώς μπορώ να γνωρίζω πότε να κυκλοφορήσω την 1.0.0;\nΑν το λογισμικό σας χρησιμοποιείται στην παραγωγή, πιθανά πρέπει ήδη να
είναι 1.0.0. Αν έχετε ένα σταθερό API στο οποίο οι χρήστες βασίζονται,
πρέπει να είναι 1.0.0. Αν ανησυχείτε πολύ σχετικά με τη συμβατότητα
προς τα πίσω, πιθανά πρέπει ήδη να είναι 1.0.0.\nΜήπως αυτό αποθαρρύνει την ταχεία ανάπτυξη και τη γρήγορη επανάληψη;\nΗ κύρια έκδοση μηδέν είναι για την ταχεία ανάπτυξη. Αν αλλάζετε το API
κάθε μέρα, είτε παραμείνετε στην έκδοση 0.y.z, είτε μεταβείτε σε ένα
διαφορετικό κλάδο ανάπτυξης, καθώς εργάζεστε για την επόμενη κύρια έκδοση.\nΑν ακόμη και η μικρότερη αλλαγή στο δημόσιο API, που είναι ασύμβατη προς τα πίσω, απαιτεί αύξηση της κύριας έκδοσης, δε θα καταλήξω στην έκδοση 42.0.0 πολύ γρήγορα;\nΑυτή είναι μια ερώτηση υπεύθυνης ανάπτυξης και προνοητικότητας. Ασύμβατες
αλλαγές δε θα πρέπει να εισάγονται εύκολα σε λογισμικό που έχει πολύ
εξαρτώμενο κώδικα. Το κόστος που πρέπει να πραγματοποιηθεί για την αναβάθμιση
μπορεί να είναι σημαντικό. Το να χρειάζεται να προσαρμόσετε τις κύριες εκδόσεις
για να κυκλοφορήσετε μη συμβατές αλλαγές σημαίνει ότι θα σκεφτείτε τον αντίκτυπο
των αλλαγών σας και θα αξιολογήσετε την αναλογία κόστους/οφέλους.\nΗ πλήρης τεκμηρίωση του δημόσιου API είναι πολύ δουλειά!\nΕίναι δική σας ευθύνη ως επαγγελματίας προγραμματιστής να τεκμηριώσετε σωστά
το λογισμικό που προορίζεται για χρήση από άλλους. Η διαχείριση της πολυπλοκότητας
του λογισμικού είναι ένα εξαιρετικά σημαντικό μέρος για τη διατήρηση της
αποτελεσματικότητας ενός εγχειρήματος και αυτό είναι δύσκολο να γίνει εάν κανείς
δεν ξέρει πώς να χρησιμοποιεί το λογισμικό σας ή ποιες μεθόδους είναι ασφαλείς να
καλέσει. Μακροπρόθεσμα, η Σημασιολογική Δημιουργία Εκδόσεων και η επιμονή σε ένα
καλά καθορισμένο δημόσιο API μπορούν να διατηρήσουν όλους και όλα σε ομαλή λειτουργία.\nΤι κάνω εάν κατά λάθος κυκλοφορήσω μια μη συμβατή αλλαγή ως δευτερεύουσα έκδοση;\nΜόλις συνειδητοποιήσετε ότι έχετε παραβιάσει την προδιαγραφή της Σημασιολογικής
Δημιουργίας Εκδόσεων, διορθώστε το πρόβλημα και κυκλοφορήστε μια νέα δευτερεύουσα
έκδοση που διορθώνει το πρόβλημα και αποκαθιστά τη συμβατότητα προς τα πίσω.
Ακόμη και υπό αυτές τις συνθήκες, είναι απαράδεκτη η τροποποίηση των κυκλοφορημένων
εκδόσεων. Εάν είναι κατάλληλο, τεκμηριώστε την ανάρμοστη έκδοση και ενημερώστε
τους χρήστες σας για το πρόβλημα, ώστε να γνωρίζουν ποια είναι η ανάρμοστη έκδοση.\nΤι πρέπει να κάνω αν ενημερώσω τις δικές μου εξαρτήσεις χωρίς να αλλάξω το δημόσιο API;\nΑυτό θα θεωρηθεί συμβατό, καθώς δεν επηρεάζει το δημόσιο API. Το λογισμικό
που εξαρτάται ρητά από τις ίδιες εξαρτήσεις με το πακέτο σας θα πρέπει να έχει
τις δικές του προδιαγραφές εξάρτησης και ο συγγραφέας θα παρατηρήσει τυχόν
διενέξεις. Ο προσδιορισμός εάν η αλλαγή είναι επίπεδο διόρθωσης ή 
δευτερεύουσας τροποποίησης, εξαρτάται από το αν ενημερώσατε τις εξαρτήσεις σας
για να διορθώσετε ένα σφάλμα ή να εισαγάγετε νέα λειτουργικότητα. Συνήθως θα
περιμέναμε πρόσθετο κώδικα για την τελευταία περίπτωση, η οποία προφανώς 
είναι μια αύξηση δευτερεύοντος επιπέδου.\nΤι θα συμβεί αν κατά λάθος αλλάξω το δημόσιο API με τρόπο που δε συμμορφώνεται με την αλλαγή του αριθμού έκδοσης (δηλαδή ο κώδικας εισάγει εσφαλμένα μια κύρια ασύμβατη αλλαγή, σε μια διορθωτική κυκλοφορία);\nΧρησιμοποιήστε την καλύτερη κρίση σας. Εάν έχετε τεράστιο κοινό που θα επηρεαστεί
δραστικά με την αλλαγή της συμπεριφοράς, πίσω σε αυτό που προόριζε το δημόσιο API,
τότε ίσως είναι καλύτερο να εκτελέσετε μια κυκλοφορία κύριας έκδοσης, παρόλο που
η επισκευή θα μπορούσε να θεωρηθεί αυστηρά ως διορθωτική κυκλοφορία. Θυμηθείτε,
η Σημασιολογική Δημιουργία Εκδόσεων έχει να κάνει με τη μετάδοση νοήματος με τον
τρόπο που αλλάζει ο αριθμός έκδοσης. Εάν αυτές οι αλλαγές είναι σημαντικές για
τους χρήστες σας, χρησιμοποιήστε τον αριθμό έκδοσης για να τους ενημερώσετε.\nΠώς πρέπει να χειριστώ τη λειτουργικότητα που καταργείται;\nΗ κατάργηση υπάρχουσας λειτουργικότητας είναι φυσιολογικό μέρος της ανάπτυξης
λογισμικού και συχνά απαιτείται για να σημειωθεί πρόοδος. Όταν καταργείτε μέρος
του δημόσιου API σας, θα πρέπει να κάνετε δύο πράγματα: (1) να ενημερώσετε την
τεκμηρίωσή για να μάθουν οι χρήστες σχετικά με την αλλαγή, (2) να εκδώσετε μια
νέα δευτερεύουσα κυκλοφορία με την κατάργηση. Προτού αφαιρέσετε εντελώς τη
λειτουργικότητα σε μια νέα κύρια κυκλοφορία, θα πρέπει να υπάρχει τουλάχιστον
μία δευτερεύουσα κυκλοφορία που να περιέχει την κατάργηση, ώστε οι χρήστες να
μπορούν να μεταβούν ομαλά στο νέο API.\nΈχει το SemVer όριο μεγέθους στη συμβολοσειρά έκδοσης;\nΌχι, αλλά χρησιμοποιήστε καλή κρίση. Μια συμβολοσειρά έκδοσης 255 χαρακτήρων
για παράδειγμα, είναι πιθανώς υπερβολική. Επίσης, συγκεκριμένα συστήματα μπορεί
να επιβάλλουν τα δικά τους όρια στο μέγεθος της συμβολοσειράς.\nΕίναι το «v1.2.3» μια σημασιολογική έκδοση;\nΌχι, το «v1.2.3» δεν είναι σημασιολογική έκδοση. Ωστόσο, το πρόθεμα μιας
σημασιολογικής έκδοσης με ένα «v», είναι ένας συνηθισμένος τρόπος (στα Αγγλικά)
για να δηλωθεί ότι είναι αριθμός έκδοσης. Η συντομογραφία του «version» ως «v»
εμφανίζεται συχνά με τον έλεγχο εκδόσεων. Παράδειγμα:
git tag v1.2.3 -m "Έκδοση κυκλοφορίας 1.2.3", στην περίπτωση αυτή το «v1.2.3»
είναι το όνομα μιας ετικέτας και η σημασιολογική έκδοση είναι «1.2.3».\nΥπάρχει μια προτεινόμενη κανονική έκφραση (RegEx) για τον έλεγχο μιας συμβολοσειράς SemVer;\nΥπάρχουν δύο. Μία με ονοματισμένες ομάδες, named groups, για εκείνα τα συστήματα
που τα υποστηρίζουν (PCRE [Perl Compatible Regular Expressions, δηλ. Perl, PHP και R], Python και Go).\nΔείτε: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nΚαι μία με αριθμημένες ομάδες σύληψης, capture groups, (έτσι cg1 = κύρια,
cg2 = δευτερεύουσα, cg3 = διορθωτική, cg4 = προκυκλοφορία και 
cg5 = μεταδεδομέναχτισίματος) που είναι συμβατή με ECMA Script (JavaScript),
PCRE (Perl Compatible Regular Expressions, δηλαδή Perl, PHP και R), Python και Go.\nΔείτε: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nΗ προδιαγραφή Σημασιολογικής Δημιουργίας Εκδόσεων συγγράφηκε αρχικά από
τον Tom Preston-Werner, δημιουργό του Gravatar
και συνιδρυτή του GitHub.\nΤην αρχική μετάφραση στα Ελληνικά έκανε ο Ευάγγελος Σκαρμούτσος\nΕυάγγελος Σκαρμούτσος\nΑν θέλετε να αφήσετε τα σχόλιά σας, παρακαλώ ανοίξτε ένα issue στο
GitHub.\nανοίξτε ένα issue στο
GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSemantic Versioning 2.0.0-rc.2

En el mundo de la gestión de software existe el temor de caer en algún momento en el llamado “infierno de las dependencias”. Mientras más grande crece tu sistema y mientras más paquetes integras en tu software, más probable es que te encuentres, un día, en este pozo de la desesperación.

En sistemas con muchas dependencias, publicar nuevas versiones de un paquete puede transformarse rápidamente en una pesadilla. Si las especificaciones de dependencia son muy estrictas está el peligro del bloqueo de versiones (la imposibilidad de actualizar un paquete sin tener que actualizar todos los que dependen de este). Si las dependencias se especifican de manera muy amplia, inevitablemente caerás en promiscuidad de versiones (asumir más compatibilidad con versiones futuras de lo razonable). El infierno de las dependencias es donde te encuentras cuando el bloqueo de versiones o la promiscuidad de versiones te impiden avanzar en tu proyecto de manera fácil y segura.

Como solución a este problema, propongo un set simple de reglas y requerimientos que dictan cómo asignar y cómo aumentar los números de versión. Para que este sistema funcione, tienes que declarar primero un API pública. Esto puede consistir en documentación o ser explicitado en el código mismo. De cualquier forma, es importante que esta API sea clara y precisa. Una vez que identificaste tu API pública, comunicas cambios a ella con aumentos específicos al número de versión. Considera un formato de versión del tipo X.Y.Z (Mayor.Menor.Parche) Los arreglos de bugs que no cambian el API incrementan el parche, los cambios y adiciones que no rompen la compatibilidad de las dependencias anteriores incrementan el menor, y los cambios que rompen la compatibilidad incrementan el mayor.

Yo llamo a este sistema “Versionamiento Semántico”. Bajo este esquema, los números de versión y la forma en que cambian entregan significado del código que está detrás y lo que fue modificado de una versión a otra.

Especificación de Versionamiento Semántico (en inglés SemVer)

En el documento original se usa el RFC 2119 para el uso de las palabras MUST, MUST NOT, SHOULD, SOULD NOT y MAY. Para que la traducción sea lo más fiel posible, he traducido siempre MUST por el verbo deber en presente (DEBE, DEBEN), SHOULD como el verbo deber en condicional (DEBERÍA, DEBERÍAN) y el verbo MAY como el verbo PODER.


  
    El software que use Versionamiento Semántico DEBE declarar una API pública. Esta API puede ser declarada en el código mismo o existir en documentación estricta. De cualquier manera, debería ser precisa y completa.
  
  
    Un número normal de versión DEBE tomar la forma X.Y.Z donde X, Y, y Z son enteros no negativos. X es la versión “mayor”, Y es la versión “menor”, y Z es la versión “parche”. Cada elemento DEBE incrementarse numéricamente en incrementos de 1. Por ejemplo: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Una vez que un paquete versionado ha sido lanzado, los contenidos de esa versión NO DEBEN ser modificadas. Cualquier modificación DEBE ser lanzada como una nueva versión.
  
  
    La versión mayor en cero (0.y.z) es para desarrollo inicial. Cualquier cosa puede cambiar en cualquier momento. El API pública no debiera ser considerada estable.
  
  
    La versión 1.0.0 define el API pública. La forma en que el número de versión es incrementado después de este lanzamiento depende de esta API pública y de cómo esta cambia.
  
  
    
      
        
          La versión parche Z (x.y.Z
          x > 0) DEBE incrementarse cuando se introducen solo arreglos compatibles con la versión anterior. Un arreglo de bug se define como un cambio interno que corrige un comportamiento erróneo.
        
      
    
  
  
    
      
        
          La versión menor Y (x.Y.z
          x > 0) DEBE ser incrementada si se introduce nueva funcionalidad compatible con la versión anterior. Se DEBE incrementar si cualquier funcionalidad de la API es marcada como deprecada. PUEDE ser incrementada si se agrega funcionalidad o arreglos considerables al código privado. Puede incluir cambios de nivel parche. La versión parche DEBE ser reseteada a 0 cuando la versión menor es incrementada.
        
      
    
  
  
    
      
        
          La versión mayor X (X.y.z
          X > 0) DEBE ser incrementada si cualquier cambio no compatible con la versión anterior es introducida a la API pública. PUEDE incluir cambios de niver menor y/o parche. Las versiones parche y menor DEBEN ser reseteadas a 0 cuando se incrementa la versión mayor.
        
      
    
  
  
    Una versión pre-lanzamiento PUEDE ser representada por adjuntar un guión y una serie de identificadores separados por puntos inmediatamente después de la versión parche. Los identificadores DEBEN consistir solo de caracteres ASCII alfanuméricos y el guión  [0-9A-Za-z-]. Las versiones pre-lanzamiento satisfacen pero tienen una menor precedencia que la versión normal asociada.Ejemplos: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    La metadata de build PUEDE ser representada adjuntando un signo más y una serie de identificadores separados por puntos inmediatamente después de la versión parche o la pre-lanzamiento. Los identificadores DEBEN consistir sólo de caracteres ASCII alfanuméricos y el guión [0-9A-Za-z-]. Los meta-datos de build DEBIERAN ser ignorados cuando se intenta determinar precedencia de versiones. Luego, dos paquetes con la misma versión pero distinta metadata de build se consideran la misma versión. Ejemplos: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  La precedencia DEBE ser calculada separando la versión en mayor, menor, parche e identificadores pre-lanzamiento en ese orden (La metadata de build no figuran en la precedencia). Las versiones mayor, menor, y parche son siempre comparadas numéricamente. La precedencia de pre-lanzamiento DEBE ser determinada comparando cada identificador separado por puntos de la siguiente manera: los identificadores que solo consisten de números son comparados numéricamente y los identificadores con letras o guiones son comparados de acuerdo al orden establecido por ASCII. Los identificadores numéricos siempre tienen una precedencia menor que los no-numéricos. Ejemplo: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.


¿Por qué usar Versionamiento Semántico?

Esta no es una idea nueva o revolucionarias. De hecho, probablemente ya haces algo cercano hoy en día. El problema es que “cercano” no es suficientemente bueno. Sin un acuerdo en algun tipo de especificación formal, los números de versiones son esencialmente inútiles para el manejo de dependencias. Al darle un nombre y una definición clara a las ideas expresadas arriba, se hace facil comunicar tus intenciones a los usuarios de tu software. Una vez que estas intenciones son claras y flexibles (pero no demasiado flexibles) finalmente se pueden hacer especificaciones de dependencias.

Un ejemplo simple puede demostrar como el Versionamiento Semántico puede ayudar a que el infierno de dependencias quede en el pasado. Considera una librería llamada “CarroBomba” Requiere de un paquete Semanticamente Versionado llamado “Escalera”. En el momento en que se crea CarroBomba, Escalera está en su versión 3.1.0. Como CarroBomba usa algunas de las funcionalidades que recién se estrenaron en la versión 3.1.0, puedes tranquilamente definir la dependencia de Escalera como mayor o igual a 3.1.0, pero menor a 4.0.0. Ahora, cuando la versión 3.1.1 y 3.2.0 de Escalera sean lanzadas, puedes usarlas en tu sistema de versionamiento de paquetes sabiendo que serán compatibles con el software dependiente.

Como desarrollador responsable que eres, claro, querrás verificar que cualquier actualización de paquete funcione como se anunció. El mundo real es complejo; no hay nada que podamos hacer salvo estar atentos. Lo que puedes hacer es dejar que el Versionamiento Semántico te provea de una manera sana de liberar y actualizar paquetes sin tener que entregar nuevas versiones de tus paquetes dependientes, ahorrándote tiempo y molestias.

Si todo esto suena deseable, todo lo que tienes que hacer para comenzar usando Versionamiento Semántico es declarar que lo estás haciendo y seguir las reglas. Haz un link a este sitio desde tu README para que otros conozcan las reglas y se puedan beneficiar de ellas.

FAQ

¿Cómo tengo que hacer con las revisiones en la etapa inicial de desarrollo 0.y.z ?

Lo más facil es empezar tu desarrollo inicial en 0.1.0 e incrementar la versión menor en cada lanzamiento.

¿Cómo sé cuándo liberar la versión 1.0.0?

Si tu software está siendo usado en producción, probablemente ya deberías estar en 1.0.0. SI tienes una API estable de la cual tus usuarios ya están dependiendo, deberías estar en 1.0.0. Si te preocupa mucho la compatibilidad con versiones anteriores, ya deberías estar en 1.0.0.

¿Esto no desincentiva el desarrollo rápido y las iteraciones cortas?

La versión mayor en cero se trata de desarrollo rápido. Si estás cambiando la API todos los días debieras o bien estar todavía en la versión 0.y.z o estar trabajando en un branch separado para la próxima versión mayor.

Si incluso el cambio incompatible con la versión anterior más pequeño requiere un aumento de la versión mayor ¿No voy a terminar en la versión 42.0.0 demasiado rápido?

Este es un tema de desarrollo responsable y visión anticipada. Los cambios incompatibles no debieran ser introducidos con ligereza al software del cual depende mucho código. El costo de actualizar puede ser significante. Tener que aumentar la versión mayor para publicar cambios incompatibles significa que vas a pensar bien el efecto de tus cambios, y evaluar el costo/beneficio asociado.

Documentar la API pública entera es demasiado trabajo!

Es tu responsabilidad como desarrollador profesional documentar adecuadamente el software pensado para que lo usen otros. Gestionar la complejidad del software es una parte tremendamente importante de mantener un proyecto eficiente, y es muy dificil de lograr si nadie sabe cómo usar tu software o qué métodos es seguro llamar. A largo plazo, el Versionamiento Semántico, y la insistencia en una API pública bien definida pueden asegurar que todos y todo corra de manera suave.

¿Qué hago si accidentalmente publico un cambio incompatible con la versión anterior como un cambio de versión menor?

Apenas te des cuenta de que rompiste con la especificación de Versionamiento Semántico, repara el problema y publica una nueva versión menor que corrige el problema y recupera la compatiblidad. Incluso en esta circunstancia, es inaceptable modificar lanzamientos versionados. Si corresponde, documenta la versión que rompe la especificación e informa a tus usuarios que estén atentos a ella.

¿Qué debería hacer si actualizo mis propias dependencias sin cambiar la API pública?

Eso sería considerado compatible ya que no afecta al API pública. El software que explícitamente depende de las mismas dependencias que tu paquete debiera tener sus propias especificaciones de dependencia y el autor va a notar cualquier conflicto. La determinación de si el cambio es a nivel de parche o menor depende de si actualizaste tus dependencias para arreglar un bug o para agregar funcionalidad nueva. Yo esperaría que haya código adicional si se trata de lo segundo, en cuyo caso el incremento del menor es la opción obvia.

¿Qué debería hacer si el bug que estoy arreglando justamente hace que vuelva a estar de acuerdo con la especificación del API pública? (es decir, el código estaba incorrectamente desincronizado con la documentación del API)

Usa tu sentido común. Si tienes una gran audiencia que se va a ver drásticamente afectada al cambiar el comportamiento a lo que la API pública debía hacer, entonces lo mejor puede ser hacer un lanzamiento mayor, incluso si el arreglo es estrictamente un lanzamiento de tipo parche. Recuerda, el Versionamiento Semántico se trata de incorporar significado a la forma en que el número de versión cambia. Si estos cambios son importantes para tus usuarios, usa el número de versión para informarlos.

¿Cómo debiera controlar la funcionalidad obsoleta?

Hacer obsoleta una funcionalidad existente es una parte normal del desarrollo de software y es típicamente requerida para avanzar. Cuando haces obsoleta parte de tu API pública, deberías hacer dos cosas: (1) actualizar tu documentación para permitir que los usuarios sepan del cambio, (2) emitir un nuevo lanzamiento menor con la funcionalidad obsoleta. Antes de sacar la funcionalidad por completo en un nuevo lanzamiento mayor, debería haber al menos un lanzamiento menor que contenga la funcionalidad obsoleta, de manera que los usuarios puedan traspasarse a la nueva API poco a poco.

Acerca de

La especificación de Versionamiento Semántico fue creada por Tom Preston-Werner, inventor de los Gravatars y co-fundador de GitHub. Esta traducción fue realizada por Agustin Feuerhake.
Si quieres dar feedback, puedes abrir un issue en GitHub.

Licencia

Creative Commons ― CC BY 3.0\nSemantic Versioning 2.0.0-rc.2\nEn el mundo de la gestión de software existe el temor de caer en algún momento en el llamado “infierno de las dependencias”. Mientras más grande crece tu sistema y mientras más paquetes integras en tu software, más probable es que te encuentres, un día, en este pozo de la desesperación.\nEn sistemas con muchas dependencias, publicar nuevas versiones de un paquete puede transformarse rápidamente en una pesadilla. Si las especificaciones de dependencia son muy estrictas está el peligro del bloqueo de versiones (la imposibilidad de actualizar un paquete sin tener que actualizar todos los que dependen de este). Si las dependencias se especifican de manera muy amplia, inevitablemente caerás en promiscuidad de versiones (asumir más compatibilidad con versiones futuras de lo razonable). El infierno de las dependencias es donde te encuentras cuando el bloqueo de versiones o la promiscuidad de versiones te impiden avanzar en tu proyecto de manera fácil y segura.\nComo solución a este problema, propongo un set simple de reglas y requerimientos que dictan cómo asignar y cómo aumentar los números de versión. Para que este sistema funcione, tienes que declarar primero un API pública. Esto puede consistir en documentación o ser explicitado en el código mismo. De cualquier forma, es importante que esta API sea clara y precisa. Una vez que identificaste tu API pública, comunicas cambios a ella con aumentos específicos al número de versión. Considera un formato de versión del tipo X.Y.Z (Mayor.Menor.Parche) Los arreglos de bugs que no cambian el API incrementan el parche, los cambios y adiciones que no rompen la compatibilidad de las dependencias anteriores incrementan el menor, y los cambios que rompen la compatibilidad incrementan el mayor.\nYo llamo a este sistema “Versionamiento Semántico”. Bajo este esquema, los números de versión y la forma en que cambian entregan significado del código que está detrás y lo que fue modificado de una versión a otra.\nEspecificación de Versionamiento Semántico (en inglés SemVer)\nEn el documento original se usa el RFC 2119 para el uso de las palabras MUST, MUST NOT, SHOULD, SOULD NOT y MAY. Para que la traducción sea lo más fiel posible, he traducido siempre MUST por el verbo deber en presente (DEBE, DEBEN), SHOULD como el verbo deber en condicional (DEBERÍA, DEBERÍAN) y el verbo MAY como el verbo PODER.\nEl software que use Versionamiento Semántico DEBE declarar una API pública. Esta API puede ser declarada en el código mismo o existir en documentación estricta. De cualquier manera, debería ser precisa y completa.\nEl software que use Versionamiento Semántico DEBE declarar una API pública. Esta API puede ser declarada en el código mismo o existir en documentación estricta. De cualquier manera, debería ser precisa y completa.\nUn número normal de versión DEBE tomar la forma X.Y.Z donde X, Y, y Z son enteros no negativos. X es la versión “mayor”, Y es la versión “menor”, y Z es la versión “parche”. Cada elemento DEBE incrementarse numéricamente en incrementos de 1. Por ejemplo: 1.9.0 -> 1.10.0 -> 1.11.0.\nUn número normal de versión DEBE tomar la forma X.Y.Z donde X, Y, y Z son enteros no negativos. X es la versión “mayor”, Y es la versión “menor”, y Z es la versión “parche”. Cada elemento DEBE incrementarse numéricamente en incrementos de 1. Por ejemplo: 1.9.0 -> 1.10.0 -> 1.11.0.\nUna vez que un paquete versionado ha sido lanzado, los contenidos de esa versión NO DEBEN ser modificadas. Cualquier modificación DEBE ser lanzada como una nueva versión.\nUna vez que un paquete versionado ha sido lanzado, los contenidos de esa versión NO DEBEN ser modificadas. Cualquier modificación DEBE ser lanzada como una nueva versión.\nLa versión mayor en cero (0.y.z) es para desarrollo inicial. Cualquier cosa puede cambiar en cualquier momento. El API pública no debiera ser considerada estable.\nLa versión mayor en cero (0.y.z) es para desarrollo inicial. Cualquier cosa puede cambiar en cualquier momento. El API pública no debiera ser considerada estable.\nLa versión 1.0.0 define el API pública. La forma en que el número de versión es incrementado después de este lanzamiento depende de esta API pública y de cómo esta cambia.\nLa versión 1.0.0 define el API pública. La forma en que el número de versión es incrementado después de este lanzamiento depende de esta API pública y de cómo esta cambia.\nLa versión parche Z (x.y.Z
          x > 0) DEBE incrementarse cuando se introducen solo arreglos compatibles con la versión anterior. Un arreglo de bug se define como un cambio interno que corrige un comportamiento erróneo.\nLa versión parche Z (x.y.Z\nx > 0) DEBE incrementarse cuando se introducen solo arreglos compatibles con la versión anterior. Un arreglo de bug se define como un cambio interno que corrige un comportamiento erróneo.\nLa versión menor Y (x.Y.z
          x > 0) DEBE ser incrementada si se introduce nueva funcionalidad compatible con la versión anterior. Se DEBE incrementar si cualquier funcionalidad de la API es marcada como deprecada. PUEDE ser incrementada si se agrega funcionalidad o arreglos considerables al código privado. Puede incluir cambios de nivel parche. La versión parche DEBE ser reseteada a 0 cuando la versión menor es incrementada.\nLa versión menor Y (x.Y.z\nx > 0) DEBE ser incrementada si se introduce nueva funcionalidad compatible con la versión anterior. Se DEBE incrementar si cualquier funcionalidad de la API es marcada como deprecada. PUEDE ser incrementada si se agrega funcionalidad o arreglos considerables al código privado. Puede incluir cambios de nivel parche. La versión parche DEBE ser reseteada a 0 cuando la versión menor es incrementada.\nLa versión mayor X (X.y.z
          X > 0) DEBE ser incrementada si cualquier cambio no compatible con la versión anterior es introducida a la API pública. PUEDE incluir cambios de niver menor y/o parche. Las versiones parche y menor DEBEN ser reseteadas a 0 cuando se incrementa la versión mayor.\nLa versión mayor X (X.y.z\nX > 0) DEBE ser incrementada si cualquier cambio no compatible con la versión anterior es introducida a la API pública. PUEDE incluir cambios de niver menor y/o parche. Las versiones parche y menor DEBEN ser reseteadas a 0 cuando se incrementa la versión mayor.\nUna versión pre-lanzamiento PUEDE ser representada por adjuntar un guión y una serie de identificadores separados por puntos inmediatamente después de la versión parche. Los identificadores DEBEN consistir solo de caracteres ASCII alfanuméricos y el guión  [0-9A-Za-z-]. Las versiones pre-lanzamiento satisfacen pero tienen una menor precedencia que la versión normal asociada.Ejemplos: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nUna versión pre-lanzamiento PUEDE ser representada por adjuntar un guión y una serie de identificadores separados por puntos inmediatamente después de la versión parche. Los identificadores DEBEN consistir solo de caracteres ASCII alfanuméricos y el guión  [0-9A-Za-z-]. Las versiones pre-lanzamiento satisfacen pero tienen una menor precedencia que la versión normal asociada.Ejemplos: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nLa metadata de build PUEDE ser representada adjuntando un signo más y una serie de identificadores separados por puntos inmediatamente después de la versión parche o la pre-lanzamiento. Los identificadores DEBEN consistir sólo de caracteres ASCII alfanuméricos y el guión [0-9A-Za-z-]. Los meta-datos de build DEBIERAN ser ignorados cuando se intenta determinar precedencia de versiones. Luego, dos paquetes con la misma versión pero distinta metadata de build se consideran la misma versión. Ejemplos: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nLa metadata de build PUEDE ser representada adjuntando un signo más y una serie de identificadores separados por puntos inmediatamente después de la versión parche o la pre-lanzamiento. Los identificadores DEBEN consistir sólo de caracteres ASCII alfanuméricos y el guión [0-9A-Za-z-]. Los meta-datos de build DEBIERAN ser ignorados cuando se intenta determinar precedencia de versiones. Luego, dos paquetes con la misma versión pero distinta metadata de build se consideran la misma versión. Ejemplos: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nLa precedencia DEBE ser calculada separando la versión en mayor, menor, parche e identificadores pre-lanzamiento en ese orden (La metadata de build no figuran en la precedencia). Las versiones mayor, menor, y parche son siempre comparadas numéricamente. La precedencia de pre-lanzamiento DEBE ser determinada comparando cada identificador separado por puntos de la siguiente manera: los identificadores que solo consisten de números son comparados numéricamente y los identificadores con letras o guiones son comparados de acuerdo al orden establecido por ASCII. Los identificadores numéricos siempre tienen una precedencia menor que los no-numéricos. Ejemplo: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\n¿Por qué usar Versionamiento Semántico?\nEsta no es una idea nueva o revolucionarias. De hecho, probablemente ya haces algo cercano hoy en día. El problema es que “cercano” no es suficientemente bueno. Sin un acuerdo en algun tipo de especificación formal, los números de versiones son esencialmente inútiles para el manejo de dependencias. Al darle un nombre y una definición clara a las ideas expresadas arriba, se hace facil comunicar tus intenciones a los usuarios de tu software. Una vez que estas intenciones son claras y flexibles (pero no demasiado flexibles) finalmente se pueden hacer especificaciones de dependencias.\nUn ejemplo simple puede demostrar como el Versionamiento Semántico puede ayudar a que el infierno de dependencias quede en el pasado. Considera una librería llamada “CarroBomba” Requiere de un paquete Semanticamente Versionado llamado “Escalera”. En el momento en que se crea CarroBomba, Escalera está en su versión 3.1.0. Como CarroBomba usa algunas de las funcionalidades que recién se estrenaron en la versión 3.1.0, puedes tranquilamente definir la dependencia de Escalera como mayor o igual a 3.1.0, pero menor a 4.0.0. Ahora, cuando la versión 3.1.1 y 3.2.0 de Escalera sean lanzadas, puedes usarlas en tu sistema de versionamiento de paquetes sabiendo que serán compatibles con el software dependiente.\nComo desarrollador responsable que eres, claro, querrás verificar que cualquier actualización de paquete funcione como se anunció. El mundo real es complejo; no hay nada que podamos hacer salvo estar atentos. Lo que puedes hacer es dejar que el Versionamiento Semántico te provea de una manera sana de liberar y actualizar paquetes sin tener que entregar nuevas versiones de tus paquetes dependientes, ahorrándote tiempo y molestias.\nSi todo esto suena deseable, todo lo que tienes que hacer para comenzar usando Versionamiento Semántico es declarar que lo estás haciendo y seguir las reglas. Haz un link a este sitio desde tu README para que otros conozcan las reglas y se puedan beneficiar de ellas.\n¿Cómo tengo que hacer con las revisiones en la etapa inicial de desarrollo 0.y.z ?\nLo más facil es empezar tu desarrollo inicial en 0.1.0 e incrementar la versión menor en cada lanzamiento.\n¿Cómo sé cuándo liberar la versión 1.0.0?\nSi tu software está siendo usado en producción, probablemente ya deberías estar en 1.0.0. SI tienes una API estable de la cual tus usuarios ya están dependiendo, deberías estar en 1.0.0. Si te preocupa mucho la compatibilidad con versiones anteriores, ya deberías estar en 1.0.0.\n¿Esto no desincentiva el desarrollo rápido y las iteraciones cortas?\nLa versión mayor en cero se trata de desarrollo rápido. Si estás cambiando la API todos los días debieras o bien estar todavía en la versión 0.y.z o estar trabajando en un branch separado para la próxima versión mayor.\nSi incluso el cambio incompatible con la versión anterior más pequeño requiere un aumento de la versión mayor ¿No voy a terminar en la versión 42.0.0 demasiado rápido?\nEste es un tema de desarrollo responsable y visión anticipada. Los cambios incompatibles no debieran ser introducidos con ligereza al software del cual depende mucho código. El costo de actualizar puede ser significante. Tener que aumentar la versión mayor para publicar cambios incompatibles significa que vas a pensar bien el efecto de tus cambios, y evaluar el costo/beneficio asociado.\nDocumentar la API pública entera es demasiado trabajo!\nEs tu responsabilidad como desarrollador profesional documentar adecuadamente el software pensado para que lo usen otros. Gestionar la complejidad del software es una parte tremendamente importante de mantener un proyecto eficiente, y es muy dificil de lograr si nadie sabe cómo usar tu software o qué métodos es seguro llamar. A largo plazo, el Versionamiento Semántico, y la insistencia en una API pública bien definida pueden asegurar que todos y todo corra de manera suave.\n¿Qué hago si accidentalmente publico un cambio incompatible con la versión anterior como un cambio de versión menor?\nApenas te des cuenta de que rompiste con la especificación de Versionamiento Semántico, repara el problema y publica una nueva versión menor que corrige el problema y recupera la compatiblidad. Incluso en esta circunstancia, es inaceptable modificar lanzamientos versionados. Si corresponde, documenta la versión que rompe la especificación e informa a tus usuarios que estén atentos a ella.\n¿Qué debería hacer si actualizo mis propias dependencias sin cambiar la API pública?\nEso sería considerado compatible ya que no afecta al API pública. El software que explícitamente depende de las mismas dependencias que tu paquete debiera tener sus propias especificaciones de dependencia y el autor va a notar cualquier conflicto. La determinación de si el cambio es a nivel de parche o menor depende de si actualizaste tus dependencias para arreglar un bug o para agregar funcionalidad nueva. Yo esperaría que haya código adicional si se trata de lo segundo, en cuyo caso el incremento del menor es la opción obvia.\n¿Qué debería hacer si el bug que estoy arreglando justamente hace que vuelva a estar de acuerdo con la especificación del API pública? (es decir, el código estaba incorrectamente desincronizado con la documentación del API)\nUsa tu sentido común. Si tienes una gran audiencia que se va a ver drásticamente afectada al cambiar el comportamiento a lo que la API pública debía hacer, entonces lo mejor puede ser hacer un lanzamiento mayor, incluso si el arreglo es estrictamente un lanzamiento de tipo parche. Recuerda, el Versionamiento Semántico se trata de incorporar significado a la forma en que el número de versión cambia. Si estos cambios son importantes para tus usuarios, usa el número de versión para informarlos.\n¿Cómo debiera controlar la funcionalidad obsoleta?\nHacer obsoleta una funcionalidad existente es una parte normal del desarrollo de software y es típicamente requerida para avanzar. Cuando haces obsoleta parte de tu API pública, deberías hacer dos cosas: (1) actualizar tu documentación para permitir que los usuarios sepan del cambio, (2) emitir un nuevo lanzamiento menor con la funcionalidad obsoleta. Antes de sacar la funcionalidad por completo en un nuevo lanzamiento mayor, debería haber al menos un lanzamiento menor que contenga la funcionalidad obsoleta, de manera que los usuarios puedan traspasarse a la nueva API poco a poco.\nLa especificación de Versionamiento Semántico fue creada por Tom Preston-Werner, inventor de los Gravatars y co-fundador de GitHub. Esta traducción fue realizada por Agustin Feuerhake.
Si quieres dar feedback, puedes abrir un issue en GitHub.\npuedes abrir un issue en GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nنسخه‌بندی معنایی 2.0.0

خلاصه

به فرض اینکه نسخهٔ MAJOR.MINOR.PATCH یا اصلی.جزیی.وصله داده شده است:


  شمارهٔ نسخهٔ اصلی (MAJOR) را زمانی افزایش دهید که تغییرات API ناسازگار اعمال کرده‌اید،
  شمارهٔ نسخهٔ جزیی (MINOR) را زمانی افزایش دهید که قابلیت‌هایی اضافه کرده‌اید که با نسخه‌های قبل سازگار هستند،
  شمارهٔ نسخهٔ وصله (PATCH) را زمانی افزایش دهید که تصحیح خطاهایی (bug) اعمال کرده‌اید که با نسخه‌های قبل سازگار هستند.


برچسب‌های اضافی برای پیش‌نشر و ساختن فراداده به صورت پسوندهایی برای قالب MAJOR.MINOR.PATCH فراهم است.

مقدمه

در دنیای مدیریت نرم‌افزار مکان مخوفی به نام «جهنم وابستگی» (dependency hell) وجود دارد. هر چه سیستم شما بزرگتر باشد و بسته‌های (package) بیشتری با نرم‌افزار شما یکپارچه شده باشند، احتمال بیشتری وجود دارد که روزی خود را دراین گودال ناامیدی بیابید.

در سیستم‌هایی با وابستگی‌های زیاد، انتشار بستهٔ جدید به زودی می‌تواند تبدیل به یک کابوس شود. اگر ویژگی‌های وابستگی‌ها بسیار جزئی‌نگرانه باشد، در خطر قفل نسخه (version lock) خواهید بود (ناتوانی برای بروزرسانی یک بسته، بدون اجبار جهت انتشار نسخه‌های جدید همهٔ بسته‌های وابسته). اگر وابستگی‌ها بسیار ضعیف مشخص شده باشند، به ناچار زخم بی‌قاعدگی نسخه را خواهید خورد (به فرض سازگاری بیش از حد معقول با نسخه‌های آتی‌تر). جهنم وابستگی آنجایی است که قفل نسخه و یا بی‌قاعدگی نسخه از پیشرفت رو به جلوی آسان و امن پروژهٔ شما جلوگیری می‌کند.

برای پاسخگویی به این مشکل، من یکسری قوانین و پیش‌نیازهای ساده را پیشنهاد میدهم که نحوهٔ تخصیص و افزایش شماره‌های نسخه را دیکته میکند. این قوانین برپایهٔ شیوه‌های موجود رایج و گستردهٔ در حال استفاده، هم در نرم‌افزارهای متن‌باز و غیر متن‌باز است، اگرچه لزوماً محدود به آن نیست. برای آنکه این سیستم کار کند نخست لازم است یک API عمومی (public) تعریف کنید. این امر ممکن است شامل مستندسازی، یا بوسیلهٔ خود کد مقید شده باشد. صرف نظر از این موضوع، مهم است که این API دقیق و واضح باشد. زمانیکه  API عمومی خود را مشخص کردید، تغییرات آن را با افزایش معین شمارهٔ نسخهٔ خود مرتبط می‌سازید. قالب نسخهای به صورت X.Y.Z را در نظر بگیرید. خطاهایی که تاثیری بر API ندارند، نسخهٔ وصله (Patch) را افزایش می‌دهند، افزایش یا تغییر API که با نسخه‌های قبلی سازگار است، نسخهٔ جزیی (Minor) را افزایش میدهند، و تغییرات API که با نسخه‌های قبل ناسازگار هستند، نسخهٔ اصلی (Major) را افزایش می‌دهند.

من این سیستم را «نسخه‌بندی معنایی» می‌نامم. بر اساس این طرح، شماره‌های نسخه و روشی که تغییر می‌کنند، معنی و مفهومی را دربارهٔ کد تحت آن نسخه، و آنچه که از یک نسخه تا نسخه‌ای دیگر ویرایش شده است، انتقال می‌دهد.

ویژگی‌های نسخه‌بندی معنایی (SemVer)

کلمات کلیدی «باید»، «نباید»، «نیاز است»، «می‌بایست»، «نمی‌بایست»، «توصیه شده است»، «ممکن است» و «اختیاری» در این مستند می‌بایست بر مبنای آنچه در  RFC 2119  تعریف شده است، معنا شوند.


  
    نرم‌افزارهایی که از نسخه‌بندی معنایی استفاده می‌کنند باید یک API عمومی اعلام کنند. این API می‌تواند در خود کد اعلام شود، یا به طور واضح در مستندسازی وجود داشته باشد. هر طور که انجام شود، می‌بایست دقیق و جامع باشد.
  
  
    یک شمارهٔ نسخهٔ عادی باید قالب X.Y.Z را داشته باشه طوری که در آن X ،Y و Z اعداد صحیح غیرمنفی هستند و نباید صفر اضافه (leading zero) داشته باشند.  X نسخهٔ اصلی، Y  نسخه جزیی، و Z نسخهٔ وصله است. هر عنصر باید به صورت شمارشی افزایش یابد. به عنوان مثال  1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    زمانی‌که یک بستهٔ نسخه‌بندی شده منتشر شد، محتوای آن نسخه نباید دستکاری شود. هرگونه تغییری باید به عنوان نسخهٔ جدید منتشر شود.
  
  
    نسخهٔ اصلی شمارهٔ صفر (0.y.z) برای توسعه‌های ابتدایی است. هرچیزی در هر زمانی ممکن است تغییر کند. API  عمومی نمی‌بایست ماندگار در نظر گرفته شود.
  
  
    نسخهٔ 1.0.0 API عمومی را تعریف می‌کند. روشی که شمارهٔ نسخهٔ بعد از این انتشار افزوده می‌شود، به این API عمومی و نحوهٔ تغییر آن وابسته است.
  
  
    نسخهٔ وصله Z  (x.y.Z | x > 0)  باید در صورتی افزوده شود که تصحیح‌های خطای سازگار با نسخهٔ قبلی معرفی شده باشند. یک تصحیح خطا به عنوان یک تغییر داخلی تعریف می‌شود که رفتارهای نادرست را اصلاح می‌کند.
  
  
    نسخهٔ جزیی Y (x.Y.z | x > 0) باید در صورتی افزوده شود که عملکرد سازگار با نسخه‌های قبل جدیدی به API عمومی معرفی شده باشد. همچنین اگر هرگونه عملکرد API عمومی به عنوان منسوخ‌شده برچسب خورده باشد، این شماره باید افزوده شود. اگر عملکرد جدید یا بهبود قابل توجهی در کدهای داخلی معرفی شده باشد، ممکن است نسخهٔ جزیی افزوده شود. ممکن است که شامل تغییرات سطح وصله هم باشد. زمانیکه نسخه جزیی افزوده شود، نسخهٔ وصله باید به 0 بازنشانده شود.
  
  
    نسخهٔ اصلی X (X.y.z | X > 0) باید در صورتی افزوده شود که هرگونه تغییرات ناسازگار با نسخه‌های قبل به API عمومی معرفی شده باشد. ممکن است این تغییرات شامل سطوح جزیی و وصله نیز باشد. نسخهٔ جزیی و وصله زمانیکه نسخهٔ اصلی افزوده می‌شود باید به 0 بازنشانی شوند.
  
  
    یک نسخهٔ پیش‌انتشار ممکن است با اضافه کردن یک خط تیره و یک سری شناسه‌هایی که به وسیلهٔ نقطه از هم جدا ‌شده‌اند و بلافاصله به دنبال نسخهٔ وصله می‌آیند، نشانه‌گذاری شود. شناسه‌ها باید تنها شامل اعداد و حروف الفبای اَسکی (ASCII)  و خط تیره [A-Za-z0-9] باشند. شناسه‌ها نباید تهی باشند. شناسه‌های عددی نباید با صفر اضافه آغاز شوند. نسخهٔ پیش‌انتشار از اولویت پایین‌تری نسبت به نسخهٔ عادی مرتبط برخوردار است. یک نسخهٔ پیش‌انتشار حاکی از آن است که نسخهٔ ناپایدار است و ممکن است نیازمندی‌های سازگاری مورد نظر را آنگونه که در نسخهٔ عادی مرتبط نشان داده شده است، برآورده نکند. مثال: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    متادیتای ساخت (build metadata) ممکن است با افزودن یک علامت جمع (+) و یک سری شناسه‌هایی که به وسیلهٔ نقطه ازهم جدا شده‌اند، و بلافاصله به دنبال نسخهٔ وصله یا پیش‌انتشار می‌آیند، نشانه‌گذاری شود. شناسه‌ها باید تنها شامل اعداد و حروف الفبای اَسکی (ASCII)  و خط تیره [A-Za-z0-9] باشند. شناسه‌ها نباید تهی باشند. متادیتای ساخت می‌بایست در زمان تعیین اولویت نسخه درنظر گرفته نشود. بنابراین دو نسخه که تنها در متادیتای ساخت با یکدیگر متفاوت هستند، اولویت یکسان دارند. مثال: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f8
  
  
    اولویت اشاره دارد به اینکه چگونه نسخه‌ها زمانی‌که مرتب شده‌اند با یکدیگر مقایسه می‌شوند. اولویت باید به وسیلهٔ جداسازی نسخه به اصلی، جزیی، وصله و شناسه‌های پیش‌انتشار به همین ترتیب، محاسبه شود (متادیتای ساخت در اولویت نمایان نمی‌شود). اولویت، به وسیلهٔ اولین تفاوت تعیین می‌شود هنگامی که این مشخصه‌ها از چپ به راست مقایسه شوند، بدین صورت: نسخه‌های اصلی، جزیی و وصله همیشه به صورت عددی مقایسه می‌شوند. مثال: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. زمانی که اصلی و جزیی و وصله برابر هستند، یک نسخهٔ پیش‌انتشار از اولویت کمتری نسبت به نسخهٔ عادی برخوردار است. مثال: 1.0.0-   alpha < 1.0.0  اولویت برای دو نسخهٔ پیش‌انتشار با نسخهٔ اصلی، جزیی و وصلهٔ مشابه باید به وسیلهٔ مقایسهٔ هر مشخصه‌ای که با نقطه جدا شده، از چپ به راست مشخص شود تا زمانی که یک تفاوت به شرح زیر یافت شود: شناسه‌هایی که تنها شامل اعداد صحیح هستند به صورت عددی و شناسه‌هایی که با حروف یا خط‌های تیره به صورت الفبایی به ترتیب ASCII مقایسه می شوند. مشخصه‌های عددی همیشه از اولویت کمتری نسبت به مشخصه‌های غیرعددی برخوردار هستند. مجموعه‌های بزرگتری از بخشهای پیش‌انتشار اولویت بیشتری نسبت به مجموعه‌های کوچکتر دارند، اگر همه مشخصه‌های اولویت برابر باشند. مثال: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


چرا از نسخه‌بندی معنایی استفاده شود؟

این ایده‌ای جدید یا انقلابی نیست. در واقع، احتمالاً شما چیزی مشابه به این را پیش از این انجام داده‌اید. مشکل اینجاست که «مشابه» به اندازهٔ کافی خوب نیست. بدون انطباق با نوعی تعریف رسمی، شماره‌های نسخه ضرورتاً برای مدیریت وابستگی (dependency) بلااستفاده هستند. بوسیلهٔ اختصاص اعداد و تعاریف واضح به ایده‌های بالا، برقراری ارتباط میان کاربران نرم‌افزار شما و اهدافتان آسان‌تر می‌شود. به‌مجرد اینکه این اهداف واضح شود، مشخصات وابستگی انعطاف‌پذیر (نه آن‌چنان انعطاف‌پذیر) می‌تواند نهایتاً ایجاد شود.

یک مثال ساده می‌تواند نشان دهد که چگونه نسخه‌بندی معنایی می‌تواند جهنم وابستگی را به خاطره‌ای از گذشته تبدیل کند. کتابخانه‌ای به نام «Firetruck» را در نظر بگیرید. این کتابخانه به یک بسته به نام «Ladder» که به صورت معنایی نسخه‌بندی شده، احتیاج دارد. در زمانی که firetruck ساخته شده، Ladder در نسخهٔ 3.1.0 است، شما می‌توانید وابستگی Ladder را با آسودگی به عنوان بزرگتر یا برابر با 3.1.0 و نه کمتر از 4.0.0 تعیین کنید. شما می‌توانید آن‌ها را در سیستم مدیریت بستهٔ خود منتشر کنید و بدانید که آن‌ها با نرم‌افزار وابسته موجود سازگار هستند.

بدون شک به عنوان یک توسعه‌دهندهٔ مسئولیت‌پذیر شما خواهید خواست که هر بسته همان‌طورکه اعلان شده ارتقاء یابد. دنیای واقعی مکان به هم ریخته ایست، ما جز اینکه هشیار باشیم نمی‌توانیم کاری دربارهٔ آن انجام دهیم. آنچه شما می‌توانید انجام دهید این است که بگذارید نسخه‌بندی معنایی به شما یک راه عاقلانه ارائه دهد، تا بسته‌ها را منتشر کرده و ارتقاء دهد بدون آنکه نسخه‌های جدیدی از بسته‌های مستقل را راه اندازی کند و شما را عذاب نداده، در وقت شما صرفه‌جویی کند..

اگر همهٔ این‌ها مطلوب به نظر می‌رسد، همهٔ آنچه شما برای شروع استفاده از نسخه‌بندی معنایی احتیاج دارید این است که اعلام کنید که در حال انجام این کار هستید و از قوانین پیروی کنید. به این وب‌سایت از طریق صفحه README خود لینک بزنید، در نتیجه دیگران دربارهٔ قوانین خواهند دانست و از آن نفع خواهند برد.

سوالات متداول

چگونه باید با نسخه‌ها در فاز توسعهٔ ابتدایی 0.y.z  کنار بیایم؟

ساده‌ترین کار برای انجام دادن این است که توسعهٔ ابتدایی خود را از انتشار 0.1.0  آغاز کنید و سپس نسخهٔ جزیی را برای هر انتشار آتی افزایش دهید.

چگونه بدانم چه زمانی باید 1.0.0 را منتشر کنم؟

اگر نرم‌افزار شما در طول تولید مورد استفاده قرار گرفته است، احتمالاً می‌بایست هم‌اکنون 1.0.0 باشد. اگر یک API ماندگار دارید که کاربران روی آن حساب می‌کنند، شما باید 1.0.0 باشید. اگر در مورد سازگاری با نسخه‌های قبل خیلی نگران هستید، احتمالاً می‌بایست هم‌اکنون 1.0.0 باشید.

آیا این روش، توسعه و تکرار سریع را کند نمی کند؟

نسخهٔ اصلی صفر تماماً در مورد توسعهٔ سریع است. اگر شما API را هر روز تغییر می‌دهید، یا باید هنوز در نسخهٔ 0.y.z  باشید یا در یک شاخهٔ توسعهٔ جداگانه که بر نسخهٔ اصلی بعدی کار می‌کند هستید.

اگر حتی کوچکترین تغییرات ناسازگار با نسخه‌های قبل در API عمومی نیازمند یک نسخهٔ اصلی باشد، آیا من خیلی سریع به نسخه 42.0.0 نخواهم رسید؟

این سوال یک توسعه‌دهندهٔ مسئولیت‌پذیر و آینده‌نگر است. تغییرات ناسازگار نمی‌بایست به راحتی در نرم‌افزاری که کدهای وابستهٔ زیادی دارد معرفی شود. هزینه‌ای که برای ارتقاء باید متحمل شد می‌تواند قابل توجه باشد. اجبار برای ایجاد نسخه‌های اصلی برای انتشار تغییرات ناسازگار، یعنی شما به تأثیر تغییراتتان فکر خواهید کرد و نرخ هزینه/سود مورد نظر را خواهید سنجید.

مستندسازی تمامی  API عمومی کار بسیار زیاد می‌برد!

این مسئولیت شما به عنوان یک توسعه‌دهندهٔ حرفه‌ای است تا به طور مناسب نرم‌افزار که می‌بایست توسط دیگران مورد استفاده قرار گیرد را مستندسازی کنید. مدیریت پیچیدگی نرم‌افزار یک بخش فوق‌العاده مهم ازکارآمد نگه‌داشتن پروژه است، و انجام آن سخت است اگر کسی نداند که چگونه نرم‌افزار شما را استفاده کند یا چه متدهایی برای صدا زدن امن است. در دراز مدت، نسخه‌بندی معنایی و پافشاری بر یک API عمومی خوش‌تعریف می‌تواند همه چیز و همه کس را در اجرا کردن راحت در موقعیت مناسبی نگه دارد.

چه کار می‌توانم بکنم اگر تصادفاً یک تغییر ناسازگار با نسخه‌های قبل را به عنوان نسخهٔ جزیی منتشر کردم؟

به مجرد اینکه متوجه این مورد بشوید، تنظیمات نسخه‌بندی معنایی را به هم زده‌اید، مشکل را حل کنید و یک نسخهٔ جزیی جدید که مشکل را تصحیح کند و سازگاری با نسخه‌های قبل را بازگرداند، منتشر سازید. حتی تحت این شرایط، این پذیرفته شده نیست که انتشارهای نسخه‌بندی شده را دستکاری کنید. اگر مناسب است نسخهٔ متخلف را مستند‌سازی کنید و کاربران خود را از مشکل مطلع سازید تا آن ها نیز از نسخهٔ متخلف آگاه باشند.

چه کار باید بکنم اگر وابستگی‌های خودم را بدون تغییر دادن API عمومی به‌روزرسانی کردم؟

این مورد تا زمانی که API عمومی را متأثر نسازد سازگار تلقی خواهد شد. نرم‌افزاری که صریحاً به همان وابستگی‌هایی که بستهٔ شما وابسته است، وابسته باشد، باید مشخصات وابستگی خود را داشته باشد و نویسنده باید هرگونه مغایرت را ذکر کند. تشخیص اینکه آیا تغییر ازنوع دستکاری در سطح جزیی است یا سطح وصله، به این بستگی دارد که آیا شما وابستگی‌های خود را جهت تصحیح یک خطا یا برای یک کاربرد جدید به‌روزرسانی کرده‌اید. من معمولاً کد اضافی برای موارد آتی در نظر می‌گیرم، که بدون شک این موارد افزایش سطح جزیی می‌باشد.

چه می شود اگر من بدون اعلام قبلی API عمومی را به صورتی تغییر دهم که با تغییر عدد نسخه سازگار نباشد؟ (یعنی کد به نادرست تغییر اصلی‌ای را در انتشار وصله معرفی می‌کند)

از بهترین قضاوت خود استفاده کنید. اگر شما مخاطبان زیادی دارید که به شدت به وسیلهٔ تغییر رفتار به آنچه قبلاً برای API  عمومی در نظر گرفته شده، متأثر خواهند شد، پس بهترین کار انجام یک انتشار نسخهٔ اصلی است، حتی اگر اصلاح اعمال شده مؤکداً یک انتشار وصله محسوب شود. به یاد داشته باشید، نسخه‌بندی معنایی تماماً دربارهٔ انتقال معنا بوسیله چگونگی تغییر عدد نسخه می‌باشد. اگر این تغییرات برای کاربران شما مهم است، از عدد نسخه برای آگاه‌سازی آن‌ها استفاده کنید.

چگونه باید با منسوخ کردن عملکرد (deprecating functionality) کنار بیایم؟

منسوخ کردن عملکرد موجود بخشی عادی از توسعهٔ نرم‌افزار است و معمولاً برای این‌که پیشرفت رو به جلو حاصل شود مورد نیاز است. زمانی‌که بخشی از API عمومی خود را منسوخ می‌کنید، باید دو کار انجام دهید: ۱) مستندسازی خود را به‌روزرسانی کنید تا به کاربر اجازه دهید از تغییرات باخبر شود. ۲) یک انتشار جزیی که در آن قسمت منسوخ شده در جایگاه خود باشد منتشر کنید. قبل از آنکه عملکرد را به طورکامل در یک انتشار اصلی حذف کنید حتماً باید حداقل یک انتشار جزیی که شامل قسمت منسوخ شده است وجود داشته باشد تا کاربران به راحتی بتوانند به API جدید منتقل شوند.

آیا SemVer محدودیت اندازه بر روی رشتهٔ نسخه دارد؟

خیر، اما از قضاوت مناسبی استفاده کنید. به عنوان مثال یک نسخهٔ ۲۵۵ نویسه‌ای احتمالاً مفید نخواهد بود! همچنین، سیستم‌های خاص ممکن است محدودیت‌های خود برای اندازهٔ رشته اعمال کنند.

در مورد من

نویسنده : Tom Preston-Werner, سازنده Gravatars و
 بنیان‌گذار GitHub.

اگر مایل به ارائهٔ بازخورد خود هستید، لطفاً یک مورد در بخش issue سایت GitHub باز کنید.
 open an issue on GitHub.

مترجم بخش فارسی : مجید حاجیان Majid Hajian 
ویراستار: فرزاد قانعی Farzad Ghanei

مجوز
Creative Commons ― CC BY 3.0\nنسخه‌بندی معنایی 2.0.0\nبه فرض اینکه نسخهٔ MAJOR.MINOR.PATCH یا اصلی.جزیی.وصله داده شده است:\nشمارهٔ نسخهٔ اصلی (MAJOR) را زمانی افزایش دهید که تغییرات API ناسازگار اعمال کرده‌اید،\nشمارهٔ نسخهٔ جزیی (MINOR) را زمانی افزایش دهید که قابلیت‌هایی اضافه کرده‌اید که با نسخه‌های قبل سازگار هستند،\nشمارهٔ نسخهٔ وصله (PATCH) را زمانی افزایش دهید که تصحیح خطاهایی (bug) اعمال کرده‌اید که با نسخه‌های قبل سازگار هستند.\nبرچسب‌های اضافی برای پیش‌نشر و ساختن فراداده به صورت پسوندهایی برای قالب MAJOR.MINOR.PATCH فراهم است.\nدر دنیای مدیریت نرم‌افزار مکان مخوفی به نام «جهنم وابستگی» (dependency hell) وجود دارد. هر چه سیستم شما بزرگتر باشد و بسته‌های (package) بیشتری با نرم‌افزار شما یکپارچه شده باشند، احتمال بیشتری وجود دارد که روزی خود را دراین گودال ناامیدی بیابید.\nدر سیستم‌هایی با وابستگی‌های زیاد، انتشار بستهٔ جدید به زودی می‌تواند تبدیل به یک کابوس شود. اگر ویژگی‌های وابستگی‌ها بسیار جزئی‌نگرانه باشد، در خطر قفل نسخه (version lock) خواهید بود (ناتوانی برای بروزرسانی یک بسته، بدون اجبار جهت انتشار نسخه‌های جدید همهٔ بسته‌های وابسته). اگر وابستگی‌ها بسیار ضعیف مشخص شده باشند، به ناچار زخم بی‌قاعدگی نسخه را خواهید خورد (به فرض سازگاری بیش از حد معقول با نسخه‌های آتی‌تر). جهنم وابستگی آنجایی است که قفل نسخه و یا بی‌قاعدگی نسخه از پیشرفت رو به جلوی آسان و امن پروژهٔ شما جلوگیری می‌کند.\nبرای پاسخگویی به این مشکل، من یکسری قوانین و پیش‌نیازهای ساده را پیشنهاد میدهم که نحوهٔ تخصیص و افزایش شماره‌های نسخه را دیکته میکند. این قوانین برپایهٔ شیوه‌های موجود رایج و گستردهٔ در حال استفاده، هم در نرم‌افزارهای متن‌باز و غیر متن‌باز است، اگرچه لزوماً محدود به آن نیست. برای آنکه این سیستم کار کند نخست لازم است یک API عمومی (public) تعریف کنید. این امر ممکن است شامل مستندسازی، یا بوسیلهٔ خود کد مقید شده باشد. صرف نظر از این موضوع، مهم است که این API دقیق و واضح باشد. زمانیکه  API عمومی خود را مشخص کردید، تغییرات آن را با افزایش معین شمارهٔ نسخهٔ خود مرتبط می‌سازید. قالب نسخهای به صورت X.Y.Z را در نظر بگیرید. خطاهایی که تاثیری بر API ندارند، نسخهٔ وصله (Patch) را افزایش می‌دهند، افزایش یا تغییر API که با نسخه‌های قبلی سازگار است، نسخهٔ جزیی (Minor) را افزایش میدهند، و تغییرات API که با نسخه‌های قبل ناسازگار هستند، نسخهٔ اصلی (Major) را افزایش می‌دهند.\nمن این سیستم را «نسخه‌بندی معنایی» می‌نامم. بر اساس این طرح، شماره‌های نسخه و روشی که تغییر می‌کنند، معنی و مفهومی را دربارهٔ کد تحت آن نسخه، و آنچه که از یک نسخه تا نسخه‌ای دیگر ویرایش شده است، انتقال می‌دهد.\nویژگی‌های نسخه‌بندی معنایی (SemVer)\nکلمات کلیدی «باید»، «نباید»، «نیاز است»، «می‌بایست»، «نمی‌بایست»، «توصیه شده است»، «ممکن است» و «اختیاری» در این مستند می‌بایست بر مبنای آنچه در  RFC 2119  تعریف شده است، معنا شوند.\nنرم‌افزارهایی که از نسخه‌بندی معنایی استفاده می‌کنند باید یک API عمومی اعلام کنند. این API می‌تواند در خود کد اعلام شود، یا به طور واضح در مستندسازی وجود داشته باشد. هر طور که انجام شود، می‌بایست دقیق و جامع باشد.\nنرم‌افزارهایی که از نسخه‌بندی معنایی استفاده می‌کنند باید یک API عمومی اعلام کنند. این API می‌تواند در خود کد اعلام شود، یا به طور واضح در مستندسازی وجود داشته باشد. هر طور که انجام شود، می‌بایست دقیق و جامع باشد.\nیک شمارهٔ نسخهٔ عادی باید قالب X.Y.Z را داشته باشه طوری که در آن X ،Y و Z اعداد صحیح غیرمنفی هستند و نباید صفر اضافه (leading zero) داشته باشند.  X نسخهٔ اصلی، Y  نسخه جزیی، و Z نسخهٔ وصله است. هر عنصر باید به صورت شمارشی افزایش یابد. به عنوان مثال  1.9.0 -> 1.10.0 -> 1.11.0.\nیک شمارهٔ نسخهٔ عادی باید قالب X.Y.Z را داشته باشه طوری که در آن X ،Y و Z اعداد صحیح غیرمنفی هستند و نباید صفر اضافه (leading zero) داشته باشند.  X نسخهٔ اصلی، Y  نسخه جزیی، و Z نسخهٔ وصله است. هر عنصر باید به صورت شمارشی افزایش یابد. به عنوان مثال  1.9.0 -> 1.10.0 -> 1.11.0.\n1.9.0 -> 1.10.0 -> 1.11.0\nزمانی‌که یک بستهٔ نسخه‌بندی شده منتشر شد، محتوای آن نسخه نباید دستکاری شود. هرگونه تغییری باید به عنوان نسخهٔ جدید منتشر شود.\nزمانی‌که یک بستهٔ نسخه‌بندی شده منتشر شد، محتوای آن نسخه نباید دستکاری شود. هرگونه تغییری باید به عنوان نسخهٔ جدید منتشر شود.\nنسخهٔ اصلی شمارهٔ صفر (0.y.z) برای توسعه‌های ابتدایی است. هرچیزی در هر زمانی ممکن است تغییر کند. API  عمومی نمی‌بایست ماندگار در نظر گرفته شود.\nنسخهٔ اصلی شمارهٔ صفر (0.y.z) برای توسعه‌های ابتدایی است. هرچیزی در هر زمانی ممکن است تغییر کند. API  عمومی نمی‌بایست ماندگار در نظر گرفته شود.\nنسخهٔ 1.0.0 API عمومی را تعریف می‌کند. روشی که شمارهٔ نسخهٔ بعد از این انتشار افزوده می‌شود، به این API عمومی و نحوهٔ تغییر آن وابسته است.\nنسخهٔ 1.0.0 API عمومی را تعریف می‌کند. روشی که شمارهٔ نسخهٔ بعد از این انتشار افزوده می‌شود، به این API عمومی و نحوهٔ تغییر آن وابسته است.\nنسخهٔ وصله Z  (x.y.Z | x > 0)  باید در صورتی افزوده شود که تصحیح‌های خطای سازگار با نسخهٔ قبلی معرفی شده باشند. یک تصحیح خطا به عنوان یک تغییر داخلی تعریف می‌شود که رفتارهای نادرست را اصلاح می‌کند.\nنسخهٔ وصله Z  (x.y.Z | x > 0)  باید در صورتی افزوده شود که تصحیح‌های خطای سازگار با نسخهٔ قبلی معرفی شده باشند. یک تصحیح خطا به عنوان یک تغییر داخلی تعریف می‌شود که رفتارهای نادرست را اصلاح می‌کند.\nنسخهٔ جزیی Y (x.Y.z | x > 0) باید در صورتی افزوده شود که عملکرد سازگار با نسخه‌های قبل جدیدی به API عمومی معرفی شده باشد. همچنین اگر هرگونه عملکرد API عمومی به عنوان منسوخ‌شده برچسب خورده باشد، این شماره باید افزوده شود. اگر عملکرد جدید یا بهبود قابل توجهی در کدهای داخلی معرفی شده باشد، ممکن است نسخهٔ جزیی افزوده شود. ممکن است که شامل تغییرات سطح وصله هم باشد. زمانیکه نسخه جزیی افزوده شود، نسخهٔ وصله باید به 0 بازنشانده شود.\nنسخهٔ جزیی Y (x.Y.z | x > 0) باید در صورتی افزوده شود که عملکرد سازگار با نسخه‌های قبل جدیدی به API عمومی معرفی شده باشد. همچنین اگر هرگونه عملکرد API عمومی به عنوان منسوخ‌شده برچسب خورده باشد، این شماره باید افزوده شود. اگر عملکرد جدید یا بهبود قابل توجهی در کدهای داخلی معرفی شده باشد، ممکن است نسخهٔ جزیی افزوده شود. ممکن است که شامل تغییرات سطح وصله هم باشد. زمانیکه نسخه جزیی افزوده شود، نسخهٔ وصله باید به 0 بازنشانده شود.\n(x.Y.z | x > 0) باید در صورتی افزوده شود که عملکرد سازگار با نسخه‌های قبل جدیدی به API عمومی معرفی شده باشد. همچنین اگر هرگونه عملکرد API عمومی به عنوان منسوخ‌شده برچسب خورده باشد، این شماره باید افزوده شود. اگر عملکرد جدید یا بهبود قابل توجهی در کدهای داخلی معرفی شده باشد، ممکن است نسخهٔ جزیی افزوده شود. ممکن است که شامل تغییرات سطح وصله هم باشد. زمانیکه نسخه جزیی افزوده شود، نسخهٔ وصله باید به 0 بازنشانده شود.\nنسخهٔ اصلی X (X.y.z | X > 0) باید در صورتی افزوده شود که هرگونه تغییرات ناسازگار با نسخه‌های قبل به API عمومی معرفی شده باشد. ممکن است این تغییرات شامل سطوح جزیی و وصله نیز باشد. نسخهٔ جزیی و وصله زمانیکه نسخهٔ اصلی افزوده می‌شود باید به 0 بازنشانی شوند.\nنسخهٔ اصلی X (X.y.z | X > 0) باید در صورتی افزوده شود که هرگونه تغییرات ناسازگار با نسخه‌های قبل به API عمومی معرفی شده باشد. ممکن است این تغییرات شامل سطوح جزیی و وصله نیز باشد. نسخهٔ جزیی و وصله زمانیکه نسخهٔ اصلی افزوده می‌شود باید به 0 بازنشانی شوند.\nیک نسخهٔ پیش‌انتشار ممکن است با اضافه کردن یک خط تیره و یک سری شناسه‌هایی که به وسیلهٔ نقطه از هم جدا ‌شده‌اند و بلافاصله به دنبال نسخهٔ وصله می‌آیند، نشانه‌گذاری شود. شناسه‌ها باید تنها شامل اعداد و حروف الفبای اَسکی (ASCII)  و خط تیره [A-Za-z0-9] باشند. شناسه‌ها نباید تهی باشند. شناسه‌های عددی نباید با صفر اضافه آغاز شوند. نسخهٔ پیش‌انتشار از اولویت پایین‌تری نسبت به نسخهٔ عادی مرتبط برخوردار است. یک نسخهٔ پیش‌انتشار حاکی از آن است که نسخهٔ ناپایدار است و ممکن است نیازمندی‌های سازگاری مورد نظر را آنگونه که در نسخهٔ عادی مرتبط نشان داده شده است، برآورده نکند. مثال: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nیک نسخهٔ پیش‌انتشار ممکن است با اضافه کردن یک خط تیره و یک سری شناسه‌هایی که به وسیلهٔ نقطه از هم جدا ‌شده‌اند و بلافاصله به دنبال نسخهٔ وصله می‌آیند، نشانه‌گذاری شود. شناسه‌ها باید تنها شامل اعداد و حروف الفبای اَسکی (ASCII)  و خط تیره [A-Za-z0-9] باشند. شناسه‌ها نباید تهی باشند. شناسه‌های عددی نباید با صفر اضافه آغاز شوند. نسخهٔ پیش‌انتشار از اولویت پایین‌تری نسبت به نسخهٔ عادی مرتبط برخوردار است. یک نسخهٔ پیش‌انتشار حاکی از آن است که نسخهٔ ناپایدار است و ممکن است نیازمندی‌های سازگاری مورد نظر را آنگونه که در نسخهٔ عادی مرتبط نشان داده شده است، برآورده نکند. مثال: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\n1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92\nمتادیتای ساخت (build metadata) ممکن است با افزودن یک علامت جمع (+) و یک سری شناسه‌هایی که به وسیلهٔ نقطه ازهم جدا شده‌اند، و بلافاصله به دنبال نسخهٔ وصله یا پیش‌انتشار می‌آیند، نشانه‌گذاری شود. شناسه‌ها باید تنها شامل اعداد و حروف الفبای اَسکی (ASCII)  و خط تیره [A-Za-z0-9] باشند. شناسه‌ها نباید تهی باشند. متادیتای ساخت می‌بایست در زمان تعیین اولویت نسخه درنظر گرفته نشود. بنابراین دو نسخه که تنها در متادیتای ساخت با یکدیگر متفاوت هستند، اولویت یکسان دارند. مثال: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f8\nمتادیتای ساخت (build metadata) ممکن است با افزودن یک علامت جمع (+) و یک سری شناسه‌هایی که به وسیلهٔ نقطه ازهم جدا شده‌اند، و بلافاصله به دنبال نسخهٔ وصله یا پیش‌انتشار می‌آیند، نشانه‌گذاری شود. شناسه‌ها باید تنها شامل اعداد و حروف الفبای اَسکی (ASCII)  و خط تیره [A-Za-z0-9] باشند. شناسه‌ها نباید تهی باشند. متادیتای ساخت می‌بایست در زمان تعیین اولویت نسخه درنظر گرفته نشود. بنابراین دو نسخه که تنها در متادیتای ساخت با یکدیگر متفاوت هستند، اولویت یکسان دارند. مثال: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f8\n1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f8\nاولویت اشاره دارد به اینکه چگونه نسخه‌ها زمانی‌که مرتب شده‌اند با یکدیگر مقایسه می‌شوند. اولویت باید به وسیلهٔ جداسازی نسخه به اصلی، جزیی، وصله و شناسه‌های پیش‌انتشار به همین ترتیب، محاسبه شود (متادیتای ساخت در اولویت نمایان نمی‌شود). اولویت، به وسیلهٔ اولین تفاوت تعیین می‌شود هنگامی که این مشخصه‌ها از چپ به راست مقایسه شوند، بدین صورت: نسخه‌های اصلی، جزیی و وصله همیشه به صورت عددی مقایسه می‌شوند. مثال: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. زمانی که اصلی و جزیی و وصله برابر هستند، یک نسخهٔ پیش‌انتشار از اولویت کمتری نسبت به نسخهٔ عادی برخوردار است. مثال: 1.0.0-   alpha < 1.0.0  اولویت برای دو نسخهٔ پیش‌انتشار با نسخهٔ اصلی، جزیی و وصلهٔ مشابه باید به وسیلهٔ مقایسهٔ هر مشخصه‌ای که با نقطه جدا شده، از چپ به راست مشخص شود تا زمانی که یک تفاوت به شرح زیر یافت شود: شناسه‌هایی که تنها شامل اعداد صحیح هستند به صورت عددی و شناسه‌هایی که با حروف یا خط‌های تیره به صورت الفبایی به ترتیب ASCII مقایسه می شوند. مشخصه‌های عددی همیشه از اولویت کمتری نسبت به مشخصه‌های غیرعددی برخوردار هستند. مجموعه‌های بزرگتری از بخشهای پیش‌انتشار اولویت بیشتری نسبت به مجموعه‌های کوچکتر دارند، اگر همه مشخصه‌های اولویت برابر باشند. مثال: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nاولویت اشاره دارد به اینکه چگونه نسخه‌ها زمانی‌که مرتب شده‌اند با یکدیگر مقایسه می‌شوند. اولویت باید به وسیلهٔ جداسازی نسخه به اصلی، جزیی، وصله و شناسه‌های پیش‌انتشار به همین ترتیب، محاسبه شود (متادیتای ساخت در اولویت نمایان نمی‌شود). اولویت، به وسیلهٔ اولین تفاوت تعیین می‌شود هنگامی که این مشخصه‌ها از چپ به راست مقایسه شوند، بدین صورت: نسخه‌های اصلی، جزیی و وصله همیشه به صورت عددی مقایسه می‌شوند. مثال: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. زمانی که اصلی و جزیی و وصله برابر هستند، یک نسخهٔ پیش‌انتشار از اولویت کمتری نسبت به نسخهٔ عادی برخوردار است. مثال: 1.0.0-   alpha < 1.0.0  اولویت برای دو نسخهٔ پیش‌انتشار با نسخهٔ اصلی، جزیی و وصلهٔ مشابه باید به وسیلهٔ مقایسهٔ هر مشخصه‌ای که با نقطه جدا شده، از چپ به راست مشخص شود تا زمانی که یک تفاوت به شرح زیر یافت شود: شناسه‌هایی که تنها شامل اعداد صحیح هستند به صورت عددی و شناسه‌هایی که با حروف یا خط‌های تیره به صورت الفبایی به ترتیب ASCII مقایسه می شوند. مشخصه‌های عددی همیشه از اولویت کمتری نسبت به مشخصه‌های غیرعددی برخوردار هستند. مجموعه‌های بزرگتری از بخشهای پیش‌انتشار اولویت بیشتری نسبت به مجموعه‌های کوچکتر دارند، اگر همه مشخصه‌های اولویت برابر باشند. مثال: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\n1.0.0 < 2.0.0 < 2.1.0 < 2.1.1\n1.0.0-   alpha < 1.0.0\n1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0\nچرا از نسخه‌بندی معنایی استفاده شود؟\nاین ایده‌ای جدید یا انقلابی نیست. در واقع، احتمالاً شما چیزی مشابه به این را پیش از این انجام داده‌اید. مشکل اینجاست که «مشابه» به اندازهٔ کافی خوب نیست. بدون انطباق با نوعی تعریف رسمی، شماره‌های نسخه ضرورتاً برای مدیریت وابستگی (dependency) بلااستفاده هستند. بوسیلهٔ اختصاص اعداد و تعاریف واضح به ایده‌های بالا، برقراری ارتباط میان کاربران نرم‌افزار شما و اهدافتان آسان‌تر می‌شود. به‌مجرد اینکه این اهداف واضح شود، مشخصات وابستگی انعطاف‌پذیر (نه آن‌چنان انعطاف‌پذیر) می‌تواند نهایتاً ایجاد شود.\nیک مثال ساده می‌تواند نشان دهد که چگونه نسخه‌بندی معنایی می‌تواند جهنم وابستگی را به خاطره‌ای از گذشته تبدیل کند. کتابخانه‌ای به نام «Firetruck» را در نظر بگیرید. این کتابخانه به یک بسته به نام «Ladder» که به صورت معنایی نسخه‌بندی شده، احتیاج دارد. در زمانی که firetruck ساخته شده، Ladder در نسخهٔ 3.1.0 است، شما می‌توانید وابستگی Ladder را با آسودگی به عنوان بزرگتر یا برابر با 3.1.0 و نه کمتر از 4.0.0 تعیین کنید. شما می‌توانید آن‌ها را در سیستم مدیریت بستهٔ خود منتشر کنید و بدانید که آن‌ها با نرم‌افزار وابسته موجود سازگار هستند.\nبدون شک به عنوان یک توسعه‌دهندهٔ مسئولیت‌پذیر شما خواهید خواست که هر بسته همان‌طورکه اعلان شده ارتقاء یابد. دنیای واقعی مکان به هم ریخته ایست، ما جز اینکه هشیار باشیم نمی‌توانیم کاری دربارهٔ آن انجام دهیم. آنچه شما می‌توانید انجام دهید این است که بگذارید نسخه‌بندی معنایی به شما یک راه عاقلانه ارائه دهد، تا بسته‌ها را منتشر کرده و ارتقاء دهد بدون آنکه نسخه‌های جدیدی از بسته‌های مستقل را راه اندازی کند و شما را عذاب نداده، در وقت شما صرفه‌جویی کند..\nاگر همهٔ این‌ها مطلوب به نظر می‌رسد، همهٔ آنچه شما برای شروع استفاده از نسخه‌بندی معنایی احتیاج دارید این است که اعلام کنید که در حال انجام این کار هستید و از قوانین پیروی کنید. به این وب‌سایت از طریق صفحه README خود لینک بزنید، در نتیجه دیگران دربارهٔ قوانین خواهند دانست و از آن نفع خواهند برد.\nچگونه باید با نسخه‌ها در فاز توسعهٔ ابتدایی 0.y.z  کنار بیایم؟\nساده‌ترین کار برای انجام دادن این است که توسعهٔ ابتدایی خود را از انتشار 0.1.0  آغاز کنید و سپس نسخهٔ جزیی را برای هر انتشار آتی افزایش دهید.\nچگونه بدانم چه زمانی باید 1.0.0 را منتشر کنم؟\nاگر نرم‌افزار شما در طول تولید مورد استفاده قرار گرفته است، احتمالاً می‌بایست هم‌اکنون 1.0.0 باشد. اگر یک API ماندگار دارید که کاربران روی آن حساب می‌کنند، شما باید 1.0.0 باشید. اگر در مورد سازگاری با نسخه‌های قبل خیلی نگران هستید، احتمالاً می‌بایست هم‌اکنون 1.0.0 باشید.\nآیا این روش، توسعه و تکرار سریع را کند نمی کند؟\nنسخهٔ اصلی صفر تماماً در مورد توسعهٔ سریع است. اگر شما API را هر روز تغییر می‌دهید، یا باید هنوز در نسخهٔ 0.y.z  باشید یا در یک شاخهٔ توسعهٔ جداگانه که بر نسخهٔ اصلی بعدی کار می‌کند هستید.\nاگر حتی کوچکترین تغییرات ناسازگار با نسخه‌های قبل در API عمومی نیازمند یک نسخهٔ اصلی باشد، آیا من خیلی سریع به نسخه 42.0.0 نخواهم رسید؟\nاین سوال یک توسعه‌دهندهٔ مسئولیت‌پذیر و آینده‌نگر است. تغییرات ناسازگار نمی‌بایست به راحتی در نرم‌افزاری که کدهای وابستهٔ زیادی دارد معرفی شود. هزینه‌ای که برای ارتقاء باید متحمل شد می‌تواند قابل توجه باشد. اجبار برای ایجاد نسخه‌های اصلی برای انتشار تغییرات ناسازگار، یعنی شما به تأثیر تغییراتتان فکر خواهید کرد و نرخ هزینه/سود مورد نظر را خواهید سنجید.\nمستندسازی تمامی  API عمومی کار بسیار زیاد می‌برد!\nاین مسئولیت شما به عنوان یک توسعه‌دهندهٔ حرفه‌ای است تا به طور مناسب نرم‌افزار که می‌بایست توسط دیگران مورد استفاده قرار گیرد را مستندسازی کنید. مدیریت پیچیدگی نرم‌افزار یک بخش فوق‌العاده مهم ازکارآمد نگه‌داشتن پروژه است، و انجام آن سخت است اگر کسی نداند که چگونه نرم‌افزار شما را استفاده کند یا چه متدهایی برای صدا زدن امن است. در دراز مدت، نسخه‌بندی معنایی و پافشاری بر یک API عمومی خوش‌تعریف می‌تواند همه چیز و همه کس را در اجرا کردن راحت در موقعیت مناسبی نگه دارد.\nچه کار می‌توانم بکنم اگر تصادفاً یک تغییر ناسازگار با نسخه‌های قبل را به عنوان نسخهٔ جزیی منتشر کردم؟\nبه مجرد اینکه متوجه این مورد بشوید، تنظیمات نسخه‌بندی معنایی را به هم زده‌اید، مشکل را حل کنید و یک نسخهٔ جزیی جدید که مشکل را تصحیح کند و سازگاری با نسخه‌های قبل را بازگرداند، منتشر سازید. حتی تحت این شرایط، این پذیرفته شده نیست که انتشارهای نسخه‌بندی شده را دستکاری کنید. اگر مناسب است نسخهٔ متخلف را مستند‌سازی کنید و کاربران خود را از مشکل مطلع سازید تا آن ها نیز از نسخهٔ متخلف آگاه باشند.\nچه کار باید بکنم اگر وابستگی‌های خودم را بدون تغییر دادن API عمومی به‌روزرسانی کردم؟\nاین مورد تا زمانی که API عمومی را متأثر نسازد سازگار تلقی خواهد شد. نرم‌افزاری که صریحاً به همان وابستگی‌هایی که بستهٔ شما وابسته است، وابسته باشد، باید مشخصات وابستگی خود را داشته باشد و نویسنده باید هرگونه مغایرت را ذکر کند. تشخیص اینکه آیا تغییر ازنوع دستکاری در سطح جزیی است یا سطح وصله، به این بستگی دارد که آیا شما وابستگی‌های خود را جهت تصحیح یک خطا یا برای یک کاربرد جدید به‌روزرسانی کرده‌اید. من معمولاً کد اضافی برای موارد آتی در نظر می‌گیرم، که بدون شک این موارد افزایش سطح جزیی می‌باشد.\nچه می شود اگر من بدون اعلام قبلی API عمومی را به صورتی تغییر دهم که با تغییر عدد نسخه سازگار نباشد؟ (یعنی کد به نادرست تغییر اصلی‌ای را در انتشار وصله معرفی می‌کند)\nاز بهترین قضاوت خود استفاده کنید. اگر شما مخاطبان زیادی دارید که به شدت به وسیلهٔ تغییر رفتار به آنچه قبلاً برای API  عمومی در نظر گرفته شده، متأثر خواهند شد، پس بهترین کار انجام یک انتشار نسخهٔ اصلی است، حتی اگر اصلاح اعمال شده مؤکداً یک انتشار وصله محسوب شود. به یاد داشته باشید، نسخه‌بندی معنایی تماماً دربارهٔ انتقال معنا بوسیله چگونگی تغییر عدد نسخه می‌باشد. اگر این تغییرات برای کاربران شما مهم است، از عدد نسخه برای آگاه‌سازی آن‌ها استفاده کنید.\nچگونه باید با منسوخ کردن عملکرد (deprecating functionality) کنار بیایم؟\nمنسوخ کردن عملکرد موجود بخشی عادی از توسعهٔ نرم‌افزار است و معمولاً برای این‌که پیشرفت رو به جلو حاصل شود مورد نیاز است. زمانی‌که بخشی از API عمومی خود را منسوخ می‌کنید، باید دو کار انجام دهید: ۱) مستندسازی خود را به‌روزرسانی کنید تا به کاربر اجازه دهید از تغییرات باخبر شود. ۲) یک انتشار جزیی که در آن قسمت منسوخ شده در جایگاه خود باشد منتشر کنید. قبل از آنکه عملکرد را به طورکامل در یک انتشار اصلی حذف کنید حتماً باید حداقل یک انتشار جزیی که شامل قسمت منسوخ شده است وجود داشته باشد تا کاربران به راحتی بتوانند به API جدید منتقل شوند.\nآیا SemVer محدودیت اندازه بر روی رشتهٔ نسخه دارد؟\nخیر، اما از قضاوت مناسبی استفاده کنید. به عنوان مثال یک نسخهٔ ۲۵۵ نویسه‌ای احتمالاً مفید نخواهد بود! همچنین، سیستم‌های خاص ممکن است محدودیت‌های خود برای اندازهٔ رشته اعمال کنند.\nنویسنده : Tom Preston-Werner, سازنده Gravatars و
 بنیان‌گذار GitHub.\nاگر مایل به ارائهٔ بازخورد خود هستید، لطفاً یک مورد در بخش issue سایت GitHub باز کنید.
 open an issue on GitHub.\nopen an issue on GitHub\nمترجم بخش فارسی : مجید حاجیان Majid Hajian 
ویراستار: فرزاد قانعی Farzad Ghanei\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nGestion sémantique de version 2.0.0

En bref

Étant donné un numéro de version MAJEUR.MINEUR.CORRECTIF, il faut incrémenter :


  le numéro de version MAJEUR quand il y a des changements non rétrocompatibles,
  le numéro de version MINEUR quand il y a des ajouts de fonctionnalités rétrocompatibles,
  le numéro de version de CORRECTIF quand il y a des corrections d’anomalies rétrocompatibles.


Des libellés supplémentaires peuvent être ajoutés pour les versions de pré-livraison et pour
des méta-données de construction sous forme d’extension du format MAJEURE.MINEURE.CORRECTIF.

Introduction

Dans le monde de la gestion des logiciels, il existe un endroit redouté appelé
« l’enfer des dépendances » (de l’anglais dependency hell). Plus votre système se
développe et plus vous intégrez de composants dans votre logiciel, plus vous êtes
susceptible de vous trouver un jour dans cet abîme de désespoir.

Dans les systèmes comportant de nombreuses dépendances, publier une nouvelle
version d’un composant peut vite devenir un cauchemar. Si les règles de
dépendance sont trop strictes, vous risquez de verrouiller vos versions
(incapacité de mettre à jour un composant sans avoir à publier une nouvelle
version de chaque composant qui en dépend). Si les règles de dépendances sont
trop lâches, vous allez inévitablement subir la promiscuité de version (supposer
une compatibilité avec plus de futures versions que raisonnable). L’enfer des
dépendances est l’endroit où vous vous trouvez lorsque vous êtes bloqué dans
une version et/ou qu’une incompatibilité de version vous empêche d’avancer
sans risque dans votre projet.

Comme solution à ce problème, je propose un ensemble de règles et d’exigences
simples qui dictent la façon dont les numéros de version sont attribués et
incrémentés. Ces règles sont basées mais pas nécessairement limitées à des
pratiques très répandues aussi bien dans les domaines du logiciel privé que du
logiciel libre. Pour que ce système fonctionne, vous devez d’abord déclarer une API
publique. Il peut s’agir d’un document ou de règles imposées par le code lui-même. Quoi qu’il en soit, il est important que cette API soit claire et précise.
Une fois celle-ci prête, vous communiquez ses modifications par des incrémentations
successives de son numéro de version. Considérons le format de version X.Y.Z
où X, Y et Z identifient la version (Majeure.Mineure.Corrective). Les corrections qui
n’affectent pas l’API incrémentent le dernier identifiant qui est l’identifiant de
version de correction. Lors d’ajouts ou de modifications rétrocompatibles de l’API,
il faut incrémenter l’identifiant de version mineure. Enfin, pour des modifications
non rétrocompatibles, il faut incrémenter l’identifiant de version majeure.

J’appelle ce système « gestion sémantique de version ». Avec ce système, les numéros de
version, et la façon dont ils changent, donnent du sens au code sous-jacent et à ce
qui a été modifié d’une version à l’autre.

Spécification de la gestion sémantique de version (SemVer)

Les mots clés “DOIT”, “NE DOIT PAS”, “OBLIGATOIRE”, “DEVRA”, “NE DEVRA PAS”,
“DEVRAIT”, “NE DEVRAIT PAS”, “RECOMMANDÉ”, “PEUT”, et “OPTIONNEL” dans ce
document doivent être interprétés comme décrit dans la RFC 2119.


  
    Tout logiciel utilisant la gestion sémantique de version DOIT déclarer une API
publique. Cette API peut être déclarée dans le code lui-même ou dans un document.
Dans tous les cas, elle doit être précise et claire.
  
  
    Un numéro de version standard DOIT prendre la forme X.Y.Z où X, Y et Z sont
des entiers non négatifs et NE DOIVENT PAS être préfixés par des zéros. X
représente l’identifiant de version majeure, Y représente l’identifiant de version mineure
et Z l’identifiant de version de correction. Chaque élément DOIT s’incrémenter
numériquement.
Exemple : 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Une fois qu’un composant est publié, le contenu de sa version NE DOIT PAS
être modifié. Toute modification DOIT être publiée dans une nouvelle version.
  
  
    L’identifiant de version majeure zéro (0.y.z) est destiné au développement initial.
Tout ou partie peut être modifié à tout moment. L’API publique ne devrait pas
être considérée comme stable.
  
  
    La version 1.0.0 définit l’API publique. La façon dont le numéro de version
est incrémenté après cette publication est dépendante de cette API publique et
de ses évolutions.
  
  
    L’identifiant de version de correction Z (x.y.Z | x > 0) DOIT être incrémenté
si seules des corrections rétrocompatibles sont introduites. Une correction
est définie comme un changement interne qui corrige un comportement incorrect.
  
  
    L’identifiant de version mineure Y (x.Y.z | x > 0) DOIT être incrémenté si de
nouvelles fonctionnalités rétrocompatibles sont introduites dans l’API
publique. Il DOIT être incrémenté si une fonctionnalité de l’API publique
est marquée comme obsolète. Il PEUT être incrémenté si de nouvelles fonctionnalités
ou améliorations substantielles sont introduites dans le code privé. Il PEUT
inclure dans le même temps des corrections. L’identifiant de version de correction
DOIT être remis à zéro lorsque l’identifiant de version mineure est incrémenté.
  
  
    L’identifiant de version majeur X (X.y.z | X > 0) DOIT être incrémenté si des
changements non rétrocompatibles sont introduits dans l’API publique. Cela PEUT
inclure dans le même temps des changements mineurs et des corrections. Les
identifiants de version mineure et de correction DOIVENT être remis à zéro quand
l’identifiant de version majeure est incrémenté.
  
  
    Une version de pré-livraison PEUT être notée par l’ajout d’un trait d’union et d’une
série d’identifiants séparés par des points suivant immédiatement l’identifiant de version
de correction. Les identifiants DOIVENT être composés uniquement de caractères
alphanumériques ASCII et de traits d’union [0-9A-Za-z-]. Les identifiants NE DOIVENT PAS
être vides. Les identifiants numériques NE DOIVENT PAS être préfixés par des zéros.
Les versions de pré-livraison précèdent la version normale associée (version de
pré-livraison < version normale). Une version de pré-livraison indique que la version
n’est pas stable et ne satisfait pas forcément les exigences de compatibilité
associées à une version normale.
Exemples : 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Les méta-données de construction PEUVENT être notées par l’ajout d’un signe
« plus » et d’une série d’identifiants séparés par des points suivant immédiatement
l’identifiant de version de correction ou de pré-livraison. Les identifiants DOIVENT
être composés uniquement de caractères alphanumériques ASCII et de traits d’union [0-9A-Za-z-].
Les identifiants NE DOIVENT PAS être vides. Les méta-données de construction DEVRAIENT
être ignorées dans l’ordre des versions. Autrement dit, deux versions qui diffèrent
seulement par leurs informations de construction ont la même priorité.
Exemples : 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    La priorité définit la façon dont sont ordonnées les versions entre elles.
La priorité DOIT être calculée en séparant les identifiants de versions entre
majeures, mineures, de correction et de pré-livraison, en suivant cet ordre
(les informations de construction n’entrent pas en compte dans la comparaison).
La priorité est déterminée par la première différence apparaissant dans la comparaison
de chacun de ces identifiants dans l’ordre : majeur, mineur et correctif. Ces
identifiants sont toujours comparés numériquement.
Exemple : 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
Lorsque ces identifiants sont identiques, une version de pré-livraison est moins
prioritaire qu’une version normale.
Exemple : 1.0.0-alpha < 1.0.0.
La priorité pour deux versions de pré-livraison ayant les mêmes identifiants de
version majeure, mineure et de correction DOIT être déterminée en comparant chaque
identifiant séparé par un point de la gauche vers la droite jusqu’à ce qu’une
différence soit trouvée, comme suit : les identifiants composés uniquement de
chiffres sont comparés numériquement et les identifiants contenant des lettres
ou des traits d’union sont comparés dans l’ordre ASCII. Les identifiants numériques
sont toujours moins prioritaires que les identifiants non numériques (identifiants
numériques < identifiants non-numériques). Un ensemble de champs plus long est
prioritaire par rapport à un ensemble de champs plus court si tous les identifiants
précédents sont identiques.
Exemple : 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Pourquoi utiliser la gestion sémantique de version ?

Il ne s’agit pas d’une idée nouvelle ou révolutionnaire. En fait, vous faites
probablement déjà quelque chose d’approchant. Et le problème vient du fait que
« quelque chose de proche » n’est pas suffisant. Sans conformité avec une méthode
formelle, les numéros de version deviennent inutilisables pour la gestion de
vos dépendances. En donnant un nom et une définition claire aux idées exposées
ci-dessus, il devient facile de communiquer vos intentions aux utilisateurs
de votre logiciel. Une fois que vos intentions sont claires, une spécification
souple (mais pas « trop » souple) des dépendances peut être réalisée.

Un exemple simple permet de montrer comment la gestion sémantique de version peut
faire de l’enfer des dépendances, une chose du passé. Considérons une bibliothèque
appelée « CamionDePompier ». Elle nécessite un composant appelé « Échelle » dont la
version est gérée sémantiquement. Lorsque la librairie CamionDePompier est créée,
Échelle en est à sa version 3.1.0. Et puisque CamionDePompier utilise des fonctionnalités
qui ont été introduites en 3.1.0, vous pouvez spécifier, sans courir le moindre risque,
une dépendance vers Échelle plus grande ou égale à 3.1.0 mais inférieure à 4.0.0.
Maintenant, lorsque les versions 3.1.1 et 3.2.0 de Échelle seront disponibles, vous
pourrez les publier dans votre système de gestion de dépendances en sachant qu’elles
seront compatibles avec les logiciels existants qui en dépendent.

En tant que développeur responsable, bien entendu, vous voudrez vérifier que toute
mise à jour de composant fonctionne comme annoncée. Dans la réalité, les choses ne
sont pas forcément toujours très cohérentes ; il n’y a donc rien d’autre à faire que
de rester vigilant. Ce que vous pouvez cependant faire est de laisser la gestion
sémantique de version vous fournir une manière saine de publier et mettre à jour vos
composants et ainsi ne pas avoir besoin de déployer de nouvelles versions de vos
sous-composants vous permettant ainsi d’économiser du temps et du souci.

Si tout cela vous semble intéressant, tout ce que vous avez à faire pour commencer
à utiliser la gestion sémantique de version est de déclarer que vous le faites
et d’en suivre les règles. Ajoutez ensuite un lien vers ce site web dans votre
README pour que d’autres puissent en connaître les règles et en bénéficier.

FAQ

Comment dois-je gérer les révisions dans la phase initiale de développement 0.y.z ?

La chose la plus simple à faire est de commencer vos développements avec
une version initiale à 0.1.0 puis d’incrémenter l’identifiant de version mineure
pour chaque nouvelle publication.

Comment savoir quand publier la version 1.0.0 ?

Si votre logiciel est utilisé en environnement de production ou que vous avez
une API stable de laquelle des utilisateurs ont commencé à dépendre, vous devriez
probablement déjà être en version 1.0.0. Et si vous vous faites déjà du souci
pour la rétro-compatibilité, vous devriez également avoir dépassé la 1.0.0.

N’est-ce pas décourager le développement rapide et les itérations courtes ?

La version majeure zéro est faite pour un développement
rapide. Si vous changez votre API tous les jours, vous devriez toujours être
en version 0.y.z ou sur une branche de développement séparée en préparant la
prochaine version majeure.

Si le moindre changement non rétrocompatible de l’API publique nécessite une incrémentation de l’identifiant de version majeure, ne vais-je pas me retrouver à la version 42.0.0 très rapidement ?

C’est une question de développement responsable et d’anticipation. Les changements
incompatibles ne doivent pas être introduits à la légère dans du logiciel dont
beaucoup de code source dépend. Le coût d’une mise à jour vers une nouvelle version
peut être important. Le besoin de faire évoluer la version majeure pour publier des
changements non rétrocompatibles signifie que vous aurez mesuré les implications de
vos modifications et évalué le rapport entre leur coût et leurs bénéfices.

Documenter l’ensemble de l’API publique demande trop de travail !

Il est de votre responsabilité en tant que développeur professionnel de documenter
correctement le logiciel qui est destiné à être utilisé par d’autres. Gérer la
complexité d’un logiciel est un élément extrêmement important pour maintenir son
projet efficacement. Cela devient difficile à faire quand personne ne sait comment
utiliser votre logiciel ou ne connaît les bonnes méthodes à appeler. Sur le long
terme, la gestion sémantique de version et les efforts dans la conservation d’une
API publique bien définie permettront à tout le monde d’avancer sans problème.

Que faire si j’ai accidentellement publié un changement non rétrocompatible dans une version mineure ?

Dès que vous réalisez que vous avez cassé votre gestion sémantique de version,
corrigez le problème et publiez une nouvelle version mineure qui rétablit la
compatibilité avec les versions précédentes. Même dans de telles circonstances,
il est inacceptable de modifier une version déjà publiée. Mettez à jour la
documentation en signalant la version défectueuse et informez vos utilisateurs
de ce problème.

Que dois-je faire lorsque je mets à jour mes propres dépendances sans changer l’API publique ?

Cela peut être considéré comme compatible dans la mesure où cela n’affecte pas l’API
publique. Les logiciels qui dépendent des mêmes librairies que votre composant
devraient avoir leur propre spécification de dépendances et l’auteur remarquera ainsi
tout conflit. Pour déterminer si la modification est de niveau correctif ou mineur,
il faut vous poser la question de savoir si vous avez mis à jour vos dépendances pour
corriger un bug ou pour introduire une nouvelle fonctionnalité. Je considère
généralement l’ajout de nouveau code comme la deuxième option ce qui sous-entend
évidemment un incrément de l’identifiant de version mineure.

Que faire si par mégarde je modifie l’API publique d’une façon qui ne correspond pas au changement de numéro de version (exemple : le code introduit un changement non rétrocompatible dans une publication de correctif) ?

C’est à vous de décider. Si vous avez une large audience qui sera considérablement
affectée par un retour à ce que l’API publique prévoyait, alors il est peut être préférable
de publier une version majeure, même si la livraison pourrait être uniquement considérée
comme un correctif. Souvenez-vous encore que la gestion sémantique de version consiste
essentiellement à transmettre du sens dans la façon dont le numéro de version change. Si
ces changements sont importants pour vos utilisateurs, utilisez les numéros de version
pour les en informer.

Comment dois-je traiter les fonctionnalités obsolètes ?

Rendre des fonctionnalités obsolètes est une part normale du développement de logiciels
et cela est souvent nécessaire pour aller de l’avant. Lorsque vous dépréciez une partie
de votre API publique, vous devez faire deux choses : (1) mettre à jour la documentation
pour informer les utilisateurs du changement, (2) publier une nouvelle version mineure
avec la dépréciation en place. Avant que vous ne supprimiez complètement la fonctionnalité
dans une nouvelle version majeure, il devrait y avoir au moins une version mineure qui
contient la dépréciation pour que les utilisateurs puissent effectuer la transition en douceur.

Est-ce que la gestion sémantique de version spécifie une limite de taille pour la chaîne de caractères d’un numéro de version ?

Non, mais faites preuve de bon sens. Par exemple, un numéro de version de 255 caractères
est probablement excessif. De plus, certains systèmes peuvent imposer leurs propres limites
sur cette taille.

À propos

La spécification de la gestion sémantique de version est écrite par Tom
Preston-Werner, inventeur de Gravatars et
cofondateur de GitHub.

Si vous souhaitez laisser des commentaires, veuillez ouvrir un ticket sur
GitHub.

Licence

Creative Commons ― CC BY 3.0\nGestion sémantique de version 2.0.0\nÉtant donné un numéro de version MAJEUR.MINEUR.CORRECTIF, il faut incrémenter :\nle numéro de version MAJEUR quand il y a des changements non rétrocompatibles,\nle numéro de version MINEUR quand il y a des ajouts de fonctionnalités rétrocompatibles,\nle numéro de version de CORRECTIF quand il y a des corrections d’anomalies rétrocompatibles.\nDes libellés supplémentaires peuvent être ajoutés pour les versions de pré-livraison et pour
des méta-données de construction sous forme d’extension du format MAJEURE.MINEURE.CORRECTIF.\nDans le monde de la gestion des logiciels, il existe un endroit redouté appelé
« l’enfer des dépendances » (de l’anglais dependency hell). Plus votre système se
développe et plus vous intégrez de composants dans votre logiciel, plus vous êtes
susceptible de vous trouver un jour dans cet abîme de désespoir.\nDans les systèmes comportant de nombreuses dépendances, publier une nouvelle
version d’un composant peut vite devenir un cauchemar. Si les règles de
dépendance sont trop strictes, vous risquez de verrouiller vos versions
(incapacité de mettre à jour un composant sans avoir à publier une nouvelle
version de chaque composant qui en dépend). Si les règles de dépendances sont
trop lâches, vous allez inévitablement subir la promiscuité de version (supposer
une compatibilité avec plus de futures versions que raisonnable). L’enfer des
dépendances est l’endroit où vous vous trouvez lorsque vous êtes bloqué dans
une version et/ou qu’une incompatibilité de version vous empêche d’avancer
sans risque dans votre projet.\nComme solution à ce problème, je propose un ensemble de règles et d’exigences
simples qui dictent la façon dont les numéros de version sont attribués et
incrémentés. Ces règles sont basées mais pas nécessairement limitées à des
pratiques très répandues aussi bien dans les domaines du logiciel privé que du
logiciel libre. Pour que ce système fonctionne, vous devez d’abord déclarer une API
publique. Il peut s’agir d’un document ou de règles imposées par le code lui-même. Quoi qu’il en soit, il est important que cette API soit claire et précise.
Une fois celle-ci prête, vous communiquez ses modifications par des incrémentations
successives de son numéro de version. Considérons le format de version X.Y.Z
où X, Y et Z identifient la version (Majeure.Mineure.Corrective). Les corrections qui
n’affectent pas l’API incrémentent le dernier identifiant qui est l’identifiant de
version de correction. Lors d’ajouts ou de modifications rétrocompatibles de l’API,
il faut incrémenter l’identifiant de version mineure. Enfin, pour des modifications
non rétrocompatibles, il faut incrémenter l’identifiant de version majeure.\nJ’appelle ce système « gestion sémantique de version ». Avec ce système, les numéros de
version, et la façon dont ils changent, donnent du sens au code sous-jacent et à ce
qui a été modifié d’une version à l’autre.\nSpécification de la gestion sémantique de version (SemVer)\nLes mots clés “DOIT”, “NE DOIT PAS”, “OBLIGATOIRE”, “DEVRA”, “NE DEVRA PAS”,
“DEVRAIT”, “NE DEVRAIT PAS”, “RECOMMANDÉ”, “PEUT”, et “OPTIONNEL” dans ce
document doivent être interprétés comme décrit dans la RFC 2119.\nTout logiciel utilisant la gestion sémantique de version DOIT déclarer une API
publique. Cette API peut être déclarée dans le code lui-même ou dans un document.
Dans tous les cas, elle doit être précise et claire.\nTout logiciel utilisant la gestion sémantique de version DOIT déclarer une API
publique. Cette API peut être déclarée dans le code lui-même ou dans un document.
Dans tous les cas, elle doit être précise et claire.\nUn numéro de version standard DOIT prendre la forme X.Y.Z où X, Y et Z sont
des entiers non négatifs et NE DOIVENT PAS être préfixés par des zéros. X
représente l’identifiant de version majeure, Y représente l’identifiant de version mineure
et Z l’identifiant de version de correction. Chaque élément DOIT s’incrémenter
numériquement.
Exemple : 1.9.0 -> 1.10.0 -> 1.11.0.\nUn numéro de version standard DOIT prendre la forme X.Y.Z où X, Y et Z sont
des entiers non négatifs et NE DOIVENT PAS être préfixés par des zéros. X
représente l’identifiant de version majeure, Y représente l’identifiant de version mineure
et Z l’identifiant de version de correction. Chaque élément DOIT s’incrémenter
numériquement.
Exemple : 1.9.0 -> 1.10.0 -> 1.11.0.\nUne fois qu’un composant est publié, le contenu de sa version NE DOIT PAS
être modifié. Toute modification DOIT être publiée dans une nouvelle version.\nUne fois qu’un composant est publié, le contenu de sa version NE DOIT PAS
être modifié. Toute modification DOIT être publiée dans une nouvelle version.\nL’identifiant de version majeure zéro (0.y.z) est destiné au développement initial.
Tout ou partie peut être modifié à tout moment. L’API publique ne devrait pas
être considérée comme stable.\nL’identifiant de version majeure zéro (0.y.z) est destiné au développement initial.
Tout ou partie peut être modifié à tout moment. L’API publique ne devrait pas
être considérée comme stable.\nLa version 1.0.0 définit l’API publique. La façon dont le numéro de version
est incrémenté après cette publication est dépendante de cette API publique et
de ses évolutions.\nLa version 1.0.0 définit l’API publique. La façon dont le numéro de version
est incrémenté après cette publication est dépendante de cette API publique et
de ses évolutions.\nL’identifiant de version de correction Z (x.y.Z | x > 0) DOIT être incrémenté
si seules des corrections rétrocompatibles sont introduites. Une correction
est définie comme un changement interne qui corrige un comportement incorrect.\nL’identifiant de version de correction Z (x.y.Z | x > 0) DOIT être incrémenté
si seules des corrections rétrocompatibles sont introduites. Une correction
est définie comme un changement interne qui corrige un comportement incorrect.\nL’identifiant de version mineure Y (x.Y.z | x > 0) DOIT être incrémenté si de
nouvelles fonctionnalités rétrocompatibles sont introduites dans l’API
publique. Il DOIT être incrémenté si une fonctionnalité de l’API publique
est marquée comme obsolète. Il PEUT être incrémenté si de nouvelles fonctionnalités
ou améliorations substantielles sont introduites dans le code privé. Il PEUT
inclure dans le même temps des corrections. L’identifiant de version de correction
DOIT être remis à zéro lorsque l’identifiant de version mineure est incrémenté.\nL’identifiant de version mineure Y (x.Y.z | x > 0) DOIT être incrémenté si de
nouvelles fonctionnalités rétrocompatibles sont introduites dans l’API
publique. Il DOIT être incrémenté si une fonctionnalité de l’API publique
est marquée comme obsolète. Il PEUT être incrémenté si de nouvelles fonctionnalités
ou améliorations substantielles sont introduites dans le code privé. Il PEUT
inclure dans le même temps des corrections. L’identifiant de version de correction
DOIT être remis à zéro lorsque l’identifiant de version mineure est incrémenté.\nL’identifiant de version majeur X (X.y.z | X > 0) DOIT être incrémenté si des
changements non rétrocompatibles sont introduits dans l’API publique. Cela PEUT
inclure dans le même temps des changements mineurs et des corrections. Les
identifiants de version mineure et de correction DOIVENT être remis à zéro quand
l’identifiant de version majeure est incrémenté.\nL’identifiant de version majeur X (X.y.z | X > 0) DOIT être incrémenté si des
changements non rétrocompatibles sont introduits dans l’API publique. Cela PEUT
inclure dans le même temps des changements mineurs et des corrections. Les
identifiants de version mineure et de correction DOIVENT être remis à zéro quand
l’identifiant de version majeure est incrémenté.\nUne version de pré-livraison PEUT être notée par l’ajout d’un trait d’union et d’une
série d’identifiants séparés par des points suivant immédiatement l’identifiant de version
de correction. Les identifiants DOIVENT être composés uniquement de caractères
alphanumériques ASCII et de traits d’union [0-9A-Za-z-]. Les identifiants NE DOIVENT PAS
être vides. Les identifiants numériques NE DOIVENT PAS être préfixés par des zéros.
Les versions de pré-livraison précèdent la version normale associée (version de
pré-livraison < version normale). Une version de pré-livraison indique que la version
n’est pas stable et ne satisfait pas forcément les exigences de compatibilité
associées à une version normale.
Exemples : 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nUne version de pré-livraison PEUT être notée par l’ajout d’un trait d’union et d’une
série d’identifiants séparés par des points suivant immédiatement l’identifiant de version
de correction. Les identifiants DOIVENT être composés uniquement de caractères
alphanumériques ASCII et de traits d’union [0-9A-Za-z-]. Les identifiants NE DOIVENT PAS
être vides. Les identifiants numériques NE DOIVENT PAS être préfixés par des zéros.
Les versions de pré-livraison précèdent la version normale associée (version de
pré-livraison < version normale). Une version de pré-livraison indique que la version
n’est pas stable et ne satisfait pas forcément les exigences de compatibilité
associées à une version normale.
Exemples : 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nLes méta-données de construction PEUVENT être notées par l’ajout d’un signe
« plus » et d’une série d’identifiants séparés par des points suivant immédiatement
l’identifiant de version de correction ou de pré-livraison. Les identifiants DOIVENT
être composés uniquement de caractères alphanumériques ASCII et de traits d’union [0-9A-Za-z-].
Les identifiants NE DOIVENT PAS être vides. Les méta-données de construction DEVRAIENT
être ignorées dans l’ordre des versions. Autrement dit, deux versions qui diffèrent
seulement par leurs informations de construction ont la même priorité.
Exemples : 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nLes méta-données de construction PEUVENT être notées par l’ajout d’un signe
« plus » et d’une série d’identifiants séparés par des points suivant immédiatement
l’identifiant de version de correction ou de pré-livraison. Les identifiants DOIVENT
être composés uniquement de caractères alphanumériques ASCII et de traits d’union [0-9A-Za-z-].
Les identifiants NE DOIVENT PAS être vides. Les méta-données de construction DEVRAIENT
être ignorées dans l’ordre des versions. Autrement dit, deux versions qui diffèrent
seulement par leurs informations de construction ont la même priorité.
Exemples : 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nLa priorité définit la façon dont sont ordonnées les versions entre elles.
La priorité DOIT être calculée en séparant les identifiants de versions entre
majeures, mineures, de correction et de pré-livraison, en suivant cet ordre
(les informations de construction n’entrent pas en compte dans la comparaison).
La priorité est déterminée par la première différence apparaissant dans la comparaison
de chacun de ces identifiants dans l’ordre : majeur, mineur et correctif. Ces
identifiants sont toujours comparés numériquement.
Exemple : 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
Lorsque ces identifiants sont identiques, une version de pré-livraison est moins
prioritaire qu’une version normale.
Exemple : 1.0.0-alpha < 1.0.0.
La priorité pour deux versions de pré-livraison ayant les mêmes identifiants de
version majeure, mineure et de correction DOIT être déterminée en comparant chaque
identifiant séparé par un point de la gauche vers la droite jusqu’à ce qu’une
différence soit trouvée, comme suit : les identifiants composés uniquement de
chiffres sont comparés numériquement et les identifiants contenant des lettres
ou des traits d’union sont comparés dans l’ordre ASCII. Les identifiants numériques
sont toujours moins prioritaires que les identifiants non numériques (identifiants
numériques < identifiants non-numériques). Un ensemble de champs plus long est
prioritaire par rapport à un ensemble de champs plus court si tous les identifiants
précédents sont identiques.
Exemple : 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nLa priorité définit la façon dont sont ordonnées les versions entre elles.
La priorité DOIT être calculée en séparant les identifiants de versions entre
majeures, mineures, de correction et de pré-livraison, en suivant cet ordre
(les informations de construction n’entrent pas en compte dans la comparaison).
La priorité est déterminée par la première différence apparaissant dans la comparaison
de chacun de ces identifiants dans l’ordre : majeur, mineur et correctif. Ces
identifiants sont toujours comparés numériquement.
Exemple : 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
Lorsque ces identifiants sont identiques, une version de pré-livraison est moins
prioritaire qu’une version normale.
Exemple : 1.0.0-alpha < 1.0.0.
La priorité pour deux versions de pré-livraison ayant les mêmes identifiants de
version majeure, mineure et de correction DOIT être déterminée en comparant chaque
identifiant séparé par un point de la gauche vers la droite jusqu’à ce qu’une
différence soit trouvée, comme suit : les identifiants composés uniquement de
chiffres sont comparés numériquement et les identifiants contenant des lettres
ou des traits d’union sont comparés dans l’ordre ASCII. Les identifiants numériques
sont toujours moins prioritaires que les identifiants non numériques (identifiants
numériques < identifiants non-numériques). Un ensemble de champs plus long est
prioritaire par rapport à un ensemble de champs plus court si tous les identifiants
précédents sont identiques.
Exemple : 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPourquoi utiliser la gestion sémantique de version ?\nIl ne s’agit pas d’une idée nouvelle ou révolutionnaire. En fait, vous faites
probablement déjà quelque chose d’approchant. Et le problème vient du fait que
« quelque chose de proche » n’est pas suffisant. Sans conformité avec une méthode
formelle, les numéros de version deviennent inutilisables pour la gestion de
vos dépendances. En donnant un nom et une définition claire aux idées exposées
ci-dessus, il devient facile de communiquer vos intentions aux utilisateurs
de votre logiciel. Une fois que vos intentions sont claires, une spécification
souple (mais pas « trop » souple) des dépendances peut être réalisée.\nUn exemple simple permet de montrer comment la gestion sémantique de version peut
faire de l’enfer des dépendances, une chose du passé. Considérons une bibliothèque
appelée « CamionDePompier ». Elle nécessite un composant appelé « Échelle » dont la
version est gérée sémantiquement. Lorsque la librairie CamionDePompier est créée,
Échelle en est à sa version 3.1.0. Et puisque CamionDePompier utilise des fonctionnalités
qui ont été introduites en 3.1.0, vous pouvez spécifier, sans courir le moindre risque,
une dépendance vers Échelle plus grande ou égale à 3.1.0 mais inférieure à 4.0.0.
Maintenant, lorsque les versions 3.1.1 et 3.2.0 de Échelle seront disponibles, vous
pourrez les publier dans votre système de gestion de dépendances en sachant qu’elles
seront compatibles avec les logiciels existants qui en dépendent.\nEn tant que développeur responsable, bien entendu, vous voudrez vérifier que toute
mise à jour de composant fonctionne comme annoncée. Dans la réalité, les choses ne
sont pas forcément toujours très cohérentes ; il n’y a donc rien d’autre à faire que
de rester vigilant. Ce que vous pouvez cependant faire est de laisser la gestion
sémantique de version vous fournir une manière saine de publier et mettre à jour vos
composants et ainsi ne pas avoir besoin de déployer de nouvelles versions de vos
sous-composants vous permettant ainsi d’économiser du temps et du souci.\nSi tout cela vous semble intéressant, tout ce que vous avez à faire pour commencer
à utiliser la gestion sémantique de version est de déclarer que vous le faites
et d’en suivre les règles. Ajoutez ensuite un lien vers ce site web dans votre
README pour que d’autres puissent en connaître les règles et en bénéficier.\nComment dois-je gérer les révisions dans la phase initiale de développement 0.y.z ?\nLa chose la plus simple à faire est de commencer vos développements avec
une version initiale à 0.1.0 puis d’incrémenter l’identifiant de version mineure
pour chaque nouvelle publication.\nComment savoir quand publier la version 1.0.0 ?\nSi votre logiciel est utilisé en environnement de production ou que vous avez
une API stable de laquelle des utilisateurs ont commencé à dépendre, vous devriez
probablement déjà être en version 1.0.0. Et si vous vous faites déjà du souci
pour la rétro-compatibilité, vous devriez également avoir dépassé la 1.0.0.\nN’est-ce pas décourager le développement rapide et les itérations courtes ?\nLa version majeure zéro est faite pour un développement
rapide. Si vous changez votre API tous les jours, vous devriez toujours être
en version 0.y.z ou sur une branche de développement séparée en préparant la
prochaine version majeure.\nSi le moindre changement non rétrocompatible de l’API publique nécessite une incrémentation de l’identifiant de version majeure, ne vais-je pas me retrouver à la version 42.0.0 très rapidement ?\nC’est une question de développement responsable et d’anticipation. Les changements
incompatibles ne doivent pas être introduits à la légère dans du logiciel dont
beaucoup de code source dépend. Le coût d’une mise à jour vers une nouvelle version
peut être important. Le besoin de faire évoluer la version majeure pour publier des
changements non rétrocompatibles signifie que vous aurez mesuré les implications de
vos modifications et évalué le rapport entre leur coût et leurs bénéfices.\nDocumenter l’ensemble de l’API publique demande trop de travail !\nIl est de votre responsabilité en tant que développeur professionnel de documenter
correctement le logiciel qui est destiné à être utilisé par d’autres. Gérer la
complexité d’un logiciel est un élément extrêmement important pour maintenir son
projet efficacement. Cela devient difficile à faire quand personne ne sait comment
utiliser votre logiciel ou ne connaît les bonnes méthodes à appeler. Sur le long
terme, la gestion sémantique de version et les efforts dans la conservation d’une
API publique bien définie permettront à tout le monde d’avancer sans problème.\nQue faire si j’ai accidentellement publié un changement non rétrocompatible dans une version mineure ?\nDès que vous réalisez que vous avez cassé votre gestion sémantique de version,
corrigez le problème et publiez une nouvelle version mineure qui rétablit la
compatibilité avec les versions précédentes. Même dans de telles circonstances,
il est inacceptable de modifier une version déjà publiée. Mettez à jour la
documentation en signalant la version défectueuse et informez vos utilisateurs
de ce problème.\nQue dois-je faire lorsque je mets à jour mes propres dépendances sans changer l’API publique ?\nCela peut être considéré comme compatible dans la mesure où cela n’affecte pas l’API
publique. Les logiciels qui dépendent des mêmes librairies que votre composant
devraient avoir leur propre spécification de dépendances et l’auteur remarquera ainsi
tout conflit. Pour déterminer si la modification est de niveau correctif ou mineur,
il faut vous poser la question de savoir si vous avez mis à jour vos dépendances pour
corriger un bug ou pour introduire une nouvelle fonctionnalité. Je considère
généralement l’ajout de nouveau code comme la deuxième option ce qui sous-entend
évidemment un incrément de l’identifiant de version mineure.\nQue faire si par mégarde je modifie l’API publique d’une façon qui ne correspond pas au changement de numéro de version (exemple : le code introduit un changement non rétrocompatible dans une publication de correctif) ?\nC’est à vous de décider. Si vous avez une large audience qui sera considérablement
affectée par un retour à ce que l’API publique prévoyait, alors il est peut être préférable
de publier une version majeure, même si la livraison pourrait être uniquement considérée
comme un correctif. Souvenez-vous encore que la gestion sémantique de version consiste
essentiellement à transmettre du sens dans la façon dont le numéro de version change. Si
ces changements sont importants pour vos utilisateurs, utilisez les numéros de version
pour les en informer.\nComment dois-je traiter les fonctionnalités obsolètes ?\nRendre des fonctionnalités obsolètes est une part normale du développement de logiciels
et cela est souvent nécessaire pour aller de l’avant. Lorsque vous dépréciez une partie
de votre API publique, vous devez faire deux choses : (1) mettre à jour la documentation
pour informer les utilisateurs du changement, (2) publier une nouvelle version mineure
avec la dépréciation en place. Avant que vous ne supprimiez complètement la fonctionnalité
dans une nouvelle version majeure, il devrait y avoir au moins une version mineure qui
contient la dépréciation pour que les utilisateurs puissent effectuer la transition en douceur.\nEst-ce que la gestion sémantique de version spécifie une limite de taille pour la chaîne de caractères d’un numéro de version ?\nNon, mais faites preuve de bon sens. Par exemple, un numéro de version de 255 caractères
est probablement excessif. De plus, certains systèmes peuvent imposer leurs propres limites
sur cette taille.\nLa spécification de la gestion sémantique de version est écrite par Tom
Preston-Werner, inventeur de Gravatars et
cofondateur de GitHub.\nSi vous souhaitez laisser des commentaires, veuillez ouvrir un ticket sur
GitHub.\nouvrir un ticket sur
GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nGestion sémantique de version 1.0.0

Dans le monde de la gestion des logiciels, il existe un endroit redouté appelé
« l’enfer des dépendances » (de l’anglais dependency hell). Plus votre système se
développe et plus vous intégrez de composants dans votre logiciel, plus vous êtes
susceptible de vous trouver un jour dans cet abîme de désespoir.

Dans les systèmes comportant de nombreuses dépendances, publier une nouvelle
version d’un composant peut vite devenir un cauchemar. Si les règles de
dépendance sont trop strictes, vous risquez de verrouiller vos versions
(incapacité de mettre à jour un composant sans avoir à publier une nouvelle
version de chaque composant qui en dépend). Si les règles de dépendances sont
trop lâches, vous allez inévitablement subir la promiscuité de version (supposer
une compatibilité avec plus de futures versions que raisonnable). L’enfer des
dépendances est l’endroit où vous vous trouvez lorsque vous êtes bloqué dans
une version et/ou qu’une incompatibilité de version vous empêche d’avancer
sans risque dans votre projet.

Comme solution à ce problème, je propose un ensemble de règles et d’exigences
simples qui dictent la façon dont les numéros de version sont attribués et
incrémentés. Pour que ce système fonctionne, vous devez d’abord déclarer une API
publique. Il peut s’agir d’un document ou de règles imposées par le code lui-même. Quoiqu’il en soit, il est important que cette API soit claire et précise.
Une fois prête, vous communiquez ses modifications par des incrémentations
successives de son numéro de version. Considérons le format de version X.Y.Z
où X, Y et Z identifient la version (Majeure.Mineure.Corrective). Les corrections qui
n’affectent pas l’API incrémentent le dernier identifiant qui est l’identifiant de
version de correction. Lors d’ajouts ou de modifications rétrocompatibles de l’API,
il faut incrémenter l’identifiant de version mineure. Enfin, pour des modifications
non rétrocompatibles, il faut incrémenter l’identifiant de version majeure.

J’appelle ce système « gestion sémantique de version ». Avec ce système, les numéros de
version, et la façon dont ils changent, donnent du sens au code sous-jacent et à ce
qui a été modifié d’une version à l’autre.

Spécification de la gestion sémantique de version (SemVer)

Les mots clés “DOIT”, “NE DOIT PAS”, “OBLIGATOIRE”, “DEVRA”, “NE DEVRA PAS”,
“DEVRAIT”, “NE DEVRAIT PAS”, “RECOMMANDÉ”, “PEUT”, et “OPTIONNEL” dans ce
document doivent être interprétés comme décrit dans la RFC 2119.


  
    Tout logiciel utilisant la gestion sémantique de version DOIT déclarer une API
publique. Cette API peut être déclarée dans le code lui-même ou dans un document.
Dans tous les cas, elle doit être précise et claire.
  
  
    Un numéro de version standard DOIT prendre la forme X.Y.Z où X, Y et Z
sont des entiers. X représente l’identifiant de version majeure, Y représente
l’identifiant de version mineure et Z l’identifiant de version de correction. Chaque
élément DOIT s’incrémenter numériquement par incréments de un.
Exemple : 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Quand l’identifiant de version majeure est incrémenté, les identifiants de version
mineure et de correction DOIVENT être remis à zéro. Quand un identifiant de version
mineure est incrémenté, l’identifiant de version de correction DOIT être remis à
zéro.
Exemples : 1.1.3 -> 2.0.0 et 2.1.7 -> 2.2.0.
  
  
    Une version de pré-livraison PEUT être notée par l’ajout d’une
chaîne de caractères arbitraire immédiatement à la suite de l’identifiant de version
de correction et d’un trait d’union. La chaîne de caractères DOIT être seulement
composée de caractères alphanumériques et/ou de traits d’union [0-9A-Za-z-].
Les versions de pré-livraison satisfont le schéma d’une version normale mais
ont une plus faible priorité que la version correspondante (sans la chaîne de
caractères). La priorité DEVRAIT ensuite être déterminée dans l’ordre lexicographique
ASCII ascendant.
Exemple : 1.0.0-alpha1 < 1.0.0-beta1 < 1.0.0-beta2 < 1.0.0-rc1 < 1.0.0.
  
  
    Une fois qu’un composant est publié, le contenu de sa version NE DOIT PAS
être modifié. Toute modification DOIT être publiée dans une nouvelle version.
  
  
    L’identifiant de version majeure zéro (0.y.z) est destiné au développement initial.
Tout ou partie peut être modifié à tout moment. L’API publique ne devrait pas
être considérée comme stable.
  
  
    La version 1.0.0 définit l’API publique. La façon dont le numéro de version
est incrémenté après cette publication est dépendante de cette API publique et
de ses évolutions.
  
  
    L’identifiant de version de correction Z (x.y.Z | x > 0) DOIT être incrémenté
si seules des corrections rétrocompatibles sont introduites. Une correction
est définie comme un changement interne qui corrige un comportement incorrect.
  
  
    L’identifiant de version mineure Y (x.Y.z | x > 0) DOIT être incrémenté si de
nouvelles fonctionnalités rétrocompatibles sont introduites dans l’API
publique. Il PEUT être incrémenté si de nouvelles fonctionnalités ou améliorations
substantielles sont introduites dans le code privé. Il PEUT inclure dans le
même temps des corrections. L’identifiant de version de correction DOIT être remis
à zéro lorsque l’identifiant de version mineure est incrémenté.
  
  
    L’identifiant de version majeure X (X.y.z | X > 0) DOIT être incrémenté si des
changements non rétrocompatibles sont introduits dans l’API publique. Cela PEUT
inclure dans le même temps des changements mineurs et des corrections. Les
identifiants de version mineure et de correction DOIVENT être remis à zéro quand
l’identifiant de version majeure est incrémenté.
  


Spécification de la Labellisation (SemVerTag)

Cette sous-spécification DEVRAIT être utilisée si vous utilisez un système
de contrôle de version (Git, Mercurial, SVN, etc.) pour sauvegarder votre
code source. Un tel système permet d’automatiser des outils pour inspecter
vos composants et déterminer votre compatibilité SemVer dans les versions
publiées.


  
    Lorsque vous labellisez vos publications dans un système de contrôle de
version, le label pour une version donnée DOIT être “vX.Y.Z”.
Exemple : “v3.1.0”.
  
  
    La première révision qui introduit la compatibilité SemVer DEVRAIT
être labellisée “semver”. Cela permet aux projets préexistants de marquer
leur compatibilité. Cela permet également aux outils automatisés de
reconnaître cet événement.
  


Pourquoi utiliser la gestion sémantique de version ?

Il ne s’agit pas d’une idée nouvelle ou révolutionnaire. En fait, vous faites
probablement déjà quelque chose d’approchant. Et le problème vient du fait que
« quelque chose de proche » n’est pas suffisant. Sans conformité avec une méthode
formelle, les numéros de version deviennent inutilisables pour la gestion de
vos dépendances. En donnant un nom et une définition claire aux idées exposées
ci-dessus, il devient facile de communiquer vos intentions aux utilisateurs
de votre logiciel. Une fois que vos intentions sont claires, une spécification
souple (mais pas « trop » souple) des dépendances peut être réalisée.

Un exemple simple permet de montrer comment la gestion sémantique de version peut
faire de l’enfer des dépendances, une chose du passé. Considérons une bibliothèque
appelée « CamionDePompier ». Elle nécessite un composant appelé « Échelle » dont la
version est gérée sémantiquement. Lorsque la librairie CamionDePompier est créée,
Échelle en est à sa version 3.1.0. Et puisque CamionDePompier utilise des fonctionnalités
qui ont été introduites en 3.1.0, vous pouvez spécifier, sans courir le moindre risque,
une dépendance vers Échelle plus grande ou égale à 3.1.0 mais inférieure à 4.0.0.
Maintenant, lorsque les versions 3.1.1 et 3.2.0 de Échelle seront disponibles, vous
pourrez les publier dans votre système de gestion de dépendances en sachant qu’elles
seront compatibles avec les logiciels existants qui en dépendent.

En tant que développeur responsable, bien entendu, vous voudrez vérifier que toute
mise à jour de composant fonctionne comme annoncée. Dans la réalité, les choses ne
sont pas forcément toujours très cohérentes ; il n’y a donc rien d’autre à faire que
de rester vigilant. Ce que vous pouvez cependant faire est de laisser la gestion
sémantique de version vous fournir une manière saine de publier et mettre à jour vos
composants et ainsi ne pas avoir besoin de déployer de nouvelles versions de vos
sous-composants vous permettant ainsi d’économiser du temps et du souci.

Si tout cela vous semble intéressant, tout ce que vous avez à faire pour commencer
à utiliser la gestion sémantique de version est de déclarer que vous le faites
et d’en suivre les règles. Ajoutez ensuite un lien vers ce site web dans votre
README pour que d’autres puissent en connaître les règles et en bénéficier.

FAQ

Comment dois-je gérer les révisions dans la phase initiale de développement 0.y.z ?

La chose la plus simple à faire est de commencer vos développements avec
une version initiale à 0.1.0 puis d’incrémenter l’identifiant de version mineure
pour chaque nouvelle publication.

Comment savoir quand publier la version 1.0.0 ?

Si votre logiciel est utilisé en environnement de production ou que vous avez
une API stable de laquelle des utilisateurs ont commencé à dépendre, vous devriez
probablement déjà être en version 1.0.0. Et si vous vous faites déjà du souci
pour la rétro-compatibilité, vous devriez également avoir dépassé la 1.0.0.

N’est-ce pas décourager le développement rapide et les itérations courtes ?

La version majeure zéro est faite pour un développement
rapide. Si vous changez votre API tous les jours, vous devriez toujours être
en version 0.y.z ou sur une branche de développement séparée en préparant la
prochaine version majeure.

Si le moindre changement non rétrocompatible de l’API publique nécessite une incrémentation de l’identifiant de version majeure, ne vais-je pas me retrouver à la version 42.0.0 très rapidement ?

C’est une question de développement responsable et d’anticipation. Les changements
incompatibles ne doivent pas être introduits à la légère dans du logiciel dont
beaucoup de code source dépend. Le coût d’une mise à jour vers une nouvelle version
peut être important. Le besoin de faire évoluer la version majeure pour publier des
changements non rétrocompatibles signifie que vous aurez mesuré les implications de
vos modifications et évalué le rapport entre leur coût et leurs bénéfices.

Documenter l’ensemble de l’API publique demande trop de travail !

Il est de votre responsabilité en tant que développeur professionnel de documenter
correctement le logiciel qui est destiné à être utilisé par d’autres. Gérer la
complexité d’un logiciel est un élément extrêmement important pour maintenir son
projet efficacement. Cela devient difficile à faire quand personne ne sait comment
utiliser votre logiciel ou ne connaît les bonnes méthodes à appeler. Sur le long
terme, la gestion sémantique de version et les efforts dans la conservation d’une
API publique bien définie permettront à tout le monde d’avancer sans problème.

Que faire si j’ai accidentellement publié un changement non rétrocompatible dans une version mineure ?

Dès que vous réalisez que vous avez cassé votre gestion sémantique de version,
corrigez le problème et publiez une nouvelle version mineure qui rétablit la
compatibilité avec les versions précédentes. Souvenez-vous que même dans de
telles circonstances, il est inacceptable de modifier une version déjà publiée.
Mettez à jour la documentation en signalant la version défectueuse et informez
vos utilisateurs de ce problème.

Que dois-je faire lorsque je mets à jour mes propres dépendances sans changer l’API publique ?

Cela peut être considéré comme compatible dans la mesure où cela n’affecte pas l’API
publique. Les logiciels qui dépendent des mêmes librairies que votre composant
devraient avoir leur propre spécification de dépendances et l’auteur remarquera ainsi
tout conflit. Pour déterminer si la modification est de niveau correctif ou mineur,
il faut vous poser la question de savoir si vous avez mis à jour vos dépendances pour
corriger un bug ou pour introduire une nouvelle fonctionnalité. Je considère
généralement l’ajout de nouveau code comme la deuxième option ce qui sous-entend
évidemment un incrément de l’identifiant de version mineure.

Que dois-je faire si l’anomalie qui est en cours de correction remet le code en conformité avec l’API publique (alors que le code n’était déjà plus synchronisé avec la documentation) ?

C’est à vous de décider. Si vous avez une large audience qui sera considérablement
affectée par un retour à ce que l’API publique prévoyait, alors il est peut-être préférable
de publier une version majeure, même si la livraison pourrait être uniquement considérée
comme un correctif. Souvenez-vous encore que la gestion sémantique de version consiste
essentiellement à transmettre du sens dans la façon dont le numéro de version change. Si
ces changements sont importants pour vos utilisateurs, utilisez les numéros de version
pour les en informer.

À propos

La spécification de la gestion sémantique de version est écrite par Tom Preston-Werner, inventeur de Gravatars et cofondateur de GitHub.

Si vous souhaitez laisser des commentaires, veuillez ouvrir un ticket sur GitHub.

Licence

Creative Commons ― CC BY 3.0
http://creativecommons.org/licenses/by/3.0/\nGestion sémantique de version 1.0.0\nDans le monde de la gestion des logiciels, il existe un endroit redouté appelé
« l’enfer des dépendances » (de l’anglais dependency hell). Plus votre système se
développe et plus vous intégrez de composants dans votre logiciel, plus vous êtes
susceptible de vous trouver un jour dans cet abîme de désespoir.\nDans les systèmes comportant de nombreuses dépendances, publier une nouvelle
version d’un composant peut vite devenir un cauchemar. Si les règles de
dépendance sont trop strictes, vous risquez de verrouiller vos versions
(incapacité de mettre à jour un composant sans avoir à publier une nouvelle
version de chaque composant qui en dépend). Si les règles de dépendances sont
trop lâches, vous allez inévitablement subir la promiscuité de version (supposer
une compatibilité avec plus de futures versions que raisonnable). L’enfer des
dépendances est l’endroit où vous vous trouvez lorsque vous êtes bloqué dans
une version et/ou qu’une incompatibilité de version vous empêche d’avancer
sans risque dans votre projet.\nComme solution à ce problème, je propose un ensemble de règles et d’exigences
simples qui dictent la façon dont les numéros de version sont attribués et
incrémentés. Pour que ce système fonctionne, vous devez d’abord déclarer une API
publique. Il peut s’agir d’un document ou de règles imposées par le code lui-même. Quoiqu’il en soit, il est important que cette API soit claire et précise.
Une fois prête, vous communiquez ses modifications par des incrémentations
successives de son numéro de version. Considérons le format de version X.Y.Z
où X, Y et Z identifient la version (Majeure.Mineure.Corrective). Les corrections qui
n’affectent pas l’API incrémentent le dernier identifiant qui est l’identifiant de
version de correction. Lors d’ajouts ou de modifications rétrocompatibles de l’API,
il faut incrémenter l’identifiant de version mineure. Enfin, pour des modifications
non rétrocompatibles, il faut incrémenter l’identifiant de version majeure.\nJ’appelle ce système « gestion sémantique de version ». Avec ce système, les numéros de
version, et la façon dont ils changent, donnent du sens au code sous-jacent et à ce
qui a été modifié d’une version à l’autre.\nSpécification de la gestion sémantique de version (SemVer)\nLes mots clés “DOIT”, “NE DOIT PAS”, “OBLIGATOIRE”, “DEVRA”, “NE DEVRA PAS”,
“DEVRAIT”, “NE DEVRAIT PAS”, “RECOMMANDÉ”, “PEUT”, et “OPTIONNEL” dans ce
document doivent être interprétés comme décrit dans la RFC 2119.\nTout logiciel utilisant la gestion sémantique de version DOIT déclarer une API
publique. Cette API peut être déclarée dans le code lui-même ou dans un document.
Dans tous les cas, elle doit être précise et claire.\nTout logiciel utilisant la gestion sémantique de version DOIT déclarer une API
publique. Cette API peut être déclarée dans le code lui-même ou dans un document.
Dans tous les cas, elle doit être précise et claire.\nUn numéro de version standard DOIT prendre la forme X.Y.Z où X, Y et Z
sont des entiers. X représente l’identifiant de version majeure, Y représente
l’identifiant de version mineure et Z l’identifiant de version de correction. Chaque
élément DOIT s’incrémenter numériquement par incréments de un.
Exemple : 1.9.0 -> 1.10.0 -> 1.11.0.\nUn numéro de version standard DOIT prendre la forme X.Y.Z où X, Y et Z
sont des entiers. X représente l’identifiant de version majeure, Y représente
l’identifiant de version mineure et Z l’identifiant de version de correction. Chaque
élément DOIT s’incrémenter numériquement par incréments de un.
Exemple : 1.9.0 -> 1.10.0 -> 1.11.0.\nQuand l’identifiant de version majeure est incrémenté, les identifiants de version
mineure et de correction DOIVENT être remis à zéro. Quand un identifiant de version
mineure est incrémenté, l’identifiant de version de correction DOIT être remis à
zéro.
Exemples : 1.1.3 -> 2.0.0 et 2.1.7 -> 2.2.0.\nQuand l’identifiant de version majeure est incrémenté, les identifiants de version
mineure et de correction DOIVENT être remis à zéro. Quand un identifiant de version
mineure est incrémenté, l’identifiant de version de correction DOIT être remis à
zéro.
Exemples : 1.1.3 -> 2.0.0 et 2.1.7 -> 2.2.0.\nUne version de pré-livraison PEUT être notée par l’ajout d’une
chaîne de caractères arbitraire immédiatement à la suite de l’identifiant de version
de correction et d’un trait d’union. La chaîne de caractères DOIT être seulement
composée de caractères alphanumériques et/ou de traits d’union [0-9A-Za-z-].
Les versions de pré-livraison satisfont le schéma d’une version normale mais
ont une plus faible priorité que la version correspondante (sans la chaîne de
caractères). La priorité DEVRAIT ensuite être déterminée dans l’ordre lexicographique
ASCII ascendant.
Exemple : 1.0.0-alpha1 < 1.0.0-beta1 < 1.0.0-beta2 < 1.0.0-rc1 < 1.0.0.\nUne version de pré-livraison PEUT être notée par l’ajout d’une
chaîne de caractères arbitraire immédiatement à la suite de l’identifiant de version
de correction et d’un trait d’union. La chaîne de caractères DOIT être seulement
composée de caractères alphanumériques et/ou de traits d’union [0-9A-Za-z-].
Les versions de pré-livraison satisfont le schéma d’une version normale mais
ont une plus faible priorité que la version correspondante (sans la chaîne de
caractères). La priorité DEVRAIT ensuite être déterminée dans l’ordre lexicographique
ASCII ascendant.
Exemple : 1.0.0-alpha1 < 1.0.0-beta1 < 1.0.0-beta2 < 1.0.0-rc1 < 1.0.0.\nUne fois qu’un composant est publié, le contenu de sa version NE DOIT PAS
être modifié. Toute modification DOIT être publiée dans une nouvelle version.\nUne fois qu’un composant est publié, le contenu de sa version NE DOIT PAS
être modifié. Toute modification DOIT être publiée dans une nouvelle version.\nL’identifiant de version majeure zéro (0.y.z) est destiné au développement initial.
Tout ou partie peut être modifié à tout moment. L’API publique ne devrait pas
être considérée comme stable.\nL’identifiant de version majeure zéro (0.y.z) est destiné au développement initial.
Tout ou partie peut être modifié à tout moment. L’API publique ne devrait pas
être considérée comme stable.\nLa version 1.0.0 définit l’API publique. La façon dont le numéro de version
est incrémenté après cette publication est dépendante de cette API publique et
de ses évolutions.\nLa version 1.0.0 définit l’API publique. La façon dont le numéro de version
est incrémenté après cette publication est dépendante de cette API publique et
de ses évolutions.\nL’identifiant de version de correction Z (x.y.Z | x > 0) DOIT être incrémenté
si seules des corrections rétrocompatibles sont introduites. Une correction
est définie comme un changement interne qui corrige un comportement incorrect.\nL’identifiant de version de correction Z (x.y.Z | x > 0) DOIT être incrémenté
si seules des corrections rétrocompatibles sont introduites. Une correction
est définie comme un changement interne qui corrige un comportement incorrect.\nL’identifiant de version mineure Y (x.Y.z | x > 0) DOIT être incrémenté si de
nouvelles fonctionnalités rétrocompatibles sont introduites dans l’API
publique. Il PEUT être incrémenté si de nouvelles fonctionnalités ou améliorations
substantielles sont introduites dans le code privé. Il PEUT inclure dans le
même temps des corrections. L’identifiant de version de correction DOIT être remis
à zéro lorsque l’identifiant de version mineure est incrémenté.\nL’identifiant de version mineure Y (x.Y.z | x > 0) DOIT être incrémenté si de
nouvelles fonctionnalités rétrocompatibles sont introduites dans l’API
publique. Il PEUT être incrémenté si de nouvelles fonctionnalités ou améliorations
substantielles sont introduites dans le code privé. Il PEUT inclure dans le
même temps des corrections. L’identifiant de version de correction DOIT être remis
à zéro lorsque l’identifiant de version mineure est incrémenté.\nL’identifiant de version majeure X (X.y.z | X > 0) DOIT être incrémenté si des
changements non rétrocompatibles sont introduits dans l’API publique. Cela PEUT
inclure dans le même temps des changements mineurs et des corrections. Les
identifiants de version mineure et de correction DOIVENT être remis à zéro quand
l’identifiant de version majeure est incrémenté.\nL’identifiant de version majeure X (X.y.z | X > 0) DOIT être incrémenté si des
changements non rétrocompatibles sont introduits dans l’API publique. Cela PEUT
inclure dans le même temps des changements mineurs et des corrections. Les
identifiants de version mineure et de correction DOIVENT être remis à zéro quand
l’identifiant de version majeure est incrémenté.\nSpécification de la Labellisation (SemVerTag)\nCette sous-spécification DEVRAIT être utilisée si vous utilisez un système
de contrôle de version (Git, Mercurial, SVN, etc.) pour sauvegarder votre
code source. Un tel système permet d’automatiser des outils pour inspecter
vos composants et déterminer votre compatibilité SemVer dans les versions
publiées.\nLorsque vous labellisez vos publications dans un système de contrôle de
version, le label pour une version donnée DOIT être “vX.Y.Z”.
Exemple : “v3.1.0”.\nLorsque vous labellisez vos publications dans un système de contrôle de
version, le label pour une version donnée DOIT être “vX.Y.Z”.
Exemple : “v3.1.0”.\nLa première révision qui introduit la compatibilité SemVer DEVRAIT
être labellisée “semver”. Cela permet aux projets préexistants de marquer
leur compatibilité. Cela permet également aux outils automatisés de
reconnaître cet événement.\nLa première révision qui introduit la compatibilité SemVer DEVRAIT
être labellisée “semver”. Cela permet aux projets préexistants de marquer
leur compatibilité. Cela permet également aux outils automatisés de
reconnaître cet événement.\nPourquoi utiliser la gestion sémantique de version ?\nIl ne s’agit pas d’une idée nouvelle ou révolutionnaire. En fait, vous faites
probablement déjà quelque chose d’approchant. Et le problème vient du fait que
« quelque chose de proche » n’est pas suffisant. Sans conformité avec une méthode
formelle, les numéros de version deviennent inutilisables pour la gestion de
vos dépendances. En donnant un nom et une définition claire aux idées exposées
ci-dessus, il devient facile de communiquer vos intentions aux utilisateurs
de votre logiciel. Une fois que vos intentions sont claires, une spécification
souple (mais pas « trop » souple) des dépendances peut être réalisée.\nUn exemple simple permet de montrer comment la gestion sémantique de version peut
faire de l’enfer des dépendances, une chose du passé. Considérons une bibliothèque
appelée « CamionDePompier ». Elle nécessite un composant appelé « Échelle » dont la
version est gérée sémantiquement. Lorsque la librairie CamionDePompier est créée,
Échelle en est à sa version 3.1.0. Et puisque CamionDePompier utilise des fonctionnalités
qui ont été introduites en 3.1.0, vous pouvez spécifier, sans courir le moindre risque,
une dépendance vers Échelle plus grande ou égale à 3.1.0 mais inférieure à 4.0.0.
Maintenant, lorsque les versions 3.1.1 et 3.2.0 de Échelle seront disponibles, vous
pourrez les publier dans votre système de gestion de dépendances en sachant qu’elles
seront compatibles avec les logiciels existants qui en dépendent.\nEn tant que développeur responsable, bien entendu, vous voudrez vérifier que toute
mise à jour de composant fonctionne comme annoncée. Dans la réalité, les choses ne
sont pas forcément toujours très cohérentes ; il n’y a donc rien d’autre à faire que
de rester vigilant. Ce que vous pouvez cependant faire est de laisser la gestion
sémantique de version vous fournir une manière saine de publier et mettre à jour vos
composants et ainsi ne pas avoir besoin de déployer de nouvelles versions de vos
sous-composants vous permettant ainsi d’économiser du temps et du souci.\nSi tout cela vous semble intéressant, tout ce que vous avez à faire pour commencer
à utiliser la gestion sémantique de version est de déclarer que vous le faites
et d’en suivre les règles. Ajoutez ensuite un lien vers ce site web dans votre
README pour que d’autres puissent en connaître les règles et en bénéficier.\nComment dois-je gérer les révisions dans la phase initiale de développement 0.y.z ?\nLa chose la plus simple à faire est de commencer vos développements avec
une version initiale à 0.1.0 puis d’incrémenter l’identifiant de version mineure
pour chaque nouvelle publication.\nComment savoir quand publier la version 1.0.0 ?\nSi votre logiciel est utilisé en environnement de production ou que vous avez
une API stable de laquelle des utilisateurs ont commencé à dépendre, vous devriez
probablement déjà être en version 1.0.0. Et si vous vous faites déjà du souci
pour la rétro-compatibilité, vous devriez également avoir dépassé la 1.0.0.\nN’est-ce pas décourager le développement rapide et les itérations courtes ?\nLa version majeure zéro est faite pour un développement
rapide. Si vous changez votre API tous les jours, vous devriez toujours être
en version 0.y.z ou sur une branche de développement séparée en préparant la
prochaine version majeure.\nSi le moindre changement non rétrocompatible de l’API publique nécessite une incrémentation de l’identifiant de version majeure, ne vais-je pas me retrouver à la version 42.0.0 très rapidement ?\nC’est une question de développement responsable et d’anticipation. Les changements
incompatibles ne doivent pas être introduits à la légère dans du logiciel dont
beaucoup de code source dépend. Le coût d’une mise à jour vers une nouvelle version
peut être important. Le besoin de faire évoluer la version majeure pour publier des
changements non rétrocompatibles signifie que vous aurez mesuré les implications de
vos modifications et évalué le rapport entre leur coût et leurs bénéfices.\nDocumenter l’ensemble de l’API publique demande trop de travail !\nIl est de votre responsabilité en tant que développeur professionnel de documenter
correctement le logiciel qui est destiné à être utilisé par d’autres. Gérer la
complexité d’un logiciel est un élément extrêmement important pour maintenir son
projet efficacement. Cela devient difficile à faire quand personne ne sait comment
utiliser votre logiciel ou ne connaît les bonnes méthodes à appeler. Sur le long
terme, la gestion sémantique de version et les efforts dans la conservation d’une
API publique bien définie permettront à tout le monde d’avancer sans problème.\nQue faire si j’ai accidentellement publié un changement non rétrocompatible dans une version mineure ?\nDès que vous réalisez que vous avez cassé votre gestion sémantique de version,
corrigez le problème et publiez une nouvelle version mineure qui rétablit la
compatibilité avec les versions précédentes. Souvenez-vous que même dans de
telles circonstances, il est inacceptable de modifier une version déjà publiée.
Mettez à jour la documentation en signalant la version défectueuse et informez
vos utilisateurs de ce problème.\nQue dois-je faire lorsque je mets à jour mes propres dépendances sans changer l’API publique ?\nCela peut être considéré comme compatible dans la mesure où cela n’affecte pas l’API
publique. Les logiciels qui dépendent des mêmes librairies que votre composant
devraient avoir leur propre spécification de dépendances et l’auteur remarquera ainsi
tout conflit. Pour déterminer si la modification est de niveau correctif ou mineur,
il faut vous poser la question de savoir si vous avez mis à jour vos dépendances pour
corriger un bug ou pour introduire une nouvelle fonctionnalité. Je considère
généralement l’ajout de nouveau code comme la deuxième option ce qui sous-entend
évidemment un incrément de l’identifiant de version mineure.\nQue dois-je faire si l’anomalie qui est en cours de correction remet le code en conformité avec l’API publique (alors que le code n’était déjà plus synchronisé avec la documentation) ?\nC’est à vous de décider. Si vous avez une large audience qui sera considérablement
affectée par un retour à ce que l’API publique prévoyait, alors il est peut-être préférable
de publier une version majeure, même si la livraison pourrait être uniquement considérée
comme un correctif. Souvenez-vous encore que la gestion sémantique de version consiste
essentiellement à transmettre du sens dans la façon dont le numéro de version change. Si
ces changements sont importants pour vos utilisateurs, utilisez les numéros de version
pour les en informer.\nLa spécification de la gestion sémantique de version est écrite par Tom Preston-Werner, inventeur de Gravatars et cofondateur de GitHub.\nSi vous souhaitez laisser des commentaires, veuillez ouvrir un ticket sur GitHub.\nouvrir un ticket sur GitHub\nCreative Commons ― CC BY 3.0
http://creativecommons.org/licenses/by/3.0/\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nגרסאות סמנטיות 2.0.0

סיכום

בהינתן מספר גרסה MAJOR.MINOR.PATCH, העלה את:


  גרסה ראשית (MAJOR) כאשר אתה עושה שינויים שאינם עולים בקנה אחד עם ה API
  גרסה משנית (MINOR) כשאר אתה מוסיף פונקציונאליות בצורה שתואמת אחורנית
  גרסת תיקון (PATCH) כאשר אתה מבצע תיקוני באגים שתואמים אחורנית


תוויות נוספות עבור גרסאות קדם הפצה ובניית מטא-דאטה זמינות כתוספת לפורמט MAJOR.MINOR.PATCH.

מבוא

בעולם של ניהול תוכנה קיים מקום מפחיד בשם “גיהנום התלויות (dependency hell)”. ככל שהמערכת גדלה ואתה משלב יותר ויותר חבילות לתוכנה, קיים סיכוי גבוה יותר שתמצא את עצמך, יום אחד, בבור של יאוש.

בתוכנות עם המון תלויות, שחרור גרסה של חבילה חדשה יכול במהירות להפוך לסיוט. אם מפרט התלויות הדוק מידי, אתה בסכנה של “נעילת גרסה (version lock)” (חוסר היכולת לשדרג חבילה מבלי לשחרר גרסה חדשה של כל חבילה תלויה). אם מפרט התלויות רופף מידי, באופן בלתי נמנע אתה תכווה ע”י “מתירנות גרסה (version promiscuity)” (השערה של תאימות, יותר מהסביר, עם גרסאות עתידיות). “גיהנום התלויות” הוא כאשר אתה נמצא במקום בו נעילת גרסה ו/או מתירנות גרסה מונעים ממך להניע את הפרויקט שלך קדימה בקלות ובבטחה.

על מנת לפתור בעיה זו, מוצע סט פשוט של כללים ודרישות המכתיבים כיצד מספרי גרסאות יוקצו ויוגדלו. כללים אלה מבוססים על מנהגים משותפים, קיימים ונפוצים בפרויקטי קוד פתוח וסגור. על מנת שמערכת זו תעבוד, תחילה צריך להכריז על API ציבורי. זה אולי יהיה מורכב מתיעוד או יאכף על ידי הקוד עצמו. בכל מקרה, זה חשוב שה API יהיה ברור ומדויק. ברגע שאתה מגדיר את ה API הציבורי שלך, אתה מתקשר בו את השינויים עם תוספות ספציפיות למספר הגרסה. הסתכל על תבנית גרסה של X.Y.Z (בפורמט Major.Minor.Patch). תיקוני באגים שלא משפיעים על ה API יגדילו את מספר את מספר התיקון (Patch), תוספות / שינויים תואמי API לאחור יגדילו את הגרסה המשנית (Minor), ושינויים שאינם נתמכים לאחור ב API יגדילו את הגרסה הראשית (Major).

אני קורא למערכת “גרסאות סמנטיות”. במסגרת זו, מספרי גרסאות והדרך שבה הם משתנים מעבירה משמעות על הקוד ועל מה שהשתנה מגרסה אחת לאחרת.

מפרט גרסאות סמנטיות (SemVer)

מילות המפתח “חייב (MUST)”, “אסור (MUST NOT)”, “חובה (REQUIRED)”, “תהא (SHALL)”, “לא (SHALL NOT)”, “צריך (SHOULD)”, “לא צריך (SHOULD NOT)”, “מומלץ (RECOMMENDED)”, “יכול (MAY)”, “אפשרי (OPTIONAL)” אשר מופיעות במסמך, צריכות להיות מפורשות כמתואר במסמך RFC 2119.


  
    תוכנה באמצעות גרסאות סמנטיות נדרשת להכריז על API ציבורי. ניתן להכריז על API זה בקוד עצמו או אך ורק בתיעוד. עם זאת זה צריך להיעשות מדויק ומקיף.
  
  
    מספר גרסה רגילה חייב (MUST) להיות בצורה X.Y.Z כאשר Y, X, ו Z הם מספרים שלמים (Integers) שאינם שליליים, ואסור (Must Not) שיכילו אפסים מובילים. X הוא גרסה ראשית (Major), לאחריו Y הוא גרסה משנית (Minor), ולבסוף Z הוא גרסת תיקון (Patch).
כל רכיב במספר הגרסה חייב (MUST) להגדיל את המספר נומרית. לדוגמה: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    לאחר שחבילה שוחררה, אסור לשנות את התוכן של החבילה באותה גרסה. כל שינוי חייב להשתחרר כגרסה חדשה.
  
  
    גרסה ראשית אפס (0.z.y) היא עבור פיתוח ראשוני. בהינתן שכל דבר יכול להשתנות בכל זמן, ה API הציבורי לא צריך להיחשב יציב.
  
  
    גרסה 1.0.0 מגדירה את ה API הציבורי. הדרך שבה מספר הגרסה עולה לאחר שחרור גרסה זו תלוי ב-API הציבורי ובאופן בו הוא משתנה.
  
  
    
      
        
          גרסת תיקון (Patch) במיקום Z (כלומר x > 0
          Z.y.x) חייבת לעלות אם ורק אם הוצגו תיקוני באגים תואמים לאחור. תיקון באג שתואם לאחור מוגדר כשינוי פנימי שמתקן התנהגות לא נכונה.
        
      
    
  
  
    
      
        
          גרסה משנית (Minor) במיקום Y (כלומר x > 0
          z.Y.x) חייבת לעלות שינויי פונקציונאליות חדש, תואם אחורה, שהוצג ב API הציבורי. הוא חייב (MUST) לעלות אם פונקציונאליות כלשהי ב API הציבורי הוגדרה כ-deprecated. הוא יכול (MAY) לעלות אם הוצגו שינויים או חידושיים משמעותיים בתוך הקוד הפרטי. הוא יכול (MAY) לכלול שינויים ברמת תיקון (Patch). מספר הגרסה ברמת תיקון (Patch) חייב (MUST) להיות מאופס ל-0 כאשר מספר הגרסה המשנית (Minor) עולה.
        
      
    
  
  
    
      
        
          גרסה ראשית (Major) במיקום X (כלומר X > 0
          z.y.X) חייבת (MUST) לעלות אם הוצגו שינויים כלשהם ל API הציבורי שאינם תואמים אחורה. היא יכולה (MAY) לכלול שינויים ברמת משנית (Minor) וברמת תיקון (Patch). מספרי גרסאות ברמת תיקון (Patch) וברמה משנית (Minor) חייבים (MUST) להיות מאופסים ל 0 כאשר עולים מספר גרסה ראשית (Major).
        
      
    
  
  
    גרסת קדם הפצה יכולה (MAY) להיות מסומנת על ידי מקף ומזהים מופרדים בנקודות מיד לאחר גרסת התיקון (Patch). מזהים חייבים (MUST) להיות מורכבים מאותיות, מקף, ומספרים בתקן ASCII בלבד [0-9A-Za-z-]. אסור שהמזהה יהיה ריק. אסור שמזהים מספריים יכילו אפסים מובילים. לגרסאות קדם הפצה יש זכות נמוכה מלגרסאות רגילות. גרסת קדם הפצה מציינת כי הגרסה אינה יציבה ויכול להיות שלא תספק את הדרישות כמו גרסה רגילה. דוגמאות: 1.0.0-alpha,  1.0.0-alpha.1,   1.0.0-0.3.7,   1.0.0-x.7.z.92
  
  
    גרסה בעלת מטא נתונים (metadata build) יכולה (MAY) להיות מסומנת על ידי סימן פלוס ומזהים המפורדים בנקודות הבאים מיד לאחר גרסת התיקון (Patch) או גרסת קדם הפצה. מזהים חייבים (MUST) להיות מורכבים מאותיות, מקף, ומספרים בתקן ASCII בלבד [0-9A-Za-z-]. אסור שהמזהה יהיה ריק. בעת קביעת עדיפות גרסה צריך (SHOULD) להתעלם מגרסת מטא נתונים. לשתי גרסאות שההבדל היחיד ביניהן הוא גרסת המטא נתונים יש אותה עדיפות. דוגמאות: 1.0.0-alpha+001,  1.0.0+20130313144700,   1.0.0-beta+exp.sha.5114f85
  
  עדיפות מתייחסת לאופן בו משווים גרסאות זה לזה כאשר הם מסודרים. עדיפות חייבת (MUST) להיות מחושבת על ידי הפרדת הגרסה לראשי (Major), משני (Minor), תיקון (Patch) ומזהי קדם הפצה בסדר הזה (נתוני מטה אינם נלקחים בחשבון בעדיפות). העדיפות נקבעת על ידי ההבדל הראשון כאשר משווים את כל המזהים מספרית משמאל לימין כדלקמן: ראשי (Major), משני (Minor) ותיקון (Patch) תמיד משווים מספרית. דוגמה 2.1.1 > 2.1.0 > 2.0.0 > 1.0.0. כאשר ראשי (Major), משני (Minor) ותיקון (Patch) שווים, ולגרסת קדם הפצה יש עדיפות נמוכה יותר מאשר לגרסה רגילה. דוגמה ֿ1.0.0 > 1.0.0-alpha. עדיפות עבור שתי גרסאות קדם הפצה עם גרסאות ראשי (Major), משני (Minor), תיקון (Patch) זהים חייב (MUST) להיקבע על ידי השוואה של מזהה בין הנקודות משמאל לימין עד שנמצא הבדל כדלקמן: מזהים המורכבים מספרות בלבד משווים בצורה מספרית (נומרית) ומזהים עם אותיות או מקפים משווים לקסיקלית בסדר מיון של תקן ASCII. למזהים מספריים תמיד תהיה עדיפות נמוכה ממזהים שאינם מספריים. לקבוצה גדולה יותר של מזהים בגרסת קדם הפצה יש עדיפות גבוהה יותר מקבוצה קטנה יותר, אם כל אמצעי ההשוואה למזהים שקדמו שווים. דוגמאות: 1.0.0 > 1.0.0-rc.1 > 1.0.0-beta.11 > 1.0.0-beta.2 > 1.0.0-beta > 1.0.0-alpha.beta > 1.0.0-alpha.1 > 1.0.0-alpha 


למה להשתמש בגרסאות סמנטיות?

זה לא רעיון חדש או מהפכני. למעשה, כנראה שאתה עושה משהו קרוב לזה כבר עכשיו. הבעיה היא ש”קרוב” זה לא מספיק טוב. ללא תאימות כלשהי למפרט פורמלי, מספרי גרסה הם למעשה חסרי תועלת לניהול תלויות. על ידי מתן שם ברור והגדרה ברורה לרעיונות שהוצגו כאן, תקשור הכוונות שלנו למשתמשי התוכנה נעשה קל יותר. לאחר שהכוונות האלו ברורות וגמישות (אבל לא גמישות מידי), יכול בסופו של דבר להתבצע מפרט תלויות.

דוגמא פשוטה תדגים כיצד גרסאות סמנטיות יכולות להפוך את “גהינום התלויות” לנחלת העבר. דמיינו ספריה בשם “כבאית”. שדורשת ספרייה בשם “סולם” שעומדת במפרט של גרסאות סמנטיות. באותו הזמן שבו הכבאית נוצרה, ספריית סולם הייתה בגרסה 3.1.0. מכיוון שהכבאית משתמשמת בפונקציונליות שהוצגה בגרסה 3.1.0, ניתן לציין את התלות של ספריית כבאית בספריית סולם כגדול או שווה לגרסה מספר 3.1.0 אך פחות מ 4.0.0. עכשיו כאשר גרסת סולם מספר 3.1.1 ומספר 3.2.0 מתפרסמות, אפשר להשתמש בהן בספריית הכבאית בבטחה, ולדעת שהן תהיינה תואמות את ה API הקיים של הספרייה עליו אנו מסתמכים בספריית הכבאית שלנו.

כמפתח אחראי תוכל, כמובן, לוודא כי כל שדרוגי החבילה מתפקדים כפי שפורסם. העולם האמיתי הינו מקום מבולגן; אין שום דבר שאנחנו יכולים לעשות לגבי זה למעט להיות על המשמר. מה שאתה יכול לעשות זה לתת למפרט הגרסאות הסמנטיות לספק לך דרך שפויה לשחרר ולשדרג חבילות מבלי לגלגל גרסה חדשה של חבילות תלויות, מה שחוסך לך זמן וטרחה.

אם כל זה נשמע טוב, כל מה שאתה צריך לעשות כדי להתחיל להשתמש בגרסאות סמנטיות הוא להכריז שאתה עושה כך, ולאחר מכן להקפיד על הכללים. כלול קישור לאתר זה בקובץ ה-README שלך כדי שאחרים ידעו את הכללים ויוכלו להפיק מהם תועלת.

שאלות נפוצות

כיצד עלי להתמודד עם תיקונים בשלב הפיתוח הראשוני O.y.z?

הדבר הפשוט ביותר לעשות הוא להתחיל לשחרר את הפיתוח הראשוני שלך בגרסה 0.1.0 ואז להגדיל את הגרסה המשנית (Minor) לכל גרסה שבא אחריה.

איך אדע מתי אוכל לשחרר את גרסה 1.0.0?

אם התוכנה שלך נמצאת בשימוש בשימוש לקוחות אמיתיים (Production), אתה כנראה צריך להיות כבר בגרסה 1.0.0. אם יש לך API יציב שעליו המשתמש יכול לסמוך, אתה צריך להיות על גרסה 1.0.0. אם אתה דואג הרבה לגבי תאימות לאחור, אתה בוודאי כבר צריך להיות בגרסה 1.0.0.

האם זה לא מונע פיתוח מהיר?

כל העניין של גרסה ראשית (Major) אפס הוא פיתוח מהיר. אם אתה משנה את ה API כל יום אתה צריך להיות על גרסה 0.z.y או על ענף פיתוח נפרד בשביל הגרסה ראשית (Major) הבאה.

אם אפילו השינויים הקטנים ביותר ל API ששוברים תמיכה לאחור מחייבים להעלות גרסה ראשית, האם אני לא אגיע מהר מאוד לגרסה 42.0.0?

זוהי שאלה של פיתוח אחראי וראיית הנולד. שינויים ששוברים תמיכה צריכים לקרות בצורה קלילה לתוכנה בעלת הרבה תלויות. העלות שנגרמת משדרוג יכולה להיות משמעותית. מכיוון שאתה חייב להעלות גרסה ראשית (Major) כדי לשחרר שינויים שוברי תאימות, אתה תחשוב היטב על ההשפעה של השינויים שלך, ותעריך את יחס העלות ― תועלת המעורב בכך.

תיעוד כל הAPI הציבורי זה יותר מדי עבודה!

זוהי האחריות שלך בתור מפתח מקצועי לתעד תוכנה שמיועדת לשימוש על ידי אחרים. ניהול המורכבות של התכונה הינו חשוב מאין כמוהו לשמירת הפרויקט יעיל, וזה משהו שקשה לעשות אם אף אחד לא יודע כיצד להשתמש בתוכנה שלך, או לאיזה מתודות אפשר לקרוא בבטחה. בטווח הארוך, גרסאות סמנטיות, וההתעקשות על API מוגדר היטב יכול לשמור על כולם והכל יפעל בצורה חלקה.

מה עלי לעשות אם אני בטעות שחררתי שינויים לא תואמים אחורה כגרסה משנית (Minor)?

ברגע שאתה מבין ששברת את מפרט הגרסאות הסמנטיות, תקן את הבעיה ושחרר גרסה משנית (Minor) חדשה עם שחזור התאימות לאחור. אפילו בנסיבות כאלו זה בלתי מקובל לשנות תוכן של גרסאות קיימות. אם זה מתאים, תעד את הגרסה הסוררת ויידע את המשתמשים שלך על הבעיה כדי שיהיו מודעים לבעיה שבגרסה זו.

מה עלי לעשות אם אני מעדכן את התלויות שלי מבלי לשנות את ה API הציבורי?

זה יחשב כתואם מכיוון שזה לא משפיע על ה API הציבורי. תוכנה שתלויה באופן מפורש באותן תלויות בהן התוכנה שלך תלויה צריכה לכלול מפרט תלויות משלה והמחבר של אותה התוכנה יבחין בקונפליקטים. קביעה האם מדובר בשינוי ברמת תיקון (Patch) או ברמה משנית (Minor) תלויה בהאם אתה מעדכן את התלויות שלך כדי לתקן באג או להציג פונקציונליות חדשה. בדרך כלל בהוספת פונקציונליות צפוי גם קוד נוסף, ובמקרה כזה זה כמובן מצריך העלה של גרסה משנית (Minor).

מה אם אני משנה בטעות את ה API הציבורי באופן שאינו תואם עם שינוי מספר הגרסה (למשל קוד מציג שינוי שובר תאימות ראשי (Major) בשחרור בעל שינוי בגרסת התיקון (Patch) בלבד)

השתמש בשיקול הדעת שלך. אם יש לך קהל ענק שיושפע באופן גדול משינוי ההתנהגות אחורה לכוונה המקורית של ה API הציבורי, אז יכול להיות שהכי טוב יהיה לבצע שחרור של גרסה ראשית (Major), אפילו אם התיקון יכול להיחשב כגרסת תיקון (Patch) בלבד. זכור, ניהול גרסאות סמנטי הוא העברת מסר באמצעות הצורה שמספר הגרסה משתנה. אם השינויים האלה חשובים למשתמשים שלך, השתמש במספר הגרסה כדי ליידע אותם.

איך אני צריך לטפל ב deprecating?

פונקציונליות שהופכת לdeprecated (מיושנת) הינו תהליך נורמלי בפיתוח תוכנה, ולפעמים הוא אף נדרש כדי להתקדם. כאשר אתה הופך חלק מה API הציבורי שלך לdeprecated, אתה צריך לעשות שני דברים: (1) לעדכן את התיעוד שלך כדי לתת למשתמשים לדעת על השינוי (2) לשחרר גרסה משנית (Minor) עם הפונקציונליות שבמצב deprecated. לפי שאתה מסיר לחלוטין את הפונקציונליות הזאת בגרסה ראשית (Major) חדשה, צריכה להיות לפחות גרסה אחת משנית (Minor) שמכילה את הפונקציונליות עם הודעת הdeprecated כדי שהמשתמשים יוכלו לעבור בקלות ל API החדש.

האם ל semver יש מגבלת גודל על ה String של הגרסה?

לא, אבל הפעל שיקול דעת. לדוגמה, מחרוזת גרסה בעלת 255 תווים היא כנראה מוגזמת. כמו כן, מערכות ספציפיות עשויות להטיל מגבלות משלהן על גודל המחרוזת.

האם “v1.2.3” היא גרסה סמנטית?

לא, “v1.2.3” אינו גרסה סמנטית. עם זאת, קידומת “v” לגרסה סמנטית היא דרך נפוצה (באנגלית) לציין מספר גרסה.
לעתים קיצור המילה “גרסה”  (version)כ-“v” מופיע בניהול גרסאות.

האם יש ביטוי רגולרי (RegEx) מומלץ לבדיקת גרסה סמנטית?

יש שניים. אחד עם קבוצות שמות (מערכות תומכות:PCRE, Perl, PHP, R, Python  ו-Go), כאן: https://regex101.com/r/Ly7O1x/3

ואחד עם קבוצות לכידה ממוספרות (תואם ל-ECMA Script (JavaScript), PCRE, Perl, PHP, R, Python ו-Go), כאן: https://regex101.com/r/vkijKf/1

אודות

מפרט הגרסאות הסמנטיות נכתב על ידי טום פרסון-ורנר, ממציא ה Gravatars וממייסדי GitHub.

אם אתה רוצה להשאיר משוב, אנא פתח issue ב GitHub.

רישיון

Creative Commons ― CC BY 3.0\nבהינתן מספר גרסה MAJOR.MINOR.PATCH, העלה את:\nגרסה ראשית (MAJOR) כאשר אתה עושה שינויים שאינם עולים בקנה אחד עם ה API\nגרסה משנית (MINOR) כשאר אתה מוסיף פונקציונאליות בצורה שתואמת אחורנית\nגרסת תיקון (PATCH) כאשר אתה מבצע תיקוני באגים שתואמים אחורנית\nתוויות נוספות עבור גרסאות קדם הפצה ובניית מטא-דאטה זמינות כתוספת לפורמט MAJOR.MINOR.PATCH.\nבעולם של ניהול תוכנה קיים מקום מפחיד בשם “גיהנום התלויות (dependency hell)”. ככל שהמערכת גדלה ואתה משלב יותר ויותר חבילות לתוכנה, קיים סיכוי גבוה יותר שתמצא את עצמך, יום אחד, בבור של יאוש.\nבתוכנות עם המון תלויות, שחרור גרסה של חבילה חדשה יכול במהירות להפוך לסיוט. אם מפרט התלויות הדוק מידי, אתה בסכנה של “נעילת גרסה (version lock)” (חוסר היכולת לשדרג חבילה מבלי לשחרר גרסה חדשה של כל חבילה תלויה). אם מפרט התלויות רופף מידי, באופן בלתי נמנע אתה תכווה ע”י “מתירנות גרסה (version promiscuity)” (השערה של תאימות, יותר מהסביר, עם גרסאות עתידיות). “גיהנום התלויות” הוא כאשר אתה נמצא במקום בו נעילת גרסה ו/או מתירנות גרסה מונעים ממך להניע את הפרויקט שלך קדימה בקלות ובבטחה.\nעל מנת לפתור בעיה זו, מוצע סט פשוט של כללים ודרישות המכתיבים כיצד מספרי גרסאות יוקצו ויוגדלו. כללים אלה מבוססים על מנהגים משותפים, קיימים ונפוצים בפרויקטי קוד פתוח וסגור. על מנת שמערכת זו תעבוד, תחילה צריך להכריז על API ציבורי. זה אולי יהיה מורכב מתיעוד או יאכף על ידי הקוד עצמו. בכל מקרה, זה חשוב שה API יהיה ברור ומדויק. ברגע שאתה מגדיר את ה API הציבורי שלך, אתה מתקשר בו את השינויים עם תוספות ספציפיות למספר הגרסה. הסתכל על תבנית גרסה של X.Y.Z (בפורמט Major.Minor.Patch). תיקוני באגים שלא משפיעים על ה API יגדילו את מספר את מספר התיקון (Patch), תוספות / שינויים תואמי API לאחור יגדילו את הגרסה המשנית (Minor), ושינויים שאינם נתמכים לאחור ב API יגדילו את הגרסה הראשית (Major).\nאני קורא למערכת “גרסאות סמנטיות”. במסגרת זו, מספרי גרסאות והדרך שבה הם משתנים מעבירה משמעות על הקוד ועל מה שהשתנה מגרסה אחת לאחרת.\nמפרט גרסאות סמנטיות (SemVer)\nמילות המפתח “חייב (MUST)”, “אסור (MUST NOT)”, “חובה (REQUIRED)”, “תהא (SHALL)”, “לא (SHALL NOT)”, “צריך (SHOULD)”, “לא צריך (SHOULD NOT)”, “מומלץ (RECOMMENDED)”, “יכול (MAY)”, “אפשרי (OPTIONAL)” אשר מופיעות במסמך, צריכות להיות מפורשות כמתואר במסמך RFC 2119.\nתוכנה באמצעות גרסאות סמנטיות נדרשת להכריז על API ציבורי. ניתן להכריז על API זה בקוד עצמו או אך ורק בתיעוד. עם זאת זה צריך להיעשות מדויק ומקיף.\nתוכנה באמצעות גרסאות סמנטיות נדרשת להכריז על API ציבורי. ניתן להכריז על API זה בקוד עצמו או אך ורק בתיעוד. עם זאת זה צריך להיעשות מדויק ומקיף.\nמספר גרסה רגילה חייב (MUST) להיות בצורה X.Y.Z כאשר Y, X, ו Z הם מספרים שלמים (Integers) שאינם שליליים, ואסור (Must Not) שיכילו אפסים מובילים. X הוא גרסה ראשית (Major), לאחריו Y הוא גרסה משנית (Minor), ולבסוף Z הוא גרסת תיקון (Patch).
כל רכיב במספר הגרסה חייב (MUST) להגדיל את המספר נומרית. לדוגמה: 1.9.0 -> 1.10.0 -> 1.11.0.\nמספר גרסה רגילה חייב (MUST) להיות בצורה X.Y.Z כאשר Y, X, ו Z הם מספרים שלמים (Integers) שאינם שליליים, ואסור (Must Not) שיכילו אפסים מובילים. X הוא גרסה ראשית (Major), לאחריו Y הוא גרסה משנית (Minor), ולבסוף Z הוא גרסת תיקון (Patch).
כל רכיב במספר הגרסה חייב (MUST) להגדיל את המספר נומרית. לדוגמה: 1.9.0 -> 1.10.0 -> 1.11.0.\nלאחר שחבילה שוחררה, אסור לשנות את התוכן של החבילה באותה גרסה. כל שינוי חייב להשתחרר כגרסה חדשה.\nלאחר שחבילה שוחררה, אסור לשנות את התוכן של החבילה באותה גרסה. כל שינוי חייב להשתחרר כגרסה חדשה.\nגרסה ראשית אפס (0.z.y) היא עבור פיתוח ראשוני. בהינתן שכל דבר יכול להשתנות בכל זמן, ה API הציבורי לא צריך להיחשב יציב.\nגרסה ראשית אפס (0.z.y) היא עבור פיתוח ראשוני. בהינתן שכל דבר יכול להשתנות בכל זמן, ה API הציבורי לא צריך להיחשב יציב.\nגרסה 1.0.0 מגדירה את ה API הציבורי. הדרך שבה מספר הגרסה עולה לאחר שחרור גרסה זו תלוי ב-API הציבורי ובאופן בו הוא משתנה.\nגרסה 1.0.0 מגדירה את ה API הציבורי. הדרך שבה מספר הגרסה עולה לאחר שחרור גרסה זו תלוי ב-API הציבורי ובאופן בו הוא משתנה.\nגרסת תיקון (Patch) במיקום Z (כלומר x > 0
          Z.y.x) חייבת לעלות אם ורק אם הוצגו תיקוני באגים תואמים לאחור. תיקון באג שתואם לאחור מוגדר כשינוי פנימי שמתקן התנהגות לא נכונה.\nגרסת תיקון (Patch) במיקום Z (כלומר x > 0\nZ.y.x) חייבת לעלות אם ורק אם הוצגו תיקוני באגים תואמים לאחור. תיקון באג שתואם לאחור מוגדר כשינוי פנימי שמתקן התנהגות לא נכונה.\nגרסה משנית (Minor) במיקום Y (כלומר x > 0
          z.Y.x) חייבת לעלות שינויי פונקציונאליות חדש, תואם אחורה, שהוצג ב API הציבורי. הוא חייב (MUST) לעלות אם פונקציונאליות כלשהי ב API הציבורי הוגדרה כ-deprecated. הוא יכול (MAY) לעלות אם הוצגו שינויים או חידושיים משמעותיים בתוך הקוד הפרטי. הוא יכול (MAY) לכלול שינויים ברמת תיקון (Patch). מספר הגרסה ברמת תיקון (Patch) חייב (MUST) להיות מאופס ל-0 כאשר מספר הגרסה המשנית (Minor) עולה.\nגרסה משנית (Minor) במיקום Y (כלומר x > 0\nz.Y.x) חייבת לעלות שינויי פונקציונאליות חדש, תואם אחורה, שהוצג ב API הציבורי. הוא חייב (MUST) לעלות אם פונקציונאליות כלשהי ב API הציבורי הוגדרה כ-deprecated. הוא יכול (MAY) לעלות אם הוצגו שינויים או חידושיים משמעותיים בתוך הקוד הפרטי. הוא יכול (MAY) לכלול שינויים ברמת תיקון (Patch). מספר הגרסה ברמת תיקון (Patch) חייב (MUST) להיות מאופס ל-0 כאשר מספר הגרסה המשנית (Minor) עולה.\nגרסה ראשית (Major) במיקום X (כלומר X > 0
          z.y.X) חייבת (MUST) לעלות אם הוצגו שינויים כלשהם ל API הציבורי שאינם תואמים אחורה. היא יכולה (MAY) לכלול שינויים ברמת משנית (Minor) וברמת תיקון (Patch). מספרי גרסאות ברמת תיקון (Patch) וברמה משנית (Minor) חייבים (MUST) להיות מאופסים ל 0 כאשר עולים מספר גרסה ראשית (Major).\nגרסה ראשית (Major) במיקום X (כלומר X > 0\nz.y.X) חייבת (MUST) לעלות אם הוצגו שינויים כלשהם ל API הציבורי שאינם תואמים אחורה. היא יכולה (MAY) לכלול שינויים ברמת משנית (Minor) וברמת תיקון (Patch). מספרי גרסאות ברמת תיקון (Patch) וברמה משנית (Minor) חייבים (MUST) להיות מאופסים ל 0 כאשר עולים מספר גרסה ראשית (Major).\nגרסת קדם הפצה יכולה (MAY) להיות מסומנת על ידי מקף ומזהים מופרדים בנקודות מיד לאחר גרסת התיקון (Patch). מזהים חייבים (MUST) להיות מורכבים מאותיות, מקף, ומספרים בתקן ASCII בלבד [0-9A-Za-z-]. אסור שהמזהה יהיה ריק. אסור שמזהים מספריים יכילו אפסים מובילים. לגרסאות קדם הפצה יש זכות נמוכה מלגרסאות רגילות. גרסת קדם הפצה מציינת כי הגרסה אינה יציבה ויכול להיות שלא תספק את הדרישות כמו גרסה רגילה. דוגמאות: 1.0.0-alpha,  1.0.0-alpha.1,   1.0.0-0.3.7,   1.0.0-x.7.z.92\nגרסת קדם הפצה יכולה (MAY) להיות מסומנת על ידי מקף ומזהים מופרדים בנקודות מיד לאחר גרסת התיקון (Patch). מזהים חייבים (MUST) להיות מורכבים מאותיות, מקף, ומספרים בתקן ASCII בלבד [0-9A-Za-z-]. אסור שהמזהה יהיה ריק. אסור שמזהים מספריים יכילו אפסים מובילים. לגרסאות קדם הפצה יש זכות נמוכה מלגרסאות רגילות. גרסת קדם הפצה מציינת כי הגרסה אינה יציבה ויכול להיות שלא תספק את הדרישות כמו גרסה רגילה. דוגמאות: 1.0.0-alpha,  1.0.0-alpha.1,   1.0.0-0.3.7,   1.0.0-x.7.z.92\n1.0.0-alpha,  1.0.0-alpha.1,   1.0.0-0.3.7,   1.0.0-x.7.z.92\nגרסה בעלת מטא נתונים (metadata build) יכולה (MAY) להיות מסומנת על ידי סימן פלוס ומזהים המפורדים בנקודות הבאים מיד לאחר גרסת התיקון (Patch) או גרסת קדם הפצה. מזהים חייבים (MUST) להיות מורכבים מאותיות, מקף, ומספרים בתקן ASCII בלבד [0-9A-Za-z-]. אסור שהמזהה יהיה ריק. בעת קביעת עדיפות גרסה צריך (SHOULD) להתעלם מגרסת מטא נתונים. לשתי גרסאות שההבדל היחיד ביניהן הוא גרסת המטא נתונים יש אותה עדיפות. דוגמאות: 1.0.0-alpha+001,  1.0.0+20130313144700,   1.0.0-beta+exp.sha.5114f85\nגרסה בעלת מטא נתונים (metadata build) יכולה (MAY) להיות מסומנת על ידי סימן פלוס ומזהים המפורדים בנקודות הבאים מיד לאחר גרסת התיקון (Patch) או גרסת קדם הפצה. מזהים חייבים (MUST) להיות מורכבים מאותיות, מקף, ומספרים בתקן ASCII בלבד [0-9A-Za-z-]. אסור שהמזהה יהיה ריק. בעת קביעת עדיפות גרסה צריך (SHOULD) להתעלם מגרסת מטא נתונים. לשתי גרסאות שההבדל היחיד ביניהן הוא גרסת המטא נתונים יש אותה עדיפות. דוגמאות: 1.0.0-alpha+001,  1.0.0+20130313144700,   1.0.0-beta+exp.sha.5114f85\n1.0.0-alpha+001,  1.0.0+20130313144700,   1.0.0-beta+exp.sha.5114f85\nעדיפות מתייחסת לאופן בו משווים גרסאות זה לזה כאשר הם מסודרים. עדיפות חייבת (MUST) להיות מחושבת על ידי הפרדת הגרסה לראשי (Major), משני (Minor), תיקון (Patch) ומזהי קדם הפצה בסדר הזה (נתוני מטה אינם נלקחים בחשבון בעדיפות). העדיפות נקבעת על ידי ההבדל הראשון כאשר משווים את כל המזהים מספרית משמאל לימין כדלקמן: ראשי (Major), משני (Minor) ותיקון (Patch) תמיד משווים מספרית. דוגמה 2.1.1 > 2.1.0 > 2.0.0 > 1.0.0. כאשר ראשי (Major), משני (Minor) ותיקון (Patch) שווים, ולגרסת קדם הפצה יש עדיפות נמוכה יותר מאשר לגרסה רגילה. דוגמה ֿ1.0.0 > 1.0.0-alpha. עדיפות עבור שתי גרסאות קדם הפצה עם גרסאות ראשי (Major), משני (Minor), תיקון (Patch) זהים חייב (MUST) להיקבע על ידי השוואה של מזהה בין הנקודות משמאל לימין עד שנמצא הבדל כדלקמן: מזהים המורכבים מספרות בלבד משווים בצורה מספרית (נומרית) ומזהים עם אותיות או מקפים משווים לקסיקלית בסדר מיון של תקן ASCII. למזהים מספריים תמיד תהיה עדיפות נמוכה ממזהים שאינם מספריים. לקבוצה גדולה יותר של מזהים בגרסת קדם הפצה יש עדיפות גבוהה יותר מקבוצה קטנה יותר, אם כל אמצעי ההשוואה למזהים שקדמו שווים. דוגמאות: 1.0.0 > 1.0.0-rc.1 > 1.0.0-beta.11 > 1.0.0-beta.2 > 1.0.0-beta > 1.0.0-alpha.beta > 1.0.0-alpha.1 > 1.0.0-alpha\n1.0.0 > 1.0.0-rc.1 > 1.0.0-beta.11 > 1.0.0-beta.2 > 1.0.0-beta > 1.0.0-alpha.beta > 1.0.0-alpha.1 > 1.0.0-alpha\nלמה להשתמש בגרסאות סמנטיות?\nזה לא רעיון חדש או מהפכני. למעשה, כנראה שאתה עושה משהו קרוב לזה כבר עכשיו. הבעיה היא ש”קרוב” זה לא מספיק טוב. ללא תאימות כלשהי למפרט פורמלי, מספרי גרסה הם למעשה חסרי תועלת לניהול תלויות. על ידי מתן שם ברור והגדרה ברורה לרעיונות שהוצגו כאן, תקשור הכוונות שלנו למשתמשי התוכנה נעשה קל יותר. לאחר שהכוונות האלו ברורות וגמישות (אבל לא גמישות מידי), יכול בסופו של דבר להתבצע מפרט תלויות.\nדוגמא פשוטה תדגים כיצד גרסאות סמנטיות יכולות להפוך את “גהינום התלויות” לנחלת העבר. דמיינו ספריה בשם “כבאית”. שדורשת ספרייה בשם “סולם” שעומדת במפרט של גרסאות סמנטיות. באותו הזמן שבו הכבאית נוצרה, ספריית סולם הייתה בגרסה 3.1.0. מכיוון שהכבאית משתמשמת בפונקציונליות שהוצגה בגרסה 3.1.0, ניתן לציין את התלות של ספריית כבאית בספריית סולם כגדול או שווה לגרסה מספר 3.1.0 אך פחות מ 4.0.0. עכשיו כאשר גרסת סולם מספר 3.1.1 ומספר 3.2.0 מתפרסמות, אפשר להשתמש בהן בספריית הכבאית בבטחה, ולדעת שהן תהיינה תואמות את ה API הקיים של הספרייה עליו אנו מסתמכים בספריית הכבאית שלנו.\nכמפתח אחראי תוכל, כמובן, לוודא כי כל שדרוגי החבילה מתפקדים כפי שפורסם. העולם האמיתי הינו מקום מבולגן; אין שום דבר שאנחנו יכולים לעשות לגבי זה למעט להיות על המשמר. מה שאתה יכול לעשות זה לתת למפרט הגרסאות הסמנטיות לספק לך דרך שפויה לשחרר ולשדרג חבילות מבלי לגלגל גרסה חדשה של חבילות תלויות, מה שחוסך לך זמן וטרחה.\nאם כל זה נשמע טוב, כל מה שאתה צריך לעשות כדי להתחיל להשתמש בגרסאות סמנטיות הוא להכריז שאתה עושה כך, ולאחר מכן להקפיד על הכללים. כלול קישור לאתר זה בקובץ ה-README שלך כדי שאחרים ידעו את הכללים ויוכלו להפיק מהם תועלת.\nכיצד עלי להתמודד עם תיקונים בשלב הפיתוח הראשוני O.y.z?\nהדבר הפשוט ביותר לעשות הוא להתחיל לשחרר את הפיתוח הראשוני שלך בגרסה 0.1.0 ואז להגדיל את הגרסה המשנית (Minor) לכל גרסה שבא אחריה.\nאיך אדע מתי אוכל לשחרר את גרסה 1.0.0?\nאם התוכנה שלך נמצאת בשימוש בשימוש לקוחות אמיתיים (Production), אתה כנראה צריך להיות כבר בגרסה 1.0.0. אם יש לך API יציב שעליו המשתמש יכול לסמוך, אתה צריך להיות על גרסה 1.0.0. אם אתה דואג הרבה לגבי תאימות לאחור, אתה בוודאי כבר צריך להיות בגרסה 1.0.0.\nהאם זה לא מונע פיתוח מהיר?\nכל העניין של גרסה ראשית (Major) אפס הוא פיתוח מהיר. אם אתה משנה את ה API כל יום אתה צריך להיות על גרסה 0.z.y או על ענף פיתוח נפרד בשביל הגרסה ראשית (Major) הבאה.\nאם אפילו השינויים הקטנים ביותר ל API ששוברים תמיכה לאחור מחייבים להעלות גרסה ראשית, האם אני לא אגיע מהר מאוד לגרסה 42.0.0?\nזוהי שאלה של פיתוח אחראי וראיית הנולד. שינויים ששוברים תמיכה צריכים לקרות בצורה קלילה לתוכנה בעלת הרבה תלויות. העלות שנגרמת משדרוג יכולה להיות משמעותית. מכיוון שאתה חייב להעלות גרסה ראשית (Major) כדי לשחרר שינויים שוברי תאימות, אתה תחשוב היטב על ההשפעה של השינויים שלך, ותעריך את יחס העלות ― תועלת המעורב בכך.\nתיעוד כל הAPI הציבורי זה יותר מדי עבודה!\nזוהי האחריות שלך בתור מפתח מקצועי לתעד תוכנה שמיועדת לשימוש על ידי אחרים. ניהול המורכבות של התכונה הינו חשוב מאין כמוהו לשמירת הפרויקט יעיל, וזה משהו שקשה לעשות אם אף אחד לא יודע כיצד להשתמש בתוכנה שלך, או לאיזה מתודות אפשר לקרוא בבטחה. בטווח הארוך, גרסאות סמנטיות, וההתעקשות על API מוגדר היטב יכול לשמור על כולם והכל יפעל בצורה חלקה.\nמה עלי לעשות אם אני בטעות שחררתי שינויים לא תואמים אחורה כגרסה משנית (Minor)?\nברגע שאתה מבין ששברת את מפרט הגרסאות הסמנטיות, תקן את הבעיה ושחרר גרסה משנית (Minor) חדשה עם שחזור התאימות לאחור. אפילו בנסיבות כאלו זה בלתי מקובל לשנות תוכן של גרסאות קיימות. אם זה מתאים, תעד את הגרסה הסוררת ויידע את המשתמשים שלך על הבעיה כדי שיהיו מודעים לבעיה שבגרסה זו.\nמה עלי לעשות אם אני מעדכן את התלויות שלי מבלי לשנות את ה API הציבורי?\nזה יחשב כתואם מכיוון שזה לא משפיע על ה API הציבורי. תוכנה שתלויה באופן מפורש באותן תלויות בהן התוכנה שלך תלויה צריכה לכלול מפרט תלויות משלה והמחבר של אותה התוכנה יבחין בקונפליקטים. קביעה האם מדובר בשינוי ברמת תיקון (Patch) או ברמה משנית (Minor) תלויה בהאם אתה מעדכן את התלויות שלך כדי לתקן באג או להציג פונקציונליות חדשה. בדרך כלל בהוספת פונקציונליות צפוי גם קוד נוסף, ובמקרה כזה זה כמובן מצריך העלה של גרסה משנית (Minor).\nמה אם אני משנה בטעות את ה API הציבורי באופן שאינו תואם עם שינוי מספר הגרסה (למשל קוד מציג שינוי שובר תאימות ראשי (Major) בשחרור בעל שינוי בגרסת התיקון (Patch) בלבד)\nהשתמש בשיקול הדעת שלך. אם יש לך קהל ענק שיושפע באופן גדול משינוי ההתנהגות אחורה לכוונה המקורית של ה API הציבורי, אז יכול להיות שהכי טוב יהיה לבצע שחרור של גרסה ראשית (Major), אפילו אם התיקון יכול להיחשב כגרסת תיקון (Patch) בלבד. זכור, ניהול גרסאות סמנטי הוא העברת מסר באמצעות הצורה שמספר הגרסה משתנה. אם השינויים האלה חשובים למשתמשים שלך, השתמש במספר הגרסה כדי ליידע אותם.\nאיך אני צריך לטפל ב deprecating?\nפונקציונליות שהופכת לdeprecated (מיושנת) הינו תהליך נורמלי בפיתוח תוכנה, ולפעמים הוא אף נדרש כדי להתקדם. כאשר אתה הופך חלק מה API הציבורי שלך לdeprecated, אתה צריך לעשות שני דברים: (1) לעדכן את התיעוד שלך כדי לתת למשתמשים לדעת על השינוי (2) לשחרר גרסה משנית (Minor) עם הפונקציונליות שבמצב deprecated. לפי שאתה מסיר לחלוטין את הפונקציונליות הזאת בגרסה ראשית (Major) חדשה, צריכה להיות לפחות גרסה אחת משנית (Minor) שמכילה את הפונקציונליות עם הודעת הdeprecated כדי שהמשתמשים יוכלו לעבור בקלות ל API החדש.\nהאם ל semver יש מגבלת גודל על ה String של הגרסה?\nלא, אבל הפעל שיקול דעת. לדוגמה, מחרוזת גרסה בעלת 255 תווים היא כנראה מוגזמת. כמו כן, מערכות ספציפיות עשויות להטיל מגבלות משלהן על גודל המחרוזת.\nהאם “v1.2.3” היא גרסה סמנטית?\nלא, “v1.2.3” אינו גרסה סמנטית. עם זאת, קידומת “v” לגרסה סמנטית היא דרך נפוצה (באנגלית) לציין מספר גרסה.
לעתים קיצור המילה “גרסה”  (version)כ-“v” מופיע בניהול גרסאות.\nהאם יש ביטוי רגולרי (RegEx) מומלץ לבדיקת גרסה סמנטית?\nיש שניים. אחד עם קבוצות שמות (מערכות תומכות:PCRE, Perl, PHP, R, Python  ו-Go), כאן: https://regex101.com/r/Ly7O1x/3\nhttps://regex101.com/r/Ly7O1x/3\nואחד עם קבוצות לכידה ממוספרות (תואם ל-ECMA Script (JavaScript), PCRE, Perl, PHP, R, Python ו-Go), כאן: https://regex101.com/r/vkijKf/1\nhttps://regex101.com/r/vkijKf/1\nמפרט הגרסאות הסמנטיות נכתב על ידי טום פרסון-ורנר, ממציא ה Gravatars וממייסדי GitHub.\nאם אתה רוצה להשאיר משוב, אנא פתח issue ב GitHub.\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nअर्थपूर्ण संस्करण 2.0.0

सारांश
एक संस्करण संख्या MAJOR.MINOR.PATCH को देखते हुए, वृद्धि:


  जब आप असंगत एपीआई परिवर्तन करते हैं तो प्रमुख संस्करण,
  MINOR संस्करण जब आप पिछड़े-संगत तरीके से कार्यक्षमता जोड़ते हैं, और
  जब आप पीछे-संगत बग फिक्स करते हैं तो पैच संस्करण।


प्री-रिलीज और मेटाडेटा के लिए अतिरिक्त लेबल MAJOR.MINOR.PATCH प्रारूप में एक्सटेंशन के रूप में उपलब्ध हैं।

परिचय

सॉफ्टवेयर प्रबंधन की दुनिया में “निर्भरता नरक” नामक एक डरावनी जगह मौजूद है। आपका सिस्टम बड़ा हो जाता है और जितना अधिक पैकेज आप अपने सॉफ़्टवेयर में एकीकृत करते हैं, उतना ही अधिक आप निराशा के इस गड्ढे में खुद को ढूंढ सकते हैं।

कई निर्भरताओं वाले सिस्टम में, नए पैकेज संस्करण जारी करने से जल्दी ही एक दुःस्वप्न बन सकता है। यदि निर्भरता विनिर्देश बहुत तंग हैं, तो आप संस्करण लॉक (प्रत्येक आश्रित पैकेज के नए संस्करणों को जारी किए बिना पैकेज को अपग्रेड करने में असमर्थता) के खतरे में हैं। यदि निर्भरताओं को बहुत कम निर्दिष्ट किया गया है, तो आप अनिवार्य रूप से संस्करण संविधान द्वारा काट लेंगे (उचित से अधिक भविष्य के संस्करणों के साथ संगतता मानते हैं)। निर्भरता नरक वह जगह है जहां आप संस्करण लॉक और / या संस्करण संविधान आपको अपने प्रोजेक्ट को आगे और आसानी से स्थानांतरित करने से रोकते हैं।

इस समस्या के समाधान के रूप में, मैं नियमों और आवश्यकताओं का एक सरल सेट प्रस्तावित करता हूं जो निर्देश देते हैं कि संस्करण संख्याएं कैसे आवंटित की जाती हैं और वृद्धि हुई हैं। ये नियम बंद और खुले स्रोत सॉफ्टवेयर दोनों में उपयोग में पूर्व-मौजूदा व्यापक सामान्य प्रथाओं तक सीमित नहीं हैं, बल्कि यह आवश्यक नहीं हैं। इस प्रणाली के लिए काम करने के लिए, आपको सबसे पहले एक सार्वजनिक एपीआई घोषित करने की आवश्यकता है। इसमें दस्तावेज शामिल हो सकते हैं या कोड द्वारा ही लागू किया जा सकता है। भले ही, यह महत्वपूर्ण है कि यह एपीआई स्पष्ट और सटीक हो। एक बार जब आप अपनी सार्वजनिक एपीआई की पहचान कर लेंगे, तो आप अपने संस्करण संख्या में विशिष्ट वृद्धि के साथ इसमें परिवर्तनों को संवाद करेंगे। XYZ (Major.Minor.Patch) के संस्करण प्रारूप पर विचार करें। बग फिक्स एपीआई वृद्धि को प्रभावित नहीं करते हैं, पैच संस्करण, पिछड़ा संगत एपीआई जोड़ / परिवर्तन मामूली संस्करण में वृद्धि करता है, और पीछे की असंगत एपीआई परिवर्तन प्रमुख संस्करण में वृद्धि करता है।

मैं इस प्रणाली को “अर्थपूर्ण संस्करण” कहता हूं। इस योजना के तहत, संस्करण संख्याएं और जिस तरह से वे बदलते हैं, अंतर्निहित कोड के बारे में अर्थ बताते हैं और एक संस्करण से अगले संस्करण में क्या संशोधित किया गया है।

अर्थपूर्ण संस्करण विशिष्टता (सेमवीर)

मुख्य शब्द “जरूरी”, “आवश्यक नहीं”, “आवश्यक”, “साझा करें”, “नहीं होगा”, “चाहिए”, “नहीं होना चाहिए”, “अनुशंसित”, “मई” और “वैकल्पिक” इस दस्तावेज़ में हैं आरएफसी 2119 में वर्णित के रूप में व्याख्या किया जाना है ।


  
    अर्थपूर्ण संस्करण का उपयोग कर सॉफ्टवेयर एक सार्वजनिक एपीआई घोषित करना चाहिए। इस एपीआई को कोड में ही घोषित किया जा सकता है या दस्तावेज़ीकरण में सख्ती से मौजूद है। हालांकि यह किया जाता है, यह सटीक और व्यापक होना चाहिए।
  
  
    एक सामान्य संस्करण संख्या को XYZ फॉर्म लेना चाहिए जहां एक्स, वाई, और जेड गैर-ऋणात्मक पूर्णांक हैं, और इसमें प्रमुख शून्य शामिल नहीं होनी चाहिए। एक्स प्रमुख संस्करण है, वाई मामूली संस्करण है, और जेड पैच संस्करण है। प्रत्येक तत्व संख्यात्मक रूप से बढ़ना चाहिए। उदाहरण के लिए: 1.9.0 -> 1.10.0 -> 1.11.0।
  
  
    एक बार एक संस्करण पैकेज जारी किया गया है, उस संस्करण की सामग्री को संशोधित नहीं किया जाना चाहिए। किसी भी संशोधन को एक नए संस्करण के रूप में जारी किया जाना चाहिए।
  
  
    प्रमुख संस्करण शून्य (0.yz) प्रारंभिक विकास के लिए है। कुछ भी किसी भी समय बदल सकता है। सार्वजनिक एपीआई को स्थिर नहीं माना जाना चाहिए।
  
  
    संस्करण 1.0.0 सार्वजनिक एपीआई को परिभाषित करता है। इस रिलीज के बाद जिस संस्करण में संस्करण संख्या बढ़ी है, इस सार्वजनिक एपीआई पर निर्भर है और यह कैसे बदलता है।
  
  
    
      
        
          पैच संस्करण जेड (xyZ
          x> 0) केवल पिछड़ा संगत बग फिक्स पेश किए जाने पर वृद्धि की जानी चाहिए। एक बग फिक्स को आंतरिक परिवर्तन के रूप में परिभाषित किया जाता है जो गलत व्यवहार को हल करता है।
        
      
    
  
  
    
      
        
          छोटे संस्करण वाई (xYz
          x> 0) को बढ़ाया जाना चाहिए यदि सार्वजनिक, एपीआई के लिए नई, पिछली संगत कार्यक्षमता पेश की गई हो। यदि किसी भी सार्वजनिक एपीआई कार्यक्षमता को बहिष्कृत के रूप में चिह्नित किया गया है तो इसे बढ़ाया जाना चाहिए। निजी कोड के भीतर पर्याप्त नई कार्यक्षमता या सुधार पेश किए जाने पर यह बढ़ाई जा सकती है। इसमें पैच स्तर परिवर्तन शामिल हो सकते हैं। छोटे संस्करण को बढ़ाए जाने पर पैच संस्करण को 0 पर रीसेट किया जाना चाहिए।
        
      
    
  
  
    
      
        
          प्रमुख संस्करण एक्स (Xyz
          X> 0) को बढ़ाया जाना चाहिए यदि सार्वजनिक एपीआई में कोई पिछड़ा असंगत परिवर्तन पेश किया गया हो। इसमें मामूली और पैच स्तर परिवर्तन शामिल हो सकते हैं। जब बड़े संस्करण में वृद्धि हुई है तो पैच और मामूली संस्करण को 0 पर रीसेट किया जाना चाहिए।
        
      
    
  
  
    एक प्री-रिलीज संस्करण पैच संस्करण के तुरंत बाद एक हाइफ़न और डॉट अलग पहचानकर्ताओं की एक श्रृंखला को जोड़कर दर्शाया जा सकता है। पहचानकर्ताओं में केवल एएससीआईआई अल्फान्यूमेरिक्स और हाइफ़न [0-9 ए-ज़ा-जेड-] शामिल होना चाहिए। पहचानकर्ता खाली नहीं होना चाहिए। संख्यात्मक पहचानकर्ताओं में अग्रणी शून्य शामिल नहीं होना चाहिए। प्री-रिलीज संस्करणों में संबंधित सामान्य संस्करण की तुलना में कम प्राथमिकता है। एक प्री-रिलीज संस्करण इंगित करता है कि संस्करण अस्थिर है और इसके अनुरूप सामान्य संस्करण द्वारा बताए गए इच्छित संगतता आवश्यकताओं को पूरा नहीं कर सकता है। उदाहरण: 1.0.0-अल्फा, 1.0.0-अल्फा .1, 1.0.0-0.3.7, 1.0.0-x.7.z.92।
  
  
    पैच या प्री-रिलीज संस्करण के तुरंत बाद एक प्लस साइन और डॉट से अलग पहचानकर्ताओं की एक श्रृंखला को जोड़कर मेटाडाटा मई को इंगित किया जा सकता है। पहचानकर्ताओं में केवल एएससीआईआई अल्फान्यूमेरिक्स और हाइफ़न [0-9 ए-ज़ा-जेड-] शामिल होना चाहिए। पहचानकर्ता खाली नहीं होना चाहिए। संस्करण प्राथमिकता निर्धारित करते समय मेटाडेटा को अनदेखा किया जाना चाहिए। इस प्रकार दो संस्करण जो बिल्ड मेटाडेटा में भिन्न होते हैं, वही प्राथमिकता रखते हैं। उदाहरण: 1.0.0-अल्फा + 001, 1.0.0 + 20130313144700, 1.0.0-बीटा + exp.sha.5114f85।
  
  प्राथमिकता यह दर्शाती है कि आदेश दिए जाने पर संस्करणों की तुलना एक दूसरे से कैसे की जाती है। प्राथमिकता को उस क्रम में प्रमुख, मामूली, पैच और प्री-रिलीज पहचानकर्ताओं में संस्करण को अलग करके गणना की जानी चाहिए (मेटाडाटा बनाएं प्राथमिकता में नहीं है)। प्राथमिकता को पहले अंतर से निर्धारित किया जाता है जब इन पहचानकर्ताओं में से प्रत्येक को बाएं से दाएं से तुलना करें: मेजर, नाबालिग और पैच संस्करणों की तुलना हमेशा संख्यात्मक रूप से की जाती है। उदाहरण: 1.0.0 <2.0.0 <2.1.0 <2.1.1। जब प्रमुख, नाबालिग और पैच बराबर होते हैं, तो प्री-रिलीज़ संस्करण में सामान्य संस्करण की तुलना में कम प्राथमिकता होती है। उदाहरण: 1.0.0-अल्फा <1.0.0। एक ही प्रमुख, नाबालिग और पैच संस्करण के साथ दो प्री-रिलीज संस्करणों की प्राथमिकता प्रत्येक डॉट से अलग पहचानकर्ता को बाएं से दाएं की तुलना करके निर्धारित किया जाना चाहिए जब तक कोई अंतर निम्नानुसार नहीं मिलता है: केवल अंकों की पहचान करने वाले पहचानकर्ताओं की संख्या संख्यात्मक रूप से तुलना की जाती है और अक्षरों या हाइफ़न वाले पहचानकर्ताओं की तुलना एएससीआईआई क्रमबद्ध क्रम में तुलनात्मक रूप से की जाती है। गैर-संख्यात्मक पहचानकर्ताओं की तुलना में संख्यात्मक पहचानकर्ताओं की हमेशा कम प्राथमिकता होती है। प्री-रिलीज फ़ील्ड्स का एक बड़ा सेट एक छोटे से सेट की तुलना में अधिक प्राथमिकता है, यदि पिछले सभी पहचानकर्ता बराबर हैं। उदाहरण: 1.0.0-अल्फा <1.0.0-alpha.1 <1.0.0-alpha.beta <1.0.0-beta <1.0.0-beta.2 <1.0.0-beta.11 <1.0.0- आरसी .1 <1.0.0।


अर्थपूर्ण संस्करण का उपयोग क्यों करें?

यह एक नया या क्रांतिकारी विचार नहीं है। असल में, आप शायद पहले से ही कुछ करीब कर सकते हैं। समस्या यह है कि “करीबी” पर्याप्त नहीं है। औपचारिक विनिर्देश के किसी प्रकार के अनुपालन के बिना, निर्भरता प्रबंधन के लिए संस्करण संख्या अनिवार्य रूप से बेकार हैं। उपर्युक्त विचारों को नाम और स्पष्ट परिभाषा देकर, अपने इरादे को अपने सॉफ़्टवेयर के उपयोगकर्ताओं को संवाद करना आसान हो जाता है। एक बार इन इरादों को स्पष्ट, लचीला (लेकिन बहुत लचीला नहीं) निर्भरता विनिर्देशों को अंत में बनाया जा सकता है।

एक साधारण उदाहरण यह दिखाएगा कि कैसे अर्थपूर्ण संस्करणिंग निर्भरता नरक को अतीत की बात कर सकती है। “फायरट्रुक” नामक एक लाइब्रेरी पर विचार करें। इसे “सीढ़ी” नामक एक सेमेन्टिकली वर्जन पैकेज की आवश्यकता होती है। जब फायरट्रुक बनाया जाता है, तो लेडर संस्करण 3.1.0 पर होता है। चूंकि फायरट्रुक कुछ कार्यक्षमता का उपयोग करता है जिसे पहली बार 3.1.0 में पेश किया गया था, आप सुरक्षित रूप से लेडर निर्भरता को 3.1.0 से अधिक या बराबर के रूप में निर्दिष्ट कर सकते हैं लेकिन 4.0.0 से कम। अब, जब लेडर संस्करण 3.1.1 और 3.2.0 उपलब्ध हो जाते हैं, तो आप उन्हें अपने पैकेज प्रबंधन प्रणाली में छोड़ सकते हैं और जानते हैं कि वे मौजूदा आश्रित सॉफ्टवेयर के साथ संगत होंगे।

एक जिम्मेदार डेवलपर के रूप में, आप निश्चित रूप से सत्यापित करना चाहते हैं कि विज्ञापन के रूप में किसी भी पैकेज अपग्रेड का कार्य करें। वास्तविक दुनिया एक गन्दा जगह है; इसके बारे में हम कुछ नहीं कर सकते लेकिन सतर्क रहें। आप क्या कर सकते हैं अर्थपूर्ण संस्करण आपको निर्भर पैकेज के नए संस्करणों को रोल किए बिना संकुल को रिलीज़ और अपग्रेड करने के लिए एक मौका तरीका प्रदान करता है, जिससे आप समय और परेशानी बचा सकते हैं।

यदि यह सब वांछनीय लगता है, तो आपको अर्थपूर्ण संस्करण का उपयोग शुरू करने के लिए केवल इतना करना है कि आप ऐसा कर रहे हैं और फिर नियमों का पालन करें। इस वेबसाइट से अपने रीडमे से लिंक करें ताकि अन्य नियमों को जान सकें और उनसे लाभ उठा सकें।

सामान्य प्रश्न
0.yz प्रारंभिक विकास चरण में संशोधन के साथ मुझे कैसे निपटना चाहिए?

करने के लिए सबसे सरल बात यह है कि अपनी शुरुआती विकास रिलीज 0.1.0 पर शुरू करें और फिर प्रत्येक आगामी रिलीज के लिए मामूली संस्करण को बढ़ाएं।

मुझे कैसे पता चलेगा कि 1.0.0 कब रिलीज़ किया जाए?

यदि आपके सॉफ़्टवेयर का उत्पादन में उपयोग किया जा रहा है, तो यह शायद पहले से ही 1.0.0 होना चाहिए। यदि आपके पास स्थिर API है जिस पर उपयोगकर्ता निर्भर हैं, तो आपको 1.0.0 होना चाहिए। यदि आप पीछे की संगतता के बारे में बहुत कुछ चिंता कर रहे हैं, तो आपको शायद पहले ही 1.0.0 होना चाहिए।

क्या यह तेजी से विकास और तेजी से पुनरावृत्ति को हतोत्साहित नहीं करता है?

प्रमुख संस्करण शून्य तेजी से विकास के बारे में है। यदि आप हर दिन एपीआई बदल रहे हैं तो आपको अभी भी संस्करण 0.yz या अगले प्रमुख संस्करण पर काम कर रहे एक अलग विकास शाखा में होना चाहिए।

यदि सार्वजनिक एपीआई में सबसे छोटा पिछड़ा असंगत परिवर्तन भी एक प्रमुख संस्करण टक्कर की आवश्यकता है, तो क्या मैं संस्करण 42.0.0 पर बहुत तेजी से समाप्त नहीं होगा?

यह जिम्मेदार विकास और दूरदर्शिता का सवाल है। असंगत परिवर्तनों को हल्के ढंग से सॉफ़्टवेयर में पेश नहीं किया जाना चाहिए जिसमें बहुत से निर्भर कोड हैं। अपग्रेड करने के लिए जो लागत होनी चाहिए वह महत्वपूर्ण हो सकती है। असंगत परिवर्तनों को जारी करने के लिए प्रमुख संस्करणों को टक्कर देने का मतलब है कि आप अपने परिवर्तनों के प्रभाव के माध्यम से सोचेंगे, और शामिल लागत / लाभ अनुपात का मूल्यांकन करेंगे।

पूरे सार्वजनिक एपीआई को दस्तावेज करना बहुत अधिक काम है!

एक पेशेवर डेवलपर के रूप में यह आपकी ज़िम्मेदारी है कि दूसरों द्वारा उपयोग के लिए सॉफ्टवेयर का सही तरीके से दस्तावेज किया जाए। सॉफ़्टवेयर जटिलता का प्रबंधन करना एक परियोजना को कुशल रखने का एक बेहद महत्वपूर्ण हिस्सा है, और यदि कोई नहीं जानता कि आपके सॉफ़्टवेयर का उपयोग कैसे करें, या कॉल करने के लिए कौन सी विधियां सुरक्षित हैं, तो यह करना मुश्किल है। लंबे समय तक, सेमेन्टिक वर्जनिंग, और एक अच्छी तरह से परिभाषित सार्वजनिक एपीआई पर जोर हर किसी और सबकुछ सुचारू रूप से चल रहा है।

यदि मैं गलती से एक मामूली संस्करण के रूप में पिछड़ा असंगत परिवर्तन जारी करता हूं तो मैं क्या करूँ?

जैसे ही आप महसूस करते हैं कि आपने अर्थात् संस्करण संस्करण को तोड़ दिया है, समस्या को ठीक करें और एक नया मामूली संस्करण जारी करें जो समस्या को सुधारता है और पीछे की संगतता को पुनर्स्थापित करता है। इस परिस्थिति में भी, संस्करण संस्करणों को संशोधित करने के लिए अस्वीकार्य है। यदि यह उचित है, तो अपमानजनक संस्करण दस्तावेज करें और समस्या के अपने उपयोगकर्ताओं को सूचित करें ताकि वे अपमानजनक संस्करण से अवगत हों।

यदि मैं सार्वजनिक एपीआई को बदले बिना अपनी निर्भरता अपडेट करता हूं तो मुझे क्या करना चाहिए?

इसे संगत माना जाएगा क्योंकि यह सार्वजनिक एपीआई को प्रभावित नहीं करता है। सॉफ़्टवेयर जो स्पष्ट रूप से समान निर्भरताओं पर निर्भर करता है क्योंकि आपके पैकेज में अपनी निर्भरता विनिर्देश होनी चाहिए और लेखक को कोई भी विवाद दिखाई देगा। यह निर्धारित करना कि परिवर्तन एक पैच स्तर है या नाबालिग स्तर संशोधन इस बात पर निर्भर करता है कि आपने बग को ठीक करने या नई कार्यक्षमता को पेश करने के लिए अपनी निर्भरताओं को अपडेट किया है या नहीं। मैं आमतौर पर बाद के उदाहरण के लिए अतिरिक्त कोड की अपेक्षा करता हूं, इस मामले में यह स्पष्ट रूप से मामूली स्तर की वृद्धि है।

क्या होगा यदि मैं अनजाने में सार्वजनिक एपीआई को ऐसे तरीके से बदलता हूं जो संस्करण संख्या परिवर्तन के अनुरूप नहीं है (यानी कोड पैच रिलीज में गलत ब्रेकिंग परिवर्तन को गलत तरीके से प्रस्तुत करता है)

अपने सबसे अच्छे फैसले का प्रयोग करें। यदि आपके पास एक विशाल दर्शक हैं जो सार्वजनिक एपीआई के इरादे से व्यवहार को बदलकर बहुत प्रभावित होंगे, तो यह एक प्रमुख संस्करण रिलीज करने के लिए सबसे अच्छा हो सकता है, भले ही फिक्स को पैच रिलीज माना जा सके। याद रखें, अर्थात् वर्जनिंग सब कुछ बताता है कि संस्करण संख्या कैसे बदलती है। यदि ये परिवर्तन आपके उपयोगकर्ताओं के लिए महत्वपूर्ण हैं, तो उन्हें सूचित करने के लिए संस्करण संख्या का उपयोग करें।

मुझे बहिष्करण कार्यक्षमता को कैसे संभालना चाहिए?

मौजूदा कार्यक्षमता को कम करना सॉफ्टवेयर विकास का एक सामान्य हिस्सा है और अक्सर प्रगति को आगे बढ़ाने की आवश्यकता होती है। जब आप अपने सार्वजनिक एपीआई का हिस्सा बहिष्कृत करते हैं, तो आपको दो चीजें करना चाहिए: (1) उपयोगकर्ताओं को परिवर्तन के बारे में जानकारी देने के लिए अपने दस्तावेज़ों को अपडेट करें, (2) जगह पर बहिष्करण के साथ एक नई मामूली रिलीज जारी करें। एक नई बड़ी रिलीज में कार्यक्षमता को पूरी तरह से हटाने से पहले कम से कम एक मामूली रिलीज होनी चाहिए जिसमें बहिष्करण शामिल है ताकि उपयोगकर्ता आसानी से नए एपीआई में संक्रमण कर सकें।

क्या वर्जन स्ट्रिंग पर सेमेवर की आकार सीमा है?

नहीं, लेकिन अच्छे फैसले का प्रयोग करें। उदाहरण के लिए, 255 वर्ण संस्करण स्ट्रिंग शायद अधिक है। साथ ही, विशिष्ट सिस्टम स्ट्रिंग के आकार पर अपनी सीमा लगा सकते हैं।

के बारे में

अर्थात् संस्करण संस्करण विनिर्देशन ट्रा प्रेस्टन-वर्नर , ग्रेवाटर के आविष्कारक और गिटहब के कोफाउंडर द्वारा लिखा गया है।

अगर आप फीडबैक छोड़ना चाहते हैं, तो कृपया गिटहब पर एक समस्या खोलें।

लाइसेंस

क्रिएटिव कॉमन्स ― 3.0 द्वारा सीसी\nअर्थपूर्ण संस्करण 2.0.0\nएक संस्करण संख्या MAJOR.MINOR.PATCH को देखते हुए, वृद्धि:\nजब आप असंगत एपीआई परिवर्तन करते हैं तो प्रमुख संस्करण,\nMINOR संस्करण जब आप पिछड़े-संगत तरीके से कार्यक्षमता जोड़ते हैं, और\nजब आप पीछे-संगत बग फिक्स करते हैं तो पैच संस्करण।\nप्री-रिलीज और मेटाडेटा के लिए अतिरिक्त लेबल MAJOR.MINOR.PATCH प्रारूप में एक्सटेंशन के रूप में उपलब्ध हैं।\nसॉफ्टवेयर प्रबंधन की दुनिया में “निर्भरता नरक” नामक एक डरावनी जगह मौजूद है। आपका सिस्टम बड़ा हो जाता है और जितना अधिक पैकेज आप अपने सॉफ़्टवेयर में एकीकृत करते हैं, उतना ही अधिक आप निराशा के इस गड्ढे में खुद को ढूंढ सकते हैं।\nकई निर्भरताओं वाले सिस्टम में, नए पैकेज संस्करण जारी करने से जल्दी ही एक दुःस्वप्न बन सकता है। यदि निर्भरता विनिर्देश बहुत तंग हैं, तो आप संस्करण लॉक (प्रत्येक आश्रित पैकेज के नए संस्करणों को जारी किए बिना पैकेज को अपग्रेड करने में असमर्थता) के खतरे में हैं। यदि निर्भरताओं को बहुत कम निर्दिष्ट किया गया है, तो आप अनिवार्य रूप से संस्करण संविधान द्वारा काट लेंगे (उचित से अधिक भविष्य के संस्करणों के साथ संगतता मानते हैं)। निर्भरता नरक वह जगह है जहां आप संस्करण लॉक और / या संस्करण संविधान आपको अपने प्रोजेक्ट को आगे और आसानी से स्थानांतरित करने से रोकते हैं।\nइस समस्या के समाधान के रूप में, मैं नियमों और आवश्यकताओं का एक सरल सेट प्रस्तावित करता हूं जो निर्देश देते हैं कि संस्करण संख्याएं कैसे आवंटित की जाती हैं और वृद्धि हुई हैं। ये नियम बंद और खुले स्रोत सॉफ्टवेयर दोनों में उपयोग में पूर्व-मौजूदा व्यापक सामान्य प्रथाओं तक सीमित नहीं हैं, बल्कि यह आवश्यक नहीं हैं। इस प्रणाली के लिए काम करने के लिए, आपको सबसे पहले एक सार्वजनिक एपीआई घोषित करने की आवश्यकता है। इसमें दस्तावेज शामिल हो सकते हैं या कोड द्वारा ही लागू किया जा सकता है। भले ही, यह महत्वपूर्ण है कि यह एपीआई स्पष्ट और सटीक हो। एक बार जब आप अपनी सार्वजनिक एपीआई की पहचान कर लेंगे, तो आप अपने संस्करण संख्या में विशिष्ट वृद्धि के साथ इसमें परिवर्तनों को संवाद करेंगे। XYZ (Major.Minor.Patch) के संस्करण प्रारूप पर विचार करें। बग फिक्स एपीआई वृद्धि को प्रभावित नहीं करते हैं, पैच संस्करण, पिछड़ा संगत एपीआई जोड़ / परिवर्तन मामूली संस्करण में वृद्धि करता है, और पीछे की असंगत एपीआई परिवर्तन प्रमुख संस्करण में वृद्धि करता है।\nमैं इस प्रणाली को “अर्थपूर्ण संस्करण” कहता हूं। इस योजना के तहत, संस्करण संख्याएं और जिस तरह से वे बदलते हैं, अंतर्निहित कोड के बारे में अर्थ बताते हैं और एक संस्करण से अगले संस्करण में क्या संशोधित किया गया है।\nअर्थपूर्ण संस्करण विशिष्टता (सेमवीर)\nमुख्य शब्द “जरूरी”, “आवश्यक नहीं”, “आवश्यक”, “साझा करें”, “नहीं होगा”, “चाहिए”, “नहीं होना चाहिए”, “अनुशंसित”, “मई” और “वैकल्पिक” इस दस्तावेज़ में हैं आरएफसी 2119 में वर्णित के रूप में व्याख्या किया जाना है ।\nअर्थपूर्ण संस्करण का उपयोग कर सॉफ्टवेयर एक सार्वजनिक एपीआई घोषित करना चाहिए। इस एपीआई को कोड में ही घोषित किया जा सकता है या दस्तावेज़ीकरण में सख्ती से मौजूद है। हालांकि यह किया जाता है, यह सटीक और व्यापक होना चाहिए।\nअर्थपूर्ण संस्करण का उपयोग कर सॉफ्टवेयर एक सार्वजनिक एपीआई घोषित करना चाहिए। इस एपीआई को कोड में ही घोषित किया जा सकता है या दस्तावेज़ीकरण में सख्ती से मौजूद है। हालांकि यह किया जाता है, यह सटीक और व्यापक होना चाहिए।\nएक सामान्य संस्करण संख्या को XYZ फॉर्म लेना चाहिए जहां एक्स, वाई, और जेड गैर-ऋणात्मक पूर्णांक हैं, और इसमें प्रमुख शून्य शामिल नहीं होनी चाहिए। एक्स प्रमुख संस्करण है, वाई मामूली संस्करण है, और जेड पैच संस्करण है। प्रत्येक तत्व संख्यात्मक रूप से बढ़ना चाहिए। उदाहरण के लिए: 1.9.0 -> 1.10.0 -> 1.11.0।\nएक सामान्य संस्करण संख्या को XYZ फॉर्म लेना चाहिए जहां एक्स, वाई, और जेड गैर-ऋणात्मक पूर्णांक हैं, और इसमें प्रमुख शून्य शामिल नहीं होनी चाहिए। एक्स प्रमुख संस्करण है, वाई मामूली संस्करण है, और जेड पैच संस्करण है। प्रत्येक तत्व संख्यात्मक रूप से बढ़ना चाहिए। उदाहरण के लिए: 1.9.0 -> 1.10.0 -> 1.11.0।\nएक बार एक संस्करण पैकेज जारी किया गया है, उस संस्करण की सामग्री को संशोधित नहीं किया जाना चाहिए। किसी भी संशोधन को एक नए संस्करण के रूप में जारी किया जाना चाहिए।\nएक बार एक संस्करण पैकेज जारी किया गया है, उस संस्करण की सामग्री को संशोधित नहीं किया जाना चाहिए। किसी भी संशोधन को एक नए संस्करण के रूप में जारी किया जाना चाहिए।\nप्रमुख संस्करण शून्य (0.yz) प्रारंभिक विकास के लिए है। कुछ भी किसी भी समय बदल सकता है। सार्वजनिक एपीआई को स्थिर नहीं माना जाना चाहिए।\nप्रमुख संस्करण शून्य (0.yz) प्रारंभिक विकास के लिए है। कुछ भी किसी भी समय बदल सकता है। सार्वजनिक एपीआई को स्थिर नहीं माना जाना चाहिए।\nसंस्करण 1.0.0 सार्वजनिक एपीआई को परिभाषित करता है। इस रिलीज के बाद जिस संस्करण में संस्करण संख्या बढ़ी है, इस सार्वजनिक एपीआई पर निर्भर है और यह कैसे बदलता है।\nसंस्करण 1.0.0 सार्वजनिक एपीआई को परिभाषित करता है। इस रिलीज के बाद जिस संस्करण में संस्करण संख्या बढ़ी है, इस सार्वजनिक एपीआई पर निर्भर है और यह कैसे बदलता है।\nपैच संस्करण जेड (xyZ
          x> 0) केवल पिछड़ा संगत बग फिक्स पेश किए जाने पर वृद्धि की जानी चाहिए। एक बग फिक्स को आंतरिक परिवर्तन के रूप में परिभाषित किया जाता है जो गलत व्यवहार को हल करता है।\nx> 0) केवल पिछड़ा संगत बग फिक्स पेश किए जाने पर वृद्धि की जानी चाहिए। एक बग फिक्स को आंतरिक परिवर्तन के रूप में परिभाषित किया जाता है जो गलत व्यवहार को हल करता है।\nछोटे संस्करण वाई (xYz
          x> 0) को बढ़ाया जाना चाहिए यदि सार्वजनिक, एपीआई के लिए नई, पिछली संगत कार्यक्षमता पेश की गई हो। यदि किसी भी सार्वजनिक एपीआई कार्यक्षमता को बहिष्कृत के रूप में चिह्नित किया गया है तो इसे बढ़ाया जाना चाहिए। निजी कोड के भीतर पर्याप्त नई कार्यक्षमता या सुधार पेश किए जाने पर यह बढ़ाई जा सकती है। इसमें पैच स्तर परिवर्तन शामिल हो सकते हैं। छोटे संस्करण को बढ़ाए जाने पर पैच संस्करण को 0 पर रीसेट किया जाना चाहिए।\nछोटे संस्करण वाई (xYz\nx> 0) को बढ़ाया जाना चाहिए यदि सार्वजनिक, एपीआई के लिए नई, पिछली संगत कार्यक्षमता पेश की गई हो। यदि किसी भी सार्वजनिक एपीआई कार्यक्षमता को बहिष्कृत के रूप में चिह्नित किया गया है तो इसे बढ़ाया जाना चाहिए। निजी कोड के भीतर पर्याप्त नई कार्यक्षमता या सुधार पेश किए जाने पर यह बढ़ाई जा सकती है। इसमें पैच स्तर परिवर्तन शामिल हो सकते हैं। छोटे संस्करण को बढ़ाए जाने पर पैच संस्करण को 0 पर रीसेट किया जाना चाहिए।\nप्रमुख संस्करण एक्स (Xyz
          X> 0) को बढ़ाया जाना चाहिए यदि सार्वजनिक एपीआई में कोई पिछड़ा असंगत परिवर्तन पेश किया गया हो। इसमें मामूली और पैच स्तर परिवर्तन शामिल हो सकते हैं। जब बड़े संस्करण में वृद्धि हुई है तो पैच और मामूली संस्करण को 0 पर रीसेट किया जाना चाहिए।\nप्रमुख संस्करण एक्स (Xyz\nX> 0) को बढ़ाया जाना चाहिए यदि सार्वजनिक एपीआई में कोई पिछड़ा असंगत परिवर्तन पेश किया गया हो। इसमें मामूली और पैच स्तर परिवर्तन शामिल हो सकते हैं। जब बड़े संस्करण में वृद्धि हुई है तो पैच और मामूली संस्करण को 0 पर रीसेट किया जाना चाहिए।\nएक प्री-रिलीज संस्करण पैच संस्करण के तुरंत बाद एक हाइफ़न और डॉट अलग पहचानकर्ताओं की एक श्रृंखला को जोड़कर दर्शाया जा सकता है। पहचानकर्ताओं में केवल एएससीआईआई अल्फान्यूमेरिक्स और हाइफ़न [0-9 ए-ज़ा-जेड-] शामिल होना चाहिए। पहचानकर्ता खाली नहीं होना चाहिए। संख्यात्मक पहचानकर्ताओं में अग्रणी शून्य शामिल नहीं होना चाहिए। प्री-रिलीज संस्करणों में संबंधित सामान्य संस्करण की तुलना में कम प्राथमिकता है। एक प्री-रिलीज संस्करण इंगित करता है कि संस्करण अस्थिर है और इसके अनुरूप सामान्य संस्करण द्वारा बताए गए इच्छित संगतता आवश्यकताओं को पूरा नहीं कर सकता है। उदाहरण: 1.0.0-अल्फा, 1.0.0-अल्फा .1, 1.0.0-0.3.7, 1.0.0-x.7.z.92।\nएक प्री-रिलीज संस्करण पैच संस्करण के तुरंत बाद एक हाइफ़न और डॉट अलग पहचानकर्ताओं की एक श्रृंखला को जोड़कर दर्शाया जा सकता है। पहचानकर्ताओं में केवल एएससीआईआई अल्फान्यूमेरिक्स और हाइफ़न [0-9 ए-ज़ा-जेड-] शामिल होना चाहिए। पहचानकर्ता खाली नहीं होना चाहिए। संख्यात्मक पहचानकर्ताओं में अग्रणी शून्य शामिल नहीं होना चाहिए। प्री-रिलीज संस्करणों में संबंधित सामान्य संस्करण की तुलना में कम प्राथमिकता है। एक प्री-रिलीज संस्करण इंगित करता है कि संस्करण अस्थिर है और इसके अनुरूप सामान्य संस्करण द्वारा बताए गए इच्छित संगतता आवश्यकताओं को पूरा नहीं कर सकता है। उदाहरण: 1.0.0-अल्फा, 1.0.0-अल्फा .1, 1.0.0-0.3.7, 1.0.0-x.7.z.92।\nपैच या प्री-रिलीज संस्करण के तुरंत बाद एक प्लस साइन और डॉट से अलग पहचानकर्ताओं की एक श्रृंखला को जोड़कर मेटाडाटा मई को इंगित किया जा सकता है। पहचानकर्ताओं में केवल एएससीआईआई अल्फान्यूमेरिक्स और हाइफ़न [0-9 ए-ज़ा-जेड-] शामिल होना चाहिए। पहचानकर्ता खाली नहीं होना चाहिए। संस्करण प्राथमिकता निर्धारित करते समय मेटाडेटा को अनदेखा किया जाना चाहिए। इस प्रकार दो संस्करण जो बिल्ड मेटाडेटा में भिन्न होते हैं, वही प्राथमिकता रखते हैं। उदाहरण: 1.0.0-अल्फा + 001, 1.0.0 + 20130313144700, 1.0.0-बीटा + exp.sha.5114f85।\nपैच या प्री-रिलीज संस्करण के तुरंत बाद एक प्लस साइन और डॉट से अलग पहचानकर्ताओं की एक श्रृंखला को जोड़कर मेटाडाटा मई को इंगित किया जा सकता है। पहचानकर्ताओं में केवल एएससीआईआई अल्फान्यूमेरिक्स और हाइफ़न [0-9 ए-ज़ा-जेड-] शामिल होना चाहिए। पहचानकर्ता खाली नहीं होना चाहिए। संस्करण प्राथमिकता निर्धारित करते समय मेटाडेटा को अनदेखा किया जाना चाहिए। इस प्रकार दो संस्करण जो बिल्ड मेटाडेटा में भिन्न होते हैं, वही प्राथमिकता रखते हैं। उदाहरण: 1.0.0-अल्फा + 001, 1.0.0 + 20130313144700, 1.0.0-बीटा + exp.sha.5114f85।\nप्राथमिकता यह दर्शाती है कि आदेश दिए जाने पर संस्करणों की तुलना एक दूसरे से कैसे की जाती है। प्राथमिकता को उस क्रम में प्रमुख, मामूली, पैच और प्री-रिलीज पहचानकर्ताओं में संस्करण को अलग करके गणना की जानी चाहिए (मेटाडाटा बनाएं प्राथमिकता में नहीं है)। प्राथमिकता को पहले अंतर से निर्धारित किया जाता है जब इन पहचानकर्ताओं में से प्रत्येक को बाएं से दाएं से तुलना करें: मेजर, नाबालिग और पैच संस्करणों की तुलना हमेशा संख्यात्मक रूप से की जाती है। उदाहरण: 1.0.0 <2.0.0 <2.1.0 <2.1.1। जब प्रमुख, नाबालिग और पैच बराबर होते हैं, तो प्री-रिलीज़ संस्करण में सामान्य संस्करण की तुलना में कम प्राथमिकता होती है। उदाहरण: 1.0.0-अल्फा <1.0.0। एक ही प्रमुख, नाबालिग और पैच संस्करण के साथ दो प्री-रिलीज संस्करणों की प्राथमिकता प्रत्येक डॉट से अलग पहचानकर्ता को बाएं से दाएं की तुलना करके निर्धारित किया जाना चाहिए जब तक कोई अंतर निम्नानुसार नहीं मिलता है: केवल अंकों की पहचान करने वाले पहचानकर्ताओं की संख्या संख्यात्मक रूप से तुलना की जाती है और अक्षरों या हाइफ़न वाले पहचानकर्ताओं की तुलना एएससीआईआई क्रमबद्ध क्रम में तुलनात्मक रूप से की जाती है। गैर-संख्यात्मक पहचानकर्ताओं की तुलना में संख्यात्मक पहचानकर्ताओं की हमेशा कम प्राथमिकता होती है। प्री-रिलीज फ़ील्ड्स का एक बड़ा सेट एक छोटे से सेट की तुलना में अधिक प्राथमिकता है, यदि पिछले सभी पहचानकर्ता बराबर हैं। उदाहरण: 1.0.0-अल्फा <1.0.0-alpha.1 <1.0.0-alpha.beta <1.0.0-beta <1.0.0-beta.2 <1.0.0-beta.11 <1.0.0- आरसी .1 <1.0.0।\nअर्थपूर्ण संस्करण का उपयोग क्यों करें?\nयह एक नया या क्रांतिकारी विचार नहीं है। असल में, आप शायद पहले से ही कुछ करीब कर सकते हैं। समस्या यह है कि “करीबी” पर्याप्त नहीं है। औपचारिक विनिर्देश के किसी प्रकार के अनुपालन के बिना, निर्भरता प्रबंधन के लिए संस्करण संख्या अनिवार्य रूप से बेकार हैं। उपर्युक्त विचारों को नाम और स्पष्ट परिभाषा देकर, अपने इरादे को अपने सॉफ़्टवेयर के उपयोगकर्ताओं को संवाद करना आसान हो जाता है। एक बार इन इरादों को स्पष्ट, लचीला (लेकिन बहुत लचीला नहीं) निर्भरता विनिर्देशों को अंत में बनाया जा सकता है।\nएक साधारण उदाहरण यह दिखाएगा कि कैसे अर्थपूर्ण संस्करणिंग निर्भरता नरक को अतीत की बात कर सकती है। “फायरट्रुक” नामक एक लाइब्रेरी पर विचार करें। इसे “सीढ़ी” नामक एक सेमेन्टिकली वर्जन पैकेज की आवश्यकता होती है। जब फायरट्रुक बनाया जाता है, तो लेडर संस्करण 3.1.0 पर होता है। चूंकि फायरट्रुक कुछ कार्यक्षमता का उपयोग करता है जिसे पहली बार 3.1.0 में पेश किया गया था, आप सुरक्षित रूप से लेडर निर्भरता को 3.1.0 से अधिक या बराबर के रूप में निर्दिष्ट कर सकते हैं लेकिन 4.0.0 से कम। अब, जब लेडर संस्करण 3.1.1 और 3.2.0 उपलब्ध हो जाते हैं, तो आप उन्हें अपने पैकेज प्रबंधन प्रणाली में छोड़ सकते हैं और जानते हैं कि वे मौजूदा आश्रित सॉफ्टवेयर के साथ संगत होंगे।\nएक जिम्मेदार डेवलपर के रूप में, आप निश्चित रूप से सत्यापित करना चाहते हैं कि विज्ञापन के रूप में किसी भी पैकेज अपग्रेड का कार्य करें। वास्तविक दुनिया एक गन्दा जगह है; इसके बारे में हम कुछ नहीं कर सकते लेकिन सतर्क रहें। आप क्या कर सकते हैं अर्थपूर्ण संस्करण आपको निर्भर पैकेज के नए संस्करणों को रोल किए बिना संकुल को रिलीज़ और अपग्रेड करने के लिए एक मौका तरीका प्रदान करता है, जिससे आप समय और परेशानी बचा सकते हैं।\nयदि यह सब वांछनीय लगता है, तो आपको अर्थपूर्ण संस्करण का उपयोग शुरू करने के लिए केवल इतना करना है कि आप ऐसा कर रहे हैं और फिर नियमों का पालन करें। इस वेबसाइट से अपने रीडमे से लिंक करें ताकि अन्य नियमों को जान सकें और उनसे लाभ उठा सकें।\n0.yz प्रारंभिक विकास चरण में संशोधन के साथ मुझे कैसे निपटना चाहिए?\nकरने के लिए सबसे सरल बात यह है कि अपनी शुरुआती विकास रिलीज 0.1.0 पर शुरू करें और फिर प्रत्येक आगामी रिलीज के लिए मामूली संस्करण को बढ़ाएं।\nमुझे कैसे पता चलेगा कि 1.0.0 कब रिलीज़ किया जाए?\nयदि आपके सॉफ़्टवेयर का उत्पादन में उपयोग किया जा रहा है, तो यह शायद पहले से ही 1.0.0 होना चाहिए। यदि आपके पास स्थिर API है जिस पर उपयोगकर्ता निर्भर हैं, तो आपको 1.0.0 होना चाहिए। यदि आप पीछे की संगतता के बारे में बहुत कुछ चिंता कर रहे हैं, तो आपको शायद पहले ही 1.0.0 होना चाहिए।\nक्या यह तेजी से विकास और तेजी से पुनरावृत्ति को हतोत्साहित नहीं करता है?\nप्रमुख संस्करण शून्य तेजी से विकास के बारे में है। यदि आप हर दिन एपीआई बदल रहे हैं तो आपको अभी भी संस्करण 0.yz या अगले प्रमुख संस्करण पर काम कर रहे एक अलग विकास शाखा में होना चाहिए।\nयदि सार्वजनिक एपीआई में सबसे छोटा पिछड़ा असंगत परिवर्तन भी एक प्रमुख संस्करण टक्कर की आवश्यकता है, तो क्या मैं संस्करण 42.0.0 पर बहुत तेजी से समाप्त नहीं होगा?\nयह जिम्मेदार विकास और दूरदर्शिता का सवाल है। असंगत परिवर्तनों को हल्के ढंग से सॉफ़्टवेयर में पेश नहीं किया जाना चाहिए जिसमें बहुत से निर्भर कोड हैं। अपग्रेड करने के लिए जो लागत होनी चाहिए वह महत्वपूर्ण हो सकती है। असंगत परिवर्तनों को जारी करने के लिए प्रमुख संस्करणों को टक्कर देने का मतलब है कि आप अपने परिवर्तनों के प्रभाव के माध्यम से सोचेंगे, और शामिल लागत / लाभ अनुपात का मूल्यांकन करेंगे।\nपूरे सार्वजनिक एपीआई को दस्तावेज करना बहुत अधिक काम है!\nएक पेशेवर डेवलपर के रूप में यह आपकी ज़िम्मेदारी है कि दूसरों द्वारा उपयोग के लिए सॉफ्टवेयर का सही तरीके से दस्तावेज किया जाए। सॉफ़्टवेयर जटिलता का प्रबंधन करना एक परियोजना को कुशल रखने का एक बेहद महत्वपूर्ण हिस्सा है, और यदि कोई नहीं जानता कि आपके सॉफ़्टवेयर का उपयोग कैसे करें, या कॉल करने के लिए कौन सी विधियां सुरक्षित हैं, तो यह करना मुश्किल है। लंबे समय तक, सेमेन्टिक वर्जनिंग, और एक अच्छी तरह से परिभाषित सार्वजनिक एपीआई पर जोर हर किसी और सबकुछ सुचारू रूप से चल रहा है।\nयदि मैं गलती से एक मामूली संस्करण के रूप में पिछड़ा असंगत परिवर्तन जारी करता हूं तो मैं क्या करूँ?\nजैसे ही आप महसूस करते हैं कि आपने अर्थात् संस्करण संस्करण को तोड़ दिया है, समस्या को ठीक करें और एक नया मामूली संस्करण जारी करें जो समस्या को सुधारता है और पीछे की संगतता को पुनर्स्थापित करता है। इस परिस्थिति में भी, संस्करण संस्करणों को संशोधित करने के लिए अस्वीकार्य है। यदि यह उचित है, तो अपमानजनक संस्करण दस्तावेज करें और समस्या के अपने उपयोगकर्ताओं को सूचित करें ताकि वे अपमानजनक संस्करण से अवगत हों।\nयदि मैं सार्वजनिक एपीआई को बदले बिना अपनी निर्भरता अपडेट करता हूं तो मुझे क्या करना चाहिए?\nइसे संगत माना जाएगा क्योंकि यह सार्वजनिक एपीआई को प्रभावित नहीं करता है। सॉफ़्टवेयर जो स्पष्ट रूप से समान निर्भरताओं पर निर्भर करता है क्योंकि आपके पैकेज में अपनी निर्भरता विनिर्देश होनी चाहिए और लेखक को कोई भी विवाद दिखाई देगा। यह निर्धारित करना कि परिवर्तन एक पैच स्तर है या नाबालिग स्तर संशोधन इस बात पर निर्भर करता है कि आपने बग को ठीक करने या नई कार्यक्षमता को पेश करने के लिए अपनी निर्भरताओं को अपडेट किया है या नहीं। मैं आमतौर पर बाद के उदाहरण के लिए अतिरिक्त कोड की अपेक्षा करता हूं, इस मामले में यह स्पष्ट रूप से मामूली स्तर की वृद्धि है।\nक्या होगा यदि मैं अनजाने में सार्वजनिक एपीआई को ऐसे तरीके से बदलता हूं जो संस्करण संख्या परिवर्तन के अनुरूप नहीं है (यानी कोड पैच रिलीज में गलत ब्रेकिंग परिवर्तन को गलत तरीके से प्रस्तुत करता है)\nअपने सबसे अच्छे फैसले का प्रयोग करें। यदि आपके पास एक विशाल दर्शक हैं जो सार्वजनिक एपीआई के इरादे से व्यवहार को बदलकर बहुत प्रभावित होंगे, तो यह एक प्रमुख संस्करण रिलीज करने के लिए सबसे अच्छा हो सकता है, भले ही फिक्स को पैच रिलीज माना जा सके। याद रखें, अर्थात् वर्जनिंग सब कुछ बताता है कि संस्करण संख्या कैसे बदलती है। यदि ये परिवर्तन आपके उपयोगकर्ताओं के लिए महत्वपूर्ण हैं, तो उन्हें सूचित करने के लिए संस्करण संख्या का उपयोग करें।\nमुझे बहिष्करण कार्यक्षमता को कैसे संभालना चाहिए?\nमौजूदा कार्यक्षमता को कम करना सॉफ्टवेयर विकास का एक सामान्य हिस्सा है और अक्सर प्रगति को आगे बढ़ाने की आवश्यकता होती है। जब आप अपने सार्वजनिक एपीआई का हिस्सा बहिष्कृत करते हैं, तो आपको दो चीजें करना चाहिए: (1) उपयोगकर्ताओं को परिवर्तन के बारे में जानकारी देने के लिए अपने दस्तावेज़ों को अपडेट करें, (2) जगह पर बहिष्करण के साथ एक नई मामूली रिलीज जारी करें। एक नई बड़ी रिलीज में कार्यक्षमता को पूरी तरह से हटाने से पहले कम से कम एक मामूली रिलीज होनी चाहिए जिसमें बहिष्करण शामिल है ताकि उपयोगकर्ता आसानी से नए एपीआई में संक्रमण कर सकें।\nक्या वर्जन स्ट्रिंग पर सेमेवर की आकार सीमा है?\nनहीं, लेकिन अच्छे फैसले का प्रयोग करें। उदाहरण के लिए, 255 वर्ण संस्करण स्ट्रिंग शायद अधिक है। साथ ही, विशिष्ट सिस्टम स्ट्रिंग के आकार पर अपनी सीमा लगा सकते हैं।\nअर्थात् संस्करण संस्करण विनिर्देशन ट्रा प्रेस्टन-वर्नर , ग्रेवाटर के आविष्कारक और गिटहब के कोफाउंडर द्वारा लिखा गया है।\nअगर आप फीडबैक छोड़ना चाहते हैं, तो कृपया गिटहब पर एक समस्या खोलें।\nगिटहब पर एक समस्या खोलें\nक्रिएटिव कॉमन्स ― 3.0 द्वारा सीसी\nक्रिएटिव कॉमन्स ― 3.0 द्वारा सीसी\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSemantičko verzioniranje 2.0.0

Sažetak

Uzevši oznake verzije VEĆA.MANJA.ZAKRPA, povećavajte:


  VEĆU verziju kada napravite inkompatibilne promjene u APIju,
  MANJU verziju kada dodate unatrag-kompatibilne funkcionalnosti i
  ZAKRPA verziju kada napravite unatrag-kompatibilne ispravke bugova.


Dodatne oznake za pred-izdanja i metapodatke builda mogu se koristiti kao proširenje na VEĆA.MANJA.ZAKRPA format.

Uvod

U svijetu upravljanja softverom postoji strašno mjesto koje zovemo
“pakao ovisnosti.” Što više vaš sustav raste i što više paketa
integrirate u vaš softver, vjerojatnije je da ćete se, jednoga dana,
naći u toj jami očaja.

U sustavima s više ovisnosti, izdavanje novih verzija paketa, može se vrlo brzo
pretvoriti u noćnu moru. Ako su specifikacije ovisnosti previše stroge, postoji
opasnost zaključavanja verzije (nemogućnosti nadogradnje paketa bez potrebe
izdavanja nove verzije svakog ovisnog paketa). Ako su pak ovisnosti specificirane
previše slobodno, sigurno ćete osjetiti posljedice verzijskog promiskuiteta
(pretpostavke kompatibilnosti s više budućih verzija nego što je razumno).
Pakao ovisnosti je slučaj gdje zaključavanje verzije i/ili verzijski promiskuitet
sprječavaju lagano i sigurno napredovanje projekta.

Kao rješenje tog problema predlažem jednostavan set pravila i zahtjeva
koji će nalagati kako se dodjeljuju i povećavaju oznake verzija.
Ova se pravila temelje, no nisu nužno i ograničena, na već postojećoj
i raširenoj uobičajenoj praksi u projektima otvorenog i zatvorenog koda.
Kako bi ovaj sustav funkcionirao, potrebno je prvo objaviti javni API. Možemo
to primijeniti u dokumentaciji ili u samom kodu. U svakom slučaju, važno je da
API bude jasan i precizan. Jednom kad identificiramo javni API, komuniciramo
promjene u njemu kroz specificirana povećanja u oznaci/broju verzije. Uzmimo
format verzije X.Y.Z (MANJA.VEĆA.ZAKRPA). Ispravci bugova koji ne utječu na API
povećavaju oznaku zakrpe, unatrag-kompatibilni dodaci/promjene u APIju
povećavaju manju verziju, a unatrag inkompatibilne promjene u APIju povećavaju
veću verziju.

Ovaj sam sustav nazvao “Semantičko verzioniranje”. Unutar ove sheme, oznake
verzije i način na koji se mijenjaju prenose određene informacije o kodu koji
se nalazi ispod i što se mijenjalo od jedne do druge verzije.

Specifikacija semantičkog verzioniranja (SemVer)

Ključne riječi “MORA”, “NE SMIJE”, “POTREBNO”, “BITI ĆE”, “NEĆE BITI”, “TREBALO BI”,
“NE BI TREBALO”, “PREPORUČENO”, “MOŽE”, i “OPCIONALNO” (“MUST”, “MUST NOT”,
“REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”,
“OPTIONAL”) u ovom dokumentu treba interpretirati kao što je opisano u
RFC 2119.


  
    Softver koji koristi Semantičko verzioniranje MORA objaviti javni API. API
može biti deklariran u samom kodu ili postojati samo unutar dokumentacije.
U svakom slučaju, mora biti precizan i jasan.
  
  
    Normalna oznaka verzije MORA biti u formatu X.Y.Z gdje su X, Y i Z prirodni
(non-negative integer) brojevi i ne smiju počinjati s nulom. X označava
veću verziju, Y manju verziju, a Z zakrpu.
Svaki se element MORA numerički povećavati. Na primjer: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Jednom kad je verzionirani paket izdan, sadržaj te verzije NE SMIJE se
mijenjati. Sve promjene MORAJU se izdavati s novom verzijom.
  
  
    Veća verzija nula (0.y.z) je za inicijalni razvoj. Bilo što se može mijenjati
u tom stadiju. Javni API se ne smatra stabilnim.
  
  
    Verzija 1.0.0 definira javni API. Način na koji će se oznaka verzije mijenjati
ovisi o tom javnom APIju i načinu na koji se on mijenja.
  
  
    Oznaka verzije zakrpe Z (x.y.Z | x > 0) MORA se povećavati samo ako se dodaju
unatrag kompatibilni ispravci bugova. Ispravci bugova definiraju se kao promjene
unutar koda koje ispravljaju nepravilno ponašanje.
  
  
    Oznaka manje verzije Y (x.Y.z | x > 0) MORA se povećavati ako se javnom APIju
dodaju nove unatrag kompatibilne funkcionalnosti. Također se MORA povećavati
ako se neke funkcionalnosti označe kao zastarjele (deprecated). MOŽE se povećavati
ako se uvode značajne nove funkcionalnosti ili poboljšanja unutar koda.
MOŽE se povećavati ako se uvode promjene na razini zakrpe. Kada se oznaka manje
verzije poveća, oznaka verzije zakrpe mora se vratiti na 0.
  
  
    Oznaka veće verzije X (X.y.z | X > 0) MORA se povećavati ako se javnom APIju
dodaju unatrag inkompatibilne funkcionalnosti. MOŽE sadržavati promjene na razini
manje verzije i zakrpe. Kada se oznaka veće verzije poveća, oznake manje verzije
i zakrpe moraju se vratiti na 0.
  
  
    Verzija predizdanja MOŽE se označiti dodavanjem crtice i niza identifikatora
odvojenih točkom, koji se odmah nastavljaju na oznaku verzije zakrpe. Ti se
identifikatori MORAJU sastojati samo od ASCII alfanumeričkih znakova i crtica
[0-9A-Za-z-]. Identifikatori NE SMIJU biti prazni. Numerički identifikatori NE
SMIJU počinjati nulom. Normalne verzije imaju prednost nad vezanim verzijama
predizdanja. Oznaka verzije predizdanja označava nestabilnu verziju koja ne
zadovoljava nužno predviđene zahtjeve kompatibilnosti navedene u vezanoj
normalnoj verziji. Primjeri: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.
  
  
    Metapodaci builda MOGU se označiti dodavanjem znaka plus i niza identifikatora
odvojenih točkom, koji se odmah nastavljaju na oznaku verzije zakrpe ili
predizdanja. Ti se identifikatori MORAJU sastojati samo od ASCII alfanumeričkih
znakova i crtica [0-9A-Za-z-]. Identifikatori NE SMIJU biti prazni. Metapodaci
builda se ignoriraju kod procjene prednosti verzije. Dakle, dvije verzije koje
se razlikuju samo u metapodacima builda imaju jednaku prednost. Primjeri:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    Pojam prednosti odnosi se na to kako uspoređujemo verzije u poretku.
Prednost se MORA procjenjivati tako da zasebno promatramo oznaku verzije kao
veću, manju, zakrpu i identifikatore predizdanja tim redom. (Metapodaci builda
ne utječu na prednost). Prednost određuje prva razlika u usporedbi svake
oznake s lijeva na desno na sljedeći način: Oznake veće verzije, manje verzije i
verzije zakrpe uvijek se uspoređuju numerički. Na primjer: 1.0.0 < 2.0.0 <
2.1.0 < 2.1.1. Kad su oznake veće, manje i verzije zakrpe jednake, normalna
verzija ima prednost nad verzijom predizdanja. Primjer: 1.0.0-alpha < 1.0.0.
Prednost između dvije verzije predizdanja s istim oznakama veće, manje i verzije
zakrpe MORAJU se odrediti usporedbom svake oznake odvojene točkom s lijeva na
desno, dok ne dođemo do razlike na sljedeći način: identifikatori koji se
sastoje samo od broja uspoređuju se numerički, dok se slova i crtice uspoređuju
leksički u ASCII poretku. Nebrojčane oznake uvijek imaju prednost nad brojčanim.
Veći niz oznaka predizdanja ima prednost nad manjim nizom, ako su prethodne
oznake jednake. Primjer: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Zašto koristiti Semantičko verzioniranje?

Ovo nije nova, niti revolucionarna ideja. Štoviše, vjerojatno već koristite
nešto vrlo slično. Problem je u tome što “slično” nije dovoljno dobro. Bez
poštivanja neke formalne specifikacije, oznake verzije su u suštini beskorisne
za upravljanje ovisnostima. Ako damo ime i jasnu definiciju gore navedenim
idejama, postaje lakše iskomunicirati svoje namjere korisnicima softvera.
Jednom kada su te namjere jasne i fleksibilne (ali ne previše fleksibilne)
možemo definirati specifikacije ovisnosti.

Možemo jednostavnim primjerom pokazati kako Semantičko verzioniranje može
ostaviti pakao ovisnosti u prošlosti. Zamislimo softversku biblioteku (library)
“Vatrogasno_vozilo.” Potreban joj je Semantički verzionirani paket “Ljestve”.
U trenutku kad je “Vatrogasno_vozilo” kreirano, “Ljestve” su na verziji 3.1.0.
Budući da “Vatrogasno_vozilo” koristi određene funkcionalnosti koje su uvedene
u verziji 3.1.0, možemo bez straha navesti ovisnost o paketu “Ljestve” verzije
veće ili jednake 3.1.0, ali manje od 4.0.0. Tako, kada “Ljestve” verzije 3.1.1
i 3.2.0 budu dostupne, možete ih dodati u svoj sustav upravljanja paketima i
biti sigurni da će biti kompatibilne s postojećim ovisnim softverom.

Kao odgovoran programer htjet ćete se, naravno, uvjeriti da će svaka nadogradnja
paketa funkcionirati kao što je navedeno. Stvarni je svijet zbrka i ne možemo
ništa poduzeti po tom pitanju osim biti oprezni. Ono što možemo napraviti je
prihvatiti Semantičko verzioniranje kao siguran način za izdavanje i nadogradnju
paketa bez potrebe za izgradnjom novih verzija ovisnih paketa te tako sačuvati
vrijeme i živce.

Ako vam ovo sve dobro zvuči, sve što vam je potrebno da bi ste počeli koristiti
Semantičko verzioniranje je da navedete da ga koristite i slijedite pravila.
Stavite poveznicu na ovu stranicu u svoju README datoteku, kako bi i ostali bili
svjesni pravila i mogli imati koristi od njih.

Česta pitanja

Kako upravljati promjenama za inicijalne faze razvoja verzija 0.y.z?

Najjednostavniji je način da započnemo inicijalni razvoj izdavanjem verzije
0.1.0 te povećavamo oznaku manje verzije za svako sljedeće izdanje.

Kako znamo kada izdati verziju 1.0.0?

Ako se softver koristi u produkciji, već bi vjerojatno trebao biti na verziji
1.0.0. Ako već imamo stabilni API, na koji korisnici mogu računati, trebao bi
biti na verziji 1.0.0. Ako smo zabrinuti zbog kompatibilnosti unatrag, softver
bi već trebao biti izdan pod verzijom 1.0.0.

Ne sprječava li ovo ubrzani razvoj i brzo povećavanje verzija?

Veća verzija nula se svodi na brzi razvoj. Ako mijenjamo API svaki dan, trebali
bi ostati na verziji 0.y.z ili na posebnoj grani raditi na sljedećoj većoj
verziji.

Ako i najmanje unatrag inkompatibilne promjene u APIju zahtijevaju povećanje veće verzije, nećemo li vrlo brzo doći do verzije 42.0.0?

Ovo je pitanje odgovornog razvoja i predviđanja. U softver koji ima puno
ovisnog koda, inkompatibilne promjene potrebno je uvoditi postepeno. Cijena
nadogradnje može biti značajna. Ako moramo povećati veću verziju, kako bismo
izdali verziju s inkompatibilnim promjenama, moramo razmisliti o posljedicama
tih promjenama i procijeniti odnos cijene i koristi.

Dokumentacija čitavog javnog APIja zahtijeva previše posla!

Naša je odgovornost kao profesionalnih programera da ispravno dokumentiramo
softver koji je namijenjen korisnicima. Upravljanje složenosti softvera vrlo
je važno kako bismo projekt održali efikasnim, što je teško ako korisnici ne
znaju kako koristiti naš softver ili koje metode mogu zvati. Semantičko
verzioniranje i kvalitetno definirani Semantički verzionirani javni API osigurat
će da sve funkcionira kako treba.

Što ako slučajno izdamo unatrag inkompatibilne promjene kao manju verziju?

Čim primijetimo da smo prekršili specifikaciju Semantičkog verzioniranja,
potrebno je ispraviti pogrešku te izdati manju verziju koja će ispraviti problem
i vratiti kompatibilnost. Čak i u takvim uvjetima, nije prihvatljivo mijenjati
verzionirana izdanja. Ako je prikladno, dokumentiramo verziju koja krši
specifikaciju te informiramo korisnike kako bi je bili svjesni.

Što činiti ako promijenimo ovisnosti bez mijenjanja javnog APIja?

Takve promjene smatramo kompatibilnima jer ne utječu na javni API. Softver koji
eksplicitno ovisi o istim ovisnostima kao i naš paket treba imati vlastite
specifikacije ovisnosti, a autor će se brinuti o konfliktima. Je li promjena
na razini zakrpe ili manje verzije, ovisi o tome jesmo li dodali ovisnosti
kako bi ispravili bug ili dodali nove funkcionalnosti. U posljednjem slučaju
možemo očekivati i dodatni kod, pri čemu se očito radi o novoj manjoj verziji.

Što ako nehotice promijenimo javni API na način koji ne odgovara promjeni oznake verzije (npr. u kodu neispravno uvodimo veću unatrag inkompatibilnu promjenu unutar izdanja zakrpe)?

Pokušamo najbolje prosuditi sami. Ako imamo velik broj korisnika, na koje će
značajno utjecati promjena unatrag, najbolje je da objavimo veću verziju, iako
bi takav ispravak mogli smatrati izdanjem zakrpe. Upamtimo, poanta Semantičkog
verzioniranja je dodavanje značenja promjenama oznake verzije. Ako su takve
promjene bitne korisnicima koristimo oznake verzije kako bismo ih informirali.

Kako upravljati zastarjelim (deprecating) funkcionalnostima?

Postojeće funkcionalnosti koje zastarijevaju, uobičajeni su dio razvoja softvera
i često su potrebne kako bi razvoj napredovao. Kad označavamo dio javnog APIja
kao zastarjeli (deprecated), potrebno je učiniti dvije stvari: (1) ažurirati
dokumentaciju kako bismo informirali korisnika, (2) izdati novu manju verziju
s definiranim zastarjelim (deprecated) dijelovima softvera. Prije nego potpuno
uklonimo zastarjele funkcionalnost u novoj većoj verziji, potrebno je izdati
barem jednu manju verziju koja sadrži zastarjele (deprecated) dijelove, kako
bi korisnici glatko prešli na novu verziju APIja.

Ima li semver ograničenu veličinu oznake verzije?

Ne, ali budite razumni. Oznaka verzije od 255 znakova je vjerojatno pretjerana,
na primjer. Također, neki sustavi mogu imati svoja ograničenja veličine oznake.

O projektu

Autor specifikacije Semantičkog Verzioniranja je Tom
Preston-Werner, izumitelj Gravatara i suosnivač
GitHuba.

Ako želite ostaviti povratne informacije, molimo otvorite issue na
GitHubu.

Licenca

Creative Commons ― CC BY 3.0\nSemantičko verzioniranje 2.0.0\nUzevši oznake verzije VEĆA.MANJA.ZAKRPA, povećavajte:\nVEĆU verziju kada napravite inkompatibilne promjene u APIju,\nMANJU verziju kada dodate unatrag-kompatibilne funkcionalnosti i\nZAKRPA verziju kada napravite unatrag-kompatibilne ispravke bugova.\nDodatne oznake za pred-izdanja i metapodatke builda mogu se koristiti kao proširenje na VEĆA.MANJA.ZAKRPA format.\nU svijetu upravljanja softverom postoji strašno mjesto koje zovemo
“pakao ovisnosti.” Što više vaš sustav raste i što više paketa
integrirate u vaš softver, vjerojatnije je da ćete se, jednoga dana,
naći u toj jami očaja.\nU sustavima s više ovisnosti, izdavanje novih verzija paketa, može se vrlo brzo
pretvoriti u noćnu moru. Ako su specifikacije ovisnosti previše stroge, postoji
opasnost zaključavanja verzije (nemogućnosti nadogradnje paketa bez potrebe
izdavanja nove verzije svakog ovisnog paketa). Ako su pak ovisnosti specificirane
previše slobodno, sigurno ćete osjetiti posljedice verzijskog promiskuiteta
(pretpostavke kompatibilnosti s više budućih verzija nego što je razumno).
Pakao ovisnosti je slučaj gdje zaključavanje verzije i/ili verzijski promiskuitet
sprječavaju lagano i sigurno napredovanje projekta.\nKao rješenje tog problema predlažem jednostavan set pravila i zahtjeva
koji će nalagati kako se dodjeljuju i povećavaju oznake verzija.
Ova se pravila temelje, no nisu nužno i ograničena, na već postojećoj
i raširenoj uobičajenoj praksi u projektima otvorenog i zatvorenog koda.
Kako bi ovaj sustav funkcionirao, potrebno je prvo objaviti javni API. Možemo
to primijeniti u dokumentaciji ili u samom kodu. U svakom slučaju, važno je da
API bude jasan i precizan. Jednom kad identificiramo javni API, komuniciramo
promjene u njemu kroz specificirana povećanja u oznaci/broju verzije. Uzmimo
format verzije X.Y.Z (MANJA.VEĆA.ZAKRPA). Ispravci bugova koji ne utječu na API
povećavaju oznaku zakrpe, unatrag-kompatibilni dodaci/promjene u APIju
povećavaju manju verziju, a unatrag inkompatibilne promjene u APIju povećavaju
veću verziju.\nOvaj sam sustav nazvao “Semantičko verzioniranje”. Unutar ove sheme, oznake
verzije i način na koji se mijenjaju prenose određene informacije o kodu koji
se nalazi ispod i što se mijenjalo od jedne do druge verzije.\nSpecifikacija semantičkog verzioniranja (SemVer)\nKljučne riječi “MORA”, “NE SMIJE”, “POTREBNO”, “BITI ĆE”, “NEĆE BITI”, “TREBALO BI”,
“NE BI TREBALO”, “PREPORUČENO”, “MOŽE”, i “OPCIONALNO” (“MUST”, “MUST NOT”,
“REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”,
“OPTIONAL”) u ovom dokumentu treba interpretirati kao što je opisano u
RFC 2119.\nSoftver koji koristi Semantičko verzioniranje MORA objaviti javni API. API
može biti deklariran u samom kodu ili postojati samo unutar dokumentacije.
U svakom slučaju, mora biti precizan i jasan.\nSoftver koji koristi Semantičko verzioniranje MORA objaviti javni API. API
može biti deklariran u samom kodu ili postojati samo unutar dokumentacije.
U svakom slučaju, mora biti precizan i jasan.\nNormalna oznaka verzije MORA biti u formatu X.Y.Z gdje su X, Y i Z prirodni
(non-negative integer) brojevi i ne smiju počinjati s nulom. X označava
veću verziju, Y manju verziju, a Z zakrpu.
Svaki se element MORA numerički povećavati. Na primjer: 1.9.0 -> 1.10.0 -> 1.11.0.\nNormalna oznaka verzije MORA biti u formatu X.Y.Z gdje su X, Y i Z prirodni
(non-negative integer) brojevi i ne smiju počinjati s nulom. X označava
veću verziju, Y manju verziju, a Z zakrpu.
Svaki se element MORA numerički povećavati. Na primjer: 1.9.0 -> 1.10.0 -> 1.11.0.\nJednom kad je verzionirani paket izdan, sadržaj te verzije NE SMIJE se
mijenjati. Sve promjene MORAJU se izdavati s novom verzijom.\nJednom kad je verzionirani paket izdan, sadržaj te verzije NE SMIJE se
mijenjati. Sve promjene MORAJU se izdavati s novom verzijom.\nVeća verzija nula (0.y.z) je za inicijalni razvoj. Bilo što se može mijenjati
u tom stadiju. Javni API se ne smatra stabilnim.\nVeća verzija nula (0.y.z) je za inicijalni razvoj. Bilo što se može mijenjati
u tom stadiju. Javni API se ne smatra stabilnim.\nVerzija 1.0.0 definira javni API. Način na koji će se oznaka verzije mijenjati
ovisi o tom javnom APIju i načinu na koji se on mijenja.\nVerzija 1.0.0 definira javni API. Način na koji će se oznaka verzije mijenjati
ovisi o tom javnom APIju i načinu na koji se on mijenja.\nOznaka verzije zakrpe Z (x.y.Z | x > 0) MORA se povećavati samo ako se dodaju
unatrag kompatibilni ispravci bugova. Ispravci bugova definiraju se kao promjene
unutar koda koje ispravljaju nepravilno ponašanje.\nOznaka verzije zakrpe Z (x.y.Z | x > 0) MORA se povećavati samo ako se dodaju
unatrag kompatibilni ispravci bugova. Ispravci bugova definiraju se kao promjene
unutar koda koje ispravljaju nepravilno ponašanje.\nOznaka manje verzije Y (x.Y.z | x > 0) MORA se povećavati ako se javnom APIju
dodaju nove unatrag kompatibilne funkcionalnosti. Također se MORA povećavati
ako se neke funkcionalnosti označe kao zastarjele (deprecated). MOŽE se povećavati
ako se uvode značajne nove funkcionalnosti ili poboljšanja unutar koda.
MOŽE se povećavati ako se uvode promjene na razini zakrpe. Kada se oznaka manje
verzije poveća, oznaka verzije zakrpe mora se vratiti na 0.\nOznaka manje verzije Y (x.Y.z | x > 0) MORA se povećavati ako se javnom APIju
dodaju nove unatrag kompatibilne funkcionalnosti. Također se MORA povećavati
ako se neke funkcionalnosti označe kao zastarjele (deprecated). MOŽE se povećavati
ako se uvode značajne nove funkcionalnosti ili poboljšanja unutar koda.
MOŽE se povećavati ako se uvode promjene na razini zakrpe. Kada se oznaka manje
verzije poveća, oznaka verzije zakrpe mora se vratiti na 0.\nOznaka veće verzije X (X.y.z | X > 0) MORA se povećavati ako se javnom APIju
dodaju unatrag inkompatibilne funkcionalnosti. MOŽE sadržavati promjene na razini
manje verzije i zakrpe. Kada se oznaka veće verzije poveća, oznake manje verzije
i zakrpe moraju se vratiti na 0.\nOznaka veće verzije X (X.y.z | X > 0) MORA se povećavati ako se javnom APIju
dodaju unatrag inkompatibilne funkcionalnosti. MOŽE sadržavati promjene na razini
manje verzije i zakrpe. Kada se oznaka veće verzije poveća, oznake manje verzije
i zakrpe moraju se vratiti na 0.\nVerzija predizdanja MOŽE se označiti dodavanjem crtice i niza identifikatora
odvojenih točkom, koji se odmah nastavljaju na oznaku verzije zakrpe. Ti se
identifikatori MORAJU sastojati samo od ASCII alfanumeričkih znakova i crtica
[0-9A-Za-z-]. Identifikatori NE SMIJU biti prazni. Numerički identifikatori NE
SMIJU počinjati nulom. Normalne verzije imaju prednost nad vezanim verzijama
predizdanja. Oznaka verzije predizdanja označava nestabilnu verziju koja ne
zadovoljava nužno predviđene zahtjeve kompatibilnosti navedene u vezanoj
normalnoj verziji. Primjeri: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.\nVerzija predizdanja MOŽE se označiti dodavanjem crtice i niza identifikatora
odvojenih točkom, koji se odmah nastavljaju na oznaku verzije zakrpe. Ti se
identifikatori MORAJU sastojati samo od ASCII alfanumeričkih znakova i crtica
[0-9A-Za-z-]. Identifikatori NE SMIJU biti prazni. Numerički identifikatori NE
SMIJU počinjati nulom. Normalne verzije imaju prednost nad vezanim verzijama
predizdanja. Oznaka verzije predizdanja označava nestabilnu verziju koja ne
zadovoljava nužno predviđene zahtjeve kompatibilnosti navedene u vezanoj
normalnoj verziji. Primjeri: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.\nMetapodaci builda MOGU se označiti dodavanjem znaka plus i niza identifikatora
odvojenih točkom, koji se odmah nastavljaju na oznaku verzije zakrpe ili
predizdanja. Ti se identifikatori MORAJU sastojati samo od ASCII alfanumeričkih
znakova i crtica [0-9A-Za-z-]. Identifikatori NE SMIJU biti prazni. Metapodaci
builda se ignoriraju kod procjene prednosti verzije. Dakle, dvije verzije koje
se razlikuju samo u metapodacima builda imaju jednaku prednost. Primjeri:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nMetapodaci builda MOGU se označiti dodavanjem znaka plus i niza identifikatora
odvojenih točkom, koji se odmah nastavljaju na oznaku verzije zakrpe ili
predizdanja. Ti se identifikatori MORAJU sastojati samo od ASCII alfanumeričkih
znakova i crtica [0-9A-Za-z-]. Identifikatori NE SMIJU biti prazni. Metapodaci
builda se ignoriraju kod procjene prednosti verzije. Dakle, dvije verzije koje
se razlikuju samo u metapodacima builda imaju jednaku prednost. Primjeri:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nPojam prednosti odnosi se na to kako uspoređujemo verzije u poretku.
Prednost se MORA procjenjivati tako da zasebno promatramo oznaku verzije kao
veću, manju, zakrpu i identifikatore predizdanja tim redom. (Metapodaci builda
ne utječu na prednost). Prednost određuje prva razlika u usporedbi svake
oznake s lijeva na desno na sljedeći način: Oznake veće verzije, manje verzije i
verzije zakrpe uvijek se uspoređuju numerički. Na primjer: 1.0.0 < 2.0.0 <
2.1.0 < 2.1.1. Kad su oznake veće, manje i verzije zakrpe jednake, normalna
verzija ima prednost nad verzijom predizdanja. Primjer: 1.0.0-alpha < 1.0.0.
Prednost između dvije verzije predizdanja s istim oznakama veće, manje i verzije
zakrpe MORAJU se odrediti usporedbom svake oznake odvojene točkom s lijeva na
desno, dok ne dođemo do razlike na sljedeći način: identifikatori koji se
sastoje samo od broja uspoređuju se numerički, dok se slova i crtice uspoređuju
leksički u ASCII poretku. Nebrojčane oznake uvijek imaju prednost nad brojčanim.
Veći niz oznaka predizdanja ima prednost nad manjim nizom, ako su prethodne
oznake jednake. Primjer: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPojam prednosti odnosi se na to kako uspoređujemo verzije u poretku.
Prednost se MORA procjenjivati tako da zasebno promatramo oznaku verzije kao
veću, manju, zakrpu i identifikatore predizdanja tim redom. (Metapodaci builda
ne utječu na prednost). Prednost određuje prva razlika u usporedbi svake
oznake s lijeva na desno na sljedeći način: Oznake veće verzije, manje verzije i
verzije zakrpe uvijek se uspoređuju numerički. Na primjer: 1.0.0 < 2.0.0 <
2.1.0 < 2.1.1. Kad su oznake veće, manje i verzije zakrpe jednake, normalna
verzija ima prednost nad verzijom predizdanja. Primjer: 1.0.0-alpha < 1.0.0.
Prednost između dvije verzije predizdanja s istim oznakama veće, manje i verzije
zakrpe MORAJU se odrediti usporedbom svake oznake odvojene točkom s lijeva na
desno, dok ne dođemo do razlike na sljedeći način: identifikatori koji se
sastoje samo od broja uspoređuju se numerički, dok se slova i crtice uspoređuju
leksički u ASCII poretku. Nebrojčane oznake uvijek imaju prednost nad brojčanim.
Veći niz oznaka predizdanja ima prednost nad manjim nizom, ako su prethodne
oznake jednake. Primjer: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nZašto koristiti Semantičko verzioniranje?\nOvo nije nova, niti revolucionarna ideja. Štoviše, vjerojatno već koristite
nešto vrlo slično. Problem je u tome što “slično” nije dovoljno dobro. Bez
poštivanja neke formalne specifikacije, oznake verzije su u suštini beskorisne
za upravljanje ovisnostima. Ako damo ime i jasnu definiciju gore navedenim
idejama, postaje lakše iskomunicirati svoje namjere korisnicima softvera.
Jednom kada su te namjere jasne i fleksibilne (ali ne previše fleksibilne)
možemo definirati specifikacije ovisnosti.\nMožemo jednostavnim primjerom pokazati kako Semantičko verzioniranje može
ostaviti pakao ovisnosti u prošlosti. Zamislimo softversku biblioteku (library)
“Vatrogasno_vozilo.” Potreban joj je Semantički verzionirani paket “Ljestve”.
U trenutku kad je “Vatrogasno_vozilo” kreirano, “Ljestve” su na verziji 3.1.0.
Budući da “Vatrogasno_vozilo” koristi određene funkcionalnosti koje su uvedene
u verziji 3.1.0, možemo bez straha navesti ovisnost o paketu “Ljestve” verzije
veće ili jednake 3.1.0, ali manje od 4.0.0. Tako, kada “Ljestve” verzije 3.1.1
i 3.2.0 budu dostupne, možete ih dodati u svoj sustav upravljanja paketima i
biti sigurni da će biti kompatibilne s postojećim ovisnim softverom.\nKao odgovoran programer htjet ćete se, naravno, uvjeriti da će svaka nadogradnja
paketa funkcionirati kao što je navedeno. Stvarni je svijet zbrka i ne možemo
ništa poduzeti po tom pitanju osim biti oprezni. Ono što možemo napraviti je
prihvatiti Semantičko verzioniranje kao siguran način za izdavanje i nadogradnju
paketa bez potrebe za izgradnjom novih verzija ovisnih paketa te tako sačuvati
vrijeme i živce.\nAko vam ovo sve dobro zvuči, sve što vam je potrebno da bi ste počeli koristiti
Semantičko verzioniranje je da navedete da ga koristite i slijedite pravila.
Stavite poveznicu na ovu stranicu u svoju README datoteku, kako bi i ostali bili
svjesni pravila i mogli imati koristi od njih.\nKako upravljati promjenama za inicijalne faze razvoja verzija 0.y.z?\nNajjednostavniji je način da započnemo inicijalni razvoj izdavanjem verzije
0.1.0 te povećavamo oznaku manje verzije za svako sljedeće izdanje.\nKako znamo kada izdati verziju 1.0.0?\nAko se softver koristi u produkciji, već bi vjerojatno trebao biti na verziji
1.0.0. Ako već imamo stabilni API, na koji korisnici mogu računati, trebao bi
biti na verziji 1.0.0. Ako smo zabrinuti zbog kompatibilnosti unatrag, softver
bi već trebao biti izdan pod verzijom 1.0.0.\nNe sprječava li ovo ubrzani razvoj i brzo povećavanje verzija?\nVeća verzija nula se svodi na brzi razvoj. Ako mijenjamo API svaki dan, trebali
bi ostati na verziji 0.y.z ili na posebnoj grani raditi na sljedećoj većoj
verziji.\nAko i najmanje unatrag inkompatibilne promjene u APIju zahtijevaju povećanje veće verzije, nećemo li vrlo brzo doći do verzije 42.0.0?\nOvo je pitanje odgovornog razvoja i predviđanja. U softver koji ima puno
ovisnog koda, inkompatibilne promjene potrebno je uvoditi postepeno. Cijena
nadogradnje može biti značajna. Ako moramo povećati veću verziju, kako bismo
izdali verziju s inkompatibilnim promjenama, moramo razmisliti o posljedicama
tih promjenama i procijeniti odnos cijene i koristi.\nDokumentacija čitavog javnog APIja zahtijeva previše posla!\nNaša je odgovornost kao profesionalnih programera da ispravno dokumentiramo
softver koji je namijenjen korisnicima. Upravljanje složenosti softvera vrlo
je važno kako bismo projekt održali efikasnim, što je teško ako korisnici ne
znaju kako koristiti naš softver ili koje metode mogu zvati. Semantičko
verzioniranje i kvalitetno definirani Semantički verzionirani javni API osigurat
će da sve funkcionira kako treba.\nŠto ako slučajno izdamo unatrag inkompatibilne promjene kao manju verziju?\nČim primijetimo da smo prekršili specifikaciju Semantičkog verzioniranja,
potrebno je ispraviti pogrešku te izdati manju verziju koja će ispraviti problem
i vratiti kompatibilnost. Čak i u takvim uvjetima, nije prihvatljivo mijenjati
verzionirana izdanja. Ako je prikladno, dokumentiramo verziju koja krši
specifikaciju te informiramo korisnike kako bi je bili svjesni.\nŠto činiti ako promijenimo ovisnosti bez mijenjanja javnog APIja?\nTakve promjene smatramo kompatibilnima jer ne utječu na javni API. Softver koji
eksplicitno ovisi o istim ovisnostima kao i naš paket treba imati vlastite
specifikacije ovisnosti, a autor će se brinuti o konfliktima. Je li promjena
na razini zakrpe ili manje verzije, ovisi o tome jesmo li dodali ovisnosti
kako bi ispravili bug ili dodali nove funkcionalnosti. U posljednjem slučaju
možemo očekivati i dodatni kod, pri čemu se očito radi o novoj manjoj verziji.\nŠto ako nehotice promijenimo javni API na način koji ne odgovara promjeni oznake verzije (npr. u kodu neispravno uvodimo veću unatrag inkompatibilnu promjenu unutar izdanja zakrpe)?\nPokušamo najbolje prosuditi sami. Ako imamo velik broj korisnika, na koje će
značajno utjecati promjena unatrag, najbolje je da objavimo veću verziju, iako
bi takav ispravak mogli smatrati izdanjem zakrpe. Upamtimo, poanta Semantičkog
verzioniranja je dodavanje značenja promjenama oznake verzije. Ako su takve
promjene bitne korisnicima koristimo oznake verzije kako bismo ih informirali.\nKako upravljati zastarjelim (deprecating) funkcionalnostima?\nPostojeće funkcionalnosti koje zastarijevaju, uobičajeni su dio razvoja softvera
i često su potrebne kako bi razvoj napredovao. Kad označavamo dio javnog APIja
kao zastarjeli (deprecated), potrebno je učiniti dvije stvari: (1) ažurirati
dokumentaciju kako bismo informirali korisnika, (2) izdati novu manju verziju
s definiranim zastarjelim (deprecated) dijelovima softvera. Prije nego potpuno
uklonimo zastarjele funkcionalnost u novoj većoj verziji, potrebno je izdati
barem jednu manju verziju koja sadrži zastarjele (deprecated) dijelove, kako
bi korisnici glatko prešli na novu verziju APIja.\nIma li semver ograničenu veličinu oznake verzije?\nNe, ali budite razumni. Oznaka verzije od 255 znakova je vjerojatno pretjerana,
na primjer. Također, neki sustavi mogu imati svoja ograničenja veličine oznake.\nAutor specifikacije Semantičkog Verzioniranja je Tom
Preston-Werner, izumitelj Gravatara i suosnivač
GitHuba.\nAko želite ostaviti povratne informacije, molimo otvorite issue na
GitHubu.\notvorite issue na
GitHubu\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSzemantikus Verziószámozás 2.0.0

Összefoglalás

Adott egy verziószám, MAJOR.MINOR.PATCH, növeljük:


  a MAJOR verziószámot, ha a változtatásaink eredményeként elveszítjük a
kompatibilitást a korábbi verzióval,
  a MINOR verziószámot, ha olyan funkcionalitást adunk, ami megőrzi a
visszafelé kompatibilitást, és
  a PATCH verziószámot, ha visszafelé kompatibilis hibajavításokat adunk hozzá.


További verziócímkéket és kiadással kapcsolatos metaadatokat a MAJOR.MINOR.PATCH
formátum kiegészítéseként lehet még hozzáadni.

Bevezetés

A szoftvermenedzsment univerzumában létezik egy rettegett hely: a verziópokol. Minél 
nagyobbra nő a rendszered, minél több csomagot adsz hozzá, annál valószínűbb, hogy 
előbb-utóbb a kellős közepében találod magad.

Sok függőséggel rendelkező rendszerekben az új csomagverziók kiadása hamar rémálommá válhat.
Ha túl szigorúak a függőségi specifikációid, fennáll a “verzió zár” veszélye (amikor már nem tudsz úgy
frissíteni egy csomagot, hogy vele együtt az összes tőle függő csomagot ne kelljen frissíteni). 
Ugyanakkor, ha túl szabadon vannak ugyanezek megszabva, elkerülhetetlen, 
hogy idővel utolérjen a verzió-keveredés (amikor jobb
kompatibilitást remélünk szoftver komponensek között, mint ami realisztikus).
A verziópokol az, amikor e két helyzet közül az egyik vagy akár egyszerre mindkettő 
meggátol a projekt könnyed és rizikómentes előrevitelében.

A probléma megoldásaként javaslom ezen egyszerű szabályok és követelmények halmazát,
melyek megszabják hogyan rendeljünk hozzá, illetve inkrementáljuk a verziószámokat.
Ezen szabályok a már jól bevett gyakorlatokon alapulnak ― ám, nem szükségszerűen korlátozódnak rájuk -, 
mind zárt- és nyílt forráskódú szoftverekben. A rendszer első feltétele egy publikus API létrehozása. 
Ez egyaránt lehet dokumentáció formájában, vagy a programon keresztül meghatározva.
Kulcsfontosságú, hogy ez az API átlátható es precíz legyen. Miután az API-t kiadtuk, 
minden változást a szoftverben verziószám növelésével kommunikálunk. 
Tekintsük az X.Y.Z(Major.Minor.Patch) verzióformátumot.
Hibajavításoknál, melyek nem érintik az API-t, növeljük a patch verziót, visszafelé kompatibilis API 
kiegészítések/módosítások esetén növeljük a minor verziót, és visszafelé nem kompatibilis módosításoknál növeljük
a major verziót.
A rendszert “Szemantikus Verziószámozásnak” keresztelem. Ezen séma alapján, a verziószámok és ahogyan ezek változnak, 
jelentést hordoznak a mögöttes kódról és hogy mi változott egyik verzióról a másikra térve.

A Szemantikus Verziószámozás leírása (SemVer)

A kulcsszavak “MUSZÁJ” vagy “KÖTELEZŐEN” (“MUST”), “NEM LEHET” vagy “NEM SZABAD”
(“MUST NOT”), “AJÁNLOTT” (“SHOULD”), “NEM AJÁNLOTT” (“SHOULD NOT”),
“VÁLASZTHATÓ(AN)” (“OPTIONAL”) ebben a dokumentumban úgy vannak használva, mint
ahogyan itt le vannak írva: RFC 2119.


  
    Szemantikus verziószámozást használó szoftvernek MUSZÁJ publikus API-t közzétennie.
Ez az felület létezhet kizárólag dokumentáció formájában, vagy akár szoftverben
meghatározva, de mindenféleképpen szükséges, hogy precíz és minden részletre
kiterjedő legyen.
  
  
    Az általános verziószám formátuma MUSZÁJ, hogy az X.Y.Z legyen, ahol az X, Y
és Z a természetes számok halmazába tartoznak, kezdő nullák nélkül. X a
“major”, Y a “minor” és Z a “patch” verziószám. Mindhárom MUSZÁJ, hogy
számtanilag helyesen növekedjen. Például: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Miután egy új csomagverzió forgalomba lett hozva, a csomag tartalma nem
változhat. Bármilyen változás MUSZÁJ, hogy új verzióként legyen hozzáadva.
  
  
    A nulladik “major” verzió (0.Y.Z) korai fejlesztésekre alkalmazható. Bárhol
várhatóak változások a szoftverben és a publikus API-tól nem elvárható, hogy
tökéletesen stabil legyen.
  
  
    Az első verzió (1.0.0) definiálja a publikus API-t. Ezt követő
verziószámok ennek az API-nak a változásától függnek.
  
  
    A “patch”, Z verziószámot (x.y.Z | x > 0) MUSZÁJ növelni, amikor kizárólag
hátrafele kompatibilis hibajavításokat adunk a szoftverhez. Ilyen hibajavítás
definíciója egy olyan belső változás, ami addig hibás viselkedést korrigál.
  
  
    A “minor”, Y verziószámot (x.Y.z | x > 0) MUSZÁJ növelni, amikor olyan új
funkciókat adunk hozzá az API-hoz, ami a hátrafele kompatibilitást nem érinti.
MUSZÁJ növelni, amikor korábbi funkciókat elavultként jelölünk meg. Növelni
LEHET, amikor a új funkciók kerülnek a belső, privát kódbázisba. VÁLASZTHATÓAN
tartalmazhat “patch” szintű változásokat is. A “patch” verziószám MUSZÁJ, hogy
nullára csökkenjen amikor a “minor” verziószám növekszik.
  
  
    A “major”, X verziószámot (X.y.z | X > 0) MUSZÁJ növelni, amikor visszafelé
inkompatibilis változások vannak hozzáadva a nyilvános API-hoz. VÁLASZTHATÓAN
tartalmazhat “patch” és “minor” szintű változásokat is. A “patch” és “minor”
verziószámok MUSZÁJ, hogy nullára csökkenjenek amikor a “major” verziószám
növekszik.
  
  
    Egy kiadás előtti (“pre-release”) verzió VÁLASZTHATÓAN jelölhető egy
kötőjelet követően pontokkal elválasztott azonosítókkal, közvetlenül a “patch”
verzió után. Ezek az azonosítók MUSZÁJ, hogy kizárólag ASCII alfanumerikus
karakterekből és kötőjelekből álljon. Azonosítók NEM LEHETNEK üresek.
Számazonosítók NEM SZABAD, hogy nullával kezdődjenek. A kiadás előtti verziókhoz
képest elsőbbséget élveznek a hozzátartozó normál verziók. Egy kiadás előtti
verzió arra utal, hogy a verzió instabil és lehet, hogy nem elégíti ki a
szándékozott kompatibilitási feltételeket amire a normál verzió utal. Például:
1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Kiadással (“build”) kapcsolatos metaadatok VÁLASZTHATÓAN egy plusz jel
hozzáadásával, majd pontokkal elválasztott azonosítókkal rögzíthetőek,
közvetlenül a “patch” vagy kiadás előtti (“pre-release”) verzió után. Ezek az
azonosítók MUSZÁJ, hogy kizárólag ASCII alfanumerikus karakterekből és
kötőjelekből álljon. Azonosítók NEM LEHETNEK üresek. Számazonosítók NEM SZABAD,
hogy nullával kezdődjenek. A kiadással kapcsolatos metaadatokat AJÁNLOTT
figyelmen kívül hagyni a verziók elsőbbségének meghatározásakor. Ennélfogva
két verzió, ami csupán kiadással kapcsolatos metaadatban különböznek egyenlő
elsőbbséget élveznek. Például: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85.
  
  
    Az elsőbbség arra utal, hogy hogy viszonyulnak egymáshoz a verziók, amikor
sorrendbe vannak téve. Az elsőbbséget MUSZÁJ a “major”, “minor”, “patch” és
“pre-release” alapján számolni, ebben a sorrendben (kiadással kapcsolatos
metaadatok, “build-metadata” nincsenek beleszámítva). Az elsőbbségi sorrendet
az első eltérő azonosító határozza meg amikor balról jobbra olvassuk a
verziószámot, tehát ebben a sorrendben: “major”, “minor” és “patch”, és a
különbség számtanilag értelmezhető. Például: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
Amikor a “major”, “minor” es “patch” verziószámok egyenlőek, a kiadás előtti
(“pre-release”) verziónak kisebb elsőbbsége van. Például: 1.0.0-alpha < 1.0.0.
Azonos normál verzióhoz tartozó, kiadás előtti (“pre-release”) verziók közötti
elsőbbséget MUSZÁJ annak alapján meghatározni, hogy balról jobbra olvasva a
ponttal elválasztott azonosítókat összehasonlítjuk karakterről karakterre.
Számazonosítók számtanilag, alfanumerikus azonosítók ASCII alapján vannak
sorrendbe rakva. Számazonosítóknak kisebb az elsőbbsége, mint a nem numerikus
azonosítóknak. Amikor két “pre-release” verzió közötti különbség csak az, hogy az
egyiknek az azonosítói pontosan megegyeznek a másikéval, de ezen felül még
tartalmaz további azonosítókat is, akkor a több azonosítóval rendelkező verzió
elsőbbséget élvez a másik felett. Például: 1.0.0-alpha < 1.0.0-alpha.1 <
1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 <
1.0.0-rc.1 < 1.0.0.
  


Miért használjam a Szemantikus Verziószámozást?

Ez nem egy új vagy forradalmi koncepció. Sőt, valószínűleg valami ehhez hasonló
rendszert alkalmazol. A gond az az, hogy a ‘hasonló’ az nem elég. Egy hivatalos
előíráshoz való szigorú ragaszkodás nélkül a verziószámok gyakorlatilag
teljesen hasztalanná válnak a függőségek számontartásában. Másrészről viszont,
megfelelő előírások és szabályok közlése mellett jelentősen egyszerűbb
kommunikálni a szándékaidat a szoftvered felhasználóinak. Ha ezek a törekvések
egyértelműek, rugalmasak (de nem túl rugalmasak), a függőségi előírások
megfogalmazhatóvá válnak.

Egy egyszerű példa bemutatja, hogy a Szemantikus Verziószámozás hogyan tüntetheti 
el az Függőségek Számontartásának Poklát. Vegyünk egy “Tűzoltóautó” nevű csomagot.
Szüksége van egy szemantikusan verziózott csomagra: a “Létrá”-ra. Amikor a
Tűzoltóautót létrehozták, a Létra verziója 3.1.0. Mivel a Tűzoltóautó olyan
funkcionalitást használ, ami a 3.1.0-ban lett bevezetve, nyugodtan meg lehet
nevezni a függőséget: egy verziószám, ami nagyobb vagy egyenlő mint 3.1.0, de
kisebb mint 4.0.0. Amikor a Létranak a 3.1.1-es, illetve 3.2.0-ás verziói
elérhetővé válnak, bevezethetőek a Tűzoltóautó csomag menedzsment rendszerébe is
anélkül, hogy a kompatibilitást veszélyeztetné.

Felelős szoftverfejlesztőként természetesen igazolni akarod majd, hogy a
csomagfrissítések megegyeznek az elvártakkal. A világ egy kaotikus hely és ezzel
szemben csak óvatosak lehetünk. Amit tehetsz az az, hogy legalább a saját
szoftverfejlesztésed és kiadásodat szabályozza a Szemantikus Verziószámozás
úgy, hogy az attól függő csomagok minimálisan legyenek érintve, időt és erőfeszítést
spórolva.

Ha ez kívánatosnak hangzik, mindössze annyit kell tenned, hogy kijelentsd,
hogy használod a Szemantikus Verziószámozást és kövesd a szabályait. Linkeld 
ezt a honlapot a csomagod README-jébe, hogy mások is megismerjék a szabályokat és
részesülhessenek az előnyeiben.

GY.I.K.

Hogyan döntsek a revízióról a 0.y.z kezdeti fejlesztési fázisban?

A legegyszerűbb dolog amit tehetsz a kezdeti fejlesztési fázisban, hogy elkezded 
a 0.1.0 verzióval és a minor verziót inkrementálod minden egyes újabb kiadásnál.

Honnan tudom mikor jön el az 1.0.0 ideje?

Ha a szoftvered élesben lesz használva, akkor valószínűleg eljött az ideje az 1.0.0 verziónak.
Ha van egy stabil API-d, amitől már felhasználók függnek, eljött az ideje az 1.0.0 verziónak. Ha
tartasz a visszafelé kompatibilitástól, nagy a valószínűsége, hogy eljött az 1.0.0 ideje.

Nem ellenzi ez a gyors fejlesztést és a gyors iterációt?

A zéró major verzió a gyors fejlesztésről szól. Ha minden nap változtatod az API-t, még a 0.y.z verziónál kell hogy tarts 
vagy egy külön ágban kell hogy dolgozz a következő major verzión.

Ha a legkisebb visszafelé inkompatibilis változtatás is a publikus API-ban egy major verzió növelést kíván, nem fogok túl gyorsan a 42.0.0 verziónál kikötni?

Ez előrelátás és felelősségteljes fejlesztés kérdése. Inkompatibilis változtatást nem kéne könnyedén bevezetni olyan szoftverbe,
ahol ez sok kód függvénye. A javítás során felmerülő költségek jelentősek lehetnek. Kiadásra szánt major verzió növelésénél 
végig kell gondolnod a változtatás hatásait és kiértékelned a benne foglalt költség/haszon arányt.

Túl sok munka dokumentálni az egész publikus API-t!

Professzionális fejlesztőként a te feladatod megfelelően dokumentálni az éles használatra
kiadott szoftvert. A projekt hatékonyságának megtartása érdekében, egy másik rendkívül fontos feladat
a szoftver komplexitásának kezelése, és azt nehéz kezelni, ha senki nem tudja, hogyan kell használni a szoftvert
vagy milyen metódusokat biztonságos meghívni. Hosszútávon a Szemantikus verziószámozás, és a jól definiált publikus API-hoz 
való ragaszkodás meghozza az eredményét, mindenki és minden zökkenőmentesen fog haladni.

Mit tegyek, ha véletlenül kiadok egy visszafelé inkompatibilis változtatást minor verzióként?

Amint rájössz, hogy megszegted a Szemantikus Verziószámozás szabályait, javítsd a hibát és
adj ki egy új minor verziót a javított hibával és a helyrehozott visszafelé kompatibilitással.
Még ezen körülmények között is elfogadhatatlan, hogy módosíts kiadott verziót. Ha lehetséges, 
dokumentáld az érintett verziót és értesítsd a felhasználókat, hogy tisztában legyenek
a verzió problémájával kapcsolatban.

Mit tegyek, ha frissítem a saját függőségeimet a publikus API változtatása nélkül?

Ez kompatibilisnek számít, mert nem érinti a publikus API-t.
Azon szoftvernek, amelyre egyértelműen ugyanazok a függőségek állnak fent, mint a te csomagodra, 
saját függőségi specifikációval kell rendelkeznie, ezért az író észre fog venni bármilyen konfliktust. 
Annak megállapítása pedig, hogy a változtatás minor vagy major szintű, attól függ, 
hogy a függőségek módosítása bug javítása, avagy új funkció bevezetéséből eredendő. Az utóbbi esetben 
általában kód bővítésre lehet számítani, melynél egyértelmű, hogy minor szintű inkrementálásról beszélünk.

Mi a teendő, ha véletlenül megváltoztatom a publikus API-t oly módon, amely nem összeférhető a verzió szám változással (pl. nagy, major változást eszközölünk egy patch kiadásban)?

Dönts legjobb meglátásod szerint. Ha meglehetősen nagy a felhasználói kör, akiket drasztikusan befolyásolna 
a publikus API működésének degradálása, akkor a legjobb, amit tehetsz, hogy eszközölsz egy új major verzió kiadást, 
akkor is, ha a változás szigorúan egy patch kiadást kívánna. Tartsd észben, a szemantikus verziószámozás jelentést hordoz a verziószámok változásával.
Ha a változások fontosak a felhasználóid számára, jelezd a verziószámokkal.

Hogyan kezeljem az elavult funkcionalitást?

Teljesen normális esemény a szoftverfejlesztésben, hogy egyes funkcionalitások elavulnak, sőt mi több, gyakran elvárt a szoftver fejlődésének érdekében. Amikor lecserélsz egy elavult részt a publikus API-dban, két dolgot kell tenned: (1) frissítsd a dokumentációt, hogy a felhasználók tudjanak a változásról, (2) eszközölj egy új minor kiadást az elavult résszel. Mielőtt teljesen eltörölnéd a funkcionalitást egy új, major kiadásban, kell lennie egy minor kiadásnak, ami még tartalmazza az elavult részt, hogy a felhasználók zökkenőmentesen át tudjanak állni az új API-ra.

Vannak-e megszorítások a verzió string hosszára nézve a semver szerint?

Nincs, de becsüljük meg észszerűen a hosszát. Például, egy 255 karakteres verzió string erős túlzás. Különböző 
rendszereknél, különböző verzió string hossz korlátokat alkalmazhatnak.

Infó

A Semantic Versioning specifikáció szerzője Tom Preston-Werner, a Gravatars feltalálója és a GitHub társalapítója.

Észrevételekért nyiss egy issue-t a GitHub-on.

Fordította:
Rebeka Marton (szerző),
Roland Kovács (szerző)

Licensz

Creative Commons ― CC BY 3.0\nSzemantikus Verziószámozás 2.0.0\nAdott egy verziószám, MAJOR.MINOR.PATCH, növeljük:\na MAJOR verziószámot, ha a változtatásaink eredményeként elveszítjük a
kompatibilitást a korábbi verzióval,\na MINOR verziószámot, ha olyan funkcionalitást adunk, ami megőrzi a
visszafelé kompatibilitást, és\na PATCH verziószámot, ha visszafelé kompatibilis hibajavításokat adunk hozzá.\nTovábbi verziócímkéket és kiadással kapcsolatos metaadatokat a MAJOR.MINOR.PATCH
formátum kiegészítéseként lehet még hozzáadni.\nA szoftvermenedzsment univerzumában létezik egy rettegett hely: a verziópokol. Minél 
nagyobbra nő a rendszered, minél több csomagot adsz hozzá, annál valószínűbb, hogy 
előbb-utóbb a kellős közepében találod magad.\nSok függőséggel rendelkező rendszerekben az új csomagverziók kiadása hamar rémálommá válhat.
Ha túl szigorúak a függőségi specifikációid, fennáll a “verzió zár” veszélye (amikor már nem tudsz úgy
frissíteni egy csomagot, hogy vele együtt az összes tőle függő csomagot ne kelljen frissíteni). 
Ugyanakkor, ha túl szabadon vannak ugyanezek megszabva, elkerülhetetlen, 
hogy idővel utolérjen a verzió-keveredés (amikor jobb
kompatibilitást remélünk szoftver komponensek között, mint ami realisztikus).
A verziópokol az, amikor e két helyzet közül az egyik vagy akár egyszerre mindkettő 
meggátol a projekt könnyed és rizikómentes előrevitelében.\nA probléma megoldásaként javaslom ezen egyszerű szabályok és követelmények halmazát,
melyek megszabják hogyan rendeljünk hozzá, illetve inkrementáljuk a verziószámokat.
Ezen szabályok a már jól bevett gyakorlatokon alapulnak ― ám, nem szükségszerűen korlátozódnak rájuk -, 
mind zárt- és nyílt forráskódú szoftverekben. A rendszer első feltétele egy publikus API létrehozása. 
Ez egyaránt lehet dokumentáció formájában, vagy a programon keresztül meghatározva.
Kulcsfontosságú, hogy ez az API átlátható es precíz legyen. Miután az API-t kiadtuk, 
minden változást a szoftverben verziószám növelésével kommunikálunk. 
Tekintsük az X.Y.Z(Major.Minor.Patch) verzióformátumot.
Hibajavításoknál, melyek nem érintik az API-t, növeljük a patch verziót, visszafelé kompatibilis API 
kiegészítések/módosítások esetén növeljük a minor verziót, és visszafelé nem kompatibilis módosításoknál növeljük
a major verziót.
A rendszert “Szemantikus Verziószámozásnak” keresztelem. Ezen séma alapján, a verziószámok és ahogyan ezek változnak, 
jelentést hordoznak a mögöttes kódról és hogy mi változott egyik verzióról a másikra térve.\nA Szemantikus Verziószámozás leírása (SemVer)\nA kulcsszavak “MUSZÁJ” vagy “KÖTELEZŐEN” (“MUST”), “NEM LEHET” vagy “NEM SZABAD”
(“MUST NOT”), “AJÁNLOTT” (“SHOULD”), “NEM AJÁNLOTT” (“SHOULD NOT”),
“VÁLASZTHATÓ(AN)” (“OPTIONAL”) ebben a dokumentumban úgy vannak használva, mint
ahogyan itt le vannak írva: RFC 2119.\nSzemantikus verziószámozást használó szoftvernek MUSZÁJ publikus API-t közzétennie.
Ez az felület létezhet kizárólag dokumentáció formájában, vagy akár szoftverben
meghatározva, de mindenféleképpen szükséges, hogy precíz és minden részletre
kiterjedő legyen.\nSzemantikus verziószámozást használó szoftvernek MUSZÁJ publikus API-t közzétennie.
Ez az felület létezhet kizárólag dokumentáció formájában, vagy akár szoftverben
meghatározva, de mindenféleképpen szükséges, hogy precíz és minden részletre
kiterjedő legyen.\nAz általános verziószám formátuma MUSZÁJ, hogy az X.Y.Z legyen, ahol az X, Y
és Z a természetes számok halmazába tartoznak, kezdő nullák nélkül. X a
“major”, Y a “minor” és Z a “patch” verziószám. Mindhárom MUSZÁJ, hogy
számtanilag helyesen növekedjen. Például: 1.9.0 -> 1.10.0 -> 1.11.0.\nAz általános verziószám formátuma MUSZÁJ, hogy az X.Y.Z legyen, ahol az X, Y
és Z a természetes számok halmazába tartoznak, kezdő nullák nélkül. X a
“major”, Y a “minor” és Z a “patch” verziószám. Mindhárom MUSZÁJ, hogy
számtanilag helyesen növekedjen. Például: 1.9.0 -> 1.10.0 -> 1.11.0.\nMiután egy új csomagverzió forgalomba lett hozva, a csomag tartalma nem
változhat. Bármilyen változás MUSZÁJ, hogy új verzióként legyen hozzáadva.\nMiután egy új csomagverzió forgalomba lett hozva, a csomag tartalma nem
változhat. Bármilyen változás MUSZÁJ, hogy új verzióként legyen hozzáadva.\nA nulladik “major” verzió (0.Y.Z) korai fejlesztésekre alkalmazható. Bárhol
várhatóak változások a szoftverben és a publikus API-tól nem elvárható, hogy
tökéletesen stabil legyen.\nA nulladik “major” verzió (0.Y.Z) korai fejlesztésekre alkalmazható. Bárhol
várhatóak változások a szoftverben és a publikus API-tól nem elvárható, hogy
tökéletesen stabil legyen.\nAz első verzió (1.0.0) definiálja a publikus API-t. Ezt követő
verziószámok ennek az API-nak a változásától függnek.\nAz első verzió (1.0.0) definiálja a publikus API-t. Ezt követő
verziószámok ennek az API-nak a változásától függnek.\nA “patch”, Z verziószámot (x.y.Z | x > 0) MUSZÁJ növelni, amikor kizárólag
hátrafele kompatibilis hibajavításokat adunk a szoftverhez. Ilyen hibajavítás
definíciója egy olyan belső változás, ami addig hibás viselkedést korrigál.\nA “patch”, Z verziószámot (x.y.Z | x > 0) MUSZÁJ növelni, amikor kizárólag
hátrafele kompatibilis hibajavításokat adunk a szoftverhez. Ilyen hibajavítás
definíciója egy olyan belső változás, ami addig hibás viselkedést korrigál.\nA “minor”, Y verziószámot (x.Y.z | x > 0) MUSZÁJ növelni, amikor olyan új
funkciókat adunk hozzá az API-hoz, ami a hátrafele kompatibilitást nem érinti.
MUSZÁJ növelni, amikor korábbi funkciókat elavultként jelölünk meg. Növelni
LEHET, amikor a új funkciók kerülnek a belső, privát kódbázisba. VÁLASZTHATÓAN
tartalmazhat “patch” szintű változásokat is. A “patch” verziószám MUSZÁJ, hogy
nullára csökkenjen amikor a “minor” verziószám növekszik.\nA “minor”, Y verziószámot (x.Y.z | x > 0) MUSZÁJ növelni, amikor olyan új
funkciókat adunk hozzá az API-hoz, ami a hátrafele kompatibilitást nem érinti.
MUSZÁJ növelni, amikor korábbi funkciókat elavultként jelölünk meg. Növelni
LEHET, amikor a új funkciók kerülnek a belső, privát kódbázisba. VÁLASZTHATÓAN
tartalmazhat “patch” szintű változásokat is. A “patch” verziószám MUSZÁJ, hogy
nullára csökkenjen amikor a “minor” verziószám növekszik.\nA “major”, X verziószámot (X.y.z | X > 0) MUSZÁJ növelni, amikor visszafelé
inkompatibilis változások vannak hozzáadva a nyilvános API-hoz. VÁLASZTHATÓAN
tartalmazhat “patch” és “minor” szintű változásokat is. A “patch” és “minor”
verziószámok MUSZÁJ, hogy nullára csökkenjenek amikor a “major” verziószám
növekszik.\nA “major”, X verziószámot (X.y.z | X > 0) MUSZÁJ növelni, amikor visszafelé
inkompatibilis változások vannak hozzáadva a nyilvános API-hoz. VÁLASZTHATÓAN
tartalmazhat “patch” és “minor” szintű változásokat is. A “patch” és “minor”
verziószámok MUSZÁJ, hogy nullára csökkenjenek amikor a “major” verziószám
növekszik.\nEgy kiadás előtti (“pre-release”) verzió VÁLASZTHATÓAN jelölhető egy
kötőjelet követően pontokkal elválasztott azonosítókkal, közvetlenül a “patch”
verzió után. Ezek az azonosítók MUSZÁJ, hogy kizárólag ASCII alfanumerikus
karakterekből és kötőjelekből álljon. Azonosítók NEM LEHETNEK üresek.
Számazonosítók NEM SZABAD, hogy nullával kezdődjenek. A kiadás előtti verziókhoz
képest elsőbbséget élveznek a hozzátartozó normál verziók. Egy kiadás előtti
verzió arra utal, hogy a verzió instabil és lehet, hogy nem elégíti ki a
szándékozott kompatibilitási feltételeket amire a normál verzió utal. Például:
1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nEgy kiadás előtti (“pre-release”) verzió VÁLASZTHATÓAN jelölhető egy
kötőjelet követően pontokkal elválasztott azonosítókkal, közvetlenül a “patch”
verzió után. Ezek az azonosítók MUSZÁJ, hogy kizárólag ASCII alfanumerikus
karakterekből és kötőjelekből álljon. Azonosítók NEM LEHETNEK üresek.
Számazonosítók NEM SZABAD, hogy nullával kezdődjenek. A kiadás előtti verziókhoz
képest elsőbbséget élveznek a hozzátartozó normál verziók. Egy kiadás előtti
verzió arra utal, hogy a verzió instabil és lehet, hogy nem elégíti ki a
szándékozott kompatibilitási feltételeket amire a normál verzió utal. Például:
1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nKiadással (“build”) kapcsolatos metaadatok VÁLASZTHATÓAN egy plusz jel
hozzáadásával, majd pontokkal elválasztott azonosítókkal rögzíthetőek,
közvetlenül a “patch” vagy kiadás előtti (“pre-release”) verzió után. Ezek az
azonosítók MUSZÁJ, hogy kizárólag ASCII alfanumerikus karakterekből és
kötőjelekből álljon. Azonosítók NEM LEHETNEK üresek. Számazonosítók NEM SZABAD,
hogy nullával kezdődjenek. A kiadással kapcsolatos metaadatokat AJÁNLOTT
figyelmen kívül hagyni a verziók elsőbbségének meghatározásakor. Ennélfogva
két verzió, ami csupán kiadással kapcsolatos metaadatban különböznek egyenlő
elsőbbséget élveznek. Például: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85.\nKiadással (“build”) kapcsolatos metaadatok VÁLASZTHATÓAN egy plusz jel
hozzáadásával, majd pontokkal elválasztott azonosítókkal rögzíthetőek,
közvetlenül a “patch” vagy kiadás előtti (“pre-release”) verzió után. Ezek az
azonosítók MUSZÁJ, hogy kizárólag ASCII alfanumerikus karakterekből és
kötőjelekből álljon. Azonosítók NEM LEHETNEK üresek. Számazonosítók NEM SZABAD,
hogy nullával kezdődjenek. A kiadással kapcsolatos metaadatokat AJÁNLOTT
figyelmen kívül hagyni a verziók elsőbbségének meghatározásakor. Ennélfogva
két verzió, ami csupán kiadással kapcsolatos metaadatban különböznek egyenlő
elsőbbséget élveznek. Például: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85.\nAz elsőbbség arra utal, hogy hogy viszonyulnak egymáshoz a verziók, amikor
sorrendbe vannak téve. Az elsőbbséget MUSZÁJ a “major”, “minor”, “patch” és
“pre-release” alapján számolni, ebben a sorrendben (kiadással kapcsolatos
metaadatok, “build-metadata” nincsenek beleszámítva). Az elsőbbségi sorrendet
az első eltérő azonosító határozza meg amikor balról jobbra olvassuk a
verziószámot, tehát ebben a sorrendben: “major”, “minor” és “patch”, és a
különbség számtanilag értelmezhető. Például: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
Amikor a “major”, “minor” es “patch” verziószámok egyenlőek, a kiadás előtti
(“pre-release”) verziónak kisebb elsőbbsége van. Például: 1.0.0-alpha < 1.0.0.
Azonos normál verzióhoz tartozó, kiadás előtti (“pre-release”) verziók közötti
elsőbbséget MUSZÁJ annak alapján meghatározni, hogy balról jobbra olvasva a
ponttal elválasztott azonosítókat összehasonlítjuk karakterről karakterre.
Számazonosítók számtanilag, alfanumerikus azonosítók ASCII alapján vannak
sorrendbe rakva. Számazonosítóknak kisebb az elsőbbsége, mint a nem numerikus
azonosítóknak. Amikor két “pre-release” verzió közötti különbség csak az, hogy az
egyiknek az azonosítói pontosan megegyeznek a másikéval, de ezen felül még
tartalmaz további azonosítókat is, akkor a több azonosítóval rendelkező verzió
elsőbbséget élvez a másik felett. Például: 1.0.0-alpha < 1.0.0-alpha.1 <
1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 <
1.0.0-rc.1 < 1.0.0.\nAz elsőbbség arra utal, hogy hogy viszonyulnak egymáshoz a verziók, amikor
sorrendbe vannak téve. Az elsőbbséget MUSZÁJ a “major”, “minor”, “patch” és
“pre-release” alapján számolni, ebben a sorrendben (kiadással kapcsolatos
metaadatok, “build-metadata” nincsenek beleszámítva). Az elsőbbségi sorrendet
az első eltérő azonosító határozza meg amikor balról jobbra olvassuk a
verziószámot, tehát ebben a sorrendben: “major”, “minor” és “patch”, és a
különbség számtanilag értelmezhető. Például: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
Amikor a “major”, “minor” es “patch” verziószámok egyenlőek, a kiadás előtti
(“pre-release”) verziónak kisebb elsőbbsége van. Például: 1.0.0-alpha < 1.0.0.
Azonos normál verzióhoz tartozó, kiadás előtti (“pre-release”) verziók közötti
elsőbbséget MUSZÁJ annak alapján meghatározni, hogy balról jobbra olvasva a
ponttal elválasztott azonosítókat összehasonlítjuk karakterről karakterre.
Számazonosítók számtanilag, alfanumerikus azonosítók ASCII alapján vannak
sorrendbe rakva. Számazonosítóknak kisebb az elsőbbsége, mint a nem numerikus
azonosítóknak. Amikor két “pre-release” verzió közötti különbség csak az, hogy az
egyiknek az azonosítói pontosan megegyeznek a másikéval, de ezen felül még
tartalmaz további azonosítókat is, akkor a több azonosítóval rendelkező verzió
elsőbbséget élvez a másik felett. Például: 1.0.0-alpha < 1.0.0-alpha.1 <
1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 <
1.0.0-rc.1 < 1.0.0.\nMiért használjam a Szemantikus Verziószámozást?\nEz nem egy új vagy forradalmi koncepció. Sőt, valószínűleg valami ehhez hasonló
rendszert alkalmazol. A gond az az, hogy a ‘hasonló’ az nem elég. Egy hivatalos
előíráshoz való szigorú ragaszkodás nélkül a verziószámok gyakorlatilag
teljesen hasztalanná válnak a függőségek számontartásában. Másrészről viszont,
megfelelő előírások és szabályok közlése mellett jelentősen egyszerűbb
kommunikálni a szándékaidat a szoftvered felhasználóinak. Ha ezek a törekvések
egyértelműek, rugalmasak (de nem túl rugalmasak), a függőségi előírások
megfogalmazhatóvá válnak.\nEgy egyszerű példa bemutatja, hogy a Szemantikus Verziószámozás hogyan tüntetheti 
el az Függőségek Számontartásának Poklát. Vegyünk egy “Tűzoltóautó” nevű csomagot.
Szüksége van egy szemantikusan verziózott csomagra: a “Létrá”-ra. Amikor a
Tűzoltóautót létrehozták, a Létra verziója 3.1.0. Mivel a Tűzoltóautó olyan
funkcionalitást használ, ami a 3.1.0-ban lett bevezetve, nyugodtan meg lehet
nevezni a függőséget: egy verziószám, ami nagyobb vagy egyenlő mint 3.1.0, de
kisebb mint 4.0.0. Amikor a Létranak a 3.1.1-es, illetve 3.2.0-ás verziói
elérhetővé válnak, bevezethetőek a Tűzoltóautó csomag menedzsment rendszerébe is
anélkül, hogy a kompatibilitást veszélyeztetné.\nFelelős szoftverfejlesztőként természetesen igazolni akarod majd, hogy a
csomagfrissítések megegyeznek az elvártakkal. A világ egy kaotikus hely és ezzel
szemben csak óvatosak lehetünk. Amit tehetsz az az, hogy legalább a saját
szoftverfejlesztésed és kiadásodat szabályozza a Szemantikus Verziószámozás
úgy, hogy az attól függő csomagok minimálisan legyenek érintve, időt és erőfeszítést
spórolva.\nHa ez kívánatosnak hangzik, mindössze annyit kell tenned, hogy kijelentsd,
hogy használod a Szemantikus Verziószámozást és kövesd a szabályait. Linkeld 
ezt a honlapot a csomagod README-jébe, hogy mások is megismerjék a szabályokat és
részesülhessenek az előnyeiben.\nHogyan döntsek a revízióról a 0.y.z kezdeti fejlesztési fázisban?\nA legegyszerűbb dolog amit tehetsz a kezdeti fejlesztési fázisban, hogy elkezded 
a 0.1.0 verzióval és a minor verziót inkrementálod minden egyes újabb kiadásnál.\nHonnan tudom mikor jön el az 1.0.0 ideje?\nHa a szoftvered élesben lesz használva, akkor valószínűleg eljött az ideje az 1.0.0 verziónak.
Ha van egy stabil API-d, amitől már felhasználók függnek, eljött az ideje az 1.0.0 verziónak. Ha
tartasz a visszafelé kompatibilitástól, nagy a valószínűsége, hogy eljött az 1.0.0 ideje.\nNem ellenzi ez a gyors fejlesztést és a gyors iterációt?\nA zéró major verzió a gyors fejlesztésről szól. Ha minden nap változtatod az API-t, még a 0.y.z verziónál kell hogy tarts 
vagy egy külön ágban kell hogy dolgozz a következő major verzión.\nHa a legkisebb visszafelé inkompatibilis változtatás is a publikus API-ban egy major verzió növelést kíván, nem fogok túl gyorsan a 42.0.0 verziónál kikötni?\nEz előrelátás és felelősségteljes fejlesztés kérdése. Inkompatibilis változtatást nem kéne könnyedén bevezetni olyan szoftverbe,
ahol ez sok kód függvénye. A javítás során felmerülő költségek jelentősek lehetnek. Kiadásra szánt major verzió növelésénél 
végig kell gondolnod a változtatás hatásait és kiértékelned a benne foglalt költség/haszon arányt.\nTúl sok munka dokumentálni az egész publikus API-t!\nProfesszionális fejlesztőként a te feladatod megfelelően dokumentálni az éles használatra
kiadott szoftvert. A projekt hatékonyságának megtartása érdekében, egy másik rendkívül fontos feladat
a szoftver komplexitásának kezelése, és azt nehéz kezelni, ha senki nem tudja, hogyan kell használni a szoftvert
vagy milyen metódusokat biztonságos meghívni. Hosszútávon a Szemantikus verziószámozás, és a jól definiált publikus API-hoz 
való ragaszkodás meghozza az eredményét, mindenki és minden zökkenőmentesen fog haladni.\nMit tegyek, ha véletlenül kiadok egy visszafelé inkompatibilis változtatást minor verzióként?\nAmint rájössz, hogy megszegted a Szemantikus Verziószámozás szabályait, javítsd a hibát és
adj ki egy új minor verziót a javított hibával és a helyrehozott visszafelé kompatibilitással.
Még ezen körülmények között is elfogadhatatlan, hogy módosíts kiadott verziót. Ha lehetséges, 
dokumentáld az érintett verziót és értesítsd a felhasználókat, hogy tisztában legyenek
a verzió problémájával kapcsolatban.\nMit tegyek, ha frissítem a saját függőségeimet a publikus API változtatása nélkül?\nEz kompatibilisnek számít, mert nem érinti a publikus API-t.
Azon szoftvernek, amelyre egyértelműen ugyanazok a függőségek állnak fent, mint a te csomagodra, 
saját függőségi specifikációval kell rendelkeznie, ezért az író észre fog venni bármilyen konfliktust. 
Annak megállapítása pedig, hogy a változtatás minor vagy major szintű, attól függ, 
hogy a függőségek módosítása bug javítása, avagy új funkció bevezetéséből eredendő. Az utóbbi esetben 
általában kód bővítésre lehet számítani, melynél egyértelmű, hogy minor szintű inkrementálásról beszélünk.\nMi a teendő, ha véletlenül megváltoztatom a publikus API-t oly módon, amely nem összeférhető a verzió szám változással (pl. nagy, major változást eszközölünk egy patch kiadásban)?\nDönts legjobb meglátásod szerint. Ha meglehetősen nagy a felhasználói kör, akiket drasztikusan befolyásolna 
a publikus API működésének degradálása, akkor a legjobb, amit tehetsz, hogy eszközölsz egy új major verzió kiadást, 
akkor is, ha a változás szigorúan egy patch kiadást kívánna. Tartsd észben, a szemantikus verziószámozás jelentést hordoz a verziószámok változásával.
Ha a változások fontosak a felhasználóid számára, jelezd a verziószámokkal.\nHogyan kezeljem az elavult funkcionalitást?\nTeljesen normális esemény a szoftverfejlesztésben, hogy egyes funkcionalitások elavulnak, sőt mi több, gyakran elvárt a szoftver fejlődésének érdekében. Amikor lecserélsz egy elavult részt a publikus API-dban, két dolgot kell tenned: (1) frissítsd a dokumentációt, hogy a felhasználók tudjanak a változásról, (2) eszközölj egy új minor kiadást az elavult résszel. Mielőtt teljesen eltörölnéd a funkcionalitást egy új, major kiadásban, kell lennie egy minor kiadásnak, ami még tartalmazza az elavult részt, hogy a felhasználók zökkenőmentesen át tudjanak állni az új API-ra.\nVannak-e megszorítások a verzió string hosszára nézve a semver szerint?\nNincs, de becsüljük meg észszerűen a hosszát. Például, egy 255 karakteres verzió string erős túlzás. Különböző 
rendszereknél, különböző verzió string hossz korlátokat alkalmazhatnak.\nA Semantic Versioning specifikáció szerzője Tom Preston-Werner, a Gravatars feltalálója és a GitHub társalapítója.\nÉszrevételekért nyiss egy issue-t a GitHub-on.\nnyiss egy issue-t a GitHub-on\nFordította:
Rebeka Marton (szerző),
Roland Kovács (szerző)\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nՍեմանտիկ Տարբերակում 2.0.0

Համառոտ

Այս ֆորմատով ներկայացված տարբերակի համարի (version number) դեպքում՝
ՄԱԺՈՐ․ՄԻՆՈՐ․ՓԱԹՉ (MAJOR.MINOR.PATCH), պետք է մեծացնել՝


  ՄԱԺՈՐ տարբերակի համարը, երբ տեղի են ունեցել API֊ի այնպիսի փոփոխություններ,
որոնց արդյունքում խախտվել է հետ համատեղելիությունը։
  ՄԻՆՈՐ տարբերակի համարը, երբ ավելացվել է նոր ֆունկցիոնալ՝ հետ
համատեղելիությունը չխախտելով (backwards-compatible)։
  ՓԱԹՉ տարբերակի համարը, երբ տեղի են ունեցել հետ համատեղելի փոփոխություններ։


Կարելի է անել նաև հավելյալ նշանակումներ՝ որպես հավելում ՄԱԺՈՐ․ՄԻՆՈՐ․ՓԱԹՉ
ֆորմատին․ մինչթողարկումային (pre-release) պիտակ (label) և բիլդ-մետատվյալ
(build metadata)։

Ներածություն

Ծրագրային ապահովման մենեջմենթի աշխարհում գոյություն ունի «կախվածությունների
դժոխք» (dependency hell) հասկացություն։ Ձեր համակարգի մեծացման և դրան ինտեգրված
փեքիջների քանակի ավելացման հետ մեծանում է հավանականությունը, որ դուք վաղ թե ուշ
կկանգնեք այս խնդրի առաջ։

Այն համակարգերում, որոնք ունեն շատ կախվածություններ, նոր տարբերակի թողարկումը
կարող է արագ վերածվել մղձավանջի։ Եթե կախվածությունների սպեցիֆիկացիան շատ խիստ է,
դուք կարող եք կանգնել նոր տարբերակի թողարկման արգելքի (version lock) առաջ
(անհնար է դառնում թարմացնել ծրագիրը՝ առանց թարմացնելու կախման մեջ գտնվող բոլոր
փեքիջները)։ Մյուս կողմից էլ, եթե կախվածությունների սպեցիֆիկացիան շատ ազատ է,
դուք անխուսափելիորեն կբախվեք տարբերակի անհամապատասխանության (version
promiscuity) խնդրին․ անհիմն է ենթադրությունը, որ ձեր ծրագիրը կմնա համատեղելի
ապագա տարբերակների հետ։ «Կախվածությունների դժոխքը» մի իրավիճակ է, երբ տարբերակի
թողարկման և/կամ տարբերակի անհապատասխանության արգելքը թույլ չի տալիս ձեզ հեշտ և
անվտանգ զարգացնել ձեր նախագիծը։

Որպես այս խնդրի լուծում՝ ես առաջարկում եմ պարզ կանոններ և պահանջներ, որոնք
սահմանում են, թե ինչպես են սահմանվում և մեծացվում տարբերակների համարները։ Այս
կանոնները հիմնված են (բայց ոչ անպայման սահմանափակված) բաց (open source) և փակ
(closed source) ծրագրային ապահովման գոյություն ունեցող և լայն տարածում գտած
պրակտիկաների վրա։ Նախևառաջ, որպեսզի այս կանոններն աշխատեն, դուք պետք է սահմանեք
փաբլիք API: Այն կարող է նկարագրված լինել ինչպես դոկումենտացիայի, այնպես էլ կոդի
մեջ։ Կարևոր է, որ API֊ը լինի ճիշտ և հասկանալի։ Ձեր API֊ը հայտարարելուց հետո դուք
փոփոխությունների մասին կտեղեկացնեք տարբերակի համարը մեծացնելու միջոցով։
Դիտարկենք այս ֆորմատով ներկայացված տարբերակ՝ X.Y.Z (ՄԱԺՈՐ․ՄԻՆՈՐ․ՓԱԹՉ)։ Սխալների
ուղղումները (bug fix), որոենք չեն ազդել API-ի վրա, մեծացնում են ՓԱԹՉ֊ը։ Հետ
համատեղելի հավելումները և փոփոխությունները մեծացնում են ՄԻՆՈՐ֊ը, հետ
համատեղելիությունը խախտող փոփոխությունները մեծացնում են ՄԱԺՈՐ֊ը։

Ես անվանել եմ այս համակարգը «Սեմանտիկ տարբերակում» (Semantic Versioning): Այս
սխեմայի միջոցով տարբերակի համարը և դրա փոխվելը իմաստավորում են կոդի
պարունակությունը և նրանում եղած փոփոխությունները տարբերակից տարբերակ։

Սեմանտիկ տարբերակման սպեցիֆիկացիա (SemVer)

Նշված բառերը՝ «ՊԵՏՔ Է» (MUST, SHALL), «ՉՊԵՏՔ Է» (MUST NOT, SHALL NOT),
«ՊԱՐՏԱԴԻՐ Է» (REQUIRED), «ԱՆՀՐԱԺԵՇՏ Է» (SHOULD), «ԱՆՀՐԱԺԵՇՏ ՉԷ» (SHOULD NOT),
«ԽՈՐՀՈՒՐԴ Է ՏՐՎՈՒՄ» (RECOMMENDED), «ԿԱՐՈՂ Է» (MAY) և «ՊԱՐՏԱԴԻՐ ՉԷ» (OPTIONAL)
պետք է ինտերպրիտացվեն RFC 2119 ստանդարտին
համապատասխան։


  
    Ծրագրային ապահովումը, որն օգտագործվում է Սեմանտիկ տարբերակում, ՊԵՏՔ Է (MUST)
հայտարարի հասանելի փաբլիք API: Այդ API֊ը կարող է հայտարարվել ինչպես կոդի մեջ,
այնպես էլ՝ առանձին դոկումենտացիայում։ Երկու դեպքում էլ այն պետք է լինի ճշգրիտ
(precise) և սպառիչ (comprehensive)։
  
  
    Տարբերակի ՆՈՐՄԱԼ համարը (normal version) ՊԵՏՔ Է (MUST) ունենա այս ֆորմատը՝
X.Y.Z, որտեղ X, Y և Z թվերը ոչ բացասական ամբողջ թվեր են և ՉՊԵՏՔ է (MUST NOT)
սկսվեն զրոյով։ X֊ը տարբերակի ՄԱԺՈՐ համարն է, Y֊ը՝ ՄԻՆՈՐ և Z֊ը՝ ՓԱԹՉ։ Բոլոր
բաղադիրչները պետք է մեծացվեն թվայնորեն․ օրինակ՝ 1.9.0 -> 1.10.0 -> 1.11.0։
  
  
    Փեքիջի թողարկումից հետո այդ տարբերակի պարունակությունը ՉՊԵՏՔ է (MUST NOT)
փոփոխության ենթարկվի։ Ցանկացած փոփոխություն ՊԵՏՔ Է (MUST) թողարկվի որպես նոր
տարբերակ։
  
  
    Զրոյական ՄԱԺՈՐ տարբերակը (0.y.z) նախատեսված է ծրագրային ապահովման
ստեղծման/մշակման նախնական փուլի (initial development) համար։ Ամեն ինչ կարող է
փոխվել՝ կամայական պահի։ Փաբլիք API֊ը չպետք է դիտարկվի որպես ստաբիլ։
  
  
    1.0.0 տարբերակի թողարկումից հետո API-ը համարվում է ստաբիլ, և տարբերակի համարը
փոխվում է կախված նրանից, թե ինչպես է փոխվում փաբլիք API֊ը։
  
  
    Տարբերակի ՓԱԹՉ համարը՝ Z (x.y.Z | x > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե տեղի են
ունեցել միայն հետ համատեղելի սխալների ուղղումներ (bug fix)։ Սխալի ուղղում՝
նշանակում է ներքին փոփոխություն, որը ուղղում է սխալ պահվածքը։
  
  
    Տարբերակի ՄԻՆՈՐ համարը՝ Y (x.Y.z | x > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե փաբլիք
API֊ում ավելացել է նոր հետ համատեղելի ֆունկցիոնալ։ Տարբերակի համարը ՊԵՏՔ Է
(MUST) մեծացվի, եթե հասանելի փաբլիք API֊ի որևէ ֆունկցիոնալ պիտակավորվել է
որպես հնացած (deprecated)։ Տարբերակի համարը ԿԱՐՈՂ Է (MAY) մեծացվել, եթե տեղի
է ունեցել նոր ֆունկցիոնալի ինտեգրացիա, կամ զգալի բարելավումներ են տեղի
ունեցել փրայվիթ կոդում։ Այն ԿԱՐՈՂ Է (MAY) նաև պարունակել ՓԱԹՉ մակարդակի
փոփոխություններ։ Տարբերակի ՓԱԹՉ համարը ՊԵՏՔ Է (MUST) զրոյացվի, երբ մեծացվում
է ՄԻՆՈՐ համարը։
  
  
    Տարբերակի ՄԱԺՈՐ համարը՝ X (X.y.z | X > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե փաբլիք
API֊ում ներկայացվել են հետ համատեղելիությունը խախտող կամայական
փոփոխություններ։ Այն ԿԱՐՈՂ Է (MAY) պարունակել նաև ՓԱԹՉ և ՄԻՆՈՐ մակարդակի
փոփոխություններ։ Տարբերակի ՓԱԹՉ և ՄԻՆՈՐ համարները ՊԵՏՔ Է (MUST) զրոյացվեն,
երբ մեծացվում է ՄԱԺՈՐ համարը։
  
  
    Մինչթողարկումային (pre-release) տարբերակը ԿԱՐՈՂ Է (MAY) պիտակավորվել
տարբերակի ՓԱԹՉ համարից անմիջապես հետո գծիկ և դրան հետևող կետիկով առանձնացված
տարբեր իդենտիֆիկատորներ ավելացնելու միջոցով։ Իդենտիֆիկատորները ՊԵՏՔ Է (MUST)
պարունակեն միայն ASCII տառա֊թվային սիմվոլներ և գծիկ՝ [0-9A-Za-z-]։
Իդենտիֆիկատորները ՉՊԵՏՔ Է (MUST NOT) լինեն դատարկ։ Թվային իդենտիֆիկատորները
ՉՊԵՏՔ Է (MUST NOT) սկսվեն զրոյով։ Մինչթողարկումային տարբերակները ունեն ավելի
ցածր ԿԱՐԳԱՎԻՃԱԿ, քան համապատասխան ՆՈՐՄԱԼ֊ները։ Մինչթողարկումային տարբերակը
ցույց է տալիս, որ այդ տարբերակը ստաբիլ չէ և կարող է չբավարարել
համատեղելիության պահանջները, որոնք նշված են համապատասխան ՆՈՐՄԱԼ տարբերակում․
օրինակ՝ 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92։
  
  
    Բիլդ֊մետատվյալները (build-metadata) ԿԱՐՈՂ ԵՆ (MAY) պիտակավորվել տարբերակի
ՓԱԹՉ համարից կամ մինչթողարկումային տարբերակի իդենտիֆիկատորից անմիջապես հետո
գումարման նշան և դրան հետևող կետիկով առանձնացված տարբեր իդենտիֆիկատորներ
ավելացնելու միջոցով։ Իդենտիֆիկատորները ՊԵՏՔ Է (MUST) պարունակեն միայն ASCII
տառա֊թվային սիմվոլներ և գծիկ՝ [0-9A-Za-z-]։ Իդենտիֆիկատորները ՉՊԵՏՔ Է (MUST
NOT) լինեն դատարկ։ Բիլդ֊մետատվյալները ՊԵՏՔ Է (MUST) անտեսել տարբերակի
ԿԱՐԳԱՎԻՃԱԿԸ որոշելիս այսինքն, եթե նույն ծրագրի երկու տարբերակները տարբերվում
են միայն բիլդ֊մետատվյալներով, ուրեմն դրանք ունեն նույն ԿԱՐԳԱՎԻՃԱԿԸ․ օրինակ՝
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85։
  
  
    ԿԱՐԳԱՎԻՃԱԿԸ (precedence) որոշում է, թե ինչպես է պետք համեմատել տարբերակները
միմյանց հետ, երբ դրանք դասավորված են։ ԿԱՐԳԱՎԻՃԱԿԸ ՊԵՏՔ Է (MUST) հաշվել
տարբերակի համարը՝ ՄԱԺՈՐ, ՄԻՆՈՐ, ՓԱԹՉ, և մինչթողարկումային իդենտիֆիկատորները
բաժանելու միջոցով։ ԿԱՐԳԱՎԻՃԱԿԸ որոշելիս բիլդ֊մետատվյալները հաշվի չեն առնվում։
ԿԱՐԳԱՎԻՃԱԿԸ որոշվում է ՄԱԺՈՐ, ՄԻՆՈՐ, ՓԱԹՉ տարբերակի համարները ձախից աջ
թվայնորեն համեմատելու միջոցով․ օրինակ՝ 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1։ Երբ
ՄԱԺՈՐ, ՄԻՆՈՐ և ՓԱԹՉ տարբերակի համարները հավասար են, մինչթողարկումային
տարբերակը ունենում է ավելի փոքր ԿԱՐԳԱՎԻՃԱԿ, քան ՆՈՐՄԱԼ տարբերակը․ օրինակ՝
1.0.0-alpha < 1.0.0։ Երբ տարբերակների ՄԱԺՈՐ, ՄԻՆՈՐ և ՓԱԹՉ համարները հավասար
են, ԿԱՐԳԱՎԻՃԱԿԸ ՊԵՏՔ Է (MUST) որոշել մինչթողարկումային տարբերակի միջոցով՝
ձախից աջ կետով առանձնացված իդենտիֆիկատորները համեմատելով մինչև առաջին
տարբերող իդենտիֆիկատոր գտնելը։ Մինչթողարկումային տարբերակները համեմատվում են
տվյալ եղանակով՝ իդենտիֆիկատորները, որոնք կազմված են միայն թվերից, համեմատվում
են թվայնորեն։ Տառեր և գծիկ պարունակող իդենտիֆիկատորները համեմատվում են
տառացի՝ ASCII աղյուսակի հերթականությամբ։ Թվային իդենտիֆիկատորները միշտ
ունենում են ավելի ցածր կարգավիճակ, քան ոչ թվայինները։ Մինչթողարկումային
սիմվոլների մեծ քանակ ունեցող տարբերակը ունենում է ավելի բարձր կարգավիճակ, երբ
համեմատվող իդենտիֆիկատորները նույնն են․ օրինակ՝ 1.0.0-alpha < 1.0.0-alpha.1 <
1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 <
1.0.0։
  


Բակուս֊Նոյերի սխեման SemVer֊ով ներկայացված տարբերակի համարների համար
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


Ի՞նչու օգտագործել սեմանտիկ տարբերակում

Սա նոր կամ հեղափոխական միտք չէ։ Հավանական է՝ դուք օգտվում եք տարբերակման նման
ինչ֊որ եղանակից։ Խնդիրն այն է, որ «նման» եղանակից օգվելը կարող է բավարար չլինել։
Առանց կոշտ սպեցիֆիկացիայի տարբերակի համարները անօգուտ են դառնում
կախվածությունները կարգավորելու հարցում։ Տալով անուն և որոշակիացնելով վերը
ձևակերպված մտքերը՝ ավելի հեշտ է դառնում հաղորդել ձեր մտքերը այն օգտատերերին,
որոնք օգտվում են ձեր ծրագրային ապահովումից։ Եթե այդ մտքերը հասկանալի են և ճկուն,
կախվածությունների սպեցիֆիկացիան կաշխատի։

Պարզ օրինակի միջոցով կարելի է ցույց տալ, թե ինչպես է Սեմանտիկ Տարբերակումը
«կախվածություննեի դժողքը» թողնում անցյալում։ Պատկերացնենք մի գրադարան (library),
որի անունն է՝ «Firetruck»։ Նրա աշխատանքի համար անհրաժեշ է Սեմանտիկ Տարբերակումով
թողարկվող «Ladder» փեքիջը։ Երբ Firetruck֊ը ստեղծվել էր, Ladder֊ի տարբերակի
համարն էր՝ 3.1.0։ Քանի որ Firetruck֊ը օգտագործում է Ladder֊ի 3.1.0 տարբերակի
ֆունկցիոնալը, դուք հանգիստ կարող եք հայտարարել կախվածությունը Ladder֊ի 3.1.0
տարբերակից, բայց ոչ ավել քան 4.0.0։ Երբ դուրս գա Ladder֊ի 3.2.0 տարբերակը, դուք
հաստատ կիմանաք, որ այն համատեղելի է ձեր ծրագրի հետ և կարող եք հանգիստ ինտեգրել
այն։

Որպես պատասխանատու ծրագրավորող՝ դուք իհարկե կցանկանաք վստահ լինել, որ բոլոր
թարմացումները աշխատում են այնպես ինչպես հայտարարվել է։ Իրական աշխարհում միշտ
խառնաշփոթ է, և ոչինչ չի կարելի անել դրա հետ, բացի ուշադիր լինելուց։ Սեմանտիկ
տարբերակման միջոցով դուք կարող եք թողարկել ձեր ծրագրային ապահովման նոր
տարբերակներ և թարմացումներ չմտածելով կախվածությունների մասին և պահպանել ձեր
ժամանակը և նյարդերը։

Եթե այս ամենը գայթակղիչ է թվում ձեզ, այն ամենը ինչ ձեզ անհրաժեշտ է՝ սկսել
օգտագործել Սեմանտիկ տարբերակումը, հայտարարել դրա մասին և հետևել կանոններին։ Նշեք
այս կայքի հղումը ձեր README֊ում և օգտագործողները կիմանան այս կանոնների մասին։

ՀՏՀ

Ի՞նչ է անհրաժեշտ անել 0.y.z տարբերակում արված փոփոխությունների հետ, ծրագրավորման նախնական փուլում։

Ամենահեշտ լուծումը աշխատանքը 0.1.0 տարբերակի թողարկումով սկսելն է և հետագայում
ամեն հաջորդ թողարկման համար ՄԻՆՈՐ տարբերակի համարը մեծացնելը։

Ի՞նչպես իմանալ, որ 1.0.0 տարբերակը թողարկելու ժամանկն է։

Եթե ձեր ծրագրային ապահովումը արդեն օգտագործվում է պրոդաքշնում, ամենայն
հավանականությամբ արդեն պետք է թողարկել 1.0.0 տարբերակը։ Եթե դուք ունեք ստաբիլ
API, որը ունի օգտագործողներ, տարբերակի համարը պետք է լինի 1.0.0։ Եթե
անհանգստանում եք հետ համատեղելիության մասին, ամենայն հավանականությամբ ձեր
ծրագրային ապահովման տարբերակի համարը արդեն պետք է լինի 1.0.0։

Արդյո՞ք աշխատելու այս ձևը չի խանգարում արագ ծրագրավորմանը (rapid development) և արագ իտերացիաներին (fast iteration)։

Երբ ՄԱԺՈՐ տարբերակի համարը 0 է, դա արդեն իսկ ենթադրում է արագ ծրագրավորում։ Եթե
դուք փոփոխեք API֊ը ամեն օր, ապա պետք է լինեք 0.y.z տարբերակի վրա, կամ առանձին
ճյուղի (branch) վրա աշխատեք հաջորդ ՄԱԺՈՐ տարբերակի թողարկման համար։

Եթե նույնիսկ փոքր փոփոխությունները, որոնք խախտում են հետ համատեղելիությունը, պահանջում են նոր ՄԱԺՈՐ տարբերակի թողարկում, արդյո՞ք դա չի հանգեցնի նրան, որ շուտով տարբերակի համարը դառնա 42.0.0։

Սա ավելի շատ պատասխանատվության և հեռատեսության խնդիր է։ Ծրագրային ապահովման հետ
համատեղելիությունը խախտող փոփոխությունները աննշան չեն, քանի որ դրա արդյունքում
թարմացումները կարող են շատ թանկ արժենալ։ Հետ համատեղելիությունը խախտող
փոփոխությունների թողարկումը տարբերակի ՄԱԺՈՐ համարի ավելացմամբ, նշանակում է՝ դուք
պետք է մտածեք ձեր փոփոխությունների հետևանքների մասին և հաշվի առնեք գին֊օգուտ
հարաբերակցությունը։

Դոկումենտացիայի կազմումը մեծ աշխատանք է պահանջում։

Որպես պրոֆեսիոնալ ծրագրավորող ձեր պատասխանատվությունն է ճիշտ դոկումենտացնել
ծրագրային ապահովումը, որը նախատեսված է ուրիշների օգտագործման համար։ Ծրագրային
ապահովման բարդության կարգավորումը նրա արդյունավետության պահպանման կարևոևագույն
կետերից մեկն է։ Եթե ոչ մեկը չգիտի, թե ինչպես օգտագործել ձեր ծրագրային
ապահովումը, կամ որ մեթոդի կանչն է անվտանգ, ինչպես պետք է նրանք օգտագործեն այն։
Երկարաժամկետ հեռանկարով Սեմանտիկ Տարբերակումը, համառ և կոշտ դիրքը որակով
շարադրված փաբլիք API֊ի նկատմամբ կնպաստեն ամենքի և ամեն ինչի ճիշտ և համակարգված
աշխատելուն։

Ի՞նչ է անհրաժեշտ անել, եթե պատահաբար թողարկվել են հետ համատեղելիությունը խախտող փոփոխություններ ՄԻՆՈՐ տարբերակի տակ։

Հենց որ դուք հասկացաք, որ խախտել եք Սեմանտիկ Տարբերակման սպեցիֆիկացիան, ուղղեք
սխալը և թողարկեք նոր ՄԻՆՈՐ տարբերակ, որը լուծում է խնդիրը և վերականգնում հետ
համատեղելիությունը։ Նույնիսկ նման դեպքերում անընդունելի է արդեն թողարկված
տարբերակներում փոփոխությունների իրականացումը։ Եթե անհրաժեշտ է, նշեք
դոկումենտացիայում և տեղյակ պահեք օգտագործողներին հետ համատեղելիության և
տարբերակման հերթականության խախտման մասին։

Ի՞նչ է անհրաժեշտ անել, եթե փոփոխվել են կախվածությունները առանց փաբլիք API֊ը փոփոխելու։

Դա կարող է դիտարկվել որպես հետ համատեղելի փոփոխություն, քանի որ այն չի ազդում
փաբլիք API֊ի վրա։ Ծրագրային ապահովումը, որը ակնհայտորեն ունի նույն
կախվածությունները, ինչ փեքիջը, պետք է ունենա իր սեփական կախվածությունների
սպեցիֆիկացիան, և հեղինակը տեղյակ կլինի ի հայտ եկած կոնֆլիկտների մասին։ Արդյոք
տվյալ փոփոխությունները ՄԱԺՈՐ, թե ՓԱԹՉ մակարդակի են, կախված է նրանից, թե դուք
փոխել եք ձեր կախվածությունները սխալներ ուղղելու, թե՞ նոր ֆունկցիոնալ ինտեգրելու
համար։ Երկրորդ դեպքում, որպես կանոն ավելանում է որոշակի քանակով կոդ և որպես
հետևանք մեծանում է տարբերակի ՄԻՆՈՐ համարը։

Ի՞նչ անել, եթե պատահաբար փոփոխվել է փաբլիք API֊ը, և այն չի համապատասխանում տարբերակի համարին (այսինքն՝ կոդը սխալմամբ պարունակում է հետ համատեղելիությունը խախտող փոփոխություններ ՓԱԹՉ տարբերակի թողարկման մեջ)։

Որոշումը ձերն է։ Եթե դուք ունեք օգտագործողների մեծ խումբ, որը կկանգնի փաբլիք
API֊ի նախկին ֆունկցիոնալի վերականգման փաստի առաջ, ուրեմն ճիշտ կլինի թողարկել նոր
տարբերակ ՄԱԺՈՐ համարի մեծացումով։ Չնայած նրան, որ այն պարունակում է միայն ՓԱԹՉ
մակարդակի փոփոխություններ, հիշեք՝ ըստ Սեմանտիկ Տարբերակման սպեցիֆիկացիայի
տարբերակի համարները մեծացվում են սպեցիֆիկացիային համաձայն։ Եթե այդ
փոփոխությունները կարևոր են ձեր օգտագործողների համար, օգտագործեք տարբերակի համարը
նրանց տեղյակ պահելու համար։

Ի՞նչ անել հնացած (deprecated) ֆունկցիոնալի հետ։

Որոշ ֆունկցիոնալի հնանալը սովորական երևույթ է և ծրագրային ապահովման
ստեղծման/մշակման ընթացքում հաճախ պարտադիր է առաջընթացի համար։ Երբ դուք հնացած եք
հայտարարում, փաբլիք API֊ի ինչ֊որ հատված, դուք պետք է երկու բան անեք․ նախ
թարմացնեք ձեր դոկումենտացիան և տեղեկացնեք օգտագործողներին փոփոխության մասին (1),
և ապա թողարկեք նոր ՄԻՆՈՐ տարբերակ՝ նշում կատարելով հնացած ֆունկցիոնալի մասին
(2)։ Մինչ դուք ամբողջովին կջնջեք հնացած ֆունկցիոնալը, հաջորդ ՄԱԺՈՐ թողարկման
ժամանակ պետք է լինի առնվազն մեկ ՄԻՆՈՐ թողարկում, որը պարունակում է տեղեկություն
ֆունկցիոնալի հնացած հայտարարվելու մասին, որպեսզի օգտագործողները հեշտությամբ
անցնեն նոր API֊ի։

Արդյոք SemVer֊ը ունի՞ սահմանափակում տարբերակի համարի երկարության վրա։

Ոչ, բայց եղեք խելամիտ։ Եթե տարբերակի համարի երկարությունը 255 սիմվոլ է,
հավանաբար դա չափազանց է։ Բացի դրանից որոշ համակարգեր կարող են ունենալ իրենց
սեփական սահմանափակումները տարբերակի համարի երկարության վրա։

«v1.2.3» ֆորմատը համարվու՞մ է տարբերակի սեմանտիկ համար։

Ոչ, «v1.2.3»֊ը տարբերակի սեմանտիկ համար չի համարվում։ Ամեն դեպքում «v» տառը
սեմանտիկ տարբերակի առջևում դնելը ընդունված երևույթ է (անգլերենում) տարբերակի
համարը ընդգծելու համար։ «v» հապավման օգտագործումը «version» բառի փոխարեն
տարածված պրակտիկա է տարբերակների կարգավորման (version control) մեջ: Օրինակ՝
git tag v1.2.3 -m "Release version 1.2.3"․ այստեղ «v1.2.3»֊ը թեգի անուն է, և
սեմանտիկ տարբերակը «1.2.3» է։

Ինչպիսի՞ ռեգուլյար արտահայտության (RegEx) միջոցով կարելի է ստուգել SemVer տարբերակի համարի ճշտությունը:

Կա երկու եղանակ.


  անվանական խմբերի միջոցով (named groups)։ (PCRE [Perl համատեղելի ռեգուլյար
արտահայտություններ, օրինակ՝ Perl, PHP և R], Python և Go)։


Տես՝ https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$



  թվային խմբերի (numbered capture groups) միջոցով (cg1 = major, cg2 = minor,
cg3 = patch, cg4 = prerelease and cg5 = buildmetadata)։ Այս եղանակը համատեղելի է
ECMA Script֊ի (JavaScript), PCRE֊ի (Perl համատեղելի ռեգուլյար
արտահայտություններ, օրինակ՝ Perl, PHP և R), Python և Go.


Տես՝ https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Հեղինակ

Սեմանտիկ Տարբերակման սպեցիֆիկացիայի հեղինակն է
Թոմ Պրեստոն-Վարները (Gravatar֊ի հիմնադիր և
GitHub֊ի համահիմնադիր)։

Եթե դուք ցանկանում եք որևէ մեկնաբանություն թողնել, խնդրում ենք
GitHub֊ում հարց (issue) բացել։

Լիցենզիա

Creative Commons ― CC BY 3.0\nՍեմանտիկ Տարբերակում 2.0.0\nԱյս ֆորմատով ներկայացված տարբերակի համարի (version number) դեպքում՝
ՄԱԺՈՐ․ՄԻՆՈՐ․ՓԱԹՉ (MAJOR.MINOR.PATCH), պետք է մեծացնել՝\nՄԱԺՈՐ տարբերակի համարը, երբ տեղի են ունեցել API֊ի այնպիսի փոփոխություններ,
որոնց արդյունքում խախտվել է հետ համատեղելիությունը։\nՄԻՆՈՐ տարբերակի համարը, երբ ավելացվել է նոր ֆունկցիոնալ՝ հետ
համատեղելիությունը չխախտելով (backwards-compatible)։\nՓԱԹՉ տարբերակի համարը, երբ տեղի են ունեցել հետ համատեղելի փոփոխություններ։\nԿարելի է անել նաև հավելյալ նշանակումներ՝ որպես հավելում ՄԱԺՈՐ․ՄԻՆՈՐ․ՓԱԹՉ
ֆորմատին․ մինչթողարկումային (pre-release) պիտակ (label) և բիլդ-մետատվյալ
(build metadata)։\nԾրագրային ապահովման մենեջմենթի աշխարհում գոյություն ունի «կախվածությունների
դժոխք» (dependency hell) հասկացություն։ Ձեր համակարգի մեծացման և դրան ինտեգրված
փեքիջների քանակի ավելացման հետ մեծանում է հավանականությունը, որ դուք վաղ թե ուշ
կկանգնեք այս խնդրի առաջ։\nԱյն համակարգերում, որոնք ունեն շատ կախվածություններ, նոր տարբերակի թողարկումը
կարող է արագ վերածվել մղձավանջի։ Եթե կախվածությունների սպեցիֆիկացիան շատ խիստ է,
դուք կարող եք կանգնել նոր տարբերակի թողարկման արգելքի (version lock) առաջ
(անհնար է դառնում թարմացնել ծրագիրը՝ առանց թարմացնելու կախման մեջ գտնվող բոլոր
փեքիջները)։ Մյուս կողմից էլ, եթե կախվածությունների սպեցիֆիկացիան շատ ազատ է,
դուք անխուսափելիորեն կբախվեք տարբերակի անհամապատասխանության (version
promiscuity) խնդրին․ անհիմն է ենթադրությունը, որ ձեր ծրագիրը կմնա համատեղելի
ապագա տարբերակների հետ։ «Կախվածությունների դժոխքը» մի իրավիճակ է, երբ տարբերակի
թողարկման և/կամ տարբերակի անհապատասխանության արգելքը թույլ չի տալիս ձեզ հեշտ և
անվտանգ զարգացնել ձեր նախագիծը։\nՈրպես այս խնդրի լուծում՝ ես առաջարկում եմ պարզ կանոններ և պահանջներ, որոնք
սահմանում են, թե ինչպես են սահմանվում և մեծացվում տարբերակների համարները։ Այս
կանոնները հիմնված են (բայց ոչ անպայման սահմանափակված) բաց (open source) և փակ
(closed source) ծրագրային ապահովման գոյություն ունեցող և լայն տարածում գտած
պրակտիկաների վրա։ Նախևառաջ, որպեսզի այս կանոններն աշխատեն, դուք պետք է սահմանեք
փաբլիք API: Այն կարող է նկարագրված լինել ինչպես դոկումենտացիայի, այնպես էլ կոդի
մեջ։ Կարևոր է, որ API֊ը լինի ճիշտ և հասկանալի։ Ձեր API֊ը հայտարարելուց հետո դուք
փոփոխությունների մասին կտեղեկացնեք տարբերակի համարը մեծացնելու միջոցով։
Դիտարկենք այս ֆորմատով ներկայացված տարբերակ՝ X.Y.Z (ՄԱԺՈՐ․ՄԻՆՈՐ․ՓԱԹՉ)։ Սխալների
ուղղումները (bug fix), որոենք չեն ազդել API-ի վրա, մեծացնում են ՓԱԹՉ֊ը։ Հետ
համատեղելի հավելումները և փոփոխությունները մեծացնում են ՄԻՆՈՐ֊ը, հետ
համատեղելիությունը խախտող փոփոխությունները մեծացնում են ՄԱԺՈՐ֊ը։\nԵս անվանել եմ այս համակարգը «Սեմանտիկ տարբերակում» (Semantic Versioning): Այս
սխեմայի միջոցով տարբերակի համարը և դրա փոխվելը իմաստավորում են կոդի
պարունակությունը և նրանում եղած փոփոխությունները տարբերակից տարբերակ։\nՍեմանտիկ տարբերակման սպեցիֆիկացիա (SemVer)\nՆշված բառերը՝ «ՊԵՏՔ Է» (MUST, SHALL), «ՉՊԵՏՔ Է» (MUST NOT, SHALL NOT),
«ՊԱՐՏԱԴԻՐ Է» (REQUIRED), «ԱՆՀՐԱԺԵՇՏ Է» (SHOULD), «ԱՆՀՐԱԺԵՇՏ ՉԷ» (SHOULD NOT),
«ԽՈՐՀՈՒՐԴ Է ՏՐՎՈՒՄ» (RECOMMENDED), «ԿԱՐՈՂ Է» (MAY) և «ՊԱՐՏԱԴԻՐ ՉԷ» (OPTIONAL)
պետք է ինտերպրիտացվեն RFC 2119 ստանդարտին
համապատասխան։\nԾրագրային ապահովումը, որն օգտագործվում է Սեմանտիկ տարբերակում, ՊԵՏՔ Է (MUST)
հայտարարի հասանելի փաբլիք API: Այդ API֊ը կարող է հայտարարվել ինչպես կոդի մեջ,
այնպես էլ՝ առանձին դոկումենտացիայում։ Երկու դեպքում էլ այն պետք է լինի ճշգրիտ
(precise) և սպառիչ (comprehensive)։\nԾրագրային ապահովումը, որն օգտագործվում է Սեմանտիկ տարբերակում, ՊԵՏՔ Է (MUST)
հայտարարի հասանելի փաբլիք API: Այդ API֊ը կարող է հայտարարվել ինչպես կոդի մեջ,
այնպես էլ՝ առանձին դոկումենտացիայում։ Երկու դեպքում էլ այն պետք է լինի ճշգրիտ
(precise) և սպառիչ (comprehensive)։\nՏարբերակի ՆՈՐՄԱԼ համարը (normal version) ՊԵՏՔ Է (MUST) ունենա այս ֆորմատը՝
X.Y.Z, որտեղ X, Y և Z թվերը ոչ բացասական ամբողջ թվեր են և ՉՊԵՏՔ է (MUST NOT)
սկսվեն զրոյով։ X֊ը տարբերակի ՄԱԺՈՐ համարն է, Y֊ը՝ ՄԻՆՈՐ և Z֊ը՝ ՓԱԹՉ։ Բոլոր
բաղադիրչները պետք է մեծացվեն թվայնորեն․ օրինակ՝ 1.9.0 -> 1.10.0 -> 1.11.0։\nՏարբերակի ՆՈՐՄԱԼ համարը (normal version) ՊԵՏՔ Է (MUST) ունենա այս ֆորմատը՝
X.Y.Z, որտեղ X, Y և Z թվերը ոչ բացասական ամբողջ թվեր են և ՉՊԵՏՔ է (MUST NOT)
սկսվեն զրոյով։ X֊ը տարբերակի ՄԱԺՈՐ համարն է, Y֊ը՝ ՄԻՆՈՐ և Z֊ը՝ ՓԱԹՉ։ Բոլոր
բաղադիրչները պետք է մեծացվեն թվայնորեն․ օրինակ՝ 1.9.0 -> 1.10.0 -> 1.11.0։\nՓեքիջի թողարկումից հետո այդ տարբերակի պարունակությունը ՉՊԵՏՔ է (MUST NOT)
փոփոխության ենթարկվի։ Ցանկացած փոփոխություն ՊԵՏՔ Է (MUST) թողարկվի որպես նոր
տարբերակ։\nՓեքիջի թողարկումից հետո այդ տարբերակի պարունակությունը ՉՊԵՏՔ է (MUST NOT)
փոփոխության ենթարկվի։ Ցանկացած փոփոխություն ՊԵՏՔ Է (MUST) թողարկվի որպես նոր
տարբերակ։\nԶրոյական ՄԱԺՈՐ տարբերակը (0.y.z) նախատեսված է ծրագրային ապահովման
ստեղծման/մշակման նախնական փուլի (initial development) համար։ Ամեն ինչ կարող է
փոխվել՝ կամայական պահի։ Փաբլիք API֊ը չպետք է դիտարկվի որպես ստաբիլ։\nԶրոյական ՄԱԺՈՐ տարբերակը (0.y.z) նախատեսված է ծրագրային ապահովման
ստեղծման/մշակման նախնական փուլի (initial development) համար։ Ամեն ինչ կարող է
փոխվել՝ կամայական պահի։ Փաբլիք API֊ը չպետք է դիտարկվի որպես ստաբիլ։\n1.0.0 տարբերակի թողարկումից հետո API-ը համարվում է ստաբիլ, և տարբերակի համարը
փոխվում է կախված նրանից, թե ինչպես է փոխվում փաբլիք API֊ը։\n1.0.0 տարբերակի թողարկումից հետո API-ը համարվում է ստաբիլ, և տարբերակի համարը
փոխվում է կախված նրանից, թե ինչպես է փոխվում փաբլիք API֊ը։\nՏարբերակի ՓԱԹՉ համարը՝ Z (x.y.Z | x > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե տեղի են
ունեցել միայն հետ համատեղելի սխալների ուղղումներ (bug fix)։ Սխալի ուղղում՝
նշանակում է ներքին փոփոխություն, որը ուղղում է սխալ պահվածքը։\nՏարբերակի ՓԱԹՉ համարը՝ Z (x.y.Z | x > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե տեղի են
ունեցել միայն հետ համատեղելի սխալների ուղղումներ (bug fix)։ Սխալի ուղղում՝
նշանակում է ներքին փոփոխություն, որը ուղղում է սխալ պահվածքը։\nՏարբերակի ՄԻՆՈՐ համարը՝ Y (x.Y.z | x > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե փաբլիք
API֊ում ավելացել է նոր հետ համատեղելի ֆունկցիոնալ։ Տարբերակի համարը ՊԵՏՔ Է
(MUST) մեծացվի, եթե հասանելի փաբլիք API֊ի որևէ ֆունկցիոնալ պիտակավորվել է
որպես հնացած (deprecated)։ Տարբերակի համարը ԿԱՐՈՂ Է (MAY) մեծացվել, եթե տեղի
է ունեցել նոր ֆունկցիոնալի ինտեգրացիա, կամ զգալի բարելավումներ են տեղի
ունեցել փրայվիթ կոդում։ Այն ԿԱՐՈՂ Է (MAY) նաև պարունակել ՓԱԹՉ մակարդակի
փոփոխություններ։ Տարբերակի ՓԱԹՉ համարը ՊԵՏՔ Է (MUST) զրոյացվի, երբ մեծացվում
է ՄԻՆՈՐ համարը։\nՏարբերակի ՄԻՆՈՐ համարը՝ Y (x.Y.z | x > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե փաբլիք
API֊ում ավելացել է նոր հետ համատեղելի ֆունկցիոնալ։ Տարբերակի համարը ՊԵՏՔ Է
(MUST) մեծացվի, եթե հասանելի փաբլիք API֊ի որևէ ֆունկցիոնալ պիտակավորվել է
որպես հնացած (deprecated)։ Տարբերակի համարը ԿԱՐՈՂ Է (MAY) մեծացվել, եթե տեղի
է ունեցել նոր ֆունկցիոնալի ինտեգրացիա, կամ զգալի բարելավումներ են տեղի
ունեցել փրայվիթ կոդում։ Այն ԿԱՐՈՂ Է (MAY) նաև պարունակել ՓԱԹՉ մակարդակի
փոփոխություններ։ Տարբերակի ՓԱԹՉ համարը ՊԵՏՔ Է (MUST) զրոյացվի, երբ մեծացվում
է ՄԻՆՈՐ համարը։\nՏարբերակի ՄԱԺՈՐ համարը՝ X (X.y.z | X > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե փաբլիք
API֊ում ներկայացվել են հետ համատեղելիությունը խախտող կամայական
փոփոխություններ։ Այն ԿԱՐՈՂ Է (MAY) պարունակել նաև ՓԱԹՉ և ՄԻՆՈՐ մակարդակի
փոփոխություններ։ Տարբերակի ՓԱԹՉ և ՄԻՆՈՐ համարները ՊԵՏՔ Է (MUST) զրոյացվեն,
երբ մեծացվում է ՄԱԺՈՐ համարը։\nՏարբերակի ՄԱԺՈՐ համարը՝ X (X.y.z | X > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե փաբլիք
API֊ում ներկայացվել են հետ համատեղելիությունը խախտող կամայական
փոփոխություններ։ Այն ԿԱՐՈՂ Է (MAY) պարունակել նաև ՓԱԹՉ և ՄԻՆՈՐ մակարդակի
փոփոխություններ։ Տարբերակի ՓԱԹՉ և ՄԻՆՈՐ համարները ՊԵՏՔ Է (MUST) զրոյացվեն,
երբ մեծացվում է ՄԱԺՈՐ համարը։\nՄինչթողարկումային (pre-release) տարբերակը ԿԱՐՈՂ Է (MAY) պիտակավորվել
տարբերակի ՓԱԹՉ համարից անմիջապես հետո գծիկ և դրան հետևող կետիկով առանձնացված
տարբեր իդենտիֆիկատորներ ավելացնելու միջոցով։ Իդենտիֆիկատորները ՊԵՏՔ Է (MUST)
պարունակեն միայն ASCII տառա֊թվային սիմվոլներ և գծիկ՝ [0-9A-Za-z-]։
Իդենտիֆիկատորները ՉՊԵՏՔ Է (MUST NOT) լինեն դատարկ։ Թվային իդենտիֆիկատորները
ՉՊԵՏՔ Է (MUST NOT) սկսվեն զրոյով։ Մինչթողարկումային տարբերակները ունեն ավելի
ցածր ԿԱՐԳԱՎԻՃԱԿ, քան համապատասխան ՆՈՐՄԱԼ֊ները։ Մինչթողարկումային տարբերակը
ցույց է տալիս, որ այդ տարբերակը ստաբիլ չէ և կարող է չբավարարել
համատեղելիության պահանջները, որոնք նշված են համապատասխան ՆՈՐՄԱԼ տարբերակում․
օրինակ՝ 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92։\nՄինչթողարկումային (pre-release) տարբերակը ԿԱՐՈՂ Է (MAY) պիտակավորվել
տարբերակի ՓԱԹՉ համարից անմիջապես հետո գծիկ և դրան հետևող կետիկով առանձնացված
տարբեր իդենտիֆիկատորներ ավելացնելու միջոցով։ Իդենտիֆիկատորները ՊԵՏՔ Է (MUST)
պարունակեն միայն ASCII տառա֊թվային սիմվոլներ և գծիկ՝ [0-9A-Za-z-]։
Իդենտիֆիկատորները ՉՊԵՏՔ Է (MUST NOT) լինեն դատարկ։ Թվային իդենտիֆիկատորները
ՉՊԵՏՔ Է (MUST NOT) սկսվեն զրոյով։ Մինչթողարկումային տարբերակները ունեն ավելի
ցածր ԿԱՐԳԱՎԻՃԱԿ, քան համապատասխան ՆՈՐՄԱԼ֊ները։ Մինչթողարկումային տարբերակը
ցույց է տալիս, որ այդ տարբերակը ստաբիլ չէ և կարող է չբավարարել
համատեղելիության պահանջները, որոնք նշված են համապատասխան ՆՈՐՄԱԼ տարբերակում․
օրինակ՝ 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92։\nԲիլդ֊մետատվյալները (build-metadata) ԿԱՐՈՂ ԵՆ (MAY) պիտակավորվել տարբերակի
ՓԱԹՉ համարից կամ մինչթողարկումային տարբերակի իդենտիֆիկատորից անմիջապես հետո
գումարման նշան և դրան հետևող կետիկով առանձնացված տարբեր իդենտիֆիկատորներ
ավելացնելու միջոցով։ Իդենտիֆիկատորները ՊԵՏՔ Է (MUST) պարունակեն միայն ASCII
տառա֊թվային սիմվոլներ և գծիկ՝ [0-9A-Za-z-]։ Իդենտիֆիկատորները ՉՊԵՏՔ Է (MUST
NOT) լինեն դատարկ։ Բիլդ֊մետատվյալները ՊԵՏՔ Է (MUST) անտեսել տարբերակի
ԿԱՐԳԱՎԻՃԱԿԸ որոշելիս այսինքն, եթե նույն ծրագրի երկու տարբերակները տարբերվում
են միայն բիլդ֊մետատվյալներով, ուրեմն դրանք ունեն նույն ԿԱՐԳԱՎԻՃԱԿԸ․ օրինակ՝
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85։\nԲիլդ֊մետատվյալները (build-metadata) ԿԱՐՈՂ ԵՆ (MAY) պիտակավորվել տարբերակի
ՓԱԹՉ համարից կամ մինչթողարկումային տարբերակի իդենտիֆիկատորից անմիջապես հետո
գումարման նշան և դրան հետևող կետիկով առանձնացված տարբեր իդենտիֆիկատորներ
ավելացնելու միջոցով։ Իդենտիֆիկատորները ՊԵՏՔ Է (MUST) պարունակեն միայն ASCII
տառա֊թվային սիմվոլներ և գծիկ՝ [0-9A-Za-z-]։ Իդենտիֆիկատորները ՉՊԵՏՔ Է (MUST
NOT) լինեն դատարկ։ Բիլդ֊մետատվյալները ՊԵՏՔ Է (MUST) անտեսել տարբերակի
ԿԱՐԳԱՎԻՃԱԿԸ որոշելիս այսինքն, եթե նույն ծրագրի երկու տարբերակները տարբերվում
են միայն բիլդ֊մետատվյալներով, ուրեմն դրանք ունեն նույն ԿԱՐԳԱՎԻՃԱԿԸ․ օրինակ՝
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85։\nԿԱՐԳԱՎԻՃԱԿԸ (precedence) որոշում է, թե ինչպես է պետք համեմատել տարբերակները
միմյանց հետ, երբ դրանք դասավորված են։ ԿԱՐԳԱՎԻՃԱԿԸ ՊԵՏՔ Է (MUST) հաշվել
տարբերակի համարը՝ ՄԱԺՈՐ, ՄԻՆՈՐ, ՓԱԹՉ, և մինչթողարկումային իդենտիֆիկատորները
բաժանելու միջոցով։ ԿԱՐԳԱՎԻՃԱԿԸ որոշելիս բիլդ֊մետատվյալները հաշվի չեն առնվում։
ԿԱՐԳԱՎԻՃԱԿԸ որոշվում է ՄԱԺՈՐ, ՄԻՆՈՐ, ՓԱԹՉ տարբերակի համարները ձախից աջ
թվայնորեն համեմատելու միջոցով․ օրինակ՝ 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1։ Երբ
ՄԱԺՈՐ, ՄԻՆՈՐ և ՓԱԹՉ տարբերակի համարները հավասար են, մինչթողարկումային
տարբերակը ունենում է ավելի փոքր ԿԱՐԳԱՎԻՃԱԿ, քան ՆՈՐՄԱԼ տարբերակը․ օրինակ՝
1.0.0-alpha < 1.0.0։ Երբ տարբերակների ՄԱԺՈՐ, ՄԻՆՈՐ և ՓԱԹՉ համարները հավասար
են, ԿԱՐԳԱՎԻՃԱԿԸ ՊԵՏՔ Է (MUST) որոշել մինչթողարկումային տարբերակի միջոցով՝
ձախից աջ կետով առանձնացված իդենտիֆիկատորները համեմատելով մինչև առաջին
տարբերող իդենտիֆիկատոր գտնելը։ Մինչթողարկումային տարբերակները համեմատվում են
տվյալ եղանակով՝ իդենտիֆիկատորները, որոնք կազմված են միայն թվերից, համեմատվում
են թվայնորեն։ Տառեր և գծիկ պարունակող իդենտիֆիկատորները համեմատվում են
տառացի՝ ASCII աղյուսակի հերթականությամբ։ Թվային իդենտիֆիկատորները միշտ
ունենում են ավելի ցածր կարգավիճակ, քան ոչ թվայինները։ Մինչթողարկումային
սիմվոլների մեծ քանակ ունեցող տարբերակը ունենում է ավելի բարձր կարգավիճակ, երբ
համեմատվող իդենտիֆիկատորները նույնն են․ օրինակ՝ 1.0.0-alpha < 1.0.0-alpha.1 <
1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 <
1.0.0։\nԿԱՐԳԱՎԻՃԱԿԸ (precedence) որոշում է, թե ինչպես է պետք համեմատել տարբերակները
միմյանց հետ, երբ դրանք դասավորված են։ ԿԱՐԳԱՎԻՃԱԿԸ ՊԵՏՔ Է (MUST) հաշվել
տարբերակի համարը՝ ՄԱԺՈՐ, ՄԻՆՈՐ, ՓԱԹՉ, և մինչթողարկումային իդենտիֆիկատորները
բաժանելու միջոցով։ ԿԱՐԳԱՎԻՃԱԿԸ որոշելիս բիլդ֊մետատվյալները հաշվի չեն առնվում։
ԿԱՐԳԱՎԻՃԱԿԸ որոշվում է ՄԱԺՈՐ, ՄԻՆՈՐ, ՓԱԹՉ տարբերակի համարները ձախից աջ
թվայնորեն համեմատելու միջոցով․ օրինակ՝ 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1։ Երբ
ՄԱԺՈՐ, ՄԻՆՈՐ և ՓԱԹՉ տարբերակի համարները հավասար են, մինչթողարկումային
տարբերակը ունենում է ավելի փոքր ԿԱՐԳԱՎԻՃԱԿ, քան ՆՈՐՄԱԼ տարբերակը․ օրինակ՝
1.0.0-alpha < 1.0.0։ Երբ տարբերակների ՄԱԺՈՐ, ՄԻՆՈՐ և ՓԱԹՉ համարները հավասար
են, ԿԱՐԳԱՎԻՃԱԿԸ ՊԵՏՔ Է (MUST) որոշել մինչթողարկումային տարբերակի միջոցով՝
ձախից աջ կետով առանձնացված իդենտիֆիկատորները համեմատելով մինչև առաջին
տարբերող իդենտիֆիկատոր գտնելը։ Մինչթողարկումային տարբերակները համեմատվում են
տվյալ եղանակով՝ իդենտիֆիկատորները, որոնք կազմված են միայն թվերից, համեմատվում
են թվայնորեն։ Տառեր և գծիկ պարունակող իդենտիֆիկատորները համեմատվում են
տառացի՝ ASCII աղյուսակի հերթականությամբ։ Թվային իդենտիֆիկատորները միշտ
ունենում են ավելի ցածր կարգավիճակ, քան ոչ թվայինները։ Մինչթողարկումային
սիմվոլների մեծ քանակ ունեցող տարբերակը ունենում է ավելի բարձր կարգավիճակ, երբ
համեմատվող իդենտիֆիկատորները նույնն են․ օրինակ՝ 1.0.0-alpha < 1.0.0-alpha.1 <
1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 <
1.0.0։\nԲակուս֊Նոյերի սխեման SemVer֊ով ներկայացված տարբերակի համարների համար\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nԻ՞նչու օգտագործել սեմանտիկ տարբերակում\nՍա նոր կամ հեղափոխական միտք չէ։ Հավանական է՝ դուք օգտվում եք տարբերակման նման
ինչ֊որ եղանակից։ Խնդիրն այն է, որ «նման» եղանակից օգվելը կարող է բավարար չլինել։
Առանց կոշտ սպեցիֆիկացիայի տարբերակի համարները անօգուտ են դառնում
կախվածությունները կարգավորելու հարցում։ Տալով անուն և որոշակիացնելով վերը
ձևակերպված մտքերը՝ ավելի հեշտ է դառնում հաղորդել ձեր մտքերը այն օգտատերերին,
որոնք օգտվում են ձեր ծրագրային ապահովումից։ Եթե այդ մտքերը հասկանալի են և ճկուն,
կախվածությունների սպեցիֆիկացիան կաշխատի։\nՊարզ օրինակի միջոցով կարելի է ցույց տալ, թե ինչպես է Սեմանտիկ Տարբերակումը
«կախվածություննեի դժողքը» թողնում անցյալում։ Պատկերացնենք մի գրադարան (library),
որի անունն է՝ «Firetruck»։ Նրա աշխատանքի համար անհրաժեշ է Սեմանտիկ Տարբերակումով
թողարկվող «Ladder» փեքիջը։ Երբ Firetruck֊ը ստեղծվել էր, Ladder֊ի տարբերակի
համարն էր՝ 3.1.0։ Քանի որ Firetruck֊ը օգտագործում է Ladder֊ի 3.1.0 տարբերակի
ֆունկցիոնալը, դուք հանգիստ կարող եք հայտարարել կախվածությունը Ladder֊ի 3.1.0
տարբերակից, բայց ոչ ավել քան 4.0.0։ Երբ դուրս գա Ladder֊ի 3.2.0 տարբերակը, դուք
հաստատ կիմանաք, որ այն համատեղելի է ձեր ծրագրի հետ և կարող եք հանգիստ ինտեգրել
այն։\nՈրպես պատասխանատու ծրագրավորող՝ դուք իհարկե կցանկանաք վստահ լինել, որ բոլոր
թարմացումները աշխատում են այնպես ինչպես հայտարարվել է։ Իրական աշխարհում միշտ
խառնաշփոթ է, և ոչինչ չի կարելի անել դրա հետ, բացի ուշադիր լինելուց։ Սեմանտիկ
տարբերակման միջոցով դուք կարող եք թողարկել ձեր ծրագրային ապահովման նոր
տարբերակներ և թարմացումներ չմտածելով կախվածությունների մասին և պահպանել ձեր
ժամանակը և նյարդերը։\nԵթե այս ամենը գայթակղիչ է թվում ձեզ, այն ամենը ինչ ձեզ անհրաժեշտ է՝ սկսել
օգտագործել Սեմանտիկ տարբերակումը, հայտարարել դրա մասին և հետևել կանոններին։ Նշեք
այս կայքի հղումը ձեր README֊ում և օգտագործողները կիմանան այս կանոնների մասին։\nԻ՞նչ է անհրաժեշտ անել 0.y.z տարբերակում արված փոփոխությունների հետ, ծրագրավորման նախնական փուլում։\nԱմենահեշտ լուծումը աշխատանքը 0.1.0 տարբերակի թողարկումով սկսելն է և հետագայում
ամեն հաջորդ թողարկման համար ՄԻՆՈՐ տարբերակի համարը մեծացնելը։\nԻ՞նչպես իմանալ, որ 1.0.0 տարբերակը թողարկելու ժամանկն է։\nԵթե ձեր ծրագրային ապահովումը արդեն օգտագործվում է պրոդաքշնում, ամենայն
հավանականությամբ արդեն պետք է թողարկել 1.0.0 տարբերակը։ Եթե դուք ունեք ստաբիլ
API, որը ունի օգտագործողներ, տարբերակի համարը պետք է լինի 1.0.0։ Եթե
անհանգստանում եք հետ համատեղելիության մասին, ամենայն հավանականությամբ ձեր
ծրագրային ապահովման տարբերակի համարը արդեն պետք է լինի 1.0.0։\nԱրդյո՞ք աշխատելու այս ձևը չի խանգարում արագ ծրագրավորմանը (rapid development) և արագ իտերացիաներին (fast iteration)։\nԵրբ ՄԱԺՈՐ տարբերակի համարը 0 է, դա արդեն իսկ ենթադրում է արագ ծրագրավորում։ Եթե
դուք փոփոխեք API֊ը ամեն օր, ապա պետք է լինեք 0.y.z տարբերակի վրա, կամ առանձին
ճյուղի (branch) վրա աշխատեք հաջորդ ՄԱԺՈՐ տարբերակի թողարկման համար։\nԵթե նույնիսկ փոքր փոփոխությունները, որոնք խախտում են հետ համատեղելիությունը, պահանջում են նոր ՄԱԺՈՐ տարբերակի թողարկում, արդյո՞ք դա չի հանգեցնի նրան, որ շուտով տարբերակի համարը դառնա 42.0.0։\nՍա ավելի շատ պատասխանատվության և հեռատեսության խնդիր է։ Ծրագրային ապահովման հետ
համատեղելիությունը խախտող փոփոխությունները աննշան չեն, քանի որ դրա արդյունքում
թարմացումները կարող են շատ թանկ արժենալ։ Հետ համատեղելիությունը խախտող
փոփոխությունների թողարկումը տարբերակի ՄԱԺՈՐ համարի ավելացմամբ, նշանակում է՝ դուք
պետք է մտածեք ձեր փոփոխությունների հետևանքների մասին և հաշվի առնեք գին֊օգուտ
հարաբերակցությունը։\nԴոկումենտացիայի կազմումը մեծ աշխատանք է պահանջում։\nՈրպես պրոֆեսիոնալ ծրագրավորող ձեր պատասխանատվությունն է ճիշտ դոկումենտացնել
ծրագրային ապահովումը, որը նախատեսված է ուրիշների օգտագործման համար։ Ծրագրային
ապահովման բարդության կարգավորումը նրա արդյունավետության պահպանման կարևոևագույն
կետերից մեկն է։ Եթե ոչ մեկը չգիտի, թե ինչպես օգտագործել ձեր ծրագրային
ապահովումը, կամ որ մեթոդի կանչն է անվտանգ, ինչպես պետք է նրանք օգտագործեն այն։
Երկարաժամկետ հեռանկարով Սեմանտիկ Տարբերակումը, համառ և կոշտ դիրքը որակով
շարադրված փաբլիք API֊ի նկատմամբ կնպաստեն ամենքի և ամեն ինչի ճիշտ և համակարգված
աշխատելուն։\nԻ՞նչ է անհրաժեշտ անել, եթե պատահաբար թողարկվել են հետ համատեղելիությունը խախտող փոփոխություններ ՄԻՆՈՐ տարբերակի տակ։\nՀենց որ դուք հասկացաք, որ խախտել եք Սեմանտիկ Տարբերակման սպեցիֆիկացիան, ուղղեք
սխալը և թողարկեք նոր ՄԻՆՈՐ տարբերակ, որը լուծում է խնդիրը և վերականգնում հետ
համատեղելիությունը։ Նույնիսկ նման դեպքերում անընդունելի է արդեն թողարկված
տարբերակներում փոփոխությունների իրականացումը։ Եթե անհրաժեշտ է, նշեք
դոկումենտացիայում և տեղյակ պահեք օգտագործողներին հետ համատեղելիության և
տարբերակման հերթականության խախտման մասին։\nԻ՞նչ է անհրաժեշտ անել, եթե փոփոխվել են կախվածությունները առանց փաբլիք API֊ը փոփոխելու։\nԴա կարող է դիտարկվել որպես հետ համատեղելի փոփոխություն, քանի որ այն չի ազդում
փաբլիք API֊ի վրա։ Ծրագրային ապահովումը, որը ակնհայտորեն ունի նույն
կախվածությունները, ինչ փեքիջը, պետք է ունենա իր սեփական կախվածությունների
սպեցիֆիկացիան, և հեղինակը տեղյակ կլինի ի հայտ եկած կոնֆլիկտների մասին։ Արդյոք
տվյալ փոփոխությունները ՄԱԺՈՐ, թե ՓԱԹՉ մակարդակի են, կախված է նրանից, թե դուք
փոխել եք ձեր կախվածությունները սխալներ ուղղելու, թե՞ նոր ֆունկցիոնալ ինտեգրելու
համար։ Երկրորդ դեպքում, որպես կանոն ավելանում է որոշակի քանակով կոդ և որպես
հետևանք մեծանում է տարբերակի ՄԻՆՈՐ համարը։\nԻ՞նչ անել, եթե պատահաբար փոփոխվել է փաբլիք API֊ը, և այն չի համապատասխանում տարբերակի համարին (այսինքն՝ կոդը սխալմամբ պարունակում է հետ համատեղելիությունը խախտող փոփոխություններ ՓԱԹՉ տարբերակի թողարկման մեջ)։\nՈրոշումը ձերն է։ Եթե դուք ունեք օգտագործողների մեծ խումբ, որը կկանգնի փաբլիք
API֊ի նախկին ֆունկցիոնալի վերականգման փաստի առաջ, ուրեմն ճիշտ կլինի թողարկել նոր
տարբերակ ՄԱԺՈՐ համարի մեծացումով։ Չնայած նրան, որ այն պարունակում է միայն ՓԱԹՉ
մակարդակի փոփոխություններ, հիշեք՝ ըստ Սեմանտիկ Տարբերակման սպեցիֆիկացիայի
տարբերակի համարները մեծացվում են սպեցիֆիկացիային համաձայն։ Եթե այդ
փոփոխությունները կարևոր են ձեր օգտագործողների համար, օգտագործեք տարբերակի համարը
նրանց տեղյակ պահելու համար։\nԻ՞նչ անել հնացած (deprecated) ֆունկցիոնալի հետ։\nՈրոշ ֆունկցիոնալի հնանալը սովորական երևույթ է և ծրագրային ապահովման
ստեղծման/մշակման ընթացքում հաճախ պարտադիր է առաջընթացի համար։ Երբ դուք հնացած եք
հայտարարում, փաբլիք API֊ի ինչ֊որ հատված, դուք պետք է երկու բան անեք․ նախ
թարմացնեք ձեր դոկումենտացիան և տեղեկացնեք օգտագործողներին փոփոխության մասին (1),
և ապա թողարկեք նոր ՄԻՆՈՐ տարբերակ՝ նշում կատարելով հնացած ֆունկցիոնալի մասին
(2)։ Մինչ դուք ամբողջովին կջնջեք հնացած ֆունկցիոնալը, հաջորդ ՄԱԺՈՐ թողարկման
ժամանակ պետք է լինի առնվազն մեկ ՄԻՆՈՐ թողարկում, որը պարունակում է տեղեկություն
ֆունկցիոնալի հնացած հայտարարվելու մասին, որպեսզի օգտագործողները հեշտությամբ
անցնեն նոր API֊ի։\nԱրդյոք SemVer֊ը ունի՞ սահմանափակում տարբերակի համարի երկարության վրա։\nՈչ, բայց եղեք խելամիտ։ Եթե տարբերակի համարի երկարությունը 255 սիմվոլ է,
հավանաբար դա չափազանց է։ Բացի դրանից որոշ համակարգեր կարող են ունենալ իրենց
սեփական սահմանափակումները տարբերակի համարի երկարության վրա։\n«v1.2.3» ֆորմատը համարվու՞մ է տարբերակի սեմանտիկ համար։\nՈչ, «v1.2.3»֊ը տարբերակի սեմանտիկ համար չի համարվում։ Ամեն դեպքում «v» տառը
սեմանտիկ տարբերակի առջևում դնելը ընդունված երևույթ է (անգլերենում) տարբերակի
համարը ընդգծելու համար։ «v» հապավման օգտագործումը «version» բառի փոխարեն
տարածված պրակտիկա է տարբերակների կարգավորման (version control) մեջ: Օրինակ՝
git tag v1.2.3 -m "Release version 1.2.3"․ այստեղ «v1.2.3»֊ը թեգի անուն է, և
սեմանտիկ տարբերակը «1.2.3» է։\nԻնչպիսի՞ ռեգուլյար արտահայտության (RegEx) միջոցով կարելի է ստուգել SemVer տարբերակի համարի ճշտությունը:\nանվանական խմբերի միջոցով (named groups)։ (PCRE [Perl համատեղելի ռեգուլյար
արտահայտություններ, օրինակ՝ Perl, PHP և R], Python և Go)։\nՏես՝ https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nթվային խմբերի (numbered capture groups) միջոցով (cg1 = major, cg2 = minor,
cg3 = patch, cg4 = prerelease and cg5 = buildmetadata)։ Այս եղանակը համատեղելի է
ECMA Script֊ի (JavaScript), PCRE֊ի (Perl համատեղելի ռեգուլյար
արտահայտություններ, օրինակ՝ Perl, PHP և R), Python և Go.\nՏես՝ https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nՍեմանտիկ Տարբերակման սպեցիֆիկացիայի հեղինակն է
Թոմ Պրեստոն-Վարները (Gravatar֊ի հիմնադիր և
GitHub֊ի համահիմնադիր)։\nԵթե դուք ցանկանում եք որևէ մեկնաբանություն թողնել, խնդրում ենք
GitHub֊ում հարց (issue) բացել։\nGitHub֊ում հարց (issue) բացել\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nՍեմանտիկ Տարբերակում 2.0.0-rc.2

Ծրագրային ապահովման մենեջմենթի աշխարհում գոյություն ունի «կախվածությունների
դժոխք» (dependency hell) հասկացություն։ Ձեր համակարգի մեծացման և դրան ինտեգրված
փեքիջների քանակի ավելացման հետ մեծանում է հավանականությունը, որ դուք վաղ թե ուշ
կկանգնեք այս խնդրի առաջ։

Այն համակարգերում, որոնք ունեն շատ կախվածություններ, նոր տարբերակի թողարկումը
կարող է արագ վերածվել մղձավանջի։ Եթե կախվածությունների սպեցիֆիկացիան շատ խիստ է,
դուք կարող եք կանգնել նոր տարբերակի թողարկման արգելքի (version lock) առաջ
(անհնար է դառնում թարմացնել ծրագիրը՝ առանց թարմացնելու կախման մեջ գտնվող բոլոր
փեքիջները)։ Մյուս կողմից էլ, եթե կախվածությունների սպեցիֆիկացիան շատ ազատ է,
դուք անխուսափելիորեն կբախվեք տարբերակի անհամապատասխանության (version
promiscuity) խնդրին․ անհիմն է ենթադրությունը, որ ձեր ծրագիրը կմնա համատեղելի
ապագա տարբերակների հետ։ «Կախվածությունների դժոխքը» մի իրավիճակ է, երբ տարբերակի
թողարկման և/կամ տարբերակի անհապատասխանության արգելքը թույլ չի տալիս ձեզ հեշտ և
անվտանգ զարգացնել ձեր նախագիծը։

Որպես այս խնդրի լուծում՝ ես առաջարկում եմ պարզ կանոններ և պահանջներ, որոնք
սահմանում են, թե ինչպես են սահմանվում և մեծացվում տարբերակների համարները։
Նախևառաջ, որպեսզի այս կանոններն աշխատեն, դուք պետք է սահմանեք փաբլիք API: Այն
կարող է նկարագրված լինել ինչպես դոկումենտացիայի, այնպես էլ կոդի մեջ։ Կարևոր է,
որ API֊ը լինի ճիշտ և հասկանալի։ Ձեր API֊ը հայտարարելուց հետո դուք
փոփոխությունների մասին կտեղեկացնեք տարբերակի համարը մեծացնելու միջոցով։
Դիտարկենք այս ֆորմատով ներկայացված տարբերակ՝ X.Y.Z (ՄԱԺՈՐ․ՄԻՆՈՐ․ՓԱԹՉ)։ Սխալների
ուղղումները (bug fix), որոենք չեն ազդել API-ի վրա, մեծացնում են ՓԱԹՉ֊ը։ Հետ
համատեղելի հավելումները և փոփոխությունները մեծացնում են ՄԻՆՈՐ֊ը, հետ
համատեղելիությունը խախտող փոփոխությունները մեծացնում են ՄԱԺՈՐ֊ը։

Ես անվանել եմ այս համակարգը «Սեմանտիկ տարբերակում» (Semantic Versioning): Այս
սխեմայի միջոցով տարբերակի համարը և դրա փոխվելը իմաստավորում են կոդի
պարունակությունը և նրանում եղած փոփոխությունները տարբերակից տարբերակ։

Սեմանտիկ տարբերակման սպեցիֆիկացիա (SemVer)

Նշված բառերը՝ «ՊԵՏՔ Է» (MUST, SHALL), «ՉՊԵՏՔ Է» (MUST NOT, SHALL NOT),
«ՊԱՐՏԱԴԻՐ Է» (REQUIRED), «ԱՆՀՐԱԺԵՇՏ Է» (SHOULD), «ԱՆՀՐԱԺԵՇՏ ՉԷ» (SHOULD NOT),
«ԽՈՐՀՈՒՐԴ Է ՏՐՎՈՒՄ» (RECOMMENDED), «ԿԱՐՈՂ Է» (MAY) և «ՊԱՐՏԱԴԻՐ ՉԷ» (OPTIONAL)
պետք է ինտերպրիտացվեն RFC 2119 ստանդարտին
համապատասխան։


  
    Ծրագրային ապահովումը, որն օգտագործվում է Սեմանտիկ տարբերակում, ՊԵՏՔ Է (MUST)
հայտարարի հասանելի փաբլիք API: Այդ API֊ը կարող է հայտարարվել ինչպես կոդի մեջ,
այնպես էլ՝ առանձին դոկումենտացիայում։ Երկու դեպքում էլ այն պետք է լինի ճշգրիտ
(precise) և սպառիչ (comprehensive)։
  
  
    Տարբերակի ՆՈՐՄԱԼ համարը (normal version) ՊԵՏՔ Է (MUST) ունենա այս ֆորմատը՝
X֊ը տարբերակի ՄԱԺՈՐ համարն է, Y֊ը՝ ՄԻՆՈՐ և Z֊ը՝ ՓԱԹՉ։ Բոլոր բաղադիրչները պետք
է մեծացվեն թվայնորեն․ օրինակ՝ 1.9.0 -> 1.10.0 -> 1.11.0։
  
  
    Փեքիջի թողարկումից հետո այդ տարբերակի պարունակությունը ՉՊԵՏՔ է (MUST NOT)
փոփոխության ենթարկվի։ Ցանկացած փոփոխություն ՊԵՏՔ Է (MUST) թողարկվի որպես նոր
տարբերակ։
  
  
    Զրոյական ՄԱԺՈՐ տարբերակը (0.y.z) նախատեսված է ծրագրային ապահովման
ստեղծման/մշակման նախնական փուլի (initial development) համար։ Ամեն ինչ կարող է
փոխվել՝ կամայական պահի։ Փաբլիք API֊ը չպետք է դիտարկվի որպես ստաբիլ։
  
  
    1.0.0 տարբերակի թողարկումից հետո API-ը համարվում է ստաբիլ, և տարբերակի համարը
փոխվում է կախված նրանից, թե ինչպես է փոխվում փաբլիք API֊ը։
  
  
    Տարբերակի ՓԱԹՉ համարը՝ Z (x.y.Z | x > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե տեղի են
ունեցել միայն հետ համատեղելի սխալների ուղղումներ (bug fix)։ Սխալի ուղղում՝
նշանակում է ներքին փոփոխություն, որը ուղղում է սխալ պահվածքը։
  
  
    Տարբերակի ՄԻՆՈՐ համարը՝ Y (x.Y.z | x > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե փաբլիք
API֊ում ավելացել է նոր հետ համատեղելի ֆունկցիոնալ։ Տարբերակի համարը ՊԵՏՔ Է
(MUST) մեծացվի, եթե հասանելի փաբլիք API֊ի որևէ ֆունկցիոնալ պիտակավորվել է
որպես հնացած (deprecated)։ Տարբերակի համարը ԿԱՐՈՂ Է (MAY) մեծացվել, եթե տեղի
է ունեցել նոր ֆունկցիոնալի ինտեգրացիա, կամ զգալի բարելավումներ են տեղի
ունեցել փրայվիթ կոդում։ Այն ԿԱՐՈՂ Է (MAY) նաև պարունակել ՓԱԹՉ մակարդակի
փոփոխություններ։ Տարբերակի ՓԱԹՉ համարը ՊԵՏՔ Է (MUST) զրոյացվի, երբ մեծացվում
է ՄԻՆՈՐ համարը։
  
  
    Տարբերակի ՄԱԺՈՐ համարը՝ X (X.y.z | X > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե փաբլիք
API֊ում ներկայացվել են հետ համատեղելիությունը խախտող կամայական
փոփոխություններ։ Այն ԿԱՐՈՂ Է (MAY) պարունակել նաև ՓԱԹՉ և ՄԻՆՈՐ մակարդակի
փոփոխություններ։ Տարբերակի ՓԱԹՉ և ՄԻՆՈՐ համարները ՊԵՏՔ Է (MUST) զրոյացվեն,
երբ մեծացվում է ՄԱԺՈՐ համարը։
  
  
    Մինչթողարկումային (pre-release) տարբերակը ԿԱՐՈՂ Է (MAY) պիտակավորվել
տարբերակի ՓԱԹՉ համարից անմիջապես հետո գծիկ և դրան հետևող կետիկով առանձնացված
տարբեր իդենտիֆիկատորներ ավելացնելու միջոցով։ Իդենտիֆիկատորները ՊԵՏՔ Է (MUST)
պարունակեն միայն ASCII տառա֊թվային սիմվոլներ և գծիկ՝ [0-9A-Za-z-]։
Մինչթողարկումային տարբերակները ունեն ավելի ցածր ԿԱՐԳԱՎԻՃԱԿ, քան համապատասխան
ՆՈՐՄԱԼ֊ները։ օրինակ՝ 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92։
  
  
    Բիլդ֊մետատվյալները (build-metadata) ԿԱՐՈՂ ԵՆ (MAY) պիտակավորվել տարբերակի
ՓԱԹՉ համարից կամ մինչթողարկումային տարբերակի իդենտիֆիկատորից անմիջապես հետո
գումարման նշան և դրան հետևող կետիկով առանձնացված տարբեր իդենտիֆիկատորներ
ավելացնելու միջոցով։ Իդենտիֆիկատորները ՊԵՏՔ Է (MUST) պարունակեն միայն ASCII
տառա֊թվային սիմվոլներ և գծիկ՝ [0-9A-Za-z-]։ Իդենտիֆիկատորները ՉՊԵՏՔ Է (MUST
NOT) լինեն դատարկ։ Բիլդ֊մետատվյալները ՊԵՏՔ Է (MUST) անտեսել տարբերակի
ԿԱՐԳԱՎԻՃԱԿԸ որոշելիս այսինքն, եթե նույն ծրագրի երկու տարբերակները տարբերվում
են միայն բիլդ֊մետատվյալներով, ուրեմն դրանք ունեն նույն ԿԱՐԳԱՎԻՃԱԿԸ․ օրինակ՝
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85։
  
  
    ԿԱՐԳԱՎԻՃԱԿԸ (precedence) որոշում է, թե ինչպես է պետք համեմատել տարբերակները
միմյանց հետ, երբ դրանք դասավորված են։ ԿԱՐԳԱՎԻՃԱԿԸ ՊԵՏՔ Է (MUST) հաշվել
տարբերակի համարը՝ ՄԱԺՈՐ, ՄԻՆՈՐ, ՓԱԹՉ, և մինչթողարկումային իդենտիֆիկատորները
բաժանելու միջոցով։ ԿԱՐԳԱՎԻՃԱԿԸ որոշելիս բիլդ֊մետատվյալները հաշվի չեն առնվում։
ԿԱՐԳԱՎԻՃԱԿԸ որոշվում է ՄԱԺՈՐ, ՄԻՆՈՐ, ՓԱԹՉ տարբերակի համարները ձախից աջ
թվայնորեն համեմատելու միջոցով․ օրինակ՝ 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1։ Երբ
ՄԱԺՈՐ, ՄԻՆՈՐ և ՓԱԹՉ տարբերակի համարները հավասար են, մինչթողարկումային
տարբերակը ունենում է ավելի փոքր ԿԱՐԳԱՎԻՃԱԿ, քան ՆՈՐՄԱԼ տարբերակը․ օրինակ՝
1.0.0-alpha < 1.0.0։ Երբ տարբերակների ՄԱԺՈՐ, ՄԻՆՈՐ և ՓԱԹՉ համարները հավասար
են, ԿԱՐԳԱՎԻՃԱԿԸ ՊԵՏՔ Է (MUST) որոշել մինչթողարկումային տարբերակի միջոցով՝
ձախից աջ կետով առանձնացված իդենտիֆիկատորները համեմատելով մինչև առաջին
տարբերող իդենտիֆիկատոր գտնելը։ Մինչթողարկումային տարբերակները համեմատվում են
տվյալ եղանակով՝ իդենտիֆիկատորները, որոնք կազմված են միայն թվերից, համեմատվում
են թվայնորեն։ Տառեր և գծիկ պարունակող իդենտիֆիկատորները համեմատվում են
տառացի՝ ASCII աղյուսակի հերթականությամբ։ Թվային իդենտիֆիկատորները միշտ
ունենում են ավելի ցածր կարգավիճակ, քան ոչ թվայինները։ Մինչթողարկումային
սիմվոլների մեծ քանակ ունեցող տարբերակը ունենում է ավելի բարձր կարգավիճակ, երբ
համեմատվող իդենտիֆիկատորները նույնն են․ օրինակ՝ 1.0.0-alpha < 1.0.0-alpha.1 <
1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 <
1.0.0։
  


Ի՞նչու օգտագործել սեմանտիկ տարբերակում

Սա նոր կամ հեղափոխական միտք չէ։ Հավանական է՝ դուք օգտվում եք տարբերակման նման
ինչ֊որ եղանակից։ Խնդիրն այն է, որ «նման» եղանակից օգվելը կարող է բավարար չլինել։
Առանց կոշտ սպեցիֆիկացիայի տարբերակի համարները անօգուտ են դառնում
կախվածությունները կարգավորելու հարցում։ Տալով անուն և որոշակիացնելով վերը
ձևակերպված մտքերը՝ ավելի հեշտ է դառնում հաղորդել ձեր մտքերը այն օգտատերերին,
որոնք օգտվում են ձեր ծրագրային ապահովումից։ Եթե այդ մտքերը հասկանալի են և ճկուն,
կախվածությունների սպեցիֆիկացիան կաշխատի։

Պարզ օրինակի միջոցով կարելի է ցույց տալ, թե ինչպես է Սեմանտիկ Տարբերակումը
«կախվածություննեի դժողքը» թողնում անցյալում։ Պատկերացնենք մի գրադարան (library),
որի անունն է՝ «Firetruck»։ Նրա աշխատանքի համար անհրաժեշ է Սեմանտիկ Տարբերակումով
թողարկվող «Ladder» փեքիջը։ Երբ Firetruck֊ը ստեղծվել էր, Ladder֊ի տարբերակի
համարն էր՝ 3.1.0։ Քանի որ Firetruck֊ը օգտագործում է Ladder֊ի 3.1.0 տարբերակի
ֆունկցիոնալը, դուք հանգիստ կարող եք հայտարարել կախվածությունը Ladder֊ի 3.1.0
տարբերակից, բայց ոչ ավել քան 4.0.0։ Երբ դուրս գա Ladder֊ի 3.2.0 տարբերակը, դուք
հաստատ կիմանաք, որ այն համատեղելի է ձեր ծրագրի հետ և կարող եք հանգիստ ինտեգրել
այն։

Որպես պատասխանատու ծրագրավորող՝ դուք իհարկե կցանկանաք վստահ լինել, որ բոլոր
թարմացումները աշխատում են այնպես ինչպես հայտարարվել է։ Իրական աշխարհում միշտ
խառնաշփոթ է, և ոչինչ չի կարելի անել դրա հետ, բացի ուշադիր լինելուց։ Սեմանտիկ
տարբերակման միջոցով դուք կարող եք թողարկել ձեր ծրագրային ապահովման նոր
տարբերակներ և թարմացումներ չմտածելով կախվածությունների մասին և պահպանել ձեր
ժամանակը և նյարդերը։

Եթե այս ամենը գայթակղիչ է թվում ձեզ, այն ամենը ինչ ձեզ անհրաժեշտ է՝ սկսել
օգտագործել Սեմանտիկ տարբերակումը, հայտարարել դրա մասին և հետևել կանոններին։ Նշեք
այս կայքի հղումը ձեր README֊ում և օգտագործողները կիմանան այս կանոնների մասին։

ՀՏՀ

Ի՞նչ է անհրաժեշտ անել 0.y.z տարբերակում արված փոփոխությունների հետ, ծրագրավորման նախնական փուլում։

Ամենահեշտ լուծումը աշխատանքը 0.1.0 տարբերակի թողարկումով սկսելն է և հետագայում
ամեն հաջորդ թողարկման համար ՄԻՆՈՐ տարբերակի համարը մեծացնելը։

Ի՞նչպես իմանալ, որ 1.0.0 տարբերակը թողարկելու ժամանկն է։

Եթե ձեր ծրագրային ապահովումը արդեն օգտագործվում է պրոդաքշնում, ամենայն
հավանականությամբ արդեն պետք է թողարկել 1.0.0 տարբերակը։ Եթե դուք ունեք ստաբիլ
API, որը ունի օգտագործողներ, տարբերակի համարը պետք է լինի 1.0.0։ Եթե
անհանգստանում եք հետ համատեղելիության մասին, ամենայն հավանականությամբ ձեր
ծրագրային ապահովման տարբերակի համարը արդեն պետք է լինի 1.0.0։

Արդյո՞ք աշխատելու այս ձևը չի խանգարում արագ ծրագրավորմանը (rapid development) և արագ իտերացիաներին (fast iteration)։

Երբ ՄԱԺՈՐ տարբերակի համարը 0 է, դա արդեն իսկ ենթադրում է արագ ծրագրավորում։ Եթե
դուք փոփոխեք API֊ը ամեն օր, ապա պետք է լինեք 0.y.z տարբերակի վրա, կամ առանձին
ճյուղի (branch) վրա աշխատեք հաջորդ ՄԱԺՈՐ տարբերակի թողարկման համար։

Եթե նույնիսկ փոքր փոփոխությունները, որոնք խախտում են հետ համատեղելիությունը, պահանջում են նոր ՄԱԺՈՐ տարբերակի թողարկում, արդյո՞ք դա չի հանգեցնի նրան, որ շուտով տարբերակի համարը դառնա 42.0.0։

Սա ավելի շատ պատասխանատվության և հեռատեսության խնդիր է։ Ծրագրային ապահովման հետ
համատեղելիությունը խախտող փոփոխությունները աննշան չեն, քանի որ դրա արդյունքում
թարմացումները կարող են շատ թանկ արժենալ։ Հետ համատեղելիությունը խախտող
փոփոխությունների թողարկումը տարբերակի ՄԱԺՈՐ համարի ավելացմամբ, նշանակում է՝ դուք
պետք է մտածեք ձեր փոփոխությունների հետևանքների մասին և հաշվի առնեք գին֊օգուտ
հարաբերակցությունը։

Դոկումենտացիայի կազմումը մեծ աշխատանք է պահանջում։

Որպես պրոֆեսիոնալ ծրագրավորող ձեր պատասխանատվությունն է ճիշտ դոկումենտացնել
ծրագրային ապահովումը, որը նախատեսված է ուրիշների օգտագործման համար։ Ծրագրային
ապահովման բարդության կարգավորումը նրա արդյունավետության պահպանման կարևոևագույն
կետերից մեկն է։ Եթե ոչ մեկը չգիտի, թե ինչպես օգտագործել ձեր ծրագրային
ապահովումը, կամ որ մեթոդի կանչն է անվտանգ, ինչպես պետք է նրանք օգտագործեն այն։
Երկարաժամկետ հեռանկարով Սեմանտիկ Տարբերակումը, համառ և կոշտ դիրքը որակով
շարադրված փաբլիք API֊ի նկատմամբ կնպաստեն ամենքի և ամեն ինչի ճիշտ և համակարգված
աշխատելուն։

Ի՞նչ է անհրաժեշտ անել, եթե պատահաբար թողարկվել են հետ համատեղելիությունը խախտող փոփոխություններ ՄԻՆՈՐ տարբերակի տակ։

Հենց որ դուք հասկացաք, որ խախտել եք Սեմանտիկ Տարբերակման սպեցիֆիկացիան, ուղղեք
սխալը և թողարկեք նոր ՄԻՆՈՐ տարբերակ, որը լուծում է խնդիրը և վերականգնում հետ
համատեղելիությունը։ Նույնիսկ նման դեպքերում անընդունելի է արդեն թողարկված
տարբերակներում փոփոխությունների իրականացումը։ Եթե անհրաժեշտ է, նշեք
դոկումենտացիայում և տեղյակ պահեք օգտագործողներին հետ համատեղելիության և
տարբերակման հերթականության խախտման մասին։

Ի՞նչ է անհրաժեշտ անել, եթե փոփոխվել են կախվածությունները առանց փաբլիք API֊ը փոփոխելու։

Դա կարող է դիտարկվել որպես հետ համատեղելի փոփոխություն, քանի որ այն չի ազդում
փաբլիք API֊ի վրա։ Ծրագրային ապահովումը, որը ակնհայտորեն ունի նույն
կախվածությունները, ինչ փեքիջը, պետք է ունենա իր սեփական կախվածությունների
սպեցիֆիկացիան, և հեղինակը տեղյակ կլինի ի հայտ եկած կոնֆլիկտների մասին։ Արդյոք
տվյալ փոփոխությունները ՄԱԺՈՐ, թե ՓԱԹՉ մակարդակի են, կախված է նրանից, թե դուք
փոխել եք ձեր կախվածությունները սխալներ ուղղելու, թե՞ նոր ֆունկցիոնալ ինտեգրելու
համար։ Երկրորդ դեպքում, որպես կանոն ավելանում է որոշակի քանակով կոդ և որպես
հետևանք մեծանում է տարբերակի ՄԻՆՈՐ համարը։

Ի՞նչ անել, եթե պատահաբար փոփոխվել է փաբլիք API֊ը, և այն չի համապատասխանում տարբերակի համարին (այսինքն՝ կոդը սխալմամբ պարունակում է հետ համատեղելիությունը խախտող փոփոխություններ ՓԱԹՉ տարբերակի թողարկման մեջ)։

Որոշումը ձերն է։ Եթե դուք ունեք օգտագործողների մեծ խումբ, որը կկանգնի փաբլիք
API֊ի նախկին ֆունկցիոնալի վերականգման փաստի առաջ, ուրեմն ճիշտ կլինի թողարկել նոր
տարբերակ ՄԱԺՈՐ համարի մեծացումով։ Չնայած նրան, որ այն պարունակում է միայն ՓԱԹՉ
մակարդակի փոփոխություններ, հիշեք՝ ըստ Սեմանտիկ Տարբերակման սպեցիֆիկացիայի
տարբերակի համարները մեծացվում են սպեցիֆիկացիային համաձայն։ Եթե այդ
փոփոխությունները կարևոր են ձեր օգտագործողների համար, օգտագործեք տարբերակի համարը
նրանց տեղյակ պահելու համար։

Ի՞նչ անել հնացած (deprecated) ֆունկցիոնալի հետ։

Որոշ ֆունկցիոնալի հնանալը սովորական երևույթ է և ծրագրային ապահովման
ստեղծման/մշակման ընթացքում հաճախ պարտադիր է առաջընթացի համար։ Երբ դուք հնացած եք
հայտարարում, փաբլիք API֊ի ինչ֊որ հատված, դուք պետք է երկու բան անեք․ նախ
թարմացնեք ձեր դոկումենտացիան և տեղեկացնեք օգտագործողներին փոփոխության մասին (1),
և ապա թողարկեք նոր ՄԻՆՈՐ տարբերակ՝ նշում կատարելով հնացած ֆունկցիոնալի մասին
(2)։ Մինչ դուք ամբողջովին կջնջեք հնացած ֆունկցիոնալը, հաջորդ ՄԱԺՈՐ թողարկման
ժամանակ պետք է լինի առնվազն մեկ ՄԻՆՈՐ թողարկում, որը պարունակում է տեղեկություն
ֆունկցիոնալի հնացած հայտարարվելու մասին, որպեսզի օգտագործողները հեշտությամբ
անցնեն նոր API֊ի։

Հեղինակ

Սեմանտիկ Տարբերակման սպեցիֆիկացիայի հեղինակն է
Թոմ Պրեստոն-Վարները (Gravatars֊ի հիմնադիր և
GitHub֊ի համահիմնադիր)։

Եթե դուք ցանկանում եք որևէ մեկնաբանություն թողնել, խնդրում ենք
GitHub֊ում հարց (issue) բացել։

Լիցենզիա

Creative Commons ― CC BY 3.0
http://creativecommons.org/licenses/by/3.0/\nՍեմանտիկ Տարբերակում 2.0.0-rc.2\nԾրագրային ապահովման մենեջմենթի աշխարհում գոյություն ունի «կախվածությունների
դժոխք» (dependency hell) հասկացություն։ Ձեր համակարգի մեծացման և դրան ինտեգրված
փեքիջների քանակի ավելացման հետ մեծանում է հավանականությունը, որ դուք վաղ թե ուշ
կկանգնեք այս խնդրի առաջ։\nԱյն համակարգերում, որոնք ունեն շատ կախվածություններ, նոր տարբերակի թողարկումը
կարող է արագ վերածվել մղձավանջի։ Եթե կախվածությունների սպեցիֆիկացիան շատ խիստ է,
դուք կարող եք կանգնել նոր տարբերակի թողարկման արգելքի (version lock) առաջ
(անհնար է դառնում թարմացնել ծրագիրը՝ առանց թարմացնելու կախման մեջ գտնվող բոլոր
փեքիջները)։ Մյուս կողմից էլ, եթե կախվածությունների սպեցիֆիկացիան շատ ազատ է,
դուք անխուսափելիորեն կբախվեք տարբերակի անհամապատասխանության (version
promiscuity) խնդրին․ անհիմն է ենթադրությունը, որ ձեր ծրագիրը կմնա համատեղելի
ապագա տարբերակների հետ։ «Կախվածությունների դժոխքը» մի իրավիճակ է, երբ տարբերակի
թողարկման և/կամ տարբերակի անհապատասխանության արգելքը թույլ չի տալիս ձեզ հեշտ և
անվտանգ զարգացնել ձեր նախագիծը։\nՈրպես այս խնդրի լուծում՝ ես առաջարկում եմ պարզ կանոններ և պահանջներ, որոնք
սահմանում են, թե ինչպես են սահմանվում և մեծացվում տարբերակների համարները։
Նախևառաջ, որպեսզի այս կանոններն աշխատեն, դուք պետք է սահմանեք փաբլիք API: Այն
կարող է նկարագրված լինել ինչպես դոկումենտացիայի, այնպես էլ կոդի մեջ։ Կարևոր է,
որ API֊ը լինի ճիշտ և հասկանալի։ Ձեր API֊ը հայտարարելուց հետո դուք
փոփոխությունների մասին կտեղեկացնեք տարբերակի համարը մեծացնելու միջոցով։
Դիտարկենք այս ֆորմատով ներկայացված տարբերակ՝ X.Y.Z (ՄԱԺՈՐ․ՄԻՆՈՐ․ՓԱԹՉ)։ Սխալների
ուղղումները (bug fix), որոենք չեն ազդել API-ի վրա, մեծացնում են ՓԱԹՉ֊ը։ Հետ
համատեղելի հավելումները և փոփոխությունները մեծացնում են ՄԻՆՈՐ֊ը, հետ
համատեղելիությունը խախտող փոփոխությունները մեծացնում են ՄԱԺՈՐ֊ը։\nԵս անվանել եմ այս համակարգը «Սեմանտիկ տարբերակում» (Semantic Versioning): Այս
սխեմայի միջոցով տարբերակի համարը և դրա փոխվելը իմաստավորում են կոդի
պարունակությունը և նրանում եղած փոփոխությունները տարբերակից տարբերակ։\nՍեմանտիկ տարբերակման սպեցիֆիկացիա (SemVer)\nՆշված բառերը՝ «ՊԵՏՔ Է» (MUST, SHALL), «ՉՊԵՏՔ Է» (MUST NOT, SHALL NOT),
«ՊԱՐՏԱԴԻՐ Է» (REQUIRED), «ԱՆՀՐԱԺԵՇՏ Է» (SHOULD), «ԱՆՀՐԱԺԵՇՏ ՉԷ» (SHOULD NOT),
«ԽՈՐՀՈՒՐԴ Է ՏՐՎՈՒՄ» (RECOMMENDED), «ԿԱՐՈՂ Է» (MAY) և «ՊԱՐՏԱԴԻՐ ՉԷ» (OPTIONAL)
պետք է ինտերպրիտացվեն RFC 2119 ստանդարտին
համապատասխան։\nԾրագրային ապահովումը, որն օգտագործվում է Սեմանտիկ տարբերակում, ՊԵՏՔ Է (MUST)
հայտարարի հասանելի փաբլիք API: Այդ API֊ը կարող է հայտարարվել ինչպես կոդի մեջ,
այնպես էլ՝ առանձին դոկումենտացիայում։ Երկու դեպքում էլ այն պետք է լինի ճշգրիտ
(precise) և սպառիչ (comprehensive)։\nԾրագրային ապահովումը, որն օգտագործվում է Սեմանտիկ տարբերակում, ՊԵՏՔ Է (MUST)
հայտարարի հասանելի փաբլիք API: Այդ API֊ը կարող է հայտարարվել ինչպես կոդի մեջ,
այնպես էլ՝ առանձին դոկումենտացիայում։ Երկու դեպքում էլ այն պետք է լինի ճշգրիտ
(precise) և սպառիչ (comprehensive)։\nՏարբերակի ՆՈՐՄԱԼ համարը (normal version) ՊԵՏՔ Է (MUST) ունենա այս ֆորմատը՝
X֊ը տարբերակի ՄԱԺՈՐ համարն է, Y֊ը՝ ՄԻՆՈՐ և Z֊ը՝ ՓԱԹՉ։ Բոլոր բաղադիրչները պետք
է մեծացվեն թվայնորեն․ օրինակ՝ 1.9.0 -> 1.10.0 -> 1.11.0։\nՏարբերակի ՆՈՐՄԱԼ համարը (normal version) ՊԵՏՔ Է (MUST) ունենա այս ֆորմատը՝
X֊ը տարբերակի ՄԱԺՈՐ համարն է, Y֊ը՝ ՄԻՆՈՐ և Z֊ը՝ ՓԱԹՉ։ Բոլոր բաղադիրչները պետք
է մեծացվեն թվայնորեն․ օրինակ՝ 1.9.0 -> 1.10.0 -> 1.11.0։\nՓեքիջի թողարկումից հետո այդ տարբերակի պարունակությունը ՉՊԵՏՔ է (MUST NOT)
փոփոխության ենթարկվի։ Ցանկացած փոփոխություն ՊԵՏՔ Է (MUST) թողարկվի որպես նոր
տարբերակ։\nՓեքիջի թողարկումից հետո այդ տարբերակի պարունակությունը ՉՊԵՏՔ է (MUST NOT)
փոփոխության ենթարկվի։ Ցանկացած փոփոխություն ՊԵՏՔ Է (MUST) թողարկվի որպես նոր
տարբերակ։\nԶրոյական ՄԱԺՈՐ տարբերակը (0.y.z) նախատեսված է ծրագրային ապահովման
ստեղծման/մշակման նախնական փուլի (initial development) համար։ Ամեն ինչ կարող է
փոխվել՝ կամայական պահի։ Փաբլիք API֊ը չպետք է դիտարկվի որպես ստաբիլ։\nԶրոյական ՄԱԺՈՐ տարբերակը (0.y.z) նախատեսված է ծրագրային ապահովման
ստեղծման/մշակման նախնական փուլի (initial development) համար։ Ամեն ինչ կարող է
փոխվել՝ կամայական պահի։ Փաբլիք API֊ը չպետք է դիտարկվի որպես ստաբիլ։\n1.0.0 տարբերակի թողարկումից հետո API-ը համարվում է ստաբիլ, և տարբերակի համարը
փոխվում է կախված նրանից, թե ինչպես է փոխվում փաբլիք API֊ը։\n1.0.0 տարբերակի թողարկումից հետո API-ը համարվում է ստաբիլ, և տարբերակի համարը
փոխվում է կախված նրանից, թե ինչպես է փոխվում փաբլիք API֊ը։\nՏարբերակի ՓԱԹՉ համարը՝ Z (x.y.Z | x > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե տեղի են
ունեցել միայն հետ համատեղելի սխալների ուղղումներ (bug fix)։ Սխալի ուղղում՝
նշանակում է ներքին փոփոխություն, որը ուղղում է սխալ պահվածքը։\nՏարբերակի ՓԱԹՉ համարը՝ Z (x.y.Z | x > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե տեղի են
ունեցել միայն հետ համատեղելի սխալների ուղղումներ (bug fix)։ Սխալի ուղղում՝
նշանակում է ներքին փոփոխություն, որը ուղղում է սխալ պահվածքը։\nՏարբերակի ՄԻՆՈՐ համարը՝ Y (x.Y.z | x > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե փաբլիք
API֊ում ավելացել է նոր հետ համատեղելի ֆունկցիոնալ։ Տարբերակի համարը ՊԵՏՔ Է
(MUST) մեծացվի, եթե հասանելի փաբլիք API֊ի որևէ ֆունկցիոնալ պիտակավորվել է
որպես հնացած (deprecated)։ Տարբերակի համարը ԿԱՐՈՂ Է (MAY) մեծացվել, եթե տեղի
է ունեցել նոր ֆունկցիոնալի ինտեգրացիա, կամ զգալի բարելավումներ են տեղի
ունեցել փրայվիթ կոդում։ Այն ԿԱՐՈՂ Է (MAY) նաև պարունակել ՓԱԹՉ մակարդակի
փոփոխություններ։ Տարբերակի ՓԱԹՉ համարը ՊԵՏՔ Է (MUST) զրոյացվի, երբ մեծացվում
է ՄԻՆՈՐ համարը։\nՏարբերակի ՄԻՆՈՐ համարը՝ Y (x.Y.z | x > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե փաբլիք
API֊ում ավելացել է նոր հետ համատեղելի ֆունկցիոնալ։ Տարբերակի համարը ՊԵՏՔ Է
(MUST) մեծացվի, եթե հասանելի փաբլիք API֊ի որևէ ֆունկցիոնալ պիտակավորվել է
որպես հնացած (deprecated)։ Տարբերակի համարը ԿԱՐՈՂ Է (MAY) մեծացվել, եթե տեղի
է ունեցել նոր ֆունկցիոնալի ինտեգրացիա, կամ զգալի բարելավումներ են տեղի
ունեցել փրայվիթ կոդում։ Այն ԿԱՐՈՂ Է (MAY) նաև պարունակել ՓԱԹՉ մակարդակի
փոփոխություններ։ Տարբերակի ՓԱԹՉ համարը ՊԵՏՔ Է (MUST) զրոյացվի, երբ մեծացվում
է ՄԻՆՈՐ համարը։\nՏարբերակի ՄԱԺՈՐ համարը՝ X (X.y.z | X > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե փաբլիք
API֊ում ներկայացվել են հետ համատեղելիությունը խախտող կամայական
փոփոխություններ։ Այն ԿԱՐՈՂ Է (MAY) պարունակել նաև ՓԱԹՉ և ՄԻՆՈՐ մակարդակի
փոփոխություններ։ Տարբերակի ՓԱԹՉ և ՄԻՆՈՐ համարները ՊԵՏՔ Է (MUST) զրոյացվեն,
երբ մեծացվում է ՄԱԺՈՐ համարը։\nՏարբերակի ՄԱԺՈՐ համարը՝ X (X.y.z | X > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե փաբլիք
API֊ում ներկայացվել են հետ համատեղելիությունը խախտող կամայական
փոփոխություններ։ Այն ԿԱՐՈՂ Է (MAY) պարունակել նաև ՓԱԹՉ և ՄԻՆՈՐ մակարդակի
փոփոխություններ։ Տարբերակի ՓԱԹՉ և ՄԻՆՈՐ համարները ՊԵՏՔ Է (MUST) զրոյացվեն,
երբ մեծացվում է ՄԱԺՈՐ համարը։\nՄինչթողարկումային (pre-release) տարբերակը ԿԱՐՈՂ Է (MAY) պիտակավորվել
տարբերակի ՓԱԹՉ համարից անմիջապես հետո գծիկ և դրան հետևող կետիկով առանձնացված
տարբեր իդենտիֆիկատորներ ավելացնելու միջոցով։ Իդենտիֆիկատորները ՊԵՏՔ Է (MUST)
պարունակեն միայն ASCII տառա֊թվային սիմվոլներ և գծիկ՝ [0-9A-Za-z-]։
Մինչթողարկումային տարբերակները ունեն ավելի ցածր ԿԱՐԳԱՎԻՃԱԿ, քան համապատասխան
ՆՈՐՄԱԼ֊ները։ օրինակ՝ 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92։\nՄինչթողարկումային (pre-release) տարբերակը ԿԱՐՈՂ Է (MAY) պիտակավորվել
տարբերակի ՓԱԹՉ համարից անմիջապես հետո գծիկ և դրան հետևող կետիկով առանձնացված
տարբեր իդենտիֆիկատորներ ավելացնելու միջոցով։ Իդենտիֆիկատորները ՊԵՏՔ Է (MUST)
պարունակեն միայն ASCII տառա֊թվային սիմվոլներ և գծիկ՝ [0-9A-Za-z-]։
Մինչթողարկումային տարբերակները ունեն ավելի ցածր ԿԱՐԳԱՎԻՃԱԿ, քան համապատասխան
ՆՈՐՄԱԼ֊ները։ օրինակ՝ 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92։\nԲիլդ֊մետատվյալները (build-metadata) ԿԱՐՈՂ ԵՆ (MAY) պիտակավորվել տարբերակի
ՓԱԹՉ համարից կամ մինչթողարկումային տարբերակի իդենտիֆիկատորից անմիջապես հետո
գումարման նշան և դրան հետևող կետիկով առանձնացված տարբեր իդենտիֆիկատորներ
ավելացնելու միջոցով։ Իդենտիֆիկատորները ՊԵՏՔ Է (MUST) պարունակեն միայն ASCII
տառա֊թվային սիմվոլներ և գծիկ՝ [0-9A-Za-z-]։ Իդենտիֆիկատորները ՉՊԵՏՔ Է (MUST
NOT) լինեն դատարկ։ Բիլդ֊մետատվյալները ՊԵՏՔ Է (MUST) անտեսել տարբերակի
ԿԱՐԳԱՎԻՃԱԿԸ որոշելիս այսինքն, եթե նույն ծրագրի երկու տարբերակները տարբերվում
են միայն բիլդ֊մետատվյալներով, ուրեմն դրանք ունեն նույն ԿԱՐԳԱՎԻՃԱԿԸ․ օրինակ՝
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85։\nԲիլդ֊մետատվյալները (build-metadata) ԿԱՐՈՂ ԵՆ (MAY) պիտակավորվել տարբերակի
ՓԱԹՉ համարից կամ մինչթողարկումային տարբերակի իդենտիֆիկատորից անմիջապես հետո
գումարման նշան և դրան հետևող կետիկով առանձնացված տարբեր իդենտիֆիկատորներ
ավելացնելու միջոցով։ Իդենտիֆիկատորները ՊԵՏՔ Է (MUST) պարունակեն միայն ASCII
տառա֊թվային սիմվոլներ և գծիկ՝ [0-9A-Za-z-]։ Իդենտիֆիկատորները ՉՊԵՏՔ Է (MUST
NOT) լինեն դատարկ։ Բիլդ֊մետատվյալները ՊԵՏՔ Է (MUST) անտեսել տարբերակի
ԿԱՐԳԱՎԻՃԱԿԸ որոշելիս այսինքն, եթե նույն ծրագրի երկու տարբերակները տարբերվում
են միայն բիլդ֊մետատվյալներով, ուրեմն դրանք ունեն նույն ԿԱՐԳԱՎԻՃԱԿԸ․ օրինակ՝
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85։\nԿԱՐԳԱՎԻՃԱԿԸ (precedence) որոշում է, թե ինչպես է պետք համեմատել տարբերակները
միմյանց հետ, երբ դրանք դասավորված են։ ԿԱՐԳԱՎԻՃԱԿԸ ՊԵՏՔ Է (MUST) հաշվել
տարբերակի համարը՝ ՄԱԺՈՐ, ՄԻՆՈՐ, ՓԱԹՉ, և մինչթողարկումային իդենտիֆիկատորները
բաժանելու միջոցով։ ԿԱՐԳԱՎԻՃԱԿԸ որոշելիս բիլդ֊մետատվյալները հաշվի չեն առնվում։
ԿԱՐԳԱՎԻՃԱԿԸ որոշվում է ՄԱԺՈՐ, ՄԻՆՈՐ, ՓԱԹՉ տարբերակի համարները ձախից աջ
թվայնորեն համեմատելու միջոցով․ օրինակ՝ 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1։ Երբ
ՄԱԺՈՐ, ՄԻՆՈՐ և ՓԱԹՉ տարբերակի համարները հավասար են, մինչթողարկումային
տարբերակը ունենում է ավելի փոքր ԿԱՐԳԱՎԻՃԱԿ, քան ՆՈՐՄԱԼ տարբերակը․ օրինակ՝
1.0.0-alpha < 1.0.0։ Երբ տարբերակների ՄԱԺՈՐ, ՄԻՆՈՐ և ՓԱԹՉ համարները հավասար
են, ԿԱՐԳԱՎԻՃԱԿԸ ՊԵՏՔ Է (MUST) որոշել մինչթողարկումային տարբերակի միջոցով՝
ձախից աջ կետով առանձնացված իդենտիֆիկատորները համեմատելով մինչև առաջին
տարբերող իդենտիֆիկատոր գտնելը։ Մինչթողարկումային տարբերակները համեմատվում են
տվյալ եղանակով՝ իդենտիֆիկատորները, որոնք կազմված են միայն թվերից, համեմատվում
են թվայնորեն։ Տառեր և գծիկ պարունակող իդենտիֆիկատորները համեմատվում են
տառացի՝ ASCII աղյուսակի հերթականությամբ։ Թվային իդենտիֆիկատորները միշտ
ունենում են ավելի ցածր կարգավիճակ, քան ոչ թվայինները։ Մինչթողարկումային
սիմվոլների մեծ քանակ ունեցող տարբերակը ունենում է ավելի բարձր կարգավիճակ, երբ
համեմատվող իդենտիֆիկատորները նույնն են․ օրինակ՝ 1.0.0-alpha < 1.0.0-alpha.1 <
1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 <
1.0.0։\nԿԱՐԳԱՎԻՃԱԿԸ (precedence) որոշում է, թե ինչպես է պետք համեմատել տարբերակները
միմյանց հետ, երբ դրանք դասավորված են։ ԿԱՐԳԱՎԻՃԱԿԸ ՊԵՏՔ Է (MUST) հաշվել
տարբերակի համարը՝ ՄԱԺՈՐ, ՄԻՆՈՐ, ՓԱԹՉ, և մինչթողարկումային իդենտիֆիկատորները
բաժանելու միջոցով։ ԿԱՐԳԱՎԻՃԱԿԸ որոշելիս բիլդ֊մետատվյալները հաշվի չեն առնվում։
ԿԱՐԳԱՎԻՃԱԿԸ որոշվում է ՄԱԺՈՐ, ՄԻՆՈՐ, ՓԱԹՉ տարբերակի համարները ձախից աջ
թվայնորեն համեմատելու միջոցով․ օրինակ՝ 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1։ Երբ
ՄԱԺՈՐ, ՄԻՆՈՐ և ՓԱԹՉ տարբերակի համարները հավասար են, մինչթողարկումային
տարբերակը ունենում է ավելի փոքր ԿԱՐԳԱՎԻՃԱԿ, քան ՆՈՐՄԱԼ տարբերակը․ օրինակ՝
1.0.0-alpha < 1.0.0։ Երբ տարբերակների ՄԱԺՈՐ, ՄԻՆՈՐ և ՓԱԹՉ համարները հավասար
են, ԿԱՐԳԱՎԻՃԱԿԸ ՊԵՏՔ Է (MUST) որոշել մինչթողարկումային տարբերակի միջոցով՝
ձախից աջ կետով առանձնացված իդենտիֆիկատորները համեմատելով մինչև առաջին
տարբերող իդենտիֆիկատոր գտնելը։ Մինչթողարկումային տարբերակները համեմատվում են
տվյալ եղանակով՝ իդենտիֆիկատորները, որոնք կազմված են միայն թվերից, համեմատվում
են թվայնորեն։ Տառեր և գծիկ պարունակող իդենտիֆիկատորները համեմատվում են
տառացի՝ ASCII աղյուսակի հերթականությամբ։ Թվային իդենտիֆիկատորները միշտ
ունենում են ավելի ցածր կարգավիճակ, քան ոչ թվայինները։ Մինչթողարկումային
սիմվոլների մեծ քանակ ունեցող տարբերակը ունենում է ավելի բարձր կարգավիճակ, երբ
համեմատվող իդենտիֆիկատորները նույնն են․ օրինակ՝ 1.0.0-alpha < 1.0.0-alpha.1 <
1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 <
1.0.0։\nԻ՞նչու օգտագործել սեմանտիկ տարբերակում\nՍա նոր կամ հեղափոխական միտք չէ։ Հավանական է՝ դուք օգտվում եք տարբերակման նման
ինչ֊որ եղանակից։ Խնդիրն այն է, որ «նման» եղանակից օգվելը կարող է բավարար չլինել։
Առանց կոշտ սպեցիֆիկացիայի տարբերակի համարները անօգուտ են դառնում
կախվածությունները կարգավորելու հարցում։ Տալով անուն և որոշակիացնելով վերը
ձևակերպված մտքերը՝ ավելի հեշտ է դառնում հաղորդել ձեր մտքերը այն օգտատերերին,
որոնք օգտվում են ձեր ծրագրային ապահովումից։ Եթե այդ մտքերը հասկանալի են և ճկուն,
կախվածությունների սպեցիֆիկացիան կաշխատի։\nՊարզ օրինակի միջոցով կարելի է ցույց տալ, թե ինչպես է Սեմանտիկ Տարբերակումը
«կախվածություննեի դժողքը» թողնում անցյալում։ Պատկերացնենք մի գրադարան (library),
որի անունն է՝ «Firetruck»։ Նրա աշխատանքի համար անհրաժեշ է Սեմանտիկ Տարբերակումով
թողարկվող «Ladder» փեքիջը։ Երբ Firetruck֊ը ստեղծվել էր, Ladder֊ի տարբերակի
համարն էր՝ 3.1.0։ Քանի որ Firetruck֊ը օգտագործում է Ladder֊ի 3.1.0 տարբերակի
ֆունկցիոնալը, դուք հանգիստ կարող եք հայտարարել կախվածությունը Ladder֊ի 3.1.0
տարբերակից, բայց ոչ ավել քան 4.0.0։ Երբ դուրս գա Ladder֊ի 3.2.0 տարբերակը, դուք
հաստատ կիմանաք, որ այն համատեղելի է ձեր ծրագրի հետ և կարող եք հանգիստ ինտեգրել
այն։\nՈրպես պատասխանատու ծրագրավորող՝ դուք իհարկե կցանկանաք վստահ լինել, որ բոլոր
թարմացումները աշխատում են այնպես ինչպես հայտարարվել է։ Իրական աշխարհում միշտ
խառնաշփոթ է, և ոչինչ չի կարելի անել դրա հետ, բացի ուշադիր լինելուց։ Սեմանտիկ
տարբերակման միջոցով դուք կարող եք թողարկել ձեր ծրագրային ապահովման նոր
տարբերակներ և թարմացումներ չմտածելով կախվածությունների մասին և պահպանել ձեր
ժամանակը և նյարդերը։\nԵթե այս ամենը գայթակղիչ է թվում ձեզ, այն ամենը ինչ ձեզ անհրաժեշտ է՝ սկսել
օգտագործել Սեմանտիկ տարբերակումը, հայտարարել դրա մասին և հետևել կանոններին։ Նշեք
այս կայքի հղումը ձեր README֊ում և օգտագործողները կիմանան այս կանոնների մասին։\nԻ՞նչ է անհրաժեշտ անել 0.y.z տարբերակում արված փոփոխությունների հետ, ծրագրավորման նախնական փուլում։\nԱմենահեշտ լուծումը աշխատանքը 0.1.0 տարբերակի թողարկումով սկսելն է և հետագայում
ամեն հաջորդ թողարկման համար ՄԻՆՈՐ տարբերակի համարը մեծացնելը։\nԻ՞նչպես իմանալ, որ 1.0.0 տարբերակը թողարկելու ժամանկն է։\nԵթե ձեր ծրագրային ապահովումը արդեն օգտագործվում է պրոդաքշնում, ամենայն
հավանականությամբ արդեն պետք է թողարկել 1.0.0 տարբերակը։ Եթե դուք ունեք ստաբիլ
API, որը ունի օգտագործողներ, տարբերակի համարը պետք է լինի 1.0.0։ Եթե
անհանգստանում եք հետ համատեղելիության մասին, ամենայն հավանականությամբ ձեր
ծրագրային ապահովման տարբերակի համարը արդեն պետք է լինի 1.0.0։\nԱրդյո՞ք աշխատելու այս ձևը չի խանգարում արագ ծրագրավորմանը (rapid development) և արագ իտերացիաներին (fast iteration)։\nԵրբ ՄԱԺՈՐ տարբերակի համարը 0 է, դա արդեն իսկ ենթադրում է արագ ծրագրավորում։ Եթե
դուք փոփոխեք API֊ը ամեն օր, ապա պետք է լինեք 0.y.z տարբերակի վրա, կամ առանձին
ճյուղի (branch) վրա աշխատեք հաջորդ ՄԱԺՈՐ տարբերակի թողարկման համար։\nԵթե նույնիսկ փոքր փոփոխությունները, որոնք խախտում են հետ համատեղելիությունը, պահանջում են նոր ՄԱԺՈՐ տարբերակի թողարկում, արդյո՞ք դա չի հանգեցնի նրան, որ շուտով տարբերակի համարը դառնա 42.0.0։\nՍա ավելի շատ պատասխանատվության և հեռատեսության խնդիր է։ Ծրագրային ապահովման հետ
համատեղելիությունը խախտող փոփոխությունները աննշան չեն, քանի որ դրա արդյունքում
թարմացումները կարող են շատ թանկ արժենալ։ Հետ համատեղելիությունը խախտող
փոփոխությունների թողարկումը տարբերակի ՄԱԺՈՐ համարի ավելացմամբ, նշանակում է՝ դուք
պետք է մտածեք ձեր փոփոխությունների հետևանքների մասին և հաշվի առնեք գին֊օգուտ
հարաբերակցությունը։\nԴոկումենտացիայի կազմումը մեծ աշխատանք է պահանջում։\nՈրպես պրոֆեսիոնալ ծրագրավորող ձեր պատասխանատվությունն է ճիշտ դոկումենտացնել
ծրագրային ապահովումը, որը նախատեսված է ուրիշների օգտագործման համար։ Ծրագրային
ապահովման բարդության կարգավորումը նրա արդյունավետության պահպանման կարևոևագույն
կետերից մեկն է։ Եթե ոչ մեկը չգիտի, թե ինչպես օգտագործել ձեր ծրագրային
ապահովումը, կամ որ մեթոդի կանչն է անվտանգ, ինչպես պետք է նրանք օգտագործեն այն։
Երկարաժամկետ հեռանկարով Սեմանտիկ Տարբերակումը, համառ և կոշտ դիրքը որակով
շարադրված փաբլիք API֊ի նկատմամբ կնպաստեն ամենքի և ամեն ինչի ճիշտ և համակարգված
աշխատելուն։\nԻ՞նչ է անհրաժեշտ անել, եթե պատահաբար թողարկվել են հետ համատեղելիությունը խախտող փոփոխություններ ՄԻՆՈՐ տարբերակի տակ։\nՀենց որ դուք հասկացաք, որ խախտել եք Սեմանտիկ Տարբերակման սպեցիֆիկացիան, ուղղեք
սխալը և թողարկեք նոր ՄԻՆՈՐ տարբերակ, որը լուծում է խնդիրը և վերականգնում հետ
համատեղելիությունը։ Նույնիսկ նման դեպքերում անընդունելի է արդեն թողարկված
տարբերակներում փոփոխությունների իրականացումը։ Եթե անհրաժեշտ է, նշեք
դոկումենտացիայում և տեղյակ պահեք օգտագործողներին հետ համատեղելիության և
տարբերակման հերթականության խախտման մասին։\nԻ՞նչ է անհրաժեշտ անել, եթե փոփոխվել են կախվածությունները առանց փաբլիք API֊ը փոփոխելու։\nԴա կարող է դիտարկվել որպես հետ համատեղելի փոփոխություն, քանի որ այն չի ազդում
փաբլիք API֊ի վրա։ Ծրագրային ապահովումը, որը ակնհայտորեն ունի նույն
կախվածությունները, ինչ փեքիջը, պետք է ունենա իր սեփական կախվածությունների
սպեցիֆիկացիան, և հեղինակը տեղյակ կլինի ի հայտ եկած կոնֆլիկտների մասին։ Արդյոք
տվյալ փոփոխությունները ՄԱԺՈՐ, թե ՓԱԹՉ մակարդակի են, կախված է նրանից, թե դուք
փոխել եք ձեր կախվածությունները սխալներ ուղղելու, թե՞ նոր ֆունկցիոնալ ինտեգրելու
համար։ Երկրորդ դեպքում, որպես կանոն ավելանում է որոշակի քանակով կոդ և որպես
հետևանք մեծանում է տարբերակի ՄԻՆՈՐ համարը։\nԻ՞նչ անել, եթե պատահաբար փոփոխվել է փաբլիք API֊ը, և այն չի համապատասխանում տարբերակի համարին (այսինքն՝ կոդը սխալմամբ պարունակում է հետ համատեղելիությունը խախտող փոփոխություններ ՓԱԹՉ տարբերակի թողարկման մեջ)։\nՈրոշումը ձերն է։ Եթե դուք ունեք օգտագործողների մեծ խումբ, որը կկանգնի փաբլիք
API֊ի նախկին ֆունկցիոնալի վերականգման փաստի առաջ, ուրեմն ճիշտ կլինի թողարկել նոր
տարբերակ ՄԱԺՈՐ համարի մեծացումով։ Չնայած նրան, որ այն պարունակում է միայն ՓԱԹՉ
մակարդակի փոփոխություններ, հիշեք՝ ըստ Սեմանտիկ Տարբերակման սպեցիֆիկացիայի
տարբերակի համարները մեծացվում են սպեցիֆիկացիային համաձայն։ Եթե այդ
փոփոխությունները կարևոր են ձեր օգտագործողների համար, օգտագործեք տարբերակի համարը
նրանց տեղյակ պահելու համար։\nԻ՞նչ անել հնացած (deprecated) ֆունկցիոնալի հետ։\nՈրոշ ֆունկցիոնալի հնանալը սովորական երևույթ է և ծրագրային ապահովման
ստեղծման/մշակման ընթացքում հաճախ պարտադիր է առաջընթացի համար։ Երբ դուք հնացած եք
հայտարարում, փաբլիք API֊ի ինչ֊որ հատված, դուք պետք է երկու բան անեք․ նախ
թարմացնեք ձեր դոկումենտացիան և տեղեկացնեք օգտագործողներին փոփոխության մասին (1),
և ապա թողարկեք նոր ՄԻՆՈՐ տարբերակ՝ նշում կատարելով հնացած ֆունկցիոնալի մասին
(2)։ Մինչ դուք ամբողջովին կջնջեք հնացած ֆունկցիոնալը, հաջորդ ՄԱԺՈՐ թողարկման
ժամանակ պետք է լինի առնվազն մեկ ՄԻՆՈՐ թողարկում, որը պարունակում է տեղեկություն
ֆունկցիոնալի հնացած հայտարարվելու մասին, որպեսզի օգտագործողները հեշտությամբ
անցնեն նոր API֊ի։\nՍեմանտիկ Տարբերակման սպեցիֆիկացիայի հեղինակն է
Թոմ Պրեստոն-Վարները (Gravatars֊ի հիմնադիր և
GitHub֊ի համահիմնադիր)։\nԵթե դուք ցանկանում եք որևէ մեկնաբանություն թողնել, խնդրում ենք
GitHub֊ում հարց (issue) բացել։\nGitHub֊ում հարց (issue) բացել\nCreative Commons ― CC BY 3.0
http://creativecommons.org/licenses/by/3.0/\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nՍեմանտիկ Տարբերակում 2.0.0-rc.1

Ծրագրային ապահովման մենեջմենթի աշխարհում գոյություն ունի «կախվածությունների
դժոխք» (dependency hell) հասկացություն։ Ձեր համակարգի մեծացման և դրան ինտեգրված
փեքիջների քանակի ավելացման հետ մեծանում է հավանականությունը, որ դուք վաղ թե ուշ
կկանգնեք այս խնդրի առաջ։

Այն համակարգերում, որոնք ունեն շատ կախվածություններ, նոր տարբերակի թողարկումը
կարող է արագ վերածվել մղձավանջի։ Եթե կախվածությունների սպեցիֆիկացիան շատ խիստ է,
դուք կարող եք կանգնել նոր տարբերակի թողարկման արգելքի (version lock) առաջ
(անհնար է դառնում թարմացնել ծրագիրը՝ առանց թարմացնելու կախման մեջ գտնվող բոլոր
փեքիջները)։ Մյուս կողմից էլ, եթե կախվածությունների սպեցիֆիկացիան շատ ազատ է,
դուք անխուսափելիորեն կբախվեք տարբերակի անհամապատասխանության (version
promiscuity) խնդրին․ անհիմն է ենթադրությունը, որ ձեր ծրագիրը կմնա համատեղելի
ապագա տարբերակների հետ։ «Կախվածությունների դժոխքը» մի իրավիճակ է, երբ տարբերակի
թողարկման և/կամ տարբերակի անհապատասխանության արգելքը թույլ չի տալիս ձեզ հեշտ և
անվտանգ զարգացնել ձեր նախագիծը։

Որպես այս խնդրի լուծում՝ ես առաջարկում եմ պարզ կանոններ և պահանջներ, որոնք
սահմանում են, թե ինչպես են սահմանվում և մեծացվում տարբերակների համարները։
Նախևառաջ, որպեսզի այս կանոններն աշխատեն, դուք պետք է սահմանեք փաբլիք API: Այն
կարող է նկարագրված լինել ինչպես դոկումենտացիայի, այնպես էլ կոդի մեջ։ Կարևոր է,
որ API֊ը լինի ճիշտ և հասկանալի։ Ձեր API֊ը հայտարարելուց հետո դուք
փոփոխությունների մասին կտեղեկացնեք տարբերակի համարը մեծացնելու միջոցով։
Դիտարկենք այս ֆորմատով ներկայացված տարբերակ՝ X.Y.Z (ՄԱԺՈՐ․ՄԻՆՈՐ․ՓԱԹՉ)։ Սխալների
ուղղումները (bug fix), որոենք չեն ազդել API-ի վրա, մեծացնում են ՓԱԹՉ֊ը։ Հետ
համատեղելի հավելումները և փոփոխությունները մեծացնում են ՄԻՆՈՐ֊ը, հետ
համատեղելիությունը խախտող փոփոխությունները մեծացնում են ՄԱԺՈՐ֊ը։

Ես անվանել եմ այս համակարգը «Սեմանտիկ տարբերակում» (Semantic Versioning): Այս
սխեմայի միջոցով տարբերակի համարը և դրա փոխվելը իմաստավորում են կոդի
պարունակությունը և նրանում եղած փոփոխությունները տարբերակից տարբերակ։

Սեմանտիկ տարբերակման սպեցիֆիկացիա (SemVer)

Նշված բառերը՝ «ՊԵՏՔ Է» (MUST, SHALL), «ՉՊԵՏՔ Է» (MUST NOT, SHALL NOT),
«ՊԱՐՏԱԴԻՐ Է» (REQUIRED), «ԱՆՀՐԱԺԵՇՏ Է» (SHOULD), «ԱՆՀՐԱԺԵՇՏ ՉԷ» (SHOULD NOT),
«ԽՈՐՀՈՒՐԴ Է ՏՐՎՈՒՄ» (RECOMMENDED), «ԿԱՐՈՂ Է» (MAY) և «ՊԱՐՏԱԴԻՐ ՉԷ» (OPTIONAL)
պետք է ինտերպրիտացվեն RFC 2119 ստանդարտին
համապատասխան։


  
    Ծրագրային ապահովումը, որն օգտագործվում է Սեմանտիկ տարբերակում, ՊԵՏՔ Է (MUST)
հայտարարի հասանելի փաբլիք API: Այդ API֊ը կարող է հայտարարվել ինչպես կոդի մեջ,
այնպես էլ՝ առանձին դոկումենտացիայում։ Երկու դեպքում էլ այն պետք է լինի ճշգրիտ
(precise) և սպառիչ (comprehensive)։
  
  
    Տարբերակի ՆՈՐՄԱԼ համարը (normal version) ՊԵՏՔ Է (MUST) ունենա այս ֆորմատը՝
X֊ը տարբերակի ՄԱԺՈՐ համարն է, Y֊ը՝ ՄԻՆՈՐ և Z֊ը՝ ՓԱԹՉ։ Բոլոր բաղադիրչները պետք
է մեծացվեն թվայնորեն․ օրինակ՝ 1.9.0 -> 1.10.0 -> 1.11.0։
  
  
    Փեքիջի թողարկումից հետո այդ տարբերակի պարունակությունը ՉՊԵՏՔ է (MUST NOT)
փոփոխության ենթարկվի։ Ցանկացած փոփոխություն ՊԵՏՔ Է (MUST) թողարկվի որպես նոր
տարբերակ։
  
  
    Զրոյական ՄԱԺՈՐ տարբերակը (0.y.z) նախատեսված է ծրագրային ապահովման
ստեղծման/մշակման նախնական փուլի (initial development) համար։ Ամեն ինչ կարող է
փոխվել՝ կամայական պահի։ Փաբլիք API֊ը չպետք է դիտարկվի որպես ստաբիլ։
  
  
    1.0.0 տարբերակի թողարկումից հետո API-ը համարվում է ստաբիլ, և տարբերակի համարը
փոխվում է կախված նրանից, թե ինչպես է փոխվում փաբլիք API֊ը։
  
  
    Տարբերակի ՓԱԹՉ համարը՝ Z (x.y.Z | x > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե տեղի են
ունեցել միայն հետ համատեղելի սխալների ուղղումներ (bug fix)։ Սխալի ուղղում՝
նշանակում է ներքին փոփոխություն, որը ուղղում է սխալ պահվածքը։
  
  
    Տարբերակի ՄԻՆՈՐ համարը՝ Y (x.Y.z | x > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե փաբլիք
API֊ում ավելացել է նոր հետ համատեղելի ֆունկցիոնալ։ Տարբերակի համարը ՊԵՏՔ Է
(MUST) մեծացվի, եթե հասանելի փաբլիք API֊ի որևէ ֆունկցիոնալ պիտակավորվել է
որպես հնացած (deprecated)։ Տարբերակի համարը ԿԱՐՈՂ Է (MAY) մեծացվել, եթե տեղի
է ունեցել նոր ֆունկցիոնալի ինտեգրացիա, կամ զգալի բարելավումներ են տեղի
ունեցել փրայվիթ կոդում։ Այն ԿԱՐՈՂ Է (MAY) նաև պարունակել ՓԱԹՉ մակարդակի
փոփոխություններ։ Տարբերակի ՓԱԹՉ համարը ՊԵՏՔ Է (MUST) զրոյացվի, երբ մեծացվում
է ՄԻՆՈՐ համարը։
  
  
    Տարբերակի ՄԱԺՈՐ համարը՝ X (X.y.z | X > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե փաբլիք
API֊ում ներկայացվել են հետ համատեղելիությունը խախտող կամայական
փոփոխություններ։ Այն ԿԱՐՈՂ Է (MAY) պարունակել նաև ՓԱԹՉ և ՄԻՆՈՐ մակարդակի
փոփոխություններ։ Տարբերակի ՓԱԹՉ և ՄԻՆՈՐ համարները ՊԵՏՔ Է (MUST) զրոյացվեն,
երբ մեծացվում է ՄԱԺՈՐ համարը։
  
  
    Մինչթողարկումային (pre-release) տարբերակը ԿԱՐՈՂ Է (MAY) պիտակավորվել
տարբերակի ՓԱԹՉ համարից անմիջապես հետո գծիկ և դրան հետևող կետիկով առանձնացված
տարբեր իդենտիֆիկատորներ ավելացնելու միջոցով։ Իդենտիֆիկատորները ՊԵՏՔ Է (MUST)
պարունակեն միայն ASCII տառա֊թվային սիմվոլներ և գծիկ՝ [0-9A-Za-z-]։
Մինչթողարկումային տարբերակները ունեն ավելի ցածր ԿԱՐԳԱՎԻՃԱԿ, քան համապատասխան
ՆՈՐՄԱԼ֊ները։ օրինակ՝ 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92։
  
  
    Բիլդ֊մետատվյալները (build-metadata) ԿԱՐՈՂ ԵՆ (MAY) պիտակավորվել տարբերակի
ՓԱԹՉ համարից կամ մինչթողարկումային տարբերակի իդենտիֆիկատորից անմիջապես հետո
գումարման նշան և դրան հետևող կետիկով առանձնացված տարբեր իդենտիֆիկատորներ
ավելացնելու միջոցով։ Իդենտիֆիկատորները ՊԵՏՔ Է (MUST) պարունակեն միայն ASCII
տառա֊թվային սիմվոլներ և գծիկ՝ [0-9A-Za-z-]։ Իդենտիֆիկատորները ՉՊԵՏՔ Է (MUST
NOT) լինեն դատարկ։ Բիլդ֊մետատվյալները ՊԵՏՔ Է (MUST) անտեսել տարբերակի
ԿԱՐԳԱՎԻՃԱԿԸ որոշելիս այսինքն, եթե նույն ծրագրի երկու տարբերակները տարբերվում
են միայն բիլդ֊մետատվյալներով, ուրեմն դրանք ունեն նույն ԿԱՐԳԱՎԻՃԱԿԸ․ օրինակ՝
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85։
  
  
    ԿԱՐԳԱՎԻՃԱԿԸ (precedence) որոշում է, թե ինչպես է պետք համեմատել տարբերակները
միմյանց հետ, երբ դրանք դասավորված են։ ԿԱՐԳԱՎԻՃԱԿԸ ՊԵՏՔ Է (MUST) հաշվել
տարբերակի համարը՝ ՄԱԺՈՐ, ՄԻՆՈՐ, ՓԱԹՉ, և մինչթողարկումային իդենտիֆիկատորները
բաժանելու միջոցով։ ԿԱՐԳԱՎԻՃԱԿԸ որոշելիս բիլդ֊մետատվյալները հաշվի չեն առնվում։
ԿԱՐԳԱՎԻՃԱԿԸ որոշվում է ՄԱԺՈՐ, ՄԻՆՈՐ, ՓԱԹՉ տարբերակի համարները ձախից աջ
թվայնորեն համեմատելու միջոցով․ օրինակ՝ 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1։ Երբ
ՄԱԺՈՐ, ՄԻՆՈՐ և ՓԱԹՉ տարբերակի համարները հավասար են, մինչթողարկումային
տարբերակը ունենում է ավելի փոքր ԿԱՐԳԱՎԻՃԱԿ, քան ՆՈՐՄԱԼ տարբերակը․ օրինակ՝
1.0.0-alpha < 1.0.0։ Երբ տարբերակների ՄԱԺՈՐ, ՄԻՆՈՐ և ՓԱԹՉ համարները հավասար
են, ԿԱՐԳԱՎԻՃԱԿԸ ՊԵՏՔ Է (MUST) որոշել մինչթողարկումային տարբերակի միջոցով՝
ձախից աջ կետով առանձնացված իդենտիֆիկատորները համեմատելով մինչև առաջին
տարբերող իդենտիֆիկատոր գտնելը։ Մինչթողարկումային տարբերակները համեմատվում են
տվյալ եղանակով՝ իդենտիֆիկատորները, որոնք կազմված են միայն թվերից, համեմատվում
են թվայնորեն։ Տառեր և գծիկ պարունակող իդենտիֆիկատորները համեմատվում են
տառացի՝ ASCII աղյուսակի հերթականությամբ։ Թվային իդենտիֆիկատորները միշտ
ունենում են ավելի ցածր կարգավիճակ, քան ոչ թվայինները։ Մինչթողարկումային
սիմվոլների մեծ քանակ ունեցող տարբերակը ունենում է ավելի բարձր կարգավիճակ, երբ
համեմատվող իդենտիֆիկատորները նույնն են․ օրինակ՝ 1.0.0-alpha < 1.0.0-alpha.1 <
1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 <
1.0.0։
  


Ի՞նչու օգտագործել սեմանտիկ տարբերակում

Սա նոր կամ հեղափոխական միտք չէ։ Հավանական է՝ դուք օգտվում եք տարբերակման նման
ինչ֊որ եղանակից։ Խնդիրն այն է, որ «նման» եղանակից օգվելը կարող է բավարար չլինել։
Առանց կոշտ սպեցիֆիկացիայի տարբերակի համարները անօգուտ են դառնում
կախվածությունները կարգավորելու հարցում։ Տալով անուն և որոշակիացնելով վերը
ձևակերպված մտքերը՝ ավելի հեշտ է դառնում հաղորդել ձեր մտքերը այն օգտատերերին,
որոնք օգտվում են ձեր ծրագրային ապահովումից։ Եթե այդ մտքերը հասկանալի են և ճկուն,
կախվածությունների սպեցիֆիկացիան կաշխատի։

Պարզ օրինակի միջոցով կարելի է ցույց տալ, թե ինչպես է Սեմանտիկ Տարբերակումը
«կախվածություննեի դժողքը» թողնում անցյալում։ Պատկերացնենք մի գրադարան (library),
որի անունն է՝ «Firetruck»։ Նրա աշխատանքի համար անհրաժեշ է Սեմանտիկ Տարբերակումով
թողարկվող «Ladder» փեքիջը։ Երբ Firetruck֊ը ստեղծվել էր, Ladder֊ի տարբերակի
համարն էր՝ 3.1.0։ Քանի որ Firetruck֊ը օգտագործում է Ladder֊ի 3.1.0 տարբերակի
ֆունկցիոնալը, դուք հանգիստ կարող եք հայտարարել կախվածությունը Ladder֊ի 3.1.0
տարբերակից, բայց ոչ ավել քան 4.0.0։ Երբ դուրս գա Ladder֊ի 3.2.0 տարբերակը, դուք
հաստատ կիմանաք, որ այն համատեղելի է ձեր ծրագրի հետ և կարող եք հանգիստ ինտեգրել
այն։

Որպես պատասխանատու ծրագրավորող՝ դուք իհարկե կցանկանաք վստահ լինել, որ բոլոր
թարմացումները աշխատում են այնպես ինչպես հայտարարվել է։ Իրական աշխարհում միշտ
խառնաշփոթ է, և ոչինչ չի կարելի անել դրա հետ, բացի ուշադիր լինելուց։ Սեմանտիկ
տարբերակման միջոցով դուք կարող եք թողարկել ձեր ծրագրային ապահովման նոր
տարբերակներ և թարմացումներ չմտածելով կախվածությունների մասին և պահպանել ձեր
ժամանակը և նյարդերը։

Եթե այս ամենը գայթակղիչ է թվում ձեզ, այն ամենը ինչ ձեզ անհրաժեշտ է՝ սկսել
օգտագործել Սեմանտիկ տարբերակումը, հայտարարել դրա մասին և հետևել կանոններին։ Նշեք
այս կայքի հղումը ձեր README֊ում և օգտագործողները կիմանան այս կանոնների մասին։

ՀՏՀ

Ի՞նչ է անհրաժեշտ անել 0.y.z տարբերակում արված փոփոխությունների հետ, ծրագրավորման նախնական փուլում։

Ամենահեշտ լուծումը աշխատանքը 0.1.0 տարբերակի թողարկումով սկսելն է և հետագայում
ամեն հաջորդ թողարկման համար ՄԻՆՈՐ տարբերակի համարը մեծացնելը։

Ի՞նչպես իմանալ, որ 1.0.0 տարբերակը թողարկելու ժամանկն է։

Եթե ձեր ծրագրային ապահովումը արդեն օգտագործվում է պրոդաքշնում, ամենայն
հավանականությամբ արդեն պետք է թողարկել 1.0.0 տարբերակը։ Եթե դուք ունեք ստաբիլ
API, որը ունի օգտագործողներ, տարբերակի համարը պետք է լինի 1.0.0։ Եթե
անհանգստանում եք հետ համատեղելիության մասին, ամենայն հավանականությամբ ձեր
ծրագրային ապահովման տարբերակի համարը արդեն պետք է լինի 1.0.0։

Արդյո՞ք աշխատելու այս ձևը չի խանգարում արագ ծրագրավորմանը (rapid development) և արագ իտերացիաներին (fast iteration)։

Երբ ՄԱԺՈՐ տարբերակի համարը 0 է, դա արդեն իսկ ենթադրում է արագ ծրագրավորում։ Եթե
դուք փոփոխեք API֊ը ամեն օր, ապա պետք է լինեք 0.y.z տարբերակի վրա, կամ առանձին
ճյուղի (branch) վրա աշխատեք հաջորդ ՄԱԺՈՐ տարբերակի թողարկման համար։

Եթե նույնիսկ փոքր փոփոխությունները, որոնք խախտում են հետ համատեղելիությունը, պահանջում են նոր ՄԱԺՈՐ տարբերակի թողարկում, արդյո՞ք դա չի հանգեցնի նրան, որ շուտով տարբերակի համարը դառնա 42.0.0։

Սա ավելի շատ պատասխանատվության և հեռատեսության խնդիր է։ Ծրագրային ապահովման հետ
համատեղելիությունը խախտող փոփոխությունները աննշան չեն, քանի որ դրա արդյունքում
թարմացումները կարող են շատ թանկ արժենալ։ Հետ համատեղելիությունը խախտող
փոփոխությունների թողարկումը տարբերակի ՄԱԺՈՐ համարի ավելացմամբ, նշանակում է՝ դուք
պետք է մտածեք ձեր փոփոխությունների հետևանքների մասին և հաշվի առնեք գին֊օգուտ
հարաբերակցությունը։

Դոկումենտացիայի կազմումը մեծ աշխատանք է պահանջում։

Որպես պրոֆեսիոնալ ծրագրավորող ձեր պատասխանատվությունն է ճիշտ դոկումենտացնել
ծրագրային ապահովումը, որը նախատեսված է ուրիշների օգտագործման համար։ Ծրագրային
ապահովման բարդության կարգավորումը նրա արդյունավետության պահպանման կարևոևագույն
կետերից մեկն է։ Եթե ոչ մեկը չգիտի, թե ինչպես օգտագործել ձեր ծրագրային
ապահովումը, կամ որ մեթոդի կանչն է անվտանգ, ինչպես պետք է նրանք օգտագործեն այն։
Երկարաժամկետ հեռանկարով Սեմանտիկ Տարբերակումը, համառ և կոշտ դիրքը որակով
շարադրված փաբլիք API֊ի նկատմամբ կնպաստեն ամենքի և ամեն ինչի ճիշտ և համակարգված
աշխատելուն։

Ի՞նչ է անհրաժեշտ անել, եթե պատահաբար թողարկվել են հետ համատեղելիությունը խախտող փոփոխություններ ՄԻՆՈՐ տարբերակի տակ։

Հենց որ դուք հասկացաք, որ խախտել եք Սեմանտիկ Տարբերակման սպեցիֆիկացիան, ուղղեք
սխալը և թողարկեք նոր ՄԻՆՈՐ տարբերակ, որը լուծում է խնդիրը և վերականգնում հետ
համատեղելիությունը։ Նույնիսկ նման դեպքերում անընդունելի է արդեն թողարկված
տարբերակներում փոփոխությունների իրականացումը։ Եթե անհրաժեշտ է, նշեք
դոկումենտացիայում և տեղյակ պահեք օգտագործողներին հետ համատեղելիության և
տարբերակման հերթականության խախտման մասին։

Ի՞նչ է անհրաժեշտ անել, եթե փոփոխվել են կախվածությունները առանց փաբլիք API֊ը փոփոխելու։

Դա կարող է դիտարկվել որպես հետ համատեղելի փոփոխություն, քանի որ այն չի ազդում
փաբլիք API֊ի վրա։ Ծրագրային ապահովումը, որը ակնհայտորեն ունի նույն
կախվածությունները, ինչ փեքիջը, պետք է ունենա իր սեփական կախվածությունների
սպեցիֆիկացիան, և հեղինակը տեղյակ կլինի ի հայտ եկած կոնֆլիկտների մասին։ Արդյոք
տվյալ փոփոխությունները ՄԱԺՈՐ, թե ՓԱԹՉ մակարդակի են, կախված է նրանից, թե դուք
փոխել եք ձեր կախվածությունները սխալներ ուղղելու, թե՞ նոր ֆունկցիոնալ ինտեգրելու
համար։ Երկրորդ դեպքում, որպես կանոն ավելանում է որոշակի քանակով կոդ և որպես
հետևանք մեծանում է տարբերակի ՄԻՆՈՐ համարը։

Ի՞նչ անել, եթե պատահաբար փոփոխվել է փաբլիք API֊ը, և այն չի համապատասխանում տարբերակի համարին (այսինքն՝ կոդը սխալմամբ պարունակում է հետ համատեղելիությունը խախտող փոփոխություններ ՓԱԹՉ տարբերակի թողարկման մեջ)։

Որոշումը ձերն է։ Եթե դուք ունեք օգտագործողների մեծ խումբ, որը կկանգնի փաբլիք
API֊ի նախկին ֆունկցիոնալի վերականգման փաստի առաջ, ուրեմն ճիշտ կլինի թողարկել նոր
տարբերակ ՄԱԺՈՐ համարի մեծացումով։ Չնայած նրան, որ այն պարունակում է միայն ՓԱԹՉ
մակարդակի փոփոխություններ, հիշեք՝ ըստ Սեմանտիկ Տարբերակման սպեցիֆիկացիայի
տարբերակի համարները մեծացվում են սպեցիֆիկացիային համաձայն։ Եթե այդ
փոփոխությունները կարևոր են ձեր օգտագործողների համար, օգտագործեք տարբերակի համարը
նրանց տեղյակ պահելու համար։

Ի՞նչ անել հնացած (deprecated) ֆունկցիոնալի հետ։

Որոշ ֆունկցիոնալի հնանալը սովորական երևույթ է և ծրագրային ապահովման
ստեղծման/մշակման ընթացքում հաճախ պարտադիր է առաջընթացի համար։ Երբ դուք հնացած եք
հայտարարում, փաբլիք API֊ի ինչ֊որ հատված, դուք պետք է երկու բան անեք․ նախ
թարմացնեք ձեր դոկումենտացիան և տեղեկացնեք օգտագործողներին փոփոխության մասին (1),
և ապա թողարկեք նոր ՄԻՆՈՐ տարբերակ՝ նշում կատարելով հնացած ֆունկցիոնալի մասին
(2)։ Մինչ դուք ամբողջովին կջնջեք հնացած ֆունկցիոնալը, հաջորդ ՄԱԺՈՐ թողարկման
ժամանակ պետք է լինի առնվազն մեկ ՄԻՆՈՐ թողարկում, որը պարունակում է տեղեկություն
ֆունկցիոնալի հնացած հայտարարվելու մասին, որպեսզի օգտագործողները հեշտությամբ
անցնեն նոր API֊ի։

Հեղինակ

Սեմանտիկ Տարբերակման սպեցիֆիկացիայի հեղինակն է
Թոմ Պրեստոն-Վարները (Gravatars֊ի հիմնադիր և
GitHub֊ի համահիմնադիր)։

Եթե դուք ցանկանում եք որևէ մեկնաբանություն թողնել, խնդրում ենք
GitHub֊ում հարց (issue) բացել։

Լիցենզիա

Creative Commons ― CC BY 3.0
http://creativecommons.org/licenses/by/3.0/\nՍեմանտիկ Տարբերակում 2.0.0-rc.1\nԾրագրային ապահովման մենեջմենթի աշխարհում գոյություն ունի «կախվածությունների
դժոխք» (dependency hell) հասկացություն։ Ձեր համակարգի մեծացման և դրան ինտեգրված
փեքիջների քանակի ավելացման հետ մեծանում է հավանականությունը, որ դուք վաղ թե ուշ
կկանգնեք այս խնդրի առաջ։\nԱյն համակարգերում, որոնք ունեն շատ կախվածություններ, նոր տարբերակի թողարկումը
կարող է արագ վերածվել մղձավանջի։ Եթե կախվածությունների սպեցիֆիկացիան շատ խիստ է,
դուք կարող եք կանգնել նոր տարբերակի թողարկման արգելքի (version lock) առաջ
(անհնար է դառնում թարմացնել ծրագիրը՝ առանց թարմացնելու կախման մեջ գտնվող բոլոր
փեքիջները)։ Մյուս կողմից էլ, եթե կախվածությունների սպեցիֆիկացիան շատ ազատ է,
դուք անխուսափելիորեն կբախվեք տարբերակի անհամապատասխանության (version
promiscuity) խնդրին․ անհիմն է ենթադրությունը, որ ձեր ծրագիրը կմնա համատեղելի
ապագա տարբերակների հետ։ «Կախվածությունների դժոխքը» մի իրավիճակ է, երբ տարբերակի
թողարկման և/կամ տարբերակի անհապատասխանության արգելքը թույլ չի տալիս ձեզ հեշտ և
անվտանգ զարգացնել ձեր նախագիծը։\nՈրպես այս խնդրի լուծում՝ ես առաջարկում եմ պարզ կանոններ և պահանջներ, որոնք
սահմանում են, թե ինչպես են սահմանվում և մեծացվում տարբերակների համարները։
Նախևառաջ, որպեսզի այս կանոններն աշխատեն, դուք պետք է սահմանեք փաբլիք API: Այն
կարող է նկարագրված լինել ինչպես դոկումենտացիայի, այնպես էլ կոդի մեջ։ Կարևոր է,
որ API֊ը լինի ճիշտ և հասկանալի։ Ձեր API֊ը հայտարարելուց հետո դուք
փոփոխությունների մասին կտեղեկացնեք տարբերակի համարը մեծացնելու միջոցով։
Դիտարկենք այս ֆորմատով ներկայացված տարբերակ՝ X.Y.Z (ՄԱԺՈՐ․ՄԻՆՈՐ․ՓԱԹՉ)։ Սխալների
ուղղումները (bug fix), որոենք չեն ազդել API-ի վրա, մեծացնում են ՓԱԹՉ֊ը։ Հետ
համատեղելի հավելումները և փոփոխությունները մեծացնում են ՄԻՆՈՐ֊ը, հետ
համատեղելիությունը խախտող փոփոխությունները մեծացնում են ՄԱԺՈՐ֊ը։\nԵս անվանել եմ այս համակարգը «Սեմանտիկ տարբերակում» (Semantic Versioning): Այս
սխեմայի միջոցով տարբերակի համարը և դրա փոխվելը իմաստավորում են կոդի
պարունակությունը և նրանում եղած փոփոխությունները տարբերակից տարբերակ։\nՍեմանտիկ տարբերակման սպեցիֆիկացիա (SemVer)\nՆշված բառերը՝ «ՊԵՏՔ Է» (MUST, SHALL), «ՉՊԵՏՔ Է» (MUST NOT, SHALL NOT),
«ՊԱՐՏԱԴԻՐ Է» (REQUIRED), «ԱՆՀՐԱԺԵՇՏ Է» (SHOULD), «ԱՆՀՐԱԺԵՇՏ ՉԷ» (SHOULD NOT),
«ԽՈՐՀՈՒՐԴ Է ՏՐՎՈՒՄ» (RECOMMENDED), «ԿԱՐՈՂ Է» (MAY) և «ՊԱՐՏԱԴԻՐ ՉԷ» (OPTIONAL)
պետք է ինտերպրիտացվեն RFC 2119 ստանդարտին
համապատասխան։\nԾրագրային ապահովումը, որն օգտագործվում է Սեմանտիկ տարբերակում, ՊԵՏՔ Է (MUST)
հայտարարի հասանելի փաբլիք API: Այդ API֊ը կարող է հայտարարվել ինչպես կոդի մեջ,
այնպես էլ՝ առանձին դոկումենտացիայում։ Երկու դեպքում էլ այն պետք է լինի ճշգրիտ
(precise) և սպառիչ (comprehensive)։\nԾրագրային ապահովումը, որն օգտագործվում է Սեմանտիկ տարբերակում, ՊԵՏՔ Է (MUST)
հայտարարի հասանելի փաբլիք API: Այդ API֊ը կարող է հայտարարվել ինչպես կոդի մեջ,
այնպես էլ՝ առանձին դոկումենտացիայում։ Երկու դեպքում էլ այն պետք է լինի ճշգրիտ
(precise) և սպառիչ (comprehensive)։\nՏարբերակի ՆՈՐՄԱԼ համարը (normal version) ՊԵՏՔ Է (MUST) ունենա այս ֆորմատը՝
X֊ը տարբերակի ՄԱԺՈՐ համարն է, Y֊ը՝ ՄԻՆՈՐ և Z֊ը՝ ՓԱԹՉ։ Բոլոր բաղադիրչները պետք
է մեծացվեն թվայնորեն․ օրինակ՝ 1.9.0 -> 1.10.0 -> 1.11.0։\nՏարբերակի ՆՈՐՄԱԼ համարը (normal version) ՊԵՏՔ Է (MUST) ունենա այս ֆորմատը՝
X֊ը տարբերակի ՄԱԺՈՐ համարն է, Y֊ը՝ ՄԻՆՈՐ և Z֊ը՝ ՓԱԹՉ։ Բոլոր բաղադիրչները պետք
է մեծացվեն թվայնորեն․ օրինակ՝ 1.9.0 -> 1.10.0 -> 1.11.0։\nՓեքիջի թողարկումից հետո այդ տարբերակի պարունակությունը ՉՊԵՏՔ է (MUST NOT)
փոփոխության ենթարկվի։ Ցանկացած փոփոխություն ՊԵՏՔ Է (MUST) թողարկվի որպես նոր
տարբերակ։\nՓեքիջի թողարկումից հետո այդ տարբերակի պարունակությունը ՉՊԵՏՔ է (MUST NOT)
փոփոխության ենթարկվի։ Ցանկացած փոփոխություն ՊԵՏՔ Է (MUST) թողարկվի որպես նոր
տարբերակ։\nԶրոյական ՄԱԺՈՐ տարբերակը (0.y.z) նախատեսված է ծրագրային ապահովման
ստեղծման/մշակման նախնական փուլի (initial development) համար։ Ամեն ինչ կարող է
փոխվել՝ կամայական պահի։ Փաբլիք API֊ը չպետք է դիտարկվի որպես ստաբիլ։\nԶրոյական ՄԱԺՈՐ տարբերակը (0.y.z) նախատեսված է ծրագրային ապահովման
ստեղծման/մշակման նախնական փուլի (initial development) համար։ Ամեն ինչ կարող է
փոխվել՝ կամայական պահի։ Փաբլիք API֊ը չպետք է դիտարկվի որպես ստաբիլ։\n1.0.0 տարբերակի թողարկումից հետո API-ը համարվում է ստաբիլ, և տարբերակի համարը
փոխվում է կախված նրանից, թե ինչպես է փոխվում փաբլիք API֊ը։\n1.0.0 տարբերակի թողարկումից հետո API-ը համարվում է ստաբիլ, և տարբերակի համարը
փոխվում է կախված նրանից, թե ինչպես է փոխվում փաբլիք API֊ը։\nՏարբերակի ՓԱԹՉ համարը՝ Z (x.y.Z | x > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե տեղի են
ունեցել միայն հետ համատեղելի սխալների ուղղումներ (bug fix)։ Սխալի ուղղում՝
նշանակում է ներքին փոփոխություն, որը ուղղում է սխալ պահվածքը։\nՏարբերակի ՓԱԹՉ համարը՝ Z (x.y.Z | x > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե տեղի են
ունեցել միայն հետ համատեղելի սխալների ուղղումներ (bug fix)։ Սխալի ուղղում՝
նշանակում է ներքին փոփոխություն, որը ուղղում է սխալ պահվածքը։\nՏարբերակի ՄԻՆՈՐ համարը՝ Y (x.Y.z | x > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե փաբլիք
API֊ում ավելացել է նոր հետ համատեղելի ֆունկցիոնալ։ Տարբերակի համարը ՊԵՏՔ Է
(MUST) մեծացվի, եթե հասանելի փաբլիք API֊ի որևէ ֆունկցիոնալ պիտակավորվել է
որպես հնացած (deprecated)։ Տարբերակի համարը ԿԱՐՈՂ Է (MAY) մեծացվել, եթե տեղի
է ունեցել նոր ֆունկցիոնալի ինտեգրացիա, կամ զգալի բարելավումներ են տեղի
ունեցել փրայվիթ կոդում։ Այն ԿԱՐՈՂ Է (MAY) նաև պարունակել ՓԱԹՉ մակարդակի
փոփոխություններ։ Տարբերակի ՓԱԹՉ համարը ՊԵՏՔ Է (MUST) զրոյացվի, երբ մեծացվում
է ՄԻՆՈՐ համարը։\nՏարբերակի ՄԻՆՈՐ համարը՝ Y (x.Y.z | x > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե փաբլիք
API֊ում ավելացել է նոր հետ համատեղելի ֆունկցիոնալ։ Տարբերակի համարը ՊԵՏՔ Է
(MUST) մեծացվի, եթե հասանելի փաբլիք API֊ի որևէ ֆունկցիոնալ պիտակավորվել է
որպես հնացած (deprecated)։ Տարբերակի համարը ԿԱՐՈՂ Է (MAY) մեծացվել, եթե տեղի
է ունեցել նոր ֆունկցիոնալի ինտեգրացիա, կամ զգալի բարելավումներ են տեղի
ունեցել փրայվիթ կոդում։ Այն ԿԱՐՈՂ Է (MAY) նաև պարունակել ՓԱԹՉ մակարդակի
փոփոխություններ։ Տարբերակի ՓԱԹՉ համարը ՊԵՏՔ Է (MUST) զրոյացվի, երբ մեծացվում
է ՄԻՆՈՐ համարը։\nՏարբերակի ՄԱԺՈՐ համարը՝ X (X.y.z | X > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե փաբլիք
API֊ում ներկայացվել են հետ համատեղելիությունը խախտող կամայական
փոփոխություններ։ Այն ԿԱՐՈՂ Է (MAY) պարունակել նաև ՓԱԹՉ և ՄԻՆՈՐ մակարդակի
փոփոխություններ։ Տարբերակի ՓԱԹՉ և ՄԻՆՈՐ համարները ՊԵՏՔ Է (MUST) զրոյացվեն,
երբ մեծացվում է ՄԱԺՈՐ համարը։\nՏարբերակի ՄԱԺՈՐ համարը՝ X (X.y.z | X > 0), ՊԵՏՔ Է (MUST) մեծացվի, եթե փաբլիք
API֊ում ներկայացվել են հետ համատեղելիությունը խախտող կամայական
փոփոխություններ։ Այն ԿԱՐՈՂ Է (MAY) պարունակել նաև ՓԱԹՉ և ՄԻՆՈՐ մակարդակի
փոփոխություններ։ Տարբերակի ՓԱԹՉ և ՄԻՆՈՐ համարները ՊԵՏՔ Է (MUST) զրոյացվեն,
երբ մեծացվում է ՄԱԺՈՐ համարը։\nՄինչթողարկումային (pre-release) տարբերակը ԿԱՐՈՂ Է (MAY) պիտակավորվել
տարբերակի ՓԱԹՉ համարից անմիջապես հետո գծիկ և դրան հետևող կետիկով առանձնացված
տարբեր իդենտիֆիկատորներ ավելացնելու միջոցով։ Իդենտիֆիկատորները ՊԵՏՔ Է (MUST)
պարունակեն միայն ASCII տառա֊թվային սիմվոլներ և գծիկ՝ [0-9A-Za-z-]։
Մինչթողարկումային տարբերակները ունեն ավելի ցածր ԿԱՐԳԱՎԻՃԱԿ, քան համապատասխան
ՆՈՐՄԱԼ֊ները։ օրինակ՝ 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92։\nՄինչթողարկումային (pre-release) տարբերակը ԿԱՐՈՂ Է (MAY) պիտակավորվել
տարբերակի ՓԱԹՉ համարից անմիջապես հետո գծիկ և դրան հետևող կետիկով առանձնացված
տարբեր իդենտիֆիկատորներ ավելացնելու միջոցով։ Իդենտիֆիկատորները ՊԵՏՔ Է (MUST)
պարունակեն միայն ASCII տառա֊թվային սիմվոլներ և գծիկ՝ [0-9A-Za-z-]։
Մինչթողարկումային տարբերակները ունեն ավելի ցածր ԿԱՐԳԱՎԻՃԱԿ, քան համապատասխան
ՆՈՐՄԱԼ֊ները։ օրինակ՝ 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92։\nԲիլդ֊մետատվյալները (build-metadata) ԿԱՐՈՂ ԵՆ (MAY) պիտակավորվել տարբերակի
ՓԱԹՉ համարից կամ մինչթողարկումային տարբերակի իդենտիֆիկատորից անմիջապես հետո
գումարման նշան և դրան հետևող կետիկով առանձնացված տարբեր իդենտիֆիկատորներ
ավելացնելու միջոցով։ Իդենտիֆիկատորները ՊԵՏՔ Է (MUST) պարունակեն միայն ASCII
տառա֊թվային սիմվոլներ և գծիկ՝ [0-9A-Za-z-]։ Իդենտիֆիկատորները ՉՊԵՏՔ Է (MUST
NOT) լինեն դատարկ։ Բիլդ֊մետատվյալները ՊԵՏՔ Է (MUST) անտեսել տարբերակի
ԿԱՐԳԱՎԻՃԱԿԸ որոշելիս այսինքն, եթե նույն ծրագրի երկու տարբերակները տարբերվում
են միայն բիլդ֊մետատվյալներով, ուրեմն դրանք ունեն նույն ԿԱՐԳԱՎԻՃԱԿԸ․ օրինակ՝
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85։\nԲիլդ֊մետատվյալները (build-metadata) ԿԱՐՈՂ ԵՆ (MAY) պիտակավորվել տարբերակի
ՓԱԹՉ համարից կամ մինչթողարկումային տարբերակի իդենտիֆիկատորից անմիջապես հետո
գումարման նշան և դրան հետևող կետիկով առանձնացված տարբեր իդենտիֆիկատորներ
ավելացնելու միջոցով։ Իդենտիֆիկատորները ՊԵՏՔ Է (MUST) պարունակեն միայն ASCII
տառա֊թվային սիմվոլներ և գծիկ՝ [0-9A-Za-z-]։ Իդենտիֆիկատորները ՉՊԵՏՔ Է (MUST
NOT) լինեն դատարկ։ Բիլդ֊մետատվյալները ՊԵՏՔ Է (MUST) անտեսել տարբերակի
ԿԱՐԳԱՎԻՃԱԿԸ որոշելիս այսինքն, եթե նույն ծրագրի երկու տարբերակները տարբերվում
են միայն բիլդ֊մետատվյալներով, ուրեմն դրանք ունեն նույն ԿԱՐԳԱՎԻՃԱԿԸ․ օրինակ՝
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85։\nԿԱՐԳԱՎԻՃԱԿԸ (precedence) որոշում է, թե ինչպես է պետք համեմատել տարբերակները
միմյանց հետ, երբ դրանք դասավորված են։ ԿԱՐԳԱՎԻՃԱԿԸ ՊԵՏՔ Է (MUST) հաշվել
տարբերակի համարը՝ ՄԱԺՈՐ, ՄԻՆՈՐ, ՓԱԹՉ, և մինչթողարկումային իդենտիֆիկատորները
բաժանելու միջոցով։ ԿԱՐԳԱՎԻՃԱԿԸ որոշելիս բիլդ֊մետատվյալները հաշվի չեն առնվում։
ԿԱՐԳԱՎԻՃԱԿԸ որոշվում է ՄԱԺՈՐ, ՄԻՆՈՐ, ՓԱԹՉ տարբերակի համարները ձախից աջ
թվայնորեն համեմատելու միջոցով․ օրինակ՝ 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1։ Երբ
ՄԱԺՈՐ, ՄԻՆՈՐ և ՓԱԹՉ տարբերակի համարները հավասար են, մինչթողարկումային
տարբերակը ունենում է ավելի փոքր ԿԱՐԳԱՎԻՃԱԿ, քան ՆՈՐՄԱԼ տարբերակը․ օրինակ՝
1.0.0-alpha < 1.0.0։ Երբ տարբերակների ՄԱԺՈՐ, ՄԻՆՈՐ և ՓԱԹՉ համարները հավասար
են, ԿԱՐԳԱՎԻՃԱԿԸ ՊԵՏՔ Է (MUST) որոշել մինչթողարկումային տարբերակի միջոցով՝
ձախից աջ կետով առանձնացված իդենտիֆիկատորները համեմատելով մինչև առաջին
տարբերող իդենտիֆիկատոր գտնելը։ Մինչթողարկումային տարբերակները համեմատվում են
տվյալ եղանակով՝ իդենտիֆիկատորները, որոնք կազմված են միայն թվերից, համեմատվում
են թվայնորեն։ Տառեր և գծիկ պարունակող իդենտիֆիկատորները համեմատվում են
տառացի՝ ASCII աղյուսակի հերթականությամբ։ Թվային իդենտիֆիկատորները միշտ
ունենում են ավելի ցածր կարգավիճակ, քան ոչ թվայինները։ Մինչթողարկումային
սիմվոլների մեծ քանակ ունեցող տարբերակը ունենում է ավելի բարձր կարգավիճակ, երբ
համեմատվող իդենտիֆիկատորները նույնն են․ օրինակ՝ 1.0.0-alpha < 1.0.0-alpha.1 <
1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 <
1.0.0։\nԿԱՐԳԱՎԻՃԱԿԸ (precedence) որոշում է, թե ինչպես է պետք համեմատել տարբերակները
միմյանց հետ, երբ դրանք դասավորված են։ ԿԱՐԳԱՎԻՃԱԿԸ ՊԵՏՔ Է (MUST) հաշվել
տարբերակի համարը՝ ՄԱԺՈՐ, ՄԻՆՈՐ, ՓԱԹՉ, և մինչթողարկումային իդենտիֆիկատորները
բաժանելու միջոցով։ ԿԱՐԳԱՎԻՃԱԿԸ որոշելիս բիլդ֊մետատվյալները հաշվի չեն առնվում։
ԿԱՐԳԱՎԻՃԱԿԸ որոշվում է ՄԱԺՈՐ, ՄԻՆՈՐ, ՓԱԹՉ տարբերակի համարները ձախից աջ
թվայնորեն համեմատելու միջոցով․ օրինակ՝ 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1։ Երբ
ՄԱԺՈՐ, ՄԻՆՈՐ և ՓԱԹՉ տարբերակի համարները հավասար են, մինչթողարկումային
տարբերակը ունենում է ավելի փոքր ԿԱՐԳԱՎԻՃԱԿ, քան ՆՈՐՄԱԼ տարբերակը․ օրինակ՝
1.0.0-alpha < 1.0.0։ Երբ տարբերակների ՄԱԺՈՐ, ՄԻՆՈՐ և ՓԱԹՉ համարները հավասար
են, ԿԱՐԳԱՎԻՃԱԿԸ ՊԵՏՔ Է (MUST) որոշել մինչթողարկումային տարբերակի միջոցով՝
ձախից աջ կետով առանձնացված իդենտիֆիկատորները համեմատելով մինչև առաջին
տարբերող իդենտիֆիկատոր գտնելը։ Մինչթողարկումային տարբերակները համեմատվում են
տվյալ եղանակով՝ իդենտիֆիկատորները, որոնք կազմված են միայն թվերից, համեմատվում
են թվայնորեն։ Տառեր և գծիկ պարունակող իդենտիֆիկատորները համեմատվում են
տառացի՝ ASCII աղյուսակի հերթականությամբ։ Թվային իդենտիֆիկատորները միշտ
ունենում են ավելի ցածր կարգավիճակ, քան ոչ թվայինները։ Մինչթողարկումային
սիմվոլների մեծ քանակ ունեցող տարբերակը ունենում է ավելի բարձր կարգավիճակ, երբ
համեմատվող իդենտիֆիկատորները նույնն են․ օրինակ՝ 1.0.0-alpha < 1.0.0-alpha.1 <
1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 <
1.0.0։\nԻ՞նչու օգտագործել սեմանտիկ տարբերակում\nՍա նոր կամ հեղափոխական միտք չէ։ Հավանական է՝ դուք օգտվում եք տարբերակման նման
ինչ֊որ եղանակից։ Խնդիրն այն է, որ «նման» եղանակից օգվելը կարող է բավարար չլինել։
Առանց կոշտ սպեցիֆիկացիայի տարբերակի համարները անօգուտ են դառնում
կախվածությունները կարգավորելու հարցում։ Տալով անուն և որոշակիացնելով վերը
ձևակերպված մտքերը՝ ավելի հեշտ է դառնում հաղորդել ձեր մտքերը այն օգտատերերին,
որոնք օգտվում են ձեր ծրագրային ապահովումից։ Եթե այդ մտքերը հասկանալի են և ճկուն,
կախվածությունների սպեցիֆիկացիան կաշխատի։\nՊարզ օրինակի միջոցով կարելի է ցույց տալ, թե ինչպես է Սեմանտիկ Տարբերակումը
«կախվածություննեի դժողքը» թողնում անցյալում։ Պատկերացնենք մի գրադարան (library),
որի անունն է՝ «Firetruck»։ Նրա աշխատանքի համար անհրաժեշ է Սեմանտիկ Տարբերակումով
թողարկվող «Ladder» փեքիջը։ Երբ Firetruck֊ը ստեղծվել էր, Ladder֊ի տարբերակի
համարն էր՝ 3.1.0։ Քանի որ Firetruck֊ը օգտագործում է Ladder֊ի 3.1.0 տարբերակի
ֆունկցիոնալը, դուք հանգիստ կարող եք հայտարարել կախվածությունը Ladder֊ի 3.1.0
տարբերակից, բայց ոչ ավել քան 4.0.0։ Երբ դուրս գա Ladder֊ի 3.2.0 տարբերակը, դուք
հաստատ կիմանաք, որ այն համատեղելի է ձեր ծրագրի հետ և կարող եք հանգիստ ինտեգրել
այն։\nՈրպես պատասխանատու ծրագրավորող՝ դուք իհարկե կցանկանաք վստահ լինել, որ բոլոր
թարմացումները աշխատում են այնպես ինչպես հայտարարվել է։ Իրական աշխարհում միշտ
խառնաշփոթ է, և ոչինչ չի կարելի անել դրա հետ, բացի ուշադիր լինելուց։ Սեմանտիկ
տարբերակման միջոցով դուք կարող եք թողարկել ձեր ծրագրային ապահովման նոր
տարբերակներ և թարմացումներ չմտածելով կախվածությունների մասին և պահպանել ձեր
ժամանակը և նյարդերը։\nԵթե այս ամենը գայթակղիչ է թվում ձեզ, այն ամենը ինչ ձեզ անհրաժեշտ է՝ սկսել
օգտագործել Սեմանտիկ տարբերակումը, հայտարարել դրա մասին և հետևել կանոններին։ Նշեք
այս կայքի հղումը ձեր README֊ում և օգտագործողները կիմանան այս կանոնների մասին։\nԻ՞նչ է անհրաժեշտ անել 0.y.z տարբերակում արված փոփոխությունների հետ, ծրագրավորման նախնական փուլում։\nԱմենահեշտ լուծումը աշխատանքը 0.1.0 տարբերակի թողարկումով սկսելն է և հետագայում
ամեն հաջորդ թողարկման համար ՄԻՆՈՐ տարբերակի համարը մեծացնելը։\nԻ՞նչպես իմանալ, որ 1.0.0 տարբերակը թողարկելու ժամանկն է։\nԵթե ձեր ծրագրային ապահովումը արդեն օգտագործվում է պրոդաքշնում, ամենայն
հավանականությամբ արդեն պետք է թողարկել 1.0.0 տարբերակը։ Եթե դուք ունեք ստաբիլ
API, որը ունի օգտագործողներ, տարբերակի համարը պետք է լինի 1.0.0։ Եթե
անհանգստանում եք հետ համատեղելիության մասին, ամենայն հավանականությամբ ձեր
ծրագրային ապահովման տարբերակի համարը արդեն պետք է լինի 1.0.0։\nԱրդյո՞ք աշխատելու այս ձևը չի խանգարում արագ ծրագրավորմանը (rapid development) և արագ իտերացիաներին (fast iteration)։\nԵրբ ՄԱԺՈՐ տարբերակի համարը 0 է, դա արդեն իսկ ենթադրում է արագ ծրագրավորում։ Եթե
դուք փոփոխեք API֊ը ամեն օր, ապա պետք է լինեք 0.y.z տարբերակի վրա, կամ առանձին
ճյուղի (branch) վրա աշխատեք հաջորդ ՄԱԺՈՐ տարբերակի թողարկման համար։\nԵթե նույնիսկ փոքր փոփոխությունները, որոնք խախտում են հետ համատեղելիությունը, պահանջում են նոր ՄԱԺՈՐ տարբերակի թողարկում, արդյո՞ք դա չի հանգեցնի նրան, որ շուտով տարբերակի համարը դառնա 42.0.0։\nՍա ավելի շատ պատասխանատվության և հեռատեսության խնդիր է։ Ծրագրային ապահովման հետ
համատեղելիությունը խախտող փոփոխությունները աննշան չեն, քանի որ դրա արդյունքում
թարմացումները կարող են շատ թանկ արժենալ։ Հետ համատեղելիությունը խախտող
փոփոխությունների թողարկումը տարբերակի ՄԱԺՈՐ համարի ավելացմամբ, նշանակում է՝ դուք
պետք է մտածեք ձեր փոփոխությունների հետևանքների մասին և հաշվի առնեք գին֊օգուտ
հարաբերակցությունը։\nԴոկումենտացիայի կազմումը մեծ աշխատանք է պահանջում։\nՈրպես պրոֆեսիոնալ ծրագրավորող ձեր պատասխանատվությունն է ճիշտ դոկումենտացնել
ծրագրային ապահովումը, որը նախատեսված է ուրիշների օգտագործման համար։ Ծրագրային
ապահովման բարդության կարգավորումը նրա արդյունավետության պահպանման կարևոևագույն
կետերից մեկն է։ Եթե ոչ մեկը չգիտի, թե ինչպես օգտագործել ձեր ծրագրային
ապահովումը, կամ որ մեթոդի կանչն է անվտանգ, ինչպես պետք է նրանք օգտագործեն այն։
Երկարաժամկետ հեռանկարով Սեմանտիկ Տարբերակումը, համառ և կոշտ դիրքը որակով
շարադրված փաբլիք API֊ի նկատմամբ կնպաստեն ամենքի և ամեն ինչի ճիշտ և համակարգված
աշխատելուն։\nԻ՞նչ է անհրաժեշտ անել, եթե պատահաբար թողարկվել են հետ համատեղելիությունը խախտող փոփոխություններ ՄԻՆՈՐ տարբերակի տակ։\nՀենց որ դուք հասկացաք, որ խախտել եք Սեմանտիկ Տարբերակման սպեցիֆիկացիան, ուղղեք
սխալը և թողարկեք նոր ՄԻՆՈՐ տարբերակ, որը լուծում է խնդիրը և վերականգնում հետ
համատեղելիությունը։ Նույնիսկ նման դեպքերում անընդունելի է արդեն թողարկված
տարբերակներում փոփոխությունների իրականացումը։ Եթե անհրաժեշտ է, նշեք
դոկումենտացիայում և տեղյակ պահեք օգտագործողներին հետ համատեղելիության և
տարբերակման հերթականության խախտման մասին։\nԻ՞նչ է անհրաժեշտ անել, եթե փոփոխվել են կախվածությունները առանց փաբլիք API֊ը փոփոխելու։\nԴա կարող է դիտարկվել որպես հետ համատեղելի փոփոխություն, քանի որ այն չի ազդում
փաբլիք API֊ի վրա։ Ծրագրային ապահովումը, որը ակնհայտորեն ունի նույն
կախվածությունները, ինչ փեքիջը, պետք է ունենա իր սեփական կախվածությունների
սպեցիֆիկացիան, և հեղինակը տեղյակ կլինի ի հայտ եկած կոնֆլիկտների մասին։ Արդյոք
տվյալ փոփոխությունները ՄԱԺՈՐ, թե ՓԱԹՉ մակարդակի են, կախված է նրանից, թե դուք
փոխել եք ձեր կախվածությունները սխալներ ուղղելու, թե՞ նոր ֆունկցիոնալ ինտեգրելու
համար։ Երկրորդ դեպքում, որպես կանոն ավելանում է որոշակի քանակով կոդ և որպես
հետևանք մեծանում է տարբերակի ՄԻՆՈՐ համարը։\nԻ՞նչ անել, եթե պատահաբար փոփոխվել է փաբլիք API֊ը, և այն չի համապատասխանում տարբերակի համարին (այսինքն՝ կոդը սխալմամբ պարունակում է հետ համատեղելիությունը խախտող փոփոխություններ ՓԱԹՉ տարբերակի թողարկման մեջ)։\nՈրոշումը ձերն է։ Եթե դուք ունեք օգտագործողների մեծ խումբ, որը կկանգնի փաբլիք
API֊ի նախկին ֆունկցիոնալի վերականգման փաստի առաջ, ուրեմն ճիշտ կլինի թողարկել նոր
տարբերակ ՄԱԺՈՐ համարի մեծացումով։ Չնայած նրան, որ այն պարունակում է միայն ՓԱԹՉ
մակարդակի փոփոխություններ, հիշեք՝ ըստ Սեմանտիկ Տարբերակման սպեցիֆիկացիայի
տարբերակի համարները մեծացվում են սպեցիֆիկացիային համաձայն։ Եթե այդ
փոփոխությունները կարևոր են ձեր օգտագործողների համար, օգտագործեք տարբերակի համարը
նրանց տեղյակ պահելու համար։\nԻ՞նչ անել հնացած (deprecated) ֆունկցիոնալի հետ։\nՈրոշ ֆունկցիոնալի հնանալը սովորական երևույթ է և ծրագրային ապահովման
ստեղծման/մշակման ընթացքում հաճախ պարտադիր է առաջընթացի համար։ Երբ դուք հնացած եք
հայտարարում, փաբլիք API֊ի ինչ֊որ հատված, դուք պետք է երկու բան անեք․ նախ
թարմացնեք ձեր դոկումենտացիան և տեղեկացնեք օգտագործողներին փոփոխության մասին (1),
և ապա թողարկեք նոր ՄԻՆՈՐ տարբերակ՝ նշում կատարելով հնացած ֆունկցիոնալի մասին
(2)։ Մինչ դուք ամբողջովին կջնջեք հնացած ֆունկցիոնալը, հաջորդ ՄԱԺՈՐ թողարկման
ժամանակ պետք է լինի առնվազն մեկ ՄԻՆՈՐ թողարկում, որը պարունակում է տեղեկություն
ֆունկցիոնալի հնացած հայտարարվելու մասին, որպեսզի օգտագործողները հեշտությամբ
անցնեն նոր API֊ի։\nՍեմանտիկ Տարբերակման սպեցիֆիկացիայի հեղինակն է
Թոմ Պրեստոն-Վարները (Gravatars֊ի հիմնադիր և
GitHub֊ի համահիմնադիր)։\nԵթե դուք ցանկանում եք որևէ մեկնաբանություն թողնել, խնդրում ենք
GitHub֊ում հարց (issue) բացել։\nGitHub֊ում հարց (issue) բացել\nCreative Commons ― CC BY 3.0
http://creativecommons.org/licenses/by/3.0/\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nPemversian Semantik 2.0.0

Ringkasan

Versi semantik ditulis dalam bentuk MAJOR.MINOR.PATCH, dengan:


  Tambah angka versi MAJOR jika membuat perubahan API yang tidak lagi cocok dengan versi sebelumnya.
  Tambah angka versi MINOR jika menambah fitur tanpa membuat versi lama tidak bisa digunakan.
  Tambah angka versi PATCH jika ada perbaikan bug tanpa membuat versi lama tidak bisa digunakan.


Tambahan label dan versi sebelum rilis atau info tambahan tersedia sebagai ekstensi dari format
MAJOR.MINOR.PATCH.

Pendahuluan

Dalam pengembangan perangkat lunak, sering terjadi permasalahan dependency hell. Semakin besar sistem yang dibuat dan semakin banyak modul yang digunakan sistem kita, semakin sering permasalahan ini akan terjadi.

Dalam sistem yang saling terkait, merilis versi baru bisa menjadi mimpi buruk. Jika spesifikasi dependensi sistem terlalu ketat, bisa jadi sistem kita tidak bisa dikembangkan lagi. Jika spesifikasi dependensi sistem terlalu bebas, semakin sulit untuk berasumsi versi mana yang bisa digunakan dengan versi yang lain. Dependency hell adalah saat Anda berada pada satu atau dua masalah ini, yang menahan Anda untuk bergerak maju dengan aman dan mudah.

Sebagai solusi permasalahan ini, kami mengusulkan seperangkat aturan dan persayaratan sederhana yang menentukan bagaimana nomor versi diberikan dan bertambah. Aturan-aturan ini didasarkan pada, namun tidak terbatas pada, praktik-praktik yang sudah ada pada perangkat lunak sumber terbuka dan tertutup. Agar sistem ini dapat bekerja, Anda harus mengumumkan API publik terlebih dahulu. Ini dapat terdiri dari dokumentasi atau diberlakukan oleh kode itu sendiri. Apapun itu, API ini harus jelas dan tepat. Setelah Anda mengidentifikasi API publik Anda, Anda mengomunikasikan perubahan pada API tersebut dengan penambahan spesifik pada nomor versi Anda. Pertimbangkan format versi X.Y.Z (Major.Minor.Patch). Perbaikan bug yang tidak memengaruhi API tersebut akan menambah versi patch, penambahan/perubahan API yang kompatibel dengan versi sebelumnya akan menambah versi minor, dan perubahan API yang tidak kompatibel dengan versi sebelumnya akan menambah versi major.

Standar ini bernama “Pemversian Semantik”. Dengan skema ini, setiap orang yang melihat angka versi bisa tahu secara umum apa yang berubah dengan sistem tersebut.

Spesifikasi Pemversian Semantik (SemVer)

Kata/frasa “HARUS” (“MUST”), “TIDAK BOLEH” (“MUST NOT”), “DIBUTUHKAN” (“REQUIRED”), “SEHARUSNYA” (“SHALL”), “JANGAN SAMPAI” (“SHALL NOT”), “SEBAIKNYA” (“SHOULD”), “SEBAIKNYA TIDAK” (“SHOULD NOT”), “DIREKOMENDASIKAN” (“RECOMMENDED”), “BISA” (“MAY”) di dokumen ini sesuai dengan RFC 2119.


  
    Perangkat lunak dengan Pemversian Semantik HARUS menentukan API public. Bisa dijelaskan dengan kode, atau ditulis di dokumentasi saja. Apapun itu HARUS ditulis dengan jelas dan akurat.
  
  
    Versi normal HARUS ditulis dalam bentuk X.Y.Z, dengan X, Y, dan Z adalah bilangan bulat nonnegatif, dan TIDAK BOLEH didahului angka 0 (contoh 01.02.03). X adalah versi major, Y adalah minor, dan Z adalah patch. Setiap elemen HARUS bertambah secara numerik dengan kenaikan sebesar satu. Contohnya: 1.9.0 -> 1.10.0 -> 1.11.0
  
  
    Setelah sebuah paket berversi dirilis, isi dari versi tersebut TIDAK BOLEH diubah. Setiap perubahan HARUS dirilis sebagai versi baru.
  
  
    Versi major 0 (0.y.z) adalah untuk pengembangan awal. Apapun BISA bisa berubah kapan saja. API publik SEBAIKNYA
dianggap tidak stabil di versi ini.
  
  
    Versi 1.0.0 adalah titik awal API publik. Cara nomor versi ini dinaikkan setelah rilis ini adalah tergantung dengan API publik ini dan bagaimana ia berubah.
  
  
    Versi patch Z (x.y.Z | x > 0) HARUS dinaikkan jika ada perbaikan bug yang kompatibel dengan versi lama. Sebuah perbaikan bug didefinisikan sebagai perubahan internal yang memperbaiki perilaku yang salah.
  
  
    Versi minor Y (x.Y.z | x > 0) HARUS dinaikkan jika ada fitur baru yang kompatibel dengan versi lama dalam API publik. Ini HARUS dinaikkan jika sebuah fungsionalitas API publik dibuat usang. Ini BISA dinaikkan jika ada tambahan fungsionalitas substansial atau terjadi peningkatan di dalam kode privat. Ini BISA diubah bersama dengan perubahan tingkat patch. Versi patch HARUS dikembalikan ke angka 0 jika versi minor dinaikkan.
  
  
    Versi major X (X.y.z | X > 0) HARUS dinaikkan jika ada perubahan yang membuat versi baru tidak kompatibel dengan versi lama pada API publik. Ini juga BISA diubah bersama dengan perubahan tingkat patch dan minor. Versi minor dan patch HARUS dikembalikan ke angka 0 jika versi major dinaikkan.
  
  
    Versi prarilis BISA ditulis dengan menambahkan tanda hubung dan rangkaian pengenal dengan pemisah titik tepat setelah versi patch. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda hubung [0-9A-Za-z]. Pengenal TIDAK BOLEH kosong. Pengenal numerik TIDAK BOLEH didahului angka 0. Versi prarilis memiliki presendens yang lebih rendah dibandingkan dengan versi normal yang terkait. Versi prarilis dianggap tidak stabil dan mungkin tidak memuaskan persyaratan kompatibilitas yang dimaksudkan seperti yang ditunjukkan oleh versi normal yang terkait. Contoh: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92, 1.0.0-x-y-z.--.
  
  
    Build metadata BISA ditulis didahului dengan tanda tambah dan rangkaian pengenal dengan pemisah titik setelah versi patch atau prarilis. Build metadata HARUS ditulis dengan huruf ASCII alfanumerik dan tanda hubung [0-9A-Za-z]. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda hubung [0-9A-Za-z]. Pengenal TIDAK BOLEH kosong. Build metadata HARUS diabaikan saat menentukan presedens versi. Dengan begitu, dua versi yang berbada hanya di build metadata-nya memiliki preseden yang sama. Contoh: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3----117B344092BD.
  
  
    Presedens mengacu pada bagaimana versi-versi dibandingkan satu sama lain ketika diurutkan.

    
      
        Presedens HARUS dihitung dengan memisahkan versi menjadi pengenal major, minor, patch, dan prarilis dalam urutan tersebut (Build metadata tidak diperhitungkan dalam pengurutan).
      
      
        Presedens ditentukan oleh perbedaan pertama saat membandingkan masing-masing pengenal ini dari kiri ke kanan sebagai berikut: Major, minor, dan patch selalu dibandingkan secara numerik.

        Contoh: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Saat versi major, minor, dan patch sama, versi prarilis lebih rendah memiliki presedens lebih rendah dibandingkan dengan versi normal:

        Contoh: 1.0.0-alpha < 1.0.0.
      
      
        Prioritas untuk dua versi prarilis dengan versi major, minor, dan patch HARUS ditentukan dengan membandingkan setiap pengenal yang dipisahkan titik dari kiri ke kanan hingga ditemukan perbedaan sebagai berikut:

        
          
            Pengenal yang hanya terdiri dari angka dibandingkan secara numerik.
          
          
            Pengenal dengan huruf atau tanda hubung dibandingkan secara leksikal dalam urutan pengurutan ASCII.
          
          
            Pengenal numerik selalu memiliki presedens yang lebih rendah daripada pengenal non-numerik pengenal non-numerik.
          
          
            Suatu set yang lebih besar dari bidang prarilis memiliki presedens yang lebih tinggi daripada yang set yang lebih kecil, jika semua pengenal sebelumnya sama.
          
        

        Contoh: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
      
    
  


Grammar Bentuk Backus–Naur untuk Versi SemVer Valid
<semver valid> ::= <inti versi>
                 | <inti versi> "-" <prarilis>
                 | <inti versi> "+" <build>
                 | <inti versi> "-" <prarilis> "+" <build>

<inti versi> ::= <major> "." <minor> "." <patch>

<major> ::= <pengenal numerik>

<minor> ::= <pengenal numerik>

<patch> ::= <pengenal numerik>

<prarilis> ::= <pengenal prarilis dengan pemisah titik>

<pengenal prarilis dengan pemisah titik> ::= <pengenal prarilis>
                                           | <pengenal prarilis> "." <pengenal prarilis dengan pemisah titik>

<build> ::= <pengenal buld dengan pemisah titik>

<pengenal buld dengan pemisah titik> ::= <pengenal build>
                                       | <pengenal build> "." <pengenal buld dengan pemisah titik>

<pengenal prarilis> ::= <pengenal alfanumerik>
                      | <pengenal numerik>

<pengenal build> ::= <pengenal alfanumerik>
                   | <angka-angka>

<pengenal alfanumerik> ::= <nonangka>
                         | <nonangka> <karakter-karakter pengenal>
                         | <karakter-karakter pengenal> <nonangka>
                         | <karakter-karakter pengenal> <nonangka> <karakter-karakter pengenal>

<pengenal numerik> ::= "0"
                     | <angka positif>
                     | <angka positif> <angka-angka>

<karakter-karakter pengenal> ::= <karakter pengenal>
                               | <karakter pengenal> <karakter-karakter pengenal>

<karakter pengenal> ::= <angka>
                      | <nonangka>

<nonangka> ::= <huruf>
             | "-"

<angka-angka> ::= <angka>
                | <angka> <angka-angka>

<angka> ::= "0"
          | <angka positif>

<angka positif> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<huruf> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
          | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
          | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
          | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
          | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
          | "y" | "z"


Kenapa Menggunakan Pemversian Semantik?

Ini bukanlah ide baru yang revolusioner. Faktanya, kalian mungkin sudah menggunakan standar ini, hanya saja tidak terlalu ketat. Masalahnya, “tidak teralu ketat” saja tidak cukup bagus. Tanpa kepatuhan terhadap beberapa jenis spesifikasi formal, nomor versi adalah pada dasarnya tidak berguna untuk manajemen dependensi. Dengan memberikan nama dan definisi yang jelas definisi yang jelas untuk ide-ide tersebut, mengkomunikasikan maksud Anda kepada pengguna perangkat lunak Anda menjadi lebih mudah. Setelah maksud ini jelas, spesifikasi ketergantungan yang fleksibel (tetapi tidak terlalu fleksibel) akhirnya dapat dibuat.

Contoh sederhana ini menunjukkan manfaat Pemversian Semantik untuk menghilangkan “dependency hell.” Misalkan ada sebuah modul bernama “MobilPemadamKebakaran”. Modul “MobilPemadamKebakaran” membutuhkan modul lain bernama “Tangga”. Pada waktu “MobilPemadamKebakaran” dibuat, “Tangga” memiliki versi 3.1.0. Dengan menggunakan Pemversian Semantik, “MobilPemadamKebakaran” bisa dengan yakin menggunakan modul “Tangga” selama modul tersebut mempunyai versi antara 3.1.0 sampai dengan sebelum versi 4.0.0.

Sebagai pengembang yang bertanggung jawab, tentu saja Anda ingin memverifikasi bahwa peningkatan paket berfungsi seperti yang diiklankan. Dunia nyata tidaklah pasti; tidak ada yang bisa kita lakukan selain waspada. Yang bisa Anda lakukan adalah membiarkan Pemversian Semantik memberi Anda cara yang masuk akal untuk merilis dan memutakhirkan paket tanpa harus menggulirkan versi baru dari paket dependen, membuat Anda menghemat waktu dan kerumitan.

Jika menurut kalian aturan ini bagus, cara untuk memulai menggunakan pemversian semantik adalah dengan menautkan situs ini dalam README kalian supaya orang lain bisa tahu mengenai aturan ini dan mulai menggunakannya juga.

Pertanyaan Yang Sering Diajukan

Bagaimana cara menangani revisi dalam fase pengembangan awal 0.y.z?

Hal yang paling sederhana untuk dilakukan adalah memulai rilis pengembangan awal Anda pada 0.1.0 dan kemudian meningkatkan versi minor untuk setiap rilis berikutnya.

Bagaimana saya tahu kapan merilis 1.0.0?

Jika perangkat lunak Anda digunakan dalam produksi, mungkin perangkat lunak Anda sudah versi 1.0.0. Jika Anda memiliki API yang stabil yang menjadi andalan pengguna, Anda harusnya sudah pada 1.0.0. Jika Anda sangat mengkhawatirkan kompatibilitas versi lama, Anda mungkin sudah pada 1.0.0.

Bukankah standar ini mencegah perkembangan yang cepat?

Versi major nol adalah tentang pengembangan yang cepat. Jika Anda mengubah API setiap hari, Anda harus tetap berada di versi 0.y.z atau di pengembangan terpisah yang bekerja pada versi major berikutnya.

Jika perubahan terkecil yang tidak kompatibel dengan API publik memerlukan kenaikkan versi major, bukankah saya akan berakhir di versi 42.0.0 dengan sangat cepat?

Ini adalah pertanyaan tentang pengembangan yang bertanggung jawab dan pandangan ke depan. Perubahan yang tidak kompatibel tidak boleh diperkenalkan dengan mudah ke perangkat lunak yang memiliki banyak kode dependen. Biaya yang harus dikeluarkan untuk meng-upgrade bisa sangat besar. Kewajiban mengganti versi major untuk merilis perubahan yang tidak kompatibel seharusnya membuat Anda memikirkan dampak dari perubahan Anda, dan mengevaluasi perbandingan biaya dan manfaat yang terkait.

Mendokumentasikan seluruh API publik sangatlah merepotkan!

Sudah tanggung jawab Anda sebagai pengembang profesional untuk mendokumentasikan perangkat lunak untuk digunakan oleh orang lain dengan benar. Mengelola kompleksitas perangkat lunak adalah bagian yang sangat penting dalam menjaga proyek tetap efisien, dan itu sulit dilakukan jika tidak ada yang tahu cara menggunakan perangkat lunak Anda, atau metode apa yang aman untuk dihubungi. Dalam jangka panjang, Pemversian Semantik, dan desakan pada API publik yang terdefinisi dengan baik dapat membuat semua orang dan segala sesuatu berjalan dengan lancar.

Bagaimana jika secara tidak sengaja membuat perubahan yang menjadikan versi lama tidak bisa dipakai?

Setelah Anda menyadari bahwa Anda telah melanggar spesifikasi Pemversian Semantik, perbaiki dan rilis versi minor baru yang memperbaiki masalah dan mengembalikan kompatibilitas versi lama. Bahkan dalam kondisi ini, memodifikasi rilis yang telah diberi versi adalah dilarang. Jika mau, dokumentasikan versi yang bermasalah dan memberi tahu pengguna Anda tentang masalah tersebut sehingga mereka mengetahui versi yang bermasalah.

Apa yang harus saya lakukan jika saya memperbarui dependensi saya sendiri tanpa mengubah API publik?

Hal tersebut dianggap kompatibel karena tidak mempengaruhi API publik. Perangkat lunak yang secara eksplisit bergantung pada dependensi yang sama dengan paket Anda harus memiliki spesifikasi dependensi mereka sendiri dan pembuatnya akan memberi tahu konflik yang ada. Menentukan apakah perubahan tersebut merupakan tingkat patch atau tingkat minor  tergantung pada apakah Anda memperbarui dependensi untuk memperbaiki bug atau memperkenalkan fungsionalitas baru. Kami biasanya mengharapkan kode tambahan untuk contoh yang kedua, yang dalam hal ini jelas merupakan kenaikan tingkat minor.

Bagaimana jika saya secara tidak sengaja mengubah API publik dengan cara yang tidak sesuai dengan perubahan nomor versi (misalnya, kode secara tidak benar memperkenalkan perubahan besar dalam rilis patch)?

Gunakan kebijakan terbaik Anda. Jika Anda memiliki audiens yang sangat besar yang akan terpengaruh secara drastis dengan apa yang dimaksudkan oleh API publik, maka lebih baik melakukan rilis versi major, meskipun perbaikannya dapat sangat dianggap sebagai rilis patch. Ingat, Pemversian Semantik adalah segalanya tentang menyampaikan makna melalui perubahan nomor versi. Jika perubahan ini perubahan ini penting bagi pengguna Anda, gunakan nomor versi itu untuk memberi tahu mereka.

Bagaimana cara menangani fungsionalitas yang sudah diusangkan?

Mengusangkan fungsionalitas yang ada adalah hal yang lumrah dalam pengembangan perangkat lunak dan sering kali diperlukan untuk membuat suatu kemajuan. Ketika Anda mengusangkan bagian  dari API publik Anda, Anda harus melakukan dua hal: (1) memperbarui dokumentasi Anda untuk memberi tahu pengguna tahu tentang perubahan tersebut, dan (2) mengeluarkan rilis minor baru dengan penghentian yang baru dengan pengusangan itu dibuat. Sebelum Anda benar-benar menghapus fungsionalitas dalam rilis major yang baru harus ada setidaknya satu rilis minor yang berisi pengusangan itu sehingga pengguna dapat beralih dengan lancar ke API yang baru.

Apakah Versi Semantik punya batasan jumlah karakter dalam versi?

Tidak, tetapi gunakan kebijakan yang baik. Misalnya, versi dengan panjang 255 karakter mungkin teralu banyak. Selain itu, sistem tertentu mungkin memiliki batasan mereka sendiri pada ukuran string.

Apakah ada regular expression (RegEx) yang disarankan untuk memeriksa string SemVer?

Ada dua. Satu dengan grup bernama untuk sistem yang didukung (PCRE [Perl Compatible Regular Expressions, yaitu Perl, PHP dan R], Python dan Go).

Lihat: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Dan satu lagi dengan kelompok tangkapan bernomor (jadi cg1 = major, cg2 = minor, cg3 = patch, cg4 = prarilis dan cg5 = build metadata) yang kompatibel dengan ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
yaitu Perl, PHP dan R), Python dan Go.

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Tentang

Spesifikasi Pemversian Semantik awalnya dibuat oleh Tom Preston-Werner, pembuat Gravatar dan cofounder dari GitHub.

Terjemahan Bahasa Indonesia ditulis oleh Aditya Purwa, Christian B. Wibowo, dan Hans5958.

Untuk saran dan kritik, silahkan buka issue di GitHub.

Lisensi

Creative Commons ― CC BY 3.0\nPemversian Semantik 2.0.0\nVersi semantik ditulis dalam bentuk MAJOR.MINOR.PATCH, dengan:\nTambah angka versi MAJOR jika membuat perubahan API yang tidak lagi cocok dengan versi sebelumnya.\nTambah angka versi MINOR jika menambah fitur tanpa membuat versi lama tidak bisa digunakan.\nTambah angka versi PATCH jika ada perbaikan bug tanpa membuat versi lama tidak bisa digunakan.\nTambahan label dan versi sebelum rilis atau info tambahan tersedia sebagai ekstensi dari format
MAJOR.MINOR.PATCH.\nDalam pengembangan perangkat lunak, sering terjadi permasalahan dependency hell. Semakin besar sistem yang dibuat dan semakin banyak modul yang digunakan sistem kita, semakin sering permasalahan ini akan terjadi.\nDalam sistem yang saling terkait, merilis versi baru bisa menjadi mimpi buruk. Jika spesifikasi dependensi sistem terlalu ketat, bisa jadi sistem kita tidak bisa dikembangkan lagi. Jika spesifikasi dependensi sistem terlalu bebas, semakin sulit untuk berasumsi versi mana yang bisa digunakan dengan versi yang lain. Dependency hell adalah saat Anda berada pada satu atau dua masalah ini, yang menahan Anda untuk bergerak maju dengan aman dan mudah.\nSebagai solusi permasalahan ini, kami mengusulkan seperangkat aturan dan persayaratan sederhana yang menentukan bagaimana nomor versi diberikan dan bertambah. Aturan-aturan ini didasarkan pada, namun tidak terbatas pada, praktik-praktik yang sudah ada pada perangkat lunak sumber terbuka dan tertutup. Agar sistem ini dapat bekerja, Anda harus mengumumkan API publik terlebih dahulu. Ini dapat terdiri dari dokumentasi atau diberlakukan oleh kode itu sendiri. Apapun itu, API ini harus jelas dan tepat. Setelah Anda mengidentifikasi API publik Anda, Anda mengomunikasikan perubahan pada API tersebut dengan penambahan spesifik pada nomor versi Anda. Pertimbangkan format versi X.Y.Z (Major.Minor.Patch). Perbaikan bug yang tidak memengaruhi API tersebut akan menambah versi patch, penambahan/perubahan API yang kompatibel dengan versi sebelumnya akan menambah versi minor, dan perubahan API yang tidak kompatibel dengan versi sebelumnya akan menambah versi major.\nStandar ini bernama “Pemversian Semantik”. Dengan skema ini, setiap orang yang melihat angka versi bisa tahu secara umum apa yang berubah dengan sistem tersebut.\nSpesifikasi Pemversian Semantik (SemVer)\nKata/frasa “HARUS” (“MUST”), “TIDAK BOLEH” (“MUST NOT”), “DIBUTUHKAN” (“REQUIRED”), “SEHARUSNYA” (“SHALL”), “JANGAN SAMPAI” (“SHALL NOT”), “SEBAIKNYA” (“SHOULD”), “SEBAIKNYA TIDAK” (“SHOULD NOT”), “DIREKOMENDASIKAN” (“RECOMMENDED”), “BISA” (“MAY”) di dokumen ini sesuai dengan RFC 2119.\nPerangkat lunak dengan Pemversian Semantik HARUS menentukan API public. Bisa dijelaskan dengan kode, atau ditulis di dokumentasi saja. Apapun itu HARUS ditulis dengan jelas dan akurat.\nPerangkat lunak dengan Pemversian Semantik HARUS menentukan API public. Bisa dijelaskan dengan kode, atau ditulis di dokumentasi saja. Apapun itu HARUS ditulis dengan jelas dan akurat.\nVersi normal HARUS ditulis dalam bentuk X.Y.Z, dengan X, Y, dan Z adalah bilangan bulat nonnegatif, dan TIDAK BOLEH didahului angka 0 (contoh 01.02.03). X adalah versi major, Y adalah minor, dan Z adalah patch. Setiap elemen HARUS bertambah secara numerik dengan kenaikan sebesar satu. Contohnya: 1.9.0 -> 1.10.0 -> 1.11.0\nVersi normal HARUS ditulis dalam bentuk X.Y.Z, dengan X, Y, dan Z adalah bilangan bulat nonnegatif, dan TIDAK BOLEH didahului angka 0 (contoh 01.02.03). X adalah versi major, Y adalah minor, dan Z adalah patch. Setiap elemen HARUS bertambah secara numerik dengan kenaikan sebesar satu. Contohnya: 1.9.0 -> 1.10.0 -> 1.11.0\nSetelah sebuah paket berversi dirilis, isi dari versi tersebut TIDAK BOLEH diubah. Setiap perubahan HARUS dirilis sebagai versi baru.\nSetelah sebuah paket berversi dirilis, isi dari versi tersebut TIDAK BOLEH diubah. Setiap perubahan HARUS dirilis sebagai versi baru.\nVersi major 0 (0.y.z) adalah untuk pengembangan awal. Apapun BISA bisa berubah kapan saja. API publik SEBAIKNYA
dianggap tidak stabil di versi ini.\nVersi major 0 (0.y.z) adalah untuk pengembangan awal. Apapun BISA bisa berubah kapan saja. API publik SEBAIKNYA
dianggap tidak stabil di versi ini.\nVersi 1.0.0 adalah titik awal API publik. Cara nomor versi ini dinaikkan setelah rilis ini adalah tergantung dengan API publik ini dan bagaimana ia berubah.\nVersi 1.0.0 adalah titik awal API publik. Cara nomor versi ini dinaikkan setelah rilis ini adalah tergantung dengan API publik ini dan bagaimana ia berubah.\nVersi patch Z (x.y.Z | x > 0) HARUS dinaikkan jika ada perbaikan bug yang kompatibel dengan versi lama. Sebuah perbaikan bug didefinisikan sebagai perubahan internal yang memperbaiki perilaku yang salah.\nVersi patch Z (x.y.Z | x > 0) HARUS dinaikkan jika ada perbaikan bug yang kompatibel dengan versi lama. Sebuah perbaikan bug didefinisikan sebagai perubahan internal yang memperbaiki perilaku yang salah.\nVersi minor Y (x.Y.z | x > 0) HARUS dinaikkan jika ada fitur baru yang kompatibel dengan versi lama dalam API publik. Ini HARUS dinaikkan jika sebuah fungsionalitas API publik dibuat usang. Ini BISA dinaikkan jika ada tambahan fungsionalitas substansial atau terjadi peningkatan di dalam kode privat. Ini BISA diubah bersama dengan perubahan tingkat patch. Versi patch HARUS dikembalikan ke angka 0 jika versi minor dinaikkan.\nVersi minor Y (x.Y.z | x > 0) HARUS dinaikkan jika ada fitur baru yang kompatibel dengan versi lama dalam API publik. Ini HARUS dinaikkan jika sebuah fungsionalitas API publik dibuat usang. Ini BISA dinaikkan jika ada tambahan fungsionalitas substansial atau terjadi peningkatan di dalam kode privat. Ini BISA diubah bersama dengan perubahan tingkat patch. Versi patch HARUS dikembalikan ke angka 0 jika versi minor dinaikkan.\nVersi major X (X.y.z | X > 0) HARUS dinaikkan jika ada perubahan yang membuat versi baru tidak kompatibel dengan versi lama pada API publik. Ini juga BISA diubah bersama dengan perubahan tingkat patch dan minor. Versi minor dan patch HARUS dikembalikan ke angka 0 jika versi major dinaikkan.\nVersi major X (X.y.z | X > 0) HARUS dinaikkan jika ada perubahan yang membuat versi baru tidak kompatibel dengan versi lama pada API publik. Ini juga BISA diubah bersama dengan perubahan tingkat patch dan minor. Versi minor dan patch HARUS dikembalikan ke angka 0 jika versi major dinaikkan.\nVersi prarilis BISA ditulis dengan menambahkan tanda hubung dan rangkaian pengenal dengan pemisah titik tepat setelah versi patch. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda hubung [0-9A-Za-z]. Pengenal TIDAK BOLEH kosong. Pengenal numerik TIDAK BOLEH didahului angka 0. Versi prarilis memiliki presendens yang lebih rendah dibandingkan dengan versi normal yang terkait. Versi prarilis dianggap tidak stabil dan mungkin tidak memuaskan persyaratan kompatibilitas yang dimaksudkan seperti yang ditunjukkan oleh versi normal yang terkait. Contoh: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92, 1.0.0-x-y-z.--.\nVersi prarilis BISA ditulis dengan menambahkan tanda hubung dan rangkaian pengenal dengan pemisah titik tepat setelah versi patch. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda hubung [0-9A-Za-z]. Pengenal TIDAK BOLEH kosong. Pengenal numerik TIDAK BOLEH didahului angka 0. Versi prarilis memiliki presendens yang lebih rendah dibandingkan dengan versi normal yang terkait. Versi prarilis dianggap tidak stabil dan mungkin tidak memuaskan persyaratan kompatibilitas yang dimaksudkan seperti yang ditunjukkan oleh versi normal yang terkait. Contoh: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92, 1.0.0-x-y-z.--.\nBuild metadata BISA ditulis didahului dengan tanda tambah dan rangkaian pengenal dengan pemisah titik setelah versi patch atau prarilis. Build metadata HARUS ditulis dengan huruf ASCII alfanumerik dan tanda hubung [0-9A-Za-z]. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda hubung [0-9A-Za-z]. Pengenal TIDAK BOLEH kosong. Build metadata HARUS diabaikan saat menentukan presedens versi. Dengan begitu, dua versi yang berbada hanya di build metadata-nya memiliki preseden yang sama. Contoh: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3----117B344092BD.\nBuild metadata BISA ditulis didahului dengan tanda tambah dan rangkaian pengenal dengan pemisah titik setelah versi patch atau prarilis. Build metadata HARUS ditulis dengan huruf ASCII alfanumerik dan tanda hubung [0-9A-Za-z]. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda hubung [0-9A-Za-z]. Pengenal TIDAK BOLEH kosong. Build metadata HARUS diabaikan saat menentukan presedens versi. Dengan begitu, dua versi yang berbada hanya di build metadata-nya memiliki preseden yang sama. Contoh: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3----117B344092BD.\nPresedens mengacu pada bagaimana versi-versi dibandingkan satu sama lain ketika diurutkan.

    
      
        Presedens HARUS dihitung dengan memisahkan versi menjadi pengenal major, minor, patch, dan prarilis dalam urutan tersebut (Build metadata tidak diperhitungkan dalam pengurutan).
      
      
        Presedens ditentukan oleh perbedaan pertama saat membandingkan masing-masing pengenal ini dari kiri ke kanan sebagai berikut: Major, minor, dan patch selalu dibandingkan secara numerik.

        Contoh: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Saat versi major, minor, dan patch sama, versi prarilis lebih rendah memiliki presedens lebih rendah dibandingkan dengan versi normal:

        Contoh: 1.0.0-alpha < 1.0.0.
      
      
        Prioritas untuk dua versi prarilis dengan versi major, minor, dan patch HARUS ditentukan dengan membandingkan setiap pengenal yang dipisahkan titik dari kiri ke kanan hingga ditemukan perbedaan sebagai berikut:

        
          
            Pengenal yang hanya terdiri dari angka dibandingkan secara numerik.
          
          
            Pengenal dengan huruf atau tanda hubung dibandingkan secara leksikal dalam urutan pengurutan ASCII.
          
          
            Pengenal numerik selalu memiliki presedens yang lebih rendah daripada pengenal non-numerik pengenal non-numerik.
          
          
            Suatu set yang lebih besar dari bidang prarilis memiliki presedens yang lebih tinggi daripada yang set yang lebih kecil, jika semua pengenal sebelumnya sama.
          
        

        Contoh: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPresedens mengacu pada bagaimana versi-versi dibandingkan satu sama lain ketika diurutkan.\nPresedens HARUS dihitung dengan memisahkan versi menjadi pengenal major, minor, patch, dan prarilis dalam urutan tersebut (Build metadata tidak diperhitungkan dalam pengurutan).\nPresedens HARUS dihitung dengan memisahkan versi menjadi pengenal major, minor, patch, dan prarilis dalam urutan tersebut (Build metadata tidak diperhitungkan dalam pengurutan).\nPresedens ditentukan oleh perbedaan pertama saat membandingkan masing-masing pengenal ini dari kiri ke kanan sebagai berikut: Major, minor, dan patch selalu dibandingkan secara numerik.

        Contoh: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nPresedens ditentukan oleh perbedaan pertama saat membandingkan masing-masing pengenal ini dari kiri ke kanan sebagai berikut: Major, minor, dan patch selalu dibandingkan secara numerik.\nContoh: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nSaat versi major, minor, dan patch sama, versi prarilis lebih rendah memiliki presedens lebih rendah dibandingkan dengan versi normal:

        Contoh: 1.0.0-alpha < 1.0.0.\nSaat versi major, minor, dan patch sama, versi prarilis lebih rendah memiliki presedens lebih rendah dibandingkan dengan versi normal:\nContoh: 1.0.0-alpha < 1.0.0.\nPrioritas untuk dua versi prarilis dengan versi major, minor, dan patch HARUS ditentukan dengan membandingkan setiap pengenal yang dipisahkan titik dari kiri ke kanan hingga ditemukan perbedaan sebagai berikut:

        
          
            Pengenal yang hanya terdiri dari angka dibandingkan secara numerik.
          
          
            Pengenal dengan huruf atau tanda hubung dibandingkan secara leksikal dalam urutan pengurutan ASCII.
          
          
            Pengenal numerik selalu memiliki presedens yang lebih rendah daripada pengenal non-numerik pengenal non-numerik.
          
          
            Suatu set yang lebih besar dari bidang prarilis memiliki presedens yang lebih tinggi daripada yang set yang lebih kecil, jika semua pengenal sebelumnya sama.
          
        

        Contoh: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPrioritas untuk dua versi prarilis dengan versi major, minor, dan patch HARUS ditentukan dengan membandingkan setiap pengenal yang dipisahkan titik dari kiri ke kanan hingga ditemukan perbedaan sebagai berikut:\nPengenal yang hanya terdiri dari angka dibandingkan secara numerik.\nPengenal yang hanya terdiri dari angka dibandingkan secara numerik.\nPengenal dengan huruf atau tanda hubung dibandingkan secara leksikal dalam urutan pengurutan ASCII.\nPengenal dengan huruf atau tanda hubung dibandingkan secara leksikal dalam urutan pengurutan ASCII.\nPengenal numerik selalu memiliki presedens yang lebih rendah daripada pengenal non-numerik pengenal non-numerik.\nPengenal numerik selalu memiliki presedens yang lebih rendah daripada pengenal non-numerik pengenal non-numerik.\nSuatu set yang lebih besar dari bidang prarilis memiliki presedens yang lebih tinggi daripada yang set yang lebih kecil, jika semua pengenal sebelumnya sama.\nSuatu set yang lebih besar dari bidang prarilis memiliki presedens yang lebih tinggi daripada yang set yang lebih kecil, jika semua pengenal sebelumnya sama.\nContoh: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nGrammar Bentuk Backus–Naur untuk Versi SemVer Valid\n<semver valid> ::= <inti versi>
                 | <inti versi> "-" <prarilis>
                 | <inti versi> "+" <build>
                 | <inti versi> "-" <prarilis> "+" <build>

<inti versi> ::= <major> "." <minor> "." <patch>

<major> ::= <pengenal numerik>

<minor> ::= <pengenal numerik>

<patch> ::= <pengenal numerik>

<prarilis> ::= <pengenal prarilis dengan pemisah titik>

<pengenal prarilis dengan pemisah titik> ::= <pengenal prarilis>
                                           | <pengenal prarilis> "." <pengenal prarilis dengan pemisah titik>

<build> ::= <pengenal buld dengan pemisah titik>

<pengenal buld dengan pemisah titik> ::= <pengenal build>
                                       | <pengenal build> "." <pengenal buld dengan pemisah titik>

<pengenal prarilis> ::= <pengenal alfanumerik>
                      | <pengenal numerik>

<pengenal build> ::= <pengenal alfanumerik>
                   | <angka-angka>

<pengenal alfanumerik> ::= <nonangka>
                         | <nonangka> <karakter-karakter pengenal>
                         | <karakter-karakter pengenal> <nonangka>
                         | <karakter-karakter pengenal> <nonangka> <karakter-karakter pengenal>

<pengenal numerik> ::= "0"
                     | <angka positif>
                     | <angka positif> <angka-angka>

<karakter-karakter pengenal> ::= <karakter pengenal>
                               | <karakter pengenal> <karakter-karakter pengenal>

<karakter pengenal> ::= <angka>
                      | <nonangka>

<nonangka> ::= <huruf>
             | "-"

<angka-angka> ::= <angka>
                | <angka> <angka-angka>

<angka> ::= "0"
          | <angka positif>

<angka positif> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<huruf> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
          | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
          | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
          | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
          | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
          | "y" | "z"\n<semver valid> ::= <inti versi>
                 | <inti versi> "-" <prarilis>
                 | <inti versi> "+" <build>
                 | <inti versi> "-" <prarilis> "+" <build>

<inti versi> ::= <major> "." <minor> "." <patch>

<major> ::= <pengenal numerik>

<minor> ::= <pengenal numerik>

<patch> ::= <pengenal numerik>

<prarilis> ::= <pengenal prarilis dengan pemisah titik>

<pengenal prarilis dengan pemisah titik> ::= <pengenal prarilis>
                                           | <pengenal prarilis> "." <pengenal prarilis dengan pemisah titik>

<build> ::= <pengenal buld dengan pemisah titik>

<pengenal buld dengan pemisah titik> ::= <pengenal build>
                                       | <pengenal build> "." <pengenal buld dengan pemisah titik>

<pengenal prarilis> ::= <pengenal alfanumerik>
                      | <pengenal numerik>

<pengenal build> ::= <pengenal alfanumerik>
                   | <angka-angka>

<pengenal alfanumerik> ::= <nonangka>
                         | <nonangka> <karakter-karakter pengenal>
                         | <karakter-karakter pengenal> <nonangka>
                         | <karakter-karakter pengenal> <nonangka> <karakter-karakter pengenal>

<pengenal numerik> ::= "0"
                     | <angka positif>
                     | <angka positif> <angka-angka>

<karakter-karakter pengenal> ::= <karakter pengenal>
                               | <karakter pengenal> <karakter-karakter pengenal>

<karakter pengenal> ::= <angka>
                      | <nonangka>

<nonangka> ::= <huruf>
             | "-"

<angka-angka> ::= <angka>
                | <angka> <angka-angka>

<angka> ::= "0"
          | <angka positif>

<angka positif> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<huruf> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
          | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
          | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
          | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
          | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
          | "y" | "z"\nKenapa Menggunakan Pemversian Semantik?\nIni bukanlah ide baru yang revolusioner. Faktanya, kalian mungkin sudah menggunakan standar ini, hanya saja tidak terlalu ketat. Masalahnya, “tidak teralu ketat” saja tidak cukup bagus. Tanpa kepatuhan terhadap beberapa jenis spesifikasi formal, nomor versi adalah pada dasarnya tidak berguna untuk manajemen dependensi. Dengan memberikan nama dan definisi yang jelas definisi yang jelas untuk ide-ide tersebut, mengkomunikasikan maksud Anda kepada pengguna perangkat lunak Anda menjadi lebih mudah. Setelah maksud ini jelas, spesifikasi ketergantungan yang fleksibel (tetapi tidak terlalu fleksibel) akhirnya dapat dibuat.\nContoh sederhana ini menunjukkan manfaat Pemversian Semantik untuk menghilangkan “dependency hell.” Misalkan ada sebuah modul bernama “MobilPemadamKebakaran”. Modul “MobilPemadamKebakaran” membutuhkan modul lain bernama “Tangga”. Pada waktu “MobilPemadamKebakaran” dibuat, “Tangga” memiliki versi 3.1.0. Dengan menggunakan Pemversian Semantik, “MobilPemadamKebakaran” bisa dengan yakin menggunakan modul “Tangga” selama modul tersebut mempunyai versi antara 3.1.0 sampai dengan sebelum versi 4.0.0.\nSebagai pengembang yang bertanggung jawab, tentu saja Anda ingin memverifikasi bahwa peningkatan paket berfungsi seperti yang diiklankan. Dunia nyata tidaklah pasti; tidak ada yang bisa kita lakukan selain waspada. Yang bisa Anda lakukan adalah membiarkan Pemversian Semantik memberi Anda cara yang masuk akal untuk merilis dan memutakhirkan paket tanpa harus menggulirkan versi baru dari paket dependen, membuat Anda menghemat waktu dan kerumitan.\nJika menurut kalian aturan ini bagus, cara untuk memulai menggunakan pemversian semantik adalah dengan menautkan situs ini dalam README kalian supaya orang lain bisa tahu mengenai aturan ini dan mulai menggunakannya juga.\nPertanyaan Yang Sering Diajukan\nBagaimana cara menangani revisi dalam fase pengembangan awal 0.y.z?\nHal yang paling sederhana untuk dilakukan adalah memulai rilis pengembangan awal Anda pada 0.1.0 dan kemudian meningkatkan versi minor untuk setiap rilis berikutnya.\nBagaimana saya tahu kapan merilis 1.0.0?\nJika perangkat lunak Anda digunakan dalam produksi, mungkin perangkat lunak Anda sudah versi 1.0.0. Jika Anda memiliki API yang stabil yang menjadi andalan pengguna, Anda harusnya sudah pada 1.0.0. Jika Anda sangat mengkhawatirkan kompatibilitas versi lama, Anda mungkin sudah pada 1.0.0.\nBukankah standar ini mencegah perkembangan yang cepat?\nVersi major nol adalah tentang pengembangan yang cepat. Jika Anda mengubah API setiap hari, Anda harus tetap berada di versi 0.y.z atau di pengembangan terpisah yang bekerja pada versi major berikutnya.\nJika perubahan terkecil yang tidak kompatibel dengan API publik memerlukan kenaikkan versi major, bukankah saya akan berakhir di versi 42.0.0 dengan sangat cepat?\nIni adalah pertanyaan tentang pengembangan yang bertanggung jawab dan pandangan ke depan. Perubahan yang tidak kompatibel tidak boleh diperkenalkan dengan mudah ke perangkat lunak yang memiliki banyak kode dependen. Biaya yang harus dikeluarkan untuk meng-upgrade bisa sangat besar. Kewajiban mengganti versi major untuk merilis perubahan yang tidak kompatibel seharusnya membuat Anda memikirkan dampak dari perubahan Anda, dan mengevaluasi perbandingan biaya dan manfaat yang terkait.\nMendokumentasikan seluruh API publik sangatlah merepotkan!\nSudah tanggung jawab Anda sebagai pengembang profesional untuk mendokumentasikan perangkat lunak untuk digunakan oleh orang lain dengan benar. Mengelola kompleksitas perangkat lunak adalah bagian yang sangat penting dalam menjaga proyek tetap efisien, dan itu sulit dilakukan jika tidak ada yang tahu cara menggunakan perangkat lunak Anda, atau metode apa yang aman untuk dihubungi. Dalam jangka panjang, Pemversian Semantik, dan desakan pada API publik yang terdefinisi dengan baik dapat membuat semua orang dan segala sesuatu berjalan dengan lancar.\nBagaimana jika secara tidak sengaja membuat perubahan yang menjadikan versi lama tidak bisa dipakai?\nSetelah Anda menyadari bahwa Anda telah melanggar spesifikasi Pemversian Semantik, perbaiki dan rilis versi minor baru yang memperbaiki masalah dan mengembalikan kompatibilitas versi lama. Bahkan dalam kondisi ini, memodifikasi rilis yang telah diberi versi adalah dilarang. Jika mau, dokumentasikan versi yang bermasalah dan memberi tahu pengguna Anda tentang masalah tersebut sehingga mereka mengetahui versi yang bermasalah.\nApa yang harus saya lakukan jika saya memperbarui dependensi saya sendiri tanpa mengubah API publik?\nHal tersebut dianggap kompatibel karena tidak mempengaruhi API publik. Perangkat lunak yang secara eksplisit bergantung pada dependensi yang sama dengan paket Anda harus memiliki spesifikasi dependensi mereka sendiri dan pembuatnya akan memberi tahu konflik yang ada. Menentukan apakah perubahan tersebut merupakan tingkat patch atau tingkat minor  tergantung pada apakah Anda memperbarui dependensi untuk memperbaiki bug atau memperkenalkan fungsionalitas baru. Kami biasanya mengharapkan kode tambahan untuk contoh yang kedua, yang dalam hal ini jelas merupakan kenaikan tingkat minor.\nBagaimana jika saya secara tidak sengaja mengubah API publik dengan cara yang tidak sesuai dengan perubahan nomor versi (misalnya, kode secara tidak benar memperkenalkan perubahan besar dalam rilis patch)?\nGunakan kebijakan terbaik Anda. Jika Anda memiliki audiens yang sangat besar yang akan terpengaruh secara drastis dengan apa yang dimaksudkan oleh API publik, maka lebih baik melakukan rilis versi major, meskipun perbaikannya dapat sangat dianggap sebagai rilis patch. Ingat, Pemversian Semantik adalah segalanya tentang menyampaikan makna melalui perubahan nomor versi. Jika perubahan ini perubahan ini penting bagi pengguna Anda, gunakan nomor versi itu untuk memberi tahu mereka.\nBagaimana cara menangani fungsionalitas yang sudah diusangkan?\nMengusangkan fungsionalitas yang ada adalah hal yang lumrah dalam pengembangan perangkat lunak dan sering kali diperlukan untuk membuat suatu kemajuan. Ketika Anda mengusangkan bagian  dari API publik Anda, Anda harus melakukan dua hal: (1) memperbarui dokumentasi Anda untuk memberi tahu pengguna tahu tentang perubahan tersebut, dan (2) mengeluarkan rilis minor baru dengan penghentian yang baru dengan pengusangan itu dibuat. Sebelum Anda benar-benar menghapus fungsionalitas dalam rilis major yang baru harus ada setidaknya satu rilis minor yang berisi pengusangan itu sehingga pengguna dapat beralih dengan lancar ke API yang baru.\nApakah Versi Semantik punya batasan jumlah karakter dalam versi?\nTidak, tetapi gunakan kebijakan yang baik. Misalnya, versi dengan panjang 255 karakter mungkin teralu banyak. Selain itu, sistem tertentu mungkin memiliki batasan mereka sendiri pada ukuran string.\nApakah ada regular expression (RegEx) yang disarankan untuk memeriksa string SemVer?\nAda dua. Satu dengan grup bernama untuk sistem yang didukung (PCRE [Perl Compatible Regular Expressions, yaitu Perl, PHP dan R], Python dan Go).\nLihat: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nDan satu lagi dengan kelompok tangkapan bernomor (jadi cg1 = major, cg2 = minor, cg3 = patch, cg4 = prarilis dan cg5 = build metadata) yang kompatibel dengan ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
yaitu Perl, PHP dan R), Python dan Go.\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nSpesifikasi Pemversian Semantik awalnya dibuat oleh Tom Preston-Werner, pembuat Gravatar dan cofounder dari GitHub.\nTerjemahan Bahasa Indonesia ditulis oleh Aditya Purwa, Christian B. Wibowo, dan Hans5958.\nUntuk saran dan kritik, silahkan buka issue di GitHub.\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nPemversian Semantik 2.0.0-rc.2

Pendahuluan

Dalam pengembangan perangkat lunak, sering terjadi permasalahan dependency hell. Semakin besar sistem yang dibuat dan semakin banyak modul yang digunakan sistem kita, semakin sering permasalahan ini akan terjadi.

Dalam sistem yang saling terkait, merilis versi baru bisa menjadi mimpi buruk. Jika spesifikasi dependensi sistem terlalu ketat, bisa jadi sistem kita tidak bisa dikembangkan lagi. Jika spesifikasi dependensi sistem terlalu bebas, semakin sulit untuk berasumsi versi mana yang bisa digunakan dengan versi yang lain. Dependency hell adalah saat Anda berada pada satu atau dua masalah ini, yang menahan Anda untuk bergerak maju dengan aman dan mudah.

Sebagai solusi permasalahan ini, saya mengusulkan seperangkat aturan dan persayaratan sederhana yang menentukan bagaimana nomor versi diberikan dan bertambah. Agar sistem ini dapat bekerja, Anda harus mengumumkan API publik terlebih dahulu. Ini dapat terdiri dari dokumentasi atau diberlakukan oleh kode itu sendiri. Apapun itu, API ini harus jelas dan tepat. Setelah Anda mengidentifikasi API publik Anda, Anda mengomunikasikan perubahan pada API tersebut dengan penambahan spesifik pada nomor versi Anda. Pertimbangkan format versi X.Y.Z (Major.Minor.Patch). Perbaikan bug yang tidak memengaruhi API tersebut akan menambah versi patch, penambahan/perubahan API yang kompatibel dengan versi sebelumnya akan menambah versi minor, dan perubahan API yang tidak kompatibel dengan versi sebelumnya akan menambah versi major.

Standar ini bernama “Pemversian Semantik”. Dengan skema ini, setiap orang yang melihat angka versi bisa tahu secara umum apa yang berubah dengan sistem tersebut.

Spesifikasi Pemversian Semantik (SemVer)

Kata/frasa “HARUS” (“MUST”), “TIDAK BOLEH” (“MUST NOT”), “DIBUTUHKAN” (“REQUIRED”), “SEHARUSNYA” (“SHALL”), “JANGAN SAMPAI” (“SHALL NOT”), “SEBAIKNYA” (“SHOULD”), “SEBAIKNYA TIDAK” (“SHOULD NOT”), “DIREKOMENDASIKAN” (“RECOMMENDED”), “BISA” (“MAY”)  di dokumen ini sesuai dengan RFC 2119.


  
    Perangkat lunak dengan Pemversian Semantik HARUS menentukan API public. Bisa dijelaskan dengan kode, atau ditulis di dokumentasi saja. Apapun itu harus ditulis dengan jelas dan akurat.
  
  
    Versi normal HARUS ditulis dalam bentuk X.Y.Z, dengan X, Y, dan Z adalah bilangan bulat nonnegatif. X adalah versi major, Y adalah minor, dan Z adalah patch. Setiap elemen HARUS bertambah secara numerik dengan kenaikan sebesar satu. Contohnya: 1.9.0 -> 1.10.0 -> 1.11.0
  
  
    Setelah sebuah paket berversi dirilis, isi dari versi tersebut TIDAK BOLEH diubah. Setiap perubahan HARUS dirilis sebagai versi baru.
  
  
    Versi major 0 (0.y.z) adalah untuk pengembangan awal. Apapun bisa bisa berubah kapanpun. API publik sebaiknya dianggap tidak stabil di versi ini.
  
  
    Versi 1.0.0 adalah titik awal API publik. Cara nomor versi ini dinaikkan setelah rilis ini adalah tergantung dengan API publik ini dan bagaimana ia berubah.
  
  
    Versi patch Z (x.y.Z | x > 0) HARUS dinaikkan jika ada perbaikan bug yang kompatibel dengan versi lama. Sebuah perbaikan bug didefinisikan sebagai perubahan internal yang memperbaiki perilaku yang salah.
  
  
    Versi minor Y (x.Y.z | x > 0) HARUS dinaikkan jika ada fitur baru yang kompatibel dengan versi lama dalam API publik. Ini HARUS dinaikkan jika sebuah fungsionalitas API publik dibuat usang. Ini BISA dinaikkan jika ada tambahan fungsionalitas substansial atau terjadi peningkatan di dalam kode privat. Ini BISA diubah bersama dengan perubahan tingkat patch. Versi patch HARUS dikembalikan ke angka 0 jika versi minor dinaikkan.
  
  
    Versi major X (X.y.z | X > 0) HARUS dinaikkan jika ada perubahan yang membuat versi baru tidak kompatibel dengan versi lama pada API publik. Ini BISA diubah bersama dengan perubahan tingkat patch dan minor. Versi minor dan patch HARUS dikembalikan ke angka 0 jika versi major dinaikkan.
  
  
    Versi prarilis BISA ditulis dengan menambahkan tanda hubung dan rangkaian pengenal dengan pemisah titik tepat setelah versi patch. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda hubung [0-9A-Za-z]. Versi prarilis diperbolehkan, namun memiliki presendens yang lebih rendah dibandingkan dengan versi normal. Contoh: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Build metadata BISA ditulis didahului dengan tanda tambah dan rangkaian pengenal dengan pemisah titik setelah versi patch atau prarilis. Build metadata HARUS ditulis dengan huruf ASCII alfanumerik dan tanda hubung [0-9A-Za-z]. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda hubung [0-9A-Za-z]. Build metadata HARUS diabaikan saat menentukan presedens versi. Dengan begitu, dua versi yang berbada hanya di build metadata-nya memiliki versi yang sama. Contoh: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3----117B344092BD.
  
  
    Presedens HARUS dihitung dengan memisahkan versi menjadi pengenal major, minor, patch, dan prarilis dalam urutan tersebut (Build metadata tidak diperhitungkan dalam pengurutan). Presedens prarilis HARUS ditentukan dengan membandingkan setiap pengenal yang dipisahkan titik sebagai berikut: pengenal yang hanya terdiri dari angka dibandingkan secara numerik dan pengenal dengan huruf atau tanda hubung dibandingkan secara leksikal dalam urutan pengurutan ASCII. Pengenal numerik selalu memiliki prioritas yang lebih rendah daripada pengenal non-numerik. Contoh: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Kenapa Menggunakan Pemversian Semantik?

Ini bukanlah ide baru yang revolusioner. Faktanya, kalian mungkin sudah menggunakan standar ini, hanya saja tidak terlalu ketat. Masalahnya, “tidak teralu ketat” saja tidak cukup bagus. Tanpa kepatuhan terhadap beberapa jenis spesifikasi formal, nomor versi adalah pada dasarnya tidak berguna untuk manajemen dependensi. Dengan memberikan nama dan definisi yang jelas definisi yang jelas untuk ide-ide tersebut, mengkomunikasikan maksud Anda kepada pengguna perangkat lunak Anda menjadi lebih mudah. Setelah maksud ini jelas, spesifikasi ketergantungan yang fleksibel (tetapi tidak terlalu fleksibel) akhirnya dapat dibuat.

Contoh sederhana ini menunjukkan manfaat Pemversian Semantik untuk menghilangkan “dependency hell.” Misalkan ada sebuah modul bernama “MobilPemadamKebakaran”. Modul “MobilPemadamKebakaran” membutuhkan modul lain bernama “Tangga”. Pada waktu “MobilPemadamKebakaran” dibuat, “Tangga” memiliki versi 3.1.0. Dengan menggunakan Pemversian Semantik, “MobilPemadamKebakaran” bisa dengan yakin menggunakan modul “Tangga” selama modul tersebut mempunyai versi antara 3.1.0 sampai dengan sebelum versi 4.0.0.

Sebagai pengembang yang bertanggung jawab, tentu saja Anda ingin memverifikasi bahwa peningkatan paket berfungsi seperti yang diiklankan. Dunia nyata tidaklah pasti; tidak ada yang bisa kita lakukan selain waspada. Yang bisa Anda lakukan adalah membiarkan Pemversian Semantik memberi Anda cara yang masuk akal untuk merilis dan memutakhirkan paket tanpa harus menggulirkan versi baru dari paket dependen, membuat Anda menghemat waktu dan kerumitan.

Jika menurut kalian aturan ini bagus, cara untuk memulai menggunakan pemversian semantik adalah dengan menautkan situs ini dalam README kalian supaya orang lain bisa tahu mengenai aturan ini dan mulai menggunakannya juga.

Pertanyaan Yang Sering Diajukan

Bagaimana cara menangani revisi dalam fase pengembangan awal 0.y.z?

Hal yang paling sederhana untuk dilakukan adalah memulai rilis pengembangan awal Anda pada 0.1.0 dan kemudian meningkatkan versi minor untuk setiap rilis berikutnya.

Bagaimana saya tahu kapan merilis 1.0.0?

Jika perangkat lunak Anda digunakan dalam produksi, mungkin perangkat lunak Anda sudah versi 1.0.0. Jika Anda memiliki API yang stabil yang menjadi andalan pengguna, Anda harusnya sudah pada 1.0.0. Jika Anda sangat mengkhawatirkan kompatibilitas versi lama, Anda mungkin sudah pada 1.0.0.

Bukankah standar ini mencegah perkembangan yang cepat?

Versi major nol adalah tentang pengembangan yang cepat. Jika Anda mengubah API setiap hari, Anda harus tetap berada di versi 0.y.z atau di pengembangan terpisah yang bekerja pada versi major berikutnya.

Jika perubahan terkecil yang tidak kompatibel dengan API publik memerlukan kenaikkan versi major, bukankah saya akan berakhir di versi 42.0.0 dengan sangat cepat?

Ini adalah pertanyaan tentang pengembangan yang bertanggung jawab dan pandangan ke depan. Perubahan yang tidak kompatibel tidak boleh diperkenalkan dengan mudah ke perangkat lunak yang memiliki banyak kode dependen. Biaya yang harus dikeluarkan untuk meng-upgrade bisa sangat besar. Kewajiban mengganti versi major untuk merilis perubahan yang tidak kompatibel seharusnya membuat Anda memikirkan dampak dari perubahan Anda, dan mengevaluasi perbandingan biaya dan manfaat yang terkait.

Mendokumentasikan seluruh API publik sangatlah merepotkan!

Sudah tanggung jawab Anda sebagai pengembang profesional untuk mendokumentasikan perangkat lunak untuk digunakan oleh orang lain dengan benar. Mengelola kompleksitas perangkat lunak adalah bagian yang sangat penting dalam menjaga proyek tetap efisien, dan itu sulit dilakukan jika tidak ada yang tahu cara menggunakan perangkat lunak Anda, atau metode apa yang aman untuk dihubungi. Dalam jangka panjang, Pemversian Semantik, dan desakan pada API publik yang terdefinisi dengan baik dapat membuat semua orang dan segala sesuatu berjalan dengan lancar.

Bagaimana jika secara tidak sengaja membuat perubahan yang menjadikan versi lama tidak bisa dipakai?

Setelah Anda menyadari bahwa Anda telah melanggar spesifikasi Pemversian Semantik, perbaiki dan rilis versi minor baru yang memperbaiki masalah dan mengembalikan kompatibilitas versi lama. Bahkan dalam kondisi ini, memodifikasi rilis yang telah diberi versi adalah dilarang. Jika mau, dokumentasikan versi yang bermasalah dan memberi tahu pengguna Anda tentang masalah tersebut sehingga mereka mengetahui versi yang bermasalah.

Apa yang harus saya lakukan jika saya memperbarui dependensi saya sendiri tanpa mengubah API publik?

Hal tersebut dianggap kompatibel karena tidak mempengaruhi API publik. Perangkat lunak yang secara eksplisit bergantung pada dependensi yang sama dengan paket Anda harus memiliki spesifikasi dependensi mereka sendiri dan pembuatnya akan memberi tahu konflik yang ada. Menentukan apakah perubahan tersebut merupakan tingkat patch atau tingkat minor  tergantung pada apakah Anda memperbarui dependensi untuk memperbaiki bug atau memperkenalkan fungsionalitas baru. Saya biasanya mengharapkan kode tambahan untuk contoh yang kedua, yang dalam hal ini jelas merupakan kenaikan tingkat minor.

Apa yang harus saya lakukan jika bug yang sedang diperbaiki mengembalikan kode agar sesuai dengan API publik (misalnya, kode tidak sinkron dengan dokumentasi API publik)?

Gunakan kebijakan terbaik Anda. Jika Anda memiliki audiens yang sangat besar yang akan terpengaruh secara drastis dengan apa yang dimaksudkan oleh API publik, maka lebih baik melakukan rilis versi major, meskipun perbaikannya dapat sangat dianggap sebagai rilis patch. Ingat, Pemversian Semantik adalah segalanya tentang menyampaikan makna melalui perubahan nomor versi. Jika perubahan ini perubahan ini penting bagi pengguna Anda, gunakan nomor versi itu untuk memberi tahu mereka.

Bagaimana cara menangani fungsionalitas yang sudah diusangkan?

Mengusangkan fungsionalitas yang ada adalah hal yang lumrah dalam pengembangan perangkat lunak dan sering kali diperlukan untuk membuat suatu kemajuan. Ketika Anda mengusangkan bagian  dari API publik Anda, Anda harus melakukan dua hal: (1) memperbarui dokumentasi Anda untuk memberi tahu pengguna tahu tentang perubahan tersebut, dan (2) mengeluarkan rilis minor baru dengan penghentian yang baru dengan pengusangan itu dibuat. Sebelum Anda benar-benar menghapus fungsionalitas dalam rilis major yang baru harus ada setidaknya satu rilis minor yang berisi pengusangan itu sehingga pengguna dapat beralih dengan lancar ke API yang baru.

Tentang

Spesifikasi Pemversian Semantik dibuat oleh Tom Preston-Werner, pembuat Gravatars dan cofounder dari GitHub.

Terjemahan Bahasa Indonesia ditulis oleh Aditya Purwa, Christian B. Wibowo, dan Hans5958.

Untuk saran dan kritik, silahkan buka issue di GitHub.

Lisensi

Creative Commons ― CC BY 3.0\nPemversian Semantik 2.0.0-rc.2\nDalam pengembangan perangkat lunak, sering terjadi permasalahan dependency hell. Semakin besar sistem yang dibuat dan semakin banyak modul yang digunakan sistem kita, semakin sering permasalahan ini akan terjadi.\nDalam sistem yang saling terkait, merilis versi baru bisa menjadi mimpi buruk. Jika spesifikasi dependensi sistem terlalu ketat, bisa jadi sistem kita tidak bisa dikembangkan lagi. Jika spesifikasi dependensi sistem terlalu bebas, semakin sulit untuk berasumsi versi mana yang bisa digunakan dengan versi yang lain. Dependency hell adalah saat Anda berada pada satu atau dua masalah ini, yang menahan Anda untuk bergerak maju dengan aman dan mudah.\nSebagai solusi permasalahan ini, saya mengusulkan seperangkat aturan dan persayaratan sederhana yang menentukan bagaimana nomor versi diberikan dan bertambah. Agar sistem ini dapat bekerja, Anda harus mengumumkan API publik terlebih dahulu. Ini dapat terdiri dari dokumentasi atau diberlakukan oleh kode itu sendiri. Apapun itu, API ini harus jelas dan tepat. Setelah Anda mengidentifikasi API publik Anda, Anda mengomunikasikan perubahan pada API tersebut dengan penambahan spesifik pada nomor versi Anda. Pertimbangkan format versi X.Y.Z (Major.Minor.Patch). Perbaikan bug yang tidak memengaruhi API tersebut akan menambah versi patch, penambahan/perubahan API yang kompatibel dengan versi sebelumnya akan menambah versi minor, dan perubahan API yang tidak kompatibel dengan versi sebelumnya akan menambah versi major.\nStandar ini bernama “Pemversian Semantik”. Dengan skema ini, setiap orang yang melihat angka versi bisa tahu secara umum apa yang berubah dengan sistem tersebut.\nSpesifikasi Pemversian Semantik (SemVer)\nKata/frasa “HARUS” (“MUST”), “TIDAK BOLEH” (“MUST NOT”), “DIBUTUHKAN” (“REQUIRED”), “SEHARUSNYA” (“SHALL”), “JANGAN SAMPAI” (“SHALL NOT”), “SEBAIKNYA” (“SHOULD”), “SEBAIKNYA TIDAK” (“SHOULD NOT”), “DIREKOMENDASIKAN” (“RECOMMENDED”), “BISA” (“MAY”)  di dokumen ini sesuai dengan RFC 2119.\nPerangkat lunak dengan Pemversian Semantik HARUS menentukan API public. Bisa dijelaskan dengan kode, atau ditulis di dokumentasi saja. Apapun itu harus ditulis dengan jelas dan akurat.\nPerangkat lunak dengan Pemversian Semantik HARUS menentukan API public. Bisa dijelaskan dengan kode, atau ditulis di dokumentasi saja. Apapun itu harus ditulis dengan jelas dan akurat.\nVersi normal HARUS ditulis dalam bentuk X.Y.Z, dengan X, Y, dan Z adalah bilangan bulat nonnegatif. X adalah versi major, Y adalah minor, dan Z adalah patch. Setiap elemen HARUS bertambah secara numerik dengan kenaikan sebesar satu. Contohnya: 1.9.0 -> 1.10.0 -> 1.11.0\nVersi normal HARUS ditulis dalam bentuk X.Y.Z, dengan X, Y, dan Z adalah bilangan bulat nonnegatif. X adalah versi major, Y adalah minor, dan Z adalah patch. Setiap elemen HARUS bertambah secara numerik dengan kenaikan sebesar satu. Contohnya: 1.9.0 -> 1.10.0 -> 1.11.0\nSetelah sebuah paket berversi dirilis, isi dari versi tersebut TIDAK BOLEH diubah. Setiap perubahan HARUS dirilis sebagai versi baru.\nSetelah sebuah paket berversi dirilis, isi dari versi tersebut TIDAK BOLEH diubah. Setiap perubahan HARUS dirilis sebagai versi baru.\nVersi major 0 (0.y.z) adalah untuk pengembangan awal. Apapun bisa bisa berubah kapanpun. API publik sebaiknya dianggap tidak stabil di versi ini.\nVersi major 0 (0.y.z) adalah untuk pengembangan awal. Apapun bisa bisa berubah kapanpun. API publik sebaiknya dianggap tidak stabil di versi ini.\nVersi 1.0.0 adalah titik awal API publik. Cara nomor versi ini dinaikkan setelah rilis ini adalah tergantung dengan API publik ini dan bagaimana ia berubah.\nVersi 1.0.0 adalah titik awal API publik. Cara nomor versi ini dinaikkan setelah rilis ini adalah tergantung dengan API publik ini dan bagaimana ia berubah.\nVersi patch Z (x.y.Z | x > 0) HARUS dinaikkan jika ada perbaikan bug yang kompatibel dengan versi lama. Sebuah perbaikan bug didefinisikan sebagai perubahan internal yang memperbaiki perilaku yang salah.\nVersi patch Z (x.y.Z | x > 0) HARUS dinaikkan jika ada perbaikan bug yang kompatibel dengan versi lama. Sebuah perbaikan bug didefinisikan sebagai perubahan internal yang memperbaiki perilaku yang salah.\nVersi minor Y (x.Y.z | x > 0) HARUS dinaikkan jika ada fitur baru yang kompatibel dengan versi lama dalam API publik. Ini HARUS dinaikkan jika sebuah fungsionalitas API publik dibuat usang. Ini BISA dinaikkan jika ada tambahan fungsionalitas substansial atau terjadi peningkatan di dalam kode privat. Ini BISA diubah bersama dengan perubahan tingkat patch. Versi patch HARUS dikembalikan ke angka 0 jika versi minor dinaikkan.\nVersi minor Y (x.Y.z | x > 0) HARUS dinaikkan jika ada fitur baru yang kompatibel dengan versi lama dalam API publik. Ini HARUS dinaikkan jika sebuah fungsionalitas API publik dibuat usang. Ini BISA dinaikkan jika ada tambahan fungsionalitas substansial atau terjadi peningkatan di dalam kode privat. Ini BISA diubah bersama dengan perubahan tingkat patch. Versi patch HARUS dikembalikan ke angka 0 jika versi minor dinaikkan.\nVersi major X (X.y.z | X > 0) HARUS dinaikkan jika ada perubahan yang membuat versi baru tidak kompatibel dengan versi lama pada API publik. Ini BISA diubah bersama dengan perubahan tingkat patch dan minor. Versi minor dan patch HARUS dikembalikan ke angka 0 jika versi major dinaikkan.\nVersi major X (X.y.z | X > 0) HARUS dinaikkan jika ada perubahan yang membuat versi baru tidak kompatibel dengan versi lama pada API publik. Ini BISA diubah bersama dengan perubahan tingkat patch dan minor. Versi minor dan patch HARUS dikembalikan ke angka 0 jika versi major dinaikkan.\nVersi prarilis BISA ditulis dengan menambahkan tanda hubung dan rangkaian pengenal dengan pemisah titik tepat setelah versi patch. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda hubung [0-9A-Za-z]. Versi prarilis diperbolehkan, namun memiliki presendens yang lebih rendah dibandingkan dengan versi normal. Contoh: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nVersi prarilis BISA ditulis dengan menambahkan tanda hubung dan rangkaian pengenal dengan pemisah titik tepat setelah versi patch. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda hubung [0-9A-Za-z]. Versi prarilis diperbolehkan, namun memiliki presendens yang lebih rendah dibandingkan dengan versi normal. Contoh: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nBuild metadata BISA ditulis didahului dengan tanda tambah dan rangkaian pengenal dengan pemisah titik setelah versi patch atau prarilis. Build metadata HARUS ditulis dengan huruf ASCII alfanumerik dan tanda hubung [0-9A-Za-z]. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda hubung [0-9A-Za-z]. Build metadata HARUS diabaikan saat menentukan presedens versi. Dengan begitu, dua versi yang berbada hanya di build metadata-nya memiliki versi yang sama. Contoh: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3----117B344092BD.\nBuild metadata BISA ditulis didahului dengan tanda tambah dan rangkaian pengenal dengan pemisah titik setelah versi patch atau prarilis. Build metadata HARUS ditulis dengan huruf ASCII alfanumerik dan tanda hubung [0-9A-Za-z]. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda hubung [0-9A-Za-z]. Build metadata HARUS diabaikan saat menentukan presedens versi. Dengan begitu, dua versi yang berbada hanya di build metadata-nya memiliki versi yang sama. Contoh: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3----117B344092BD.\nPresedens HARUS dihitung dengan memisahkan versi menjadi pengenal major, minor, patch, dan prarilis dalam urutan tersebut (Build metadata tidak diperhitungkan dalam pengurutan). Presedens prarilis HARUS ditentukan dengan membandingkan setiap pengenal yang dipisahkan titik sebagai berikut: pengenal yang hanya terdiri dari angka dibandingkan secara numerik dan pengenal dengan huruf atau tanda hubung dibandingkan secara leksikal dalam urutan pengurutan ASCII. Pengenal numerik selalu memiliki prioritas yang lebih rendah daripada pengenal non-numerik. Contoh: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPresedens HARUS dihitung dengan memisahkan versi menjadi pengenal major, minor, patch, dan prarilis dalam urutan tersebut (Build metadata tidak diperhitungkan dalam pengurutan). Presedens prarilis HARUS ditentukan dengan membandingkan setiap pengenal yang dipisahkan titik sebagai berikut: pengenal yang hanya terdiri dari angka dibandingkan secara numerik dan pengenal dengan huruf atau tanda hubung dibandingkan secara leksikal dalam urutan pengurutan ASCII. Pengenal numerik selalu memiliki prioritas yang lebih rendah daripada pengenal non-numerik. Contoh: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nKenapa Menggunakan Pemversian Semantik?\nIni bukanlah ide baru yang revolusioner. Faktanya, kalian mungkin sudah menggunakan standar ini, hanya saja tidak terlalu ketat. Masalahnya, “tidak teralu ketat” saja tidak cukup bagus. Tanpa kepatuhan terhadap beberapa jenis spesifikasi formal, nomor versi adalah pada dasarnya tidak berguna untuk manajemen dependensi. Dengan memberikan nama dan definisi yang jelas definisi yang jelas untuk ide-ide tersebut, mengkomunikasikan maksud Anda kepada pengguna perangkat lunak Anda menjadi lebih mudah. Setelah maksud ini jelas, spesifikasi ketergantungan yang fleksibel (tetapi tidak terlalu fleksibel) akhirnya dapat dibuat.\nContoh sederhana ini menunjukkan manfaat Pemversian Semantik untuk menghilangkan “dependency hell.” Misalkan ada sebuah modul bernama “MobilPemadamKebakaran”. Modul “MobilPemadamKebakaran” membutuhkan modul lain bernama “Tangga”. Pada waktu “MobilPemadamKebakaran” dibuat, “Tangga” memiliki versi 3.1.0. Dengan menggunakan Pemversian Semantik, “MobilPemadamKebakaran” bisa dengan yakin menggunakan modul “Tangga” selama modul tersebut mempunyai versi antara 3.1.0 sampai dengan sebelum versi 4.0.0.\nSebagai pengembang yang bertanggung jawab, tentu saja Anda ingin memverifikasi bahwa peningkatan paket berfungsi seperti yang diiklankan. Dunia nyata tidaklah pasti; tidak ada yang bisa kita lakukan selain waspada. Yang bisa Anda lakukan adalah membiarkan Pemversian Semantik memberi Anda cara yang masuk akal untuk merilis dan memutakhirkan paket tanpa harus menggulirkan versi baru dari paket dependen, membuat Anda menghemat waktu dan kerumitan.\nJika menurut kalian aturan ini bagus, cara untuk memulai menggunakan pemversian semantik adalah dengan menautkan situs ini dalam README kalian supaya orang lain bisa tahu mengenai aturan ini dan mulai menggunakannya juga.\nPertanyaan Yang Sering Diajukan\nBagaimana cara menangani revisi dalam fase pengembangan awal 0.y.z?\nHal yang paling sederhana untuk dilakukan adalah memulai rilis pengembangan awal Anda pada 0.1.0 dan kemudian meningkatkan versi minor untuk setiap rilis berikutnya.\nBagaimana saya tahu kapan merilis 1.0.0?\nJika perangkat lunak Anda digunakan dalam produksi, mungkin perangkat lunak Anda sudah versi 1.0.0. Jika Anda memiliki API yang stabil yang menjadi andalan pengguna, Anda harusnya sudah pada 1.0.0. Jika Anda sangat mengkhawatirkan kompatibilitas versi lama, Anda mungkin sudah pada 1.0.0.\nBukankah standar ini mencegah perkembangan yang cepat?\nVersi major nol adalah tentang pengembangan yang cepat. Jika Anda mengubah API setiap hari, Anda harus tetap berada di versi 0.y.z atau di pengembangan terpisah yang bekerja pada versi major berikutnya.\nJika perubahan terkecil yang tidak kompatibel dengan API publik memerlukan kenaikkan versi major, bukankah saya akan berakhir di versi 42.0.0 dengan sangat cepat?\nIni adalah pertanyaan tentang pengembangan yang bertanggung jawab dan pandangan ke depan. Perubahan yang tidak kompatibel tidak boleh diperkenalkan dengan mudah ke perangkat lunak yang memiliki banyak kode dependen. Biaya yang harus dikeluarkan untuk meng-upgrade bisa sangat besar. Kewajiban mengganti versi major untuk merilis perubahan yang tidak kompatibel seharusnya membuat Anda memikirkan dampak dari perubahan Anda, dan mengevaluasi perbandingan biaya dan manfaat yang terkait.\nMendokumentasikan seluruh API publik sangatlah merepotkan!\nSudah tanggung jawab Anda sebagai pengembang profesional untuk mendokumentasikan perangkat lunak untuk digunakan oleh orang lain dengan benar. Mengelola kompleksitas perangkat lunak adalah bagian yang sangat penting dalam menjaga proyek tetap efisien, dan itu sulit dilakukan jika tidak ada yang tahu cara menggunakan perangkat lunak Anda, atau metode apa yang aman untuk dihubungi. Dalam jangka panjang, Pemversian Semantik, dan desakan pada API publik yang terdefinisi dengan baik dapat membuat semua orang dan segala sesuatu berjalan dengan lancar.\nBagaimana jika secara tidak sengaja membuat perubahan yang menjadikan versi lama tidak bisa dipakai?\nSetelah Anda menyadari bahwa Anda telah melanggar spesifikasi Pemversian Semantik, perbaiki dan rilis versi minor baru yang memperbaiki masalah dan mengembalikan kompatibilitas versi lama. Bahkan dalam kondisi ini, memodifikasi rilis yang telah diberi versi adalah dilarang. Jika mau, dokumentasikan versi yang bermasalah dan memberi tahu pengguna Anda tentang masalah tersebut sehingga mereka mengetahui versi yang bermasalah.\nApa yang harus saya lakukan jika saya memperbarui dependensi saya sendiri tanpa mengubah API publik?\nHal tersebut dianggap kompatibel karena tidak mempengaruhi API publik. Perangkat lunak yang secara eksplisit bergantung pada dependensi yang sama dengan paket Anda harus memiliki spesifikasi dependensi mereka sendiri dan pembuatnya akan memberi tahu konflik yang ada. Menentukan apakah perubahan tersebut merupakan tingkat patch atau tingkat minor  tergantung pada apakah Anda memperbarui dependensi untuk memperbaiki bug atau memperkenalkan fungsionalitas baru. Saya biasanya mengharapkan kode tambahan untuk contoh yang kedua, yang dalam hal ini jelas merupakan kenaikan tingkat minor.\nApa yang harus saya lakukan jika bug yang sedang diperbaiki mengembalikan kode agar sesuai dengan API publik (misalnya, kode tidak sinkron dengan dokumentasi API publik)?\nGunakan kebijakan terbaik Anda. Jika Anda memiliki audiens yang sangat besar yang akan terpengaruh secara drastis dengan apa yang dimaksudkan oleh API publik, maka lebih baik melakukan rilis versi major, meskipun perbaikannya dapat sangat dianggap sebagai rilis patch. Ingat, Pemversian Semantik adalah segalanya tentang menyampaikan makna melalui perubahan nomor versi. Jika perubahan ini perubahan ini penting bagi pengguna Anda, gunakan nomor versi itu untuk memberi tahu mereka.\nBagaimana cara menangani fungsionalitas yang sudah diusangkan?\nMengusangkan fungsionalitas yang ada adalah hal yang lumrah dalam pengembangan perangkat lunak dan sering kali diperlukan untuk membuat suatu kemajuan. Ketika Anda mengusangkan bagian  dari API publik Anda, Anda harus melakukan dua hal: (1) memperbarui dokumentasi Anda untuk memberi tahu pengguna tahu tentang perubahan tersebut, dan (2) mengeluarkan rilis minor baru dengan penghentian yang baru dengan pengusangan itu dibuat. Sebelum Anda benar-benar menghapus fungsionalitas dalam rilis major yang baru harus ada setidaknya satu rilis minor yang berisi pengusangan itu sehingga pengguna dapat beralih dengan lancar ke API yang baru.\nSpesifikasi Pemversian Semantik dibuat oleh Tom Preston-Werner, pembuat Gravatars dan cofounder dari GitHub.\nTerjemahan Bahasa Indonesia ditulis oleh Aditya Purwa, Christian B. Wibowo, dan Hans5958.\nUntuk saran dan kritik, silahkan buka issue di GitHub.\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nPemversian Semantik 2.0.0-rc.1

Dalam pengembangan perangkat lunak, sering terjadi permasalahan dependency hell. Semakin besar sistem yang dibuat dan semakin banyak modul yang digunakan sistem kita, semakin sering permasalahan ini akan terjadi.

Dalam sistem yang saling terkait, merilis versi baru bisa menjadi mimpi buruk. Jika spesifikasi dependensi sistem terlalu ketat, bisa jadi sistem kita tidak bisa dikembangkan lagi. Jika spesifikasi dependensi sistem terlalu bebas, semakin sulit untuk berasumsi versi mana yang bisa digunakan dengan versi yang lain. Dependency hell adalah saat Anda berada pada satu atau dua masalah ini, yang menahan Anda untuk bergerak maju dengan aman dan mudah.

Sebagai solusi permasalahan ini, saya mengusulkan seperangkat aturan dan persayaratan sederhana yang menentukan bagaimana nomor versi diberikan dan bertambah. Agar sistem ini dapat bekerja, Anda harus mengumumkan API publik terlebih dahulu. Ini dapat terdiri dari dokumentasi atau diberlakukan oleh kode itu sendiri. Apapun itu, API ini harus jelas dan tepat. Setelah Anda mengidentifikasi API publik Anda, Anda mengomunikasikan perubahan pada API tersebut dengan penambahan spesifik pada nomor versi Anda. Pertimbangkan format versi X.Y.Z (Major.Minor.Patch). Perbaikan bug yang tidak memengaruhi API tersebut akan menambah versi patch, penambahan/perubahan API yang kompatibel dengan versi sebelumnya akan menambah versi minor, dan perubahan API yang tidak kompatibel dengan versi sebelumnya akan menambah versi major.

Standar ini bernama “Pemversian Semantik”. Dengan skema ini, setiap orang yang melihat angka versi bisa tahu secara umum apa yang berubah dengan sistem tersebut.

Spesifikasi Pemversian Semantik (SemVer)

Kata/frasa “HARUS” (“MUST”), “TIDAK BOLEH” (“MUST NOT”), “DIBUTUHKAN” (“REQUIRED”), “SEHARUSNYA” (“SHALL”), “JANGAN SAMPAI” (“SHALL NOT”), “SEBAIKNYA” (“SHOULD”), “SEBAIKNYA TIDAK” (“SHOULD NOT”), “DIREKOMENDASIKAN” (“RECOMMENDED”), “BISA” (“MAY”)  di dokumen ini sesuai dengan RFC 2119.


  
    Perangkat lunak dengan Pemversian Semantik HARUS menentukan API public. Bisa dijelaskan dengan kode, atau ditulis di dokumentasi saja. Apapun itu harus ditulis dengan jelas dan akurat.
  
  
    Versi normal HARUS ditulis dalam bentuk X.Y.Z, dengan X, Y, dan Z adalah bilangan bulat nonnegatif. X adalah versi major, Y adalah minor, dan Z adalah patch. Setiap elemen HARUS bertambah secara numerik dengan kenaikan sebesar satu. Contohnya: 1.9.0 -> 1.10.0 -> 1.11.0
  
  
    Ketika nomor versi major bertambah, versi minor dan patch versi HARUS diatur ulang ke nol. Ketika nomor versi minor bertambah, nomor versi patch HARUS disetel ulang ke nol. Misalnya: 1.1.3 -> 2.0.0 dan 2.1.7 ->
2.2.0.
  
  
    Setelah sebuah paket berversi dirilis, isi dari versi tersebut TIDAK BOLEH diubah. Setiap perubahan harus dirilis sebagai versi baru.
  
  
    Versi major 0 (0.y.z) adalah untuk pengembangan awal. Apapun bisa bisa berubah kapanpun. API publik sebaiknya dianggap tidak stabil di versi ini.
  
  
    Versi 1.0.0 adalah titik awal API publik. Cara nomor versi ini dinaikkan setelah rilis ini adalah tergantung dengan API publik ini dan bagaimana ia berubah.
  
  
    Versi patch Z (x.y.Z | x > 0) HARUS dinaikkan jika ada perbaikan bug yang kompatibel dengan versi lama. Sebuah perbaikan bug didefinisikan sebagai perubahan internal yang memperbaiki perilaku yang salah.
  
  
    Versi minor Y (x.Y.z | x > 0) HARUS dinaikkan jika ada fitur baru yang kompatibel dengan versi lama dalam API publik. Ini HARUS dinaikkan jika sebuah fungsionalitas API publik dibuat usang. Ini BISA dinaikkan jika ada tambahan fungsionalitas substansial atau terjadi peningkatan di dalam kode privat. Ini BISA diubah bersama dengan perubahan tingkat patch. Versi patch HARUS dikembalikan ke angka 0 jika versi minor dinaikkan.
  
  
    Versi major X (X.y.z | X > 0) HARUS dinaikkan jika ada perubahan yang membuat versi baru tidak kompatibel dengan versi lama pada API publik. Ini BISA diubah bersama dengan perubahan tingkat patch dan minor. Versi minor dan patch HARUS dikembalikan ke angka 0 jika versi major dinaikkan.
  
  
    Versi prarilis BISA ditulis dengan menambahkan tanda pisah dan rangkaian pengenal dengan pemisah titik tepat setelah versi patch. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda pisah [0-9A-Za-z]. Versi prarilis diperbolehkan, namun memiliki presendens yang lebih rendah dibandingkan dengan versi normal. Contoh: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Sebuah versi build BISA ditulis didahului dengan tanda tambah dan rangkaian pengenal dengan pemisah titik setelah versi patch atau prarilis. Versi build HARUS ditulis dengan huruf ASCII alfanumerik dan tanda pisah [0-9A-Za-z]. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda pisah [0-9A-Za-z]. Versi build dapat digunakan dan memiliki presedens lebih tinggi dibandingkan versi normal yang terkait. Contoh: 1.0.0+build.1, 1.3.7+build.11.e0f985a.
  
  
    Presedens HARUS dihitung dengan memisahkan versi menjadi pengenal major, minor, patch, prarilis, dan pengenal build dalam urutan tersebut. Presedens prarilis dan pengenal build HARUS ditentukan dengan membandingkan setiap pengenal yang dipisahkan titik sebagai berikut: pengenal yang hanya terdiri dari angka dibandingkan secara numerik dan pengenal dengan huruf atau tanda pisah dibandingkan secara leksikal dalam urutan pengurutan ASCII. Pengenal numerik selalu memiliki prioritas yang lebih rendah daripada pengenal non-numerik. Contoh: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0-rc.1+build.1 < 1.0.0 < 1.0.0+0.3.7 < 1.3.7+build < 1.3.7+build.2.b8f12d7 < 1.3.7+build.11.e0f985a.
  


Kenapa Menggunakan Pemversian Semantik?

Ini bukanlah ide baru yang revolusioner. Faktanya, kalian mungkin sudah menggunakan standar ini, hanya saja tidak terlalu ketat. Masalahnya, “tidak teralu ketat” saja tidak cukup bagus. Tanpa kepatuhan terhadap beberapa jenis spesifikasi formal, nomor versi adalah pada dasarnya tidak berguna untuk manajemen dependensi. Dengan memberikan nama dan definisi yang jelas definisi yang jelas untuk ide-ide tersebut, mengkomunikasikan maksud Anda kepada pengguna perangkat lunak Anda menjadi lebih mudah. Setelah maksud ini jelas, spesifikasi ketergantungan yang fleksibel (tetapi tidak terlalu fleksibel) akhirnya dapat dibuat.

Contoh sederhana ini menunjukkan manfaat Pemversian Semantik untuk menghilangkan “dependency hell.” Misalkan ada sebuah modul bernama “MobilPemadamKebakaran”. Modul “MobilPemadamKebakaran” membutuhkan modul lain bernama “Tangga”. Pada waktu “MobilPemadamKebakaran” dibuat, “Tangga” memiliki versi 3.1.0. Dengan menggunakan Pemversian Semantik, “MobilPemadamKebakaran” bisa dengan yakin menggunakan modul “Tangga” selama modul tersebut mempunyai versi antara 3.1.0 sampai dengan sebelum versi 4.0.0.

Sebagai pengembang yang bertanggung jawab, tentu saja Anda ingin memverifikasi bahwa peningkatan paket berfungsi seperti yang diiklankan. Dunia nyata tidaklah pasti; tidak ada yang bisa kita lakukan selain waspada. Yang bisa Anda lakukan adalah membiarkan Pemversian Semantik memberi Anda cara yang masuk akal untuk merilis dan memutakhirkan paket tanpa harus menggulirkan versi baru dari paket dependen, membuat Anda menghemat waktu dan kerumitan.

Jika menurut kalian aturan ini bagus, cara untuk memulai menggunakan pemversian semantik adalah dengan menautkan situs ini dalam README kalian supaya orang lain bisa tahu mengenai aturan ini dan mulai menggunakannya juga.

Pertanyaan Yang Sering Diajukan

Bagaimana cara menangani revisi dalam fase pengembangan awal 0.y.z?

Hal yang paling sederhana untuk dilakukan adalah memulai rilis pengembangan awal Anda pada 0.1.0 dan kemudian meningkatkan versi minor untuk setiap rilis berikutnya.

Bagaimana saya tahu kapan merilis 1.0.0?

Jika perangkat lunak Anda digunakan dalam produksi, mungkin perangkat lunak Anda sudah versi 1.0.0. Jika Anda memiliki API yang stabil yang menjadi andalan pengguna, Anda harusnya sudah pada 1.0.0. Jika Anda sangat mengkhawatirkan kompatibilitas versi lama, Anda mungkin sudah pada 1.0.0.

Bukankah standar ini mencegah perkembangan yang cepat?

Versi major nol adalah tentang pengembangan yang cepat. Jika Anda mengubah API setiap hari, Anda harus tetap berada di versi 0.x.x atau di pengembangan terpisah yang bekerja pada versi major berikutnya.

Jika perubahan terkecil yang tidak kompatibel dengan API publik memerlukan kenaikkan versi major, bukankah saya akan berakhir di versi 42.0.0 dengan sangat cepat?

Ini adalah pertanyaan tentang pengembangan yang bertanggung jawab dan pandangan ke depan. Perubahan yang tidak kompatibel tidak boleh diperkenalkan dengan mudah ke perangkat lunak yang memiliki banyak kode dependen. Biaya yang harus dikeluarkan untuk meng-upgrade bisa sangat besar. Kewajiban mengganti versi major untuk merilis perubahan yang tidak kompatibel seharusnya membuat Anda memikirkan dampak dari perubahan Anda, dan mengevaluasi perbandingan biaya dan manfaat yang terkait.

Mendokumentasikan seluruh API publik sangatlah merepotkan!

Sudah tanggung jawab Anda sebagai pengembang profesional untuk mendokumentasikan perangkat lunak untuk digunakan oleh orang lain dengan benar. Mengelola kompleksitas perangkat lunak adalah bagian yang sangat penting dalam menjaga proyek tetap efisien, dan itu sulit dilakukan jika tidak ada yang tahu cara menggunakan perangkat lunak Anda, atau metode apa yang aman untuk dihubungi. Dalam jangka panjang, Pemversian Semantik, dan desakan pada API publik yang terdefinisi dengan baik dapat membuat semua orang dan segala sesuatu berjalan dengan lancar.

Bagaimana jika secara tidak sengaja membuat perubahan yang menjadikan versi lama tidak bisa dipakai?

Setelah Anda menyadari bahwa Anda telah melanggar spesifikasi Pemversian Semantik, perbaiki dan rilis versi minor baru yang memperbaiki masalah dan mengembalikan kompatibilitas versi lama. Ingat, memodifikasi rilis yang telah diberi versi adalah dilarang, bahkan dalam kondisi ini. Jika mau, dokumentasikan versi yang bermasalah dan memberi tahu pengguna Anda tentang masalah tersebut sehingga mereka mengetahui versi yang bermasalah.

Apa yang harus saya lakukan jika saya memperbarui dependensi saya sendiri tanpa mengubah API publik?

Hal tersebut dianggap kompatibel karena tidak mempengaruhi API publik. Perangkat lunak yang secara eksplisit bergantung pada dependensi yang sama dengan paket Anda harus memiliki spesifikasi dependensi mereka sendiri dan pembuatnya akan memberi tahu konflik yang ada. Menentukan apakah perubahan tersebut merupakan tingkat patch atau tingkat minor  tergantung pada apakah Anda memperbarui dependensi untuk memperbaiki bug atau memperkenalkan fungsionalitas baru. Saya biasanya mengharapkan kode tambahan untuk contoh yang kedua, yang dalam hal ini jelas merupakan kenaikan tingkat minor.

Apa yang harus saya lakukan jika bug yang sedang diperbaiki mengembalikan kode agar sesuai dengan API publik (misalnya, kode tidak sinkron dengan dokumentasi API publik)?

Gunakan kebijakan terbaik Anda. Jika Anda memiliki audiens yang sangat besar yang akan terpengaruh secara drastis dengan apa yang dimaksudkan oleh API publik, maka lebih baik melakukan rilis versi major, meskipun perbaikannya dapat sangat dianggap sebagai rilis patch. Ingat, Pemversian Semantik adalah segalanya tentang menyampaikan makna melalui perubahan nomor versi. Jika perubahan ini perubahan ini penting bagi pengguna Anda, gunakan nomor versi itu untuk memberi tahu mereka.

Bagaimana cara menangani fungsionalitas yang sudah diusangkan?

Mengusangkan fungsionalitas yang ada adalah hal yang lumrah dalam pengembangan perangkat lunak dan sering kali diperlukan untuk membuat suatu kemajuan. Ketika Anda mengusangkan bagian  dari API publik Anda, Anda harus melakukan dua hal: (1) memperbarui dokumentasi Anda untuk memberi tahu pengguna tahu tentang perubahan tersebut, dan (2) mengeluarkan rilis minor baru dengan penghentian yang baru dengan pengusangan itu dibuat. Sebelum Anda benar-benar menghapus fungsionalitas dalam rilis major yang baru harus ada setidaknya satu rilis minor yang berisi pengusangan itu sehingga pengguna dapat beralih dengan lancar ke API yang baru.

Tentang

Spesifikasi Pemversian Semantik dibuat oleh Tom Preston-Werner, pembuat Gravatars dan cofounder dari GitHub.

Terjemahan Bahasa Indonesia ditulis oleh Aditya Purwa, Christian B. Wibowo, dan Hans5958.

Untuk saran dan kritik, silahkan buka issue di GitHub.

Lisensi

Creative Commons ― CC BY 3.0\nPemversian Semantik 2.0.0-rc.1\nDalam pengembangan perangkat lunak, sering terjadi permasalahan dependency hell. Semakin besar sistem yang dibuat dan semakin banyak modul yang digunakan sistem kita, semakin sering permasalahan ini akan terjadi.\nDalam sistem yang saling terkait, merilis versi baru bisa menjadi mimpi buruk. Jika spesifikasi dependensi sistem terlalu ketat, bisa jadi sistem kita tidak bisa dikembangkan lagi. Jika spesifikasi dependensi sistem terlalu bebas, semakin sulit untuk berasumsi versi mana yang bisa digunakan dengan versi yang lain. Dependency hell adalah saat Anda berada pada satu atau dua masalah ini, yang menahan Anda untuk bergerak maju dengan aman dan mudah.\nSebagai solusi permasalahan ini, saya mengusulkan seperangkat aturan dan persayaratan sederhana yang menentukan bagaimana nomor versi diberikan dan bertambah. Agar sistem ini dapat bekerja, Anda harus mengumumkan API publik terlebih dahulu. Ini dapat terdiri dari dokumentasi atau diberlakukan oleh kode itu sendiri. Apapun itu, API ini harus jelas dan tepat. Setelah Anda mengidentifikasi API publik Anda, Anda mengomunikasikan perubahan pada API tersebut dengan penambahan spesifik pada nomor versi Anda. Pertimbangkan format versi X.Y.Z (Major.Minor.Patch). Perbaikan bug yang tidak memengaruhi API tersebut akan menambah versi patch, penambahan/perubahan API yang kompatibel dengan versi sebelumnya akan menambah versi minor, dan perubahan API yang tidak kompatibel dengan versi sebelumnya akan menambah versi major.\nStandar ini bernama “Pemversian Semantik”. Dengan skema ini, setiap orang yang melihat angka versi bisa tahu secara umum apa yang berubah dengan sistem tersebut.\nSpesifikasi Pemversian Semantik (SemVer)\nKata/frasa “HARUS” (“MUST”), “TIDAK BOLEH” (“MUST NOT”), “DIBUTUHKAN” (“REQUIRED”), “SEHARUSNYA” (“SHALL”), “JANGAN SAMPAI” (“SHALL NOT”), “SEBAIKNYA” (“SHOULD”), “SEBAIKNYA TIDAK” (“SHOULD NOT”), “DIREKOMENDASIKAN” (“RECOMMENDED”), “BISA” (“MAY”)  di dokumen ini sesuai dengan RFC 2119.\nPerangkat lunak dengan Pemversian Semantik HARUS menentukan API public. Bisa dijelaskan dengan kode, atau ditulis di dokumentasi saja. Apapun itu harus ditulis dengan jelas dan akurat.\nPerangkat lunak dengan Pemversian Semantik HARUS menentukan API public. Bisa dijelaskan dengan kode, atau ditulis di dokumentasi saja. Apapun itu harus ditulis dengan jelas dan akurat.\nVersi normal HARUS ditulis dalam bentuk X.Y.Z, dengan X, Y, dan Z adalah bilangan bulat nonnegatif. X adalah versi major, Y adalah minor, dan Z adalah patch. Setiap elemen HARUS bertambah secara numerik dengan kenaikan sebesar satu. Contohnya: 1.9.0 -> 1.10.0 -> 1.11.0\nVersi normal HARUS ditulis dalam bentuk X.Y.Z, dengan X, Y, dan Z adalah bilangan bulat nonnegatif. X adalah versi major, Y adalah minor, dan Z adalah patch. Setiap elemen HARUS bertambah secara numerik dengan kenaikan sebesar satu. Contohnya: 1.9.0 -> 1.10.0 -> 1.11.0\nKetika nomor versi major bertambah, versi minor dan patch versi HARUS diatur ulang ke nol. Ketika nomor versi minor bertambah, nomor versi patch HARUS disetel ulang ke nol. Misalnya: 1.1.3 -> 2.0.0 dan 2.1.7 ->
2.2.0.\nKetika nomor versi major bertambah, versi minor dan patch versi HARUS diatur ulang ke nol. Ketika nomor versi minor bertambah, nomor versi patch HARUS disetel ulang ke nol. Misalnya: 1.1.3 -> 2.0.0 dan 2.1.7 ->
2.2.0.\nSetelah sebuah paket berversi dirilis, isi dari versi tersebut TIDAK BOLEH diubah. Setiap perubahan harus dirilis sebagai versi baru.\nSetelah sebuah paket berversi dirilis, isi dari versi tersebut TIDAK BOLEH diubah. Setiap perubahan harus dirilis sebagai versi baru.\nVersi major 0 (0.y.z) adalah untuk pengembangan awal. Apapun bisa bisa berubah kapanpun. API publik sebaiknya dianggap tidak stabil di versi ini.\nVersi major 0 (0.y.z) adalah untuk pengembangan awal. Apapun bisa bisa berubah kapanpun. API publik sebaiknya dianggap tidak stabil di versi ini.\nVersi 1.0.0 adalah titik awal API publik. Cara nomor versi ini dinaikkan setelah rilis ini adalah tergantung dengan API publik ini dan bagaimana ia berubah.\nVersi 1.0.0 adalah titik awal API publik. Cara nomor versi ini dinaikkan setelah rilis ini adalah tergantung dengan API publik ini dan bagaimana ia berubah.\nVersi patch Z (x.y.Z | x > 0) HARUS dinaikkan jika ada perbaikan bug yang kompatibel dengan versi lama. Sebuah perbaikan bug didefinisikan sebagai perubahan internal yang memperbaiki perilaku yang salah.\nVersi patch Z (x.y.Z | x > 0) HARUS dinaikkan jika ada perbaikan bug yang kompatibel dengan versi lama. Sebuah perbaikan bug didefinisikan sebagai perubahan internal yang memperbaiki perilaku yang salah.\nVersi minor Y (x.Y.z | x > 0) HARUS dinaikkan jika ada fitur baru yang kompatibel dengan versi lama dalam API publik. Ini HARUS dinaikkan jika sebuah fungsionalitas API publik dibuat usang. Ini BISA dinaikkan jika ada tambahan fungsionalitas substansial atau terjadi peningkatan di dalam kode privat. Ini BISA diubah bersama dengan perubahan tingkat patch. Versi patch HARUS dikembalikan ke angka 0 jika versi minor dinaikkan.\nVersi minor Y (x.Y.z | x > 0) HARUS dinaikkan jika ada fitur baru yang kompatibel dengan versi lama dalam API publik. Ini HARUS dinaikkan jika sebuah fungsionalitas API publik dibuat usang. Ini BISA dinaikkan jika ada tambahan fungsionalitas substansial atau terjadi peningkatan di dalam kode privat. Ini BISA diubah bersama dengan perubahan tingkat patch. Versi patch HARUS dikembalikan ke angka 0 jika versi minor dinaikkan.\nVersi major X (X.y.z | X > 0) HARUS dinaikkan jika ada perubahan yang membuat versi baru tidak kompatibel dengan versi lama pada API publik. Ini BISA diubah bersama dengan perubahan tingkat patch dan minor. Versi minor dan patch HARUS dikembalikan ke angka 0 jika versi major dinaikkan.\nVersi major X (X.y.z | X > 0) HARUS dinaikkan jika ada perubahan yang membuat versi baru tidak kompatibel dengan versi lama pada API publik. Ini BISA diubah bersama dengan perubahan tingkat patch dan minor. Versi minor dan patch HARUS dikembalikan ke angka 0 jika versi major dinaikkan.\nVersi prarilis BISA ditulis dengan menambahkan tanda pisah dan rangkaian pengenal dengan pemisah titik tepat setelah versi patch. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda pisah [0-9A-Za-z]. Versi prarilis diperbolehkan, namun memiliki presendens yang lebih rendah dibandingkan dengan versi normal. Contoh: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nVersi prarilis BISA ditulis dengan menambahkan tanda pisah dan rangkaian pengenal dengan pemisah titik tepat setelah versi patch. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda pisah [0-9A-Za-z]. Versi prarilis diperbolehkan, namun memiliki presendens yang lebih rendah dibandingkan dengan versi normal. Contoh: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nSebuah versi build BISA ditulis didahului dengan tanda tambah dan rangkaian pengenal dengan pemisah titik setelah versi patch atau prarilis. Versi build HARUS ditulis dengan huruf ASCII alfanumerik dan tanda pisah [0-9A-Za-z]. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda pisah [0-9A-Za-z]. Versi build dapat digunakan dan memiliki presedens lebih tinggi dibandingkan versi normal yang terkait. Contoh: 1.0.0+build.1, 1.3.7+build.11.e0f985a.\nSebuah versi build BISA ditulis didahului dengan tanda tambah dan rangkaian pengenal dengan pemisah titik setelah versi patch atau prarilis. Versi build HARUS ditulis dengan huruf ASCII alfanumerik dan tanda pisah [0-9A-Za-z]. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda pisah [0-9A-Za-z]. Versi build dapat digunakan dan memiliki presedens lebih tinggi dibandingkan versi normal yang terkait. Contoh: 1.0.0+build.1, 1.3.7+build.11.e0f985a.\nPresedens HARUS dihitung dengan memisahkan versi menjadi pengenal major, minor, patch, prarilis, dan pengenal build dalam urutan tersebut. Presedens prarilis dan pengenal build HARUS ditentukan dengan membandingkan setiap pengenal yang dipisahkan titik sebagai berikut: pengenal yang hanya terdiri dari angka dibandingkan secara numerik dan pengenal dengan huruf atau tanda pisah dibandingkan secara leksikal dalam urutan pengurutan ASCII. Pengenal numerik selalu memiliki prioritas yang lebih rendah daripada pengenal non-numerik. Contoh: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0-rc.1+build.1 < 1.0.0 < 1.0.0+0.3.7 < 1.3.7+build < 1.3.7+build.2.b8f12d7 < 1.3.7+build.11.e0f985a.\nPresedens HARUS dihitung dengan memisahkan versi menjadi pengenal major, minor, patch, prarilis, dan pengenal build dalam urutan tersebut. Presedens prarilis dan pengenal build HARUS ditentukan dengan membandingkan setiap pengenal yang dipisahkan titik sebagai berikut: pengenal yang hanya terdiri dari angka dibandingkan secara numerik dan pengenal dengan huruf atau tanda pisah dibandingkan secara leksikal dalam urutan pengurutan ASCII. Pengenal numerik selalu memiliki prioritas yang lebih rendah daripada pengenal non-numerik. Contoh: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0-rc.1+build.1 < 1.0.0 < 1.0.0+0.3.7 < 1.3.7+build < 1.3.7+build.2.b8f12d7 < 1.3.7+build.11.e0f985a.\nKenapa Menggunakan Pemversian Semantik?\nIni bukanlah ide baru yang revolusioner. Faktanya, kalian mungkin sudah menggunakan standar ini, hanya saja tidak terlalu ketat. Masalahnya, “tidak teralu ketat” saja tidak cukup bagus. Tanpa kepatuhan terhadap beberapa jenis spesifikasi formal, nomor versi adalah pada dasarnya tidak berguna untuk manajemen dependensi. Dengan memberikan nama dan definisi yang jelas definisi yang jelas untuk ide-ide tersebut, mengkomunikasikan maksud Anda kepada pengguna perangkat lunak Anda menjadi lebih mudah. Setelah maksud ini jelas, spesifikasi ketergantungan yang fleksibel (tetapi tidak terlalu fleksibel) akhirnya dapat dibuat.\nContoh sederhana ini menunjukkan manfaat Pemversian Semantik untuk menghilangkan “dependency hell.” Misalkan ada sebuah modul bernama “MobilPemadamKebakaran”. Modul “MobilPemadamKebakaran” membutuhkan modul lain bernama “Tangga”. Pada waktu “MobilPemadamKebakaran” dibuat, “Tangga” memiliki versi 3.1.0. Dengan menggunakan Pemversian Semantik, “MobilPemadamKebakaran” bisa dengan yakin menggunakan modul “Tangga” selama modul tersebut mempunyai versi antara 3.1.0 sampai dengan sebelum versi 4.0.0.\nSebagai pengembang yang bertanggung jawab, tentu saja Anda ingin memverifikasi bahwa peningkatan paket berfungsi seperti yang diiklankan. Dunia nyata tidaklah pasti; tidak ada yang bisa kita lakukan selain waspada. Yang bisa Anda lakukan adalah membiarkan Pemversian Semantik memberi Anda cara yang masuk akal untuk merilis dan memutakhirkan paket tanpa harus menggulirkan versi baru dari paket dependen, membuat Anda menghemat waktu dan kerumitan.\nJika menurut kalian aturan ini bagus, cara untuk memulai menggunakan pemversian semantik adalah dengan menautkan situs ini dalam README kalian supaya orang lain bisa tahu mengenai aturan ini dan mulai menggunakannya juga.\nPertanyaan Yang Sering Diajukan\nBagaimana cara menangani revisi dalam fase pengembangan awal 0.y.z?\nHal yang paling sederhana untuk dilakukan adalah memulai rilis pengembangan awal Anda pada 0.1.0 dan kemudian meningkatkan versi minor untuk setiap rilis berikutnya.\nBagaimana saya tahu kapan merilis 1.0.0?\nJika perangkat lunak Anda digunakan dalam produksi, mungkin perangkat lunak Anda sudah versi 1.0.0. Jika Anda memiliki API yang stabil yang menjadi andalan pengguna, Anda harusnya sudah pada 1.0.0. Jika Anda sangat mengkhawatirkan kompatibilitas versi lama, Anda mungkin sudah pada 1.0.0.\nBukankah standar ini mencegah perkembangan yang cepat?\nVersi major nol adalah tentang pengembangan yang cepat. Jika Anda mengubah API setiap hari, Anda harus tetap berada di versi 0.x.x atau di pengembangan terpisah yang bekerja pada versi major berikutnya.\nJika perubahan terkecil yang tidak kompatibel dengan API publik memerlukan kenaikkan versi major, bukankah saya akan berakhir di versi 42.0.0 dengan sangat cepat?\nIni adalah pertanyaan tentang pengembangan yang bertanggung jawab dan pandangan ke depan. Perubahan yang tidak kompatibel tidak boleh diperkenalkan dengan mudah ke perangkat lunak yang memiliki banyak kode dependen. Biaya yang harus dikeluarkan untuk meng-upgrade bisa sangat besar. Kewajiban mengganti versi major untuk merilis perubahan yang tidak kompatibel seharusnya membuat Anda memikirkan dampak dari perubahan Anda, dan mengevaluasi perbandingan biaya dan manfaat yang terkait.\nMendokumentasikan seluruh API publik sangatlah merepotkan!\nSudah tanggung jawab Anda sebagai pengembang profesional untuk mendokumentasikan perangkat lunak untuk digunakan oleh orang lain dengan benar. Mengelola kompleksitas perangkat lunak adalah bagian yang sangat penting dalam menjaga proyek tetap efisien, dan itu sulit dilakukan jika tidak ada yang tahu cara menggunakan perangkat lunak Anda, atau metode apa yang aman untuk dihubungi. Dalam jangka panjang, Pemversian Semantik, dan desakan pada API publik yang terdefinisi dengan baik dapat membuat semua orang dan segala sesuatu berjalan dengan lancar.\nBagaimana jika secara tidak sengaja membuat perubahan yang menjadikan versi lama tidak bisa dipakai?\nSetelah Anda menyadari bahwa Anda telah melanggar spesifikasi Pemversian Semantik, perbaiki dan rilis versi minor baru yang memperbaiki masalah dan mengembalikan kompatibilitas versi lama. Ingat, memodifikasi rilis yang telah diberi versi adalah dilarang, bahkan dalam kondisi ini. Jika mau, dokumentasikan versi yang bermasalah dan memberi tahu pengguna Anda tentang masalah tersebut sehingga mereka mengetahui versi yang bermasalah.\nApa yang harus saya lakukan jika saya memperbarui dependensi saya sendiri tanpa mengubah API publik?\nHal tersebut dianggap kompatibel karena tidak mempengaruhi API publik. Perangkat lunak yang secara eksplisit bergantung pada dependensi yang sama dengan paket Anda harus memiliki spesifikasi dependensi mereka sendiri dan pembuatnya akan memberi tahu konflik yang ada. Menentukan apakah perubahan tersebut merupakan tingkat patch atau tingkat minor  tergantung pada apakah Anda memperbarui dependensi untuk memperbaiki bug atau memperkenalkan fungsionalitas baru. Saya biasanya mengharapkan kode tambahan untuk contoh yang kedua, yang dalam hal ini jelas merupakan kenaikan tingkat minor.\nApa yang harus saya lakukan jika bug yang sedang diperbaiki mengembalikan kode agar sesuai dengan API publik (misalnya, kode tidak sinkron dengan dokumentasi API publik)?\nGunakan kebijakan terbaik Anda. Jika Anda memiliki audiens yang sangat besar yang akan terpengaruh secara drastis dengan apa yang dimaksudkan oleh API publik, maka lebih baik melakukan rilis versi major, meskipun perbaikannya dapat sangat dianggap sebagai rilis patch. Ingat, Pemversian Semantik adalah segalanya tentang menyampaikan makna melalui perubahan nomor versi. Jika perubahan ini perubahan ini penting bagi pengguna Anda, gunakan nomor versi itu untuk memberi tahu mereka.\nBagaimana cara menangani fungsionalitas yang sudah diusangkan?\nMengusangkan fungsionalitas yang ada adalah hal yang lumrah dalam pengembangan perangkat lunak dan sering kali diperlukan untuk membuat suatu kemajuan. Ketika Anda mengusangkan bagian  dari API publik Anda, Anda harus melakukan dua hal: (1) memperbarui dokumentasi Anda untuk memberi tahu pengguna tahu tentang perubahan tersebut, dan (2) mengeluarkan rilis minor baru dengan penghentian yang baru dengan pengusangan itu dibuat. Sebelum Anda benar-benar menghapus fungsionalitas dalam rilis major yang baru harus ada setidaknya satu rilis minor yang berisi pengusangan itu sehingga pengguna dapat beralih dengan lancar ke API yang baru.\nSpesifikasi Pemversian Semantik dibuat oleh Tom Preston-Werner, pembuat Gravatars dan cofounder dari GitHub.\nTerjemahan Bahasa Indonesia ditulis oleh Aditya Purwa, Christian B. Wibowo, dan Hans5958.\nUntuk saran dan kritik, silahkan buka issue di GitHub.\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nPemversian Semantik 1.0.0

Dalam pengembangan perangkat lunak, sering terjadi permasalahan dependency hell. Semakin besar sistem yang dibuat dan semakin banyak modul yang digunakan sistem kita, semakin sering permasalahan ini akan terjadi.

Dalam sistem yang saling terkait, merilis versi baru bisa menjadi mimpi buruk. Jika spesifikasi dependensi sistem terlalu ketat, bisa jadi sistem kita tidak bisa dikembangkan lagi. Jika spesifikasi dependensi sistem terlalu bebas, semakin sulit untuk berasumsi versi mana yang bisa digunakan dengan versi yang lain. Dependency hell adalah saat Anda berada pada satu atau dua masalah ini, yang menahan Anda untuk bergerak maju dengan aman dan mudah.

Sebagai solusi permasalahan ini, saya mengusulkan seperangkat aturan dan persayaratan sederhana yang menentukan bagaimana nomor versi diberikan dan bertambah. Agar sistem ini dapat bekerja, Anda harus mengumumkan API publik terlebih dahulu. Ini dapat terdiri dari dokumentasi atau diberlakukan oleh kode itu sendiri. Apapun itu, API ini harus jelas dan tepat. Setelah Anda mengidentifikasi API publik Anda, Anda mengomunikasikan perubahan pada API tersebut dengan penambahan spesifik pada nomor versi Anda. Pertimbangkan format versi X.Y.Z (Major.Minor.Patch). Perbaikan bug yang tidak memengaruhi API tersebut akan menambah versi patch, penambahan/perubahan API yang kompatibel dengan versi sebelumnya akan menambah versi minor, dan perubahan API yang tidak kompatibel dengan versi sebelumnya akan menambah versi major.

Standar ini bernama “Pemversian Semantik”. Dengan skema ini, setiap orang yang melihat angka versi bisa tahu secara umum apa yang berubah dengan sistem tersebut.

Spesifikasi Pemversian Semantik (SemVer)

Kata/frasa “HARUS” (“MUST”), “TIDAK BOLEH” (“MUST NOT”), “DIBUTUHKAN” (“REQUIRED”), “SEHARUSNYA” (“SHALL”), “JANGAN SAMPAI” (“SHALL NOT”), “SEBAIKNYA” (“SHOULD”), “SEBAIKNYA TIDAK” (“SHOULD NOT”), “DIREKOMENDASIKAN” (“RECOMMENDED”), “BISA” (“MAY”) , dan “OPSIONAL” di dokumen ini sesuai dengan RFC 2119.


  
    Perangkat lunak dengan Pemversian Semantik HARUS menentukan API public. Bisa dijelaskan dengan kode, atau ditulis di dokumentasi saja. Apapun itu harus ditulis dengan jelas dan akurat.
  
  
    Versi normal HARUS ditulis dalam bentuk X.Y.Z, dengan X, Y, dan Z adalah bilangan bulat. X adalah versi major, Y adalah minor, dan Z adalah patch. Setiap elemen HARUS bertambah secara numerik dengan kenaikan sebesar satu. Contohnya: 1.9.0 -> 1.10.0 -> 1.11.0
  
  
    Ketika nomor versi major bertambah, versi minor dan patch versi HARUS diatur ulang ke nol. Ketika nomor versi minor bertambah, nomor versi patch HARUS disetel ulang ke nol. Misalnya: 1.1.3 -> 2.0.0 dan 2.1.7 ->
2.2.0.
  
  
    Versi prarilis BISA ditulis dengan menambahkan tanda pisah dan rangkaian pengenal dengan pemisah titik tepat setelah versi patch. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda pisah [0-9A-Za-z]. Versi prarilis diperbolehkan, namun memiliki presendens yang lebih rendah dibandingkan dengan versi normal. Presedens SEBAIKNYA ditentukan dari urutan leksikografik ASCII. Contoh: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Setelah sebuah paket berversi dirilis, isi dari versi tersebut TIDAK BOLEH diubah. Setiap perubahan harus dirilis sebagai versi baru.
  
  
    Versi major 0 (0.y.z) adalah untuk pengembangan awal. Apapun bisa bisa berubah kapanpun. API publik sebaiknya dianggap tidak stabil di versi ini.
  
  
    Versi 1.0.0 adalah titik awal API publik. Cara nomor versi ini dinaikkan setelah rilis ini adalah tergantung dengan API publik ini dan bagaimana ia berubah.
  
  
    Versi patch Z (x.y.Z | x > 0) HARUS dinaikkan jika ada perbaikan bug yang kompatibel dengan versi lama. Sebuah perbaikan bug didefinisikan sebagai perubahan internal yang memperbaiki perilaku yang salah.
  
  
    Versi minor Y (x.Y.z | x > 0) HARUS dinaikkan jika ada fitur baru yang kompatibel dengan versi lama dalam API publik. Ini BISA dinaikkan jika ada tambahan fungsionalitas substansial atau terjadi peningkatan di dalam kode privat. Ini BISA diubah bersama dengan perubahan tingkat patch. Versi patch HARUS dikembalikan ke angka 0 jika versi minor dinaikkan.
  
  
    Versi major X (X.y.z | X > 0) HARUS dinaikkan jika ada perubahan yang membuat versi baru tidak kompatibel dengan versi lama pada API publik. Ini BISA diubah bersama dengan perubahan tingkat patch dan minor. Versi minor dan patch HARUS dikembalikan ke angka 0 jika versi major dinaikkan.
  


Spesifikasi Penandaan (SemVerTag)

Subspesifikasi ini SEBAIKNYA digunakan jika Anda menggunakan sistem kontrol versi (Git, Mercurial, SVN, dll) untuk menyimpan kode Anda. Dengan menggunaakan sistem ini, alat otomatis dapat memeriksa paket Anda dan menentukan kepatuhan SemVer dan versi yang dirilis.


  
    Saat menandai rilis dalam sistem kontrol versi, tag untuk sebuah versi HARUS “vX.Y.Z”, seperti “v3.1.0”.
  
  
    Revisi pertama yang memperkenalkan kepatuhan SemVer SEBAIKNYA diberi tag “semver”. Hal ini memungkinkan proyek yang sudah ada sebelumnya untuk mengasumsikan kepatuhan pada suatu titik dan agar alat otomatis tahu tentang hal ini.
  


Kenapa Menggunakan Pemversian Semantik?

Ini bukanlah ide baru yang revolusioner. Faktanya, kalian mungkin sudah menggunakan standar ini, hanya saja tidak terlalu ketat. Masalahnya, “tidak teralu ketat” saja tidak cukup bagus. Tanpa kepatuhan terhadap beberapa jenis spesifikasi formal, nomor versi adalah pada dasarnya tidak berguna untuk manajemen dependensi. Dengan memberikan nama dan definisi yang jelas definisi yang jelas untuk ide-ide tersebut, mengkomunikasikan maksud Anda kepada pengguna perangkat lunak Anda menjadi lebih mudah. Setelah maksud ini jelas, spesifikasi ketergantungan yang fleksibel (tetapi tidak terlalu fleksibel) akhirnya dapat dibuat.

Contoh sederhana ini menunjukkan manfaat Pemversian Semantik untuk menghilangkan “dependency hell.” Misalkan ada sebuah modul bernama “MobilPemadamKebakaran”. Modul “MobilPemadamKebakaran” membutuhkan modul lain bernama “Tangga”. Pada waktu “MobilPemadamKebakaran” dibuat, “Tangga” memiliki versi 3.1.0. Dengan menggunakan Pemversian Semantik, “MobilPemadamKebakaran” bisa dengan yakin menggunakan modul “Tangga” selama modul tersebut mempunyai versi antara 3.1.0 sampai dengan sebelum versi 4.0.0.

Sebagai pengembang yang bertanggung jawab, tentu saja Anda ingin memverifikasi bahwa peningkatan paket berfungsi seperti yang diiklankan. Dunia nyata tidaklah pasti; tidak ada yang bisa kita lakukan selain waspada. Yang bisa Anda lakukan adalah membiarkan Pemversian Semantik memberi Anda cara yang masuk akal untuk merilis dan memutakhirkan paket tanpa harus menggulirkan versi baru dari paket dependen, membuat Anda menghemat waktu dan kerumitan.

Jika menurut kalian aturan ini bagus, cara untuk memulai menggunakan pemversian semantik adalah dengan menautkan situs ini dalam README kalian supaya orang lain bisa tahu mengenai aturan ini dan mulai menggunakannya juga.

Pertanyaan Yang Sering Diajukan

Bagaimana cara menangani revisi dalam fase pengembangan awal 0.y.z?

Hal yang paling sederhana untuk dilakukan adalah memulai rilis pengembangan awal Anda pada 0.1.0 dan kemudian meningkatkan versi minor untuk setiap rilis berikutnya.

Bagaimana saya tahu kapan merilis 1.0.0?

Jika perangkat lunak Anda digunakan dalam produksi, mungkin perangkat lunak Anda sudah versi 1.0.0. Jika Anda memiliki API yang stabil yang menjadi andalan pengguna, Anda harusnya sudah pada 1.0.0. Jika Anda sangat mengkhawatirkan kompatibilitas versi lama, Anda mungkin sudah pada 1.0.0.

Bukankah standar ini mencegah perkembangan yang cepat?

Versi major nol adalah tentang pengembangan yang cepat. Jika Anda mengubah API setiap hari, Anda harus tetap berada di versi 0.x.x atau di pengembangan terpisah yang bekerja pada versi major berikutnya.

Jika perubahan terkecil yang tidak kompatibel dengan API publik memerlukan kenaikkan versi major, bukankah saya akan berakhir di versi 42.0.0 dengan sangat cepat?

Ini adalah pertanyaan tentang pengembangan yang bertanggung jawab dan pandangan ke depan. Perubahan yang tidak kompatibel tidak boleh diperkenalkan dengan mudah ke perangkat lunak yang memiliki banyak kode dependen. Biaya yang harus dikeluarkan untuk meng-upgrade bisa sangat besar. Kewajiban mengganti versi major untuk merilis perubahan yang tidak kompatibel seharusnya membuat Anda memikirkan dampak dari perubahan Anda, dan mengevaluasi perbandingan biaya dan manfaat yang terkait.

Mendokumentasikan seluruh API publik sangatlah merepotkan!

Sudah tanggung jawab Anda sebagai pengembang profesional untuk mendokumentasikan perangkat lunak untuk digunakan oleh orang lain dengan benar. Mengelola kompleksitas perangkat lunak adalah bagian yang sangat penting dalam menjaga proyek tetap efisien, dan itu sulit dilakukan jika tidak ada yang tahu cara menggunakan perangkat lunak Anda, atau metode apa yang aman untuk dihubungi. Dalam jangka panjang, Pemversian Semantik, dan desakan pada API publik yang terdefinisi dengan baik dapat membuat semua orang dan segala sesuatu berjalan dengan lancar.

Bagaimana jika secara tidak sengaja membuat perubahan yang menjadikan versi lama tidak bisa dipakai?

Setelah Anda menyadari bahwa Anda telah melanggar spesifikasi Pemversian Semantik, perbaiki dan rilis versi minor baru yang memperbaiki masalah dan mengembalikan kompatibilitas versi lama. Ingat, memodifikasi rilis yang telah diberi versi adalah dilarang, bahkan dalam kondisi ini. Jika mau, dokumentasikan versi yang bermasalah dan memberi tahu pengguna Anda tentang masalah tersebut sehingga mereka mengetahui versi yang bermasalah.

Apa yang harus saya lakukan jika saya memperbarui dependensi saya sendiri tanpa mengubah API publik?

Hal tersebut dianggap kompatibel karena tidak mempengaruhi API publik. Perangkat lunak yang secara eksplisit bergantung pada dependensi yang sama dengan paket Anda harus memiliki spesifikasi dependensi mereka sendiri dan pembuatnya akan memberi tahu konflik yang ada. Menentukan apakah perubahan tersebut merupakan tingkat patch atau tingkat minor  tergantung pada apakah Anda memperbarui dependensi untuk memperbaiki bug atau memperkenalkan fungsionalitas baru. Saya biasanya mengharapkan kode tambahan untuk contoh yang kedua, yang dalam hal ini jelas merupakan kenaikan tingkat minor.

Apa yang harus saya lakukan jika bug yang sedang diperbaiki mengembalikan kode agar sesuai dengan API publik (misalnya, kode tidak sinkron dengan dokumentasi API publik)?

Gunakan kebijakan terbaik Anda. Jika Anda memiliki audiens yang sangat besar yang akan terpengaruh secara drastis dengan apa yang dimaksudkan oleh API publik, maka lebih baik melakukan rilis versi major, meskipun perbaikannya dapat sangat dianggap sebagai rilis patch. Ingat, Pemversian Semantik adalah segalanya tentang menyampaikan makna melalui perubahan nomor versi. Jika perubahan ini perubahan ini penting bagi pengguna Anda, gunakan nomor versi itu untuk memberi tahu mereka.

Tentang

Spesifikasi Pemversian Semantik dibuat oleh Tom Preston-Werner, pembuat Gravatars dan cofounder dari GitHub.

Terjemahan Bahasa Indonesia ditulis oleh Aditya Purwa, Christian B. Wibowo, dan Hans5958.

Untuk saran dan kritik, silahkan buka issue di GitHub.

Lisensi

Creative Commons ― CC BY 3.0\nPemversian Semantik 1.0.0\nDalam pengembangan perangkat lunak, sering terjadi permasalahan dependency hell. Semakin besar sistem yang dibuat dan semakin banyak modul yang digunakan sistem kita, semakin sering permasalahan ini akan terjadi.\nDalam sistem yang saling terkait, merilis versi baru bisa menjadi mimpi buruk. Jika spesifikasi dependensi sistem terlalu ketat, bisa jadi sistem kita tidak bisa dikembangkan lagi. Jika spesifikasi dependensi sistem terlalu bebas, semakin sulit untuk berasumsi versi mana yang bisa digunakan dengan versi yang lain. Dependency hell adalah saat Anda berada pada satu atau dua masalah ini, yang menahan Anda untuk bergerak maju dengan aman dan mudah.\nSebagai solusi permasalahan ini, saya mengusulkan seperangkat aturan dan persayaratan sederhana yang menentukan bagaimana nomor versi diberikan dan bertambah. Agar sistem ini dapat bekerja, Anda harus mengumumkan API publik terlebih dahulu. Ini dapat terdiri dari dokumentasi atau diberlakukan oleh kode itu sendiri. Apapun itu, API ini harus jelas dan tepat. Setelah Anda mengidentifikasi API publik Anda, Anda mengomunikasikan perubahan pada API tersebut dengan penambahan spesifik pada nomor versi Anda. Pertimbangkan format versi X.Y.Z (Major.Minor.Patch). Perbaikan bug yang tidak memengaruhi API tersebut akan menambah versi patch, penambahan/perubahan API yang kompatibel dengan versi sebelumnya akan menambah versi minor, dan perubahan API yang tidak kompatibel dengan versi sebelumnya akan menambah versi major.\nStandar ini bernama “Pemversian Semantik”. Dengan skema ini, setiap orang yang melihat angka versi bisa tahu secara umum apa yang berubah dengan sistem tersebut.\nSpesifikasi Pemversian Semantik (SemVer)\nKata/frasa “HARUS” (“MUST”), “TIDAK BOLEH” (“MUST NOT”), “DIBUTUHKAN” (“REQUIRED”), “SEHARUSNYA” (“SHALL”), “JANGAN SAMPAI” (“SHALL NOT”), “SEBAIKNYA” (“SHOULD”), “SEBAIKNYA TIDAK” (“SHOULD NOT”), “DIREKOMENDASIKAN” (“RECOMMENDED”), “BISA” (“MAY”) , dan “OPSIONAL” di dokumen ini sesuai dengan RFC 2119.\nPerangkat lunak dengan Pemversian Semantik HARUS menentukan API public. Bisa dijelaskan dengan kode, atau ditulis di dokumentasi saja. Apapun itu harus ditulis dengan jelas dan akurat.\nPerangkat lunak dengan Pemversian Semantik HARUS menentukan API public. Bisa dijelaskan dengan kode, atau ditulis di dokumentasi saja. Apapun itu harus ditulis dengan jelas dan akurat.\nVersi normal HARUS ditulis dalam bentuk X.Y.Z, dengan X, Y, dan Z adalah bilangan bulat. X adalah versi major, Y adalah minor, dan Z adalah patch. Setiap elemen HARUS bertambah secara numerik dengan kenaikan sebesar satu. Contohnya: 1.9.0 -> 1.10.0 -> 1.11.0\nVersi normal HARUS ditulis dalam bentuk X.Y.Z, dengan X, Y, dan Z adalah bilangan bulat. X adalah versi major, Y adalah minor, dan Z adalah patch. Setiap elemen HARUS bertambah secara numerik dengan kenaikan sebesar satu. Contohnya: 1.9.0 -> 1.10.0 -> 1.11.0\nKetika nomor versi major bertambah, versi minor dan patch versi HARUS diatur ulang ke nol. Ketika nomor versi minor bertambah, nomor versi patch HARUS disetel ulang ke nol. Misalnya: 1.1.3 -> 2.0.0 dan 2.1.7 ->
2.2.0.\nKetika nomor versi major bertambah, versi minor dan patch versi HARUS diatur ulang ke nol. Ketika nomor versi minor bertambah, nomor versi patch HARUS disetel ulang ke nol. Misalnya: 1.1.3 -> 2.0.0 dan 2.1.7 ->
2.2.0.\nVersi prarilis BISA ditulis dengan menambahkan tanda pisah dan rangkaian pengenal dengan pemisah titik tepat setelah versi patch. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda pisah [0-9A-Za-z]. Versi prarilis diperbolehkan, namun memiliki presendens yang lebih rendah dibandingkan dengan versi normal. Presedens SEBAIKNYA ditentukan dari urutan leksikografik ASCII. Contoh: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nVersi prarilis BISA ditulis dengan menambahkan tanda pisah dan rangkaian pengenal dengan pemisah titik tepat setelah versi patch. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda pisah [0-9A-Za-z]. Versi prarilis diperbolehkan, namun memiliki presendens yang lebih rendah dibandingkan dengan versi normal. Presedens SEBAIKNYA ditentukan dari urutan leksikografik ASCII. Contoh: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nSetelah sebuah paket berversi dirilis, isi dari versi tersebut TIDAK BOLEH diubah. Setiap perubahan harus dirilis sebagai versi baru.\nSetelah sebuah paket berversi dirilis, isi dari versi tersebut TIDAK BOLEH diubah. Setiap perubahan harus dirilis sebagai versi baru.\nVersi major 0 (0.y.z) adalah untuk pengembangan awal. Apapun bisa bisa berubah kapanpun. API publik sebaiknya dianggap tidak stabil di versi ini.\nVersi major 0 (0.y.z) adalah untuk pengembangan awal. Apapun bisa bisa berubah kapanpun. API publik sebaiknya dianggap tidak stabil di versi ini.\nVersi 1.0.0 adalah titik awal API publik. Cara nomor versi ini dinaikkan setelah rilis ini adalah tergantung dengan API publik ini dan bagaimana ia berubah.\nVersi 1.0.0 adalah titik awal API publik. Cara nomor versi ini dinaikkan setelah rilis ini adalah tergantung dengan API publik ini dan bagaimana ia berubah.\nVersi patch Z (x.y.Z | x > 0) HARUS dinaikkan jika ada perbaikan bug yang kompatibel dengan versi lama. Sebuah perbaikan bug didefinisikan sebagai perubahan internal yang memperbaiki perilaku yang salah.\nVersi patch Z (x.y.Z | x > 0) HARUS dinaikkan jika ada perbaikan bug yang kompatibel dengan versi lama. Sebuah perbaikan bug didefinisikan sebagai perubahan internal yang memperbaiki perilaku yang salah.\nVersi minor Y (x.Y.z | x > 0) HARUS dinaikkan jika ada fitur baru yang kompatibel dengan versi lama dalam API publik. Ini BISA dinaikkan jika ada tambahan fungsionalitas substansial atau terjadi peningkatan di dalam kode privat. Ini BISA diubah bersama dengan perubahan tingkat patch. Versi patch HARUS dikembalikan ke angka 0 jika versi minor dinaikkan.\nVersi minor Y (x.Y.z | x > 0) HARUS dinaikkan jika ada fitur baru yang kompatibel dengan versi lama dalam API publik. Ini BISA dinaikkan jika ada tambahan fungsionalitas substansial atau terjadi peningkatan di dalam kode privat. Ini BISA diubah bersama dengan perubahan tingkat patch. Versi patch HARUS dikembalikan ke angka 0 jika versi minor dinaikkan.\nVersi major X (X.y.z | X > 0) HARUS dinaikkan jika ada perubahan yang membuat versi baru tidak kompatibel dengan versi lama pada API publik. Ini BISA diubah bersama dengan perubahan tingkat patch dan minor. Versi minor dan patch HARUS dikembalikan ke angka 0 jika versi major dinaikkan.\nVersi major X (X.y.z | X > 0) HARUS dinaikkan jika ada perubahan yang membuat versi baru tidak kompatibel dengan versi lama pada API publik. Ini BISA diubah bersama dengan perubahan tingkat patch dan minor. Versi minor dan patch HARUS dikembalikan ke angka 0 jika versi major dinaikkan.\nSpesifikasi Penandaan (SemVerTag)\nSubspesifikasi ini SEBAIKNYA digunakan jika Anda menggunakan sistem kontrol versi (Git, Mercurial, SVN, dll) untuk menyimpan kode Anda. Dengan menggunaakan sistem ini, alat otomatis dapat memeriksa paket Anda dan menentukan kepatuhan SemVer dan versi yang dirilis.\nSaat menandai rilis dalam sistem kontrol versi, tag untuk sebuah versi HARUS “vX.Y.Z”, seperti “v3.1.0”.\nSaat menandai rilis dalam sistem kontrol versi, tag untuk sebuah versi HARUS “vX.Y.Z”, seperti “v3.1.0”.\nRevisi pertama yang memperkenalkan kepatuhan SemVer SEBAIKNYA diberi tag “semver”. Hal ini memungkinkan proyek yang sudah ada sebelumnya untuk mengasumsikan kepatuhan pada suatu titik dan agar alat otomatis tahu tentang hal ini.\nRevisi pertama yang memperkenalkan kepatuhan SemVer SEBAIKNYA diberi tag “semver”. Hal ini memungkinkan proyek yang sudah ada sebelumnya untuk mengasumsikan kepatuhan pada suatu titik dan agar alat otomatis tahu tentang hal ini.\nKenapa Menggunakan Pemversian Semantik?\nIni bukanlah ide baru yang revolusioner. Faktanya, kalian mungkin sudah menggunakan standar ini, hanya saja tidak terlalu ketat. Masalahnya, “tidak teralu ketat” saja tidak cukup bagus. Tanpa kepatuhan terhadap beberapa jenis spesifikasi formal, nomor versi adalah pada dasarnya tidak berguna untuk manajemen dependensi. Dengan memberikan nama dan definisi yang jelas definisi yang jelas untuk ide-ide tersebut, mengkomunikasikan maksud Anda kepada pengguna perangkat lunak Anda menjadi lebih mudah. Setelah maksud ini jelas, spesifikasi ketergantungan yang fleksibel (tetapi tidak terlalu fleksibel) akhirnya dapat dibuat.\nContoh sederhana ini menunjukkan manfaat Pemversian Semantik untuk menghilangkan “dependency hell.” Misalkan ada sebuah modul bernama “MobilPemadamKebakaran”. Modul “MobilPemadamKebakaran” membutuhkan modul lain bernama “Tangga”. Pada waktu “MobilPemadamKebakaran” dibuat, “Tangga” memiliki versi 3.1.0. Dengan menggunakan Pemversian Semantik, “MobilPemadamKebakaran” bisa dengan yakin menggunakan modul “Tangga” selama modul tersebut mempunyai versi antara 3.1.0 sampai dengan sebelum versi 4.0.0.\nSebagai pengembang yang bertanggung jawab, tentu saja Anda ingin memverifikasi bahwa peningkatan paket berfungsi seperti yang diiklankan. Dunia nyata tidaklah pasti; tidak ada yang bisa kita lakukan selain waspada. Yang bisa Anda lakukan adalah membiarkan Pemversian Semantik memberi Anda cara yang masuk akal untuk merilis dan memutakhirkan paket tanpa harus menggulirkan versi baru dari paket dependen, membuat Anda menghemat waktu dan kerumitan.\nJika menurut kalian aturan ini bagus, cara untuk memulai menggunakan pemversian semantik adalah dengan menautkan situs ini dalam README kalian supaya orang lain bisa tahu mengenai aturan ini dan mulai menggunakannya juga.\nPertanyaan Yang Sering Diajukan\nBagaimana cara menangani revisi dalam fase pengembangan awal 0.y.z?\nHal yang paling sederhana untuk dilakukan adalah memulai rilis pengembangan awal Anda pada 0.1.0 dan kemudian meningkatkan versi minor untuk setiap rilis berikutnya.\nBagaimana saya tahu kapan merilis 1.0.0?\nJika perangkat lunak Anda digunakan dalam produksi, mungkin perangkat lunak Anda sudah versi 1.0.0. Jika Anda memiliki API yang stabil yang menjadi andalan pengguna, Anda harusnya sudah pada 1.0.0. Jika Anda sangat mengkhawatirkan kompatibilitas versi lama, Anda mungkin sudah pada 1.0.0.\nBukankah standar ini mencegah perkembangan yang cepat?\nVersi major nol adalah tentang pengembangan yang cepat. Jika Anda mengubah API setiap hari, Anda harus tetap berada di versi 0.x.x atau di pengembangan terpisah yang bekerja pada versi major berikutnya.\nJika perubahan terkecil yang tidak kompatibel dengan API publik memerlukan kenaikkan versi major, bukankah saya akan berakhir di versi 42.0.0 dengan sangat cepat?\nIni adalah pertanyaan tentang pengembangan yang bertanggung jawab dan pandangan ke depan. Perubahan yang tidak kompatibel tidak boleh diperkenalkan dengan mudah ke perangkat lunak yang memiliki banyak kode dependen. Biaya yang harus dikeluarkan untuk meng-upgrade bisa sangat besar. Kewajiban mengganti versi major untuk merilis perubahan yang tidak kompatibel seharusnya membuat Anda memikirkan dampak dari perubahan Anda, dan mengevaluasi perbandingan biaya dan manfaat yang terkait.\nMendokumentasikan seluruh API publik sangatlah merepotkan!\nSudah tanggung jawab Anda sebagai pengembang profesional untuk mendokumentasikan perangkat lunak untuk digunakan oleh orang lain dengan benar. Mengelola kompleksitas perangkat lunak adalah bagian yang sangat penting dalam menjaga proyek tetap efisien, dan itu sulit dilakukan jika tidak ada yang tahu cara menggunakan perangkat lunak Anda, atau metode apa yang aman untuk dihubungi. Dalam jangka panjang, Pemversian Semantik, dan desakan pada API publik yang terdefinisi dengan baik dapat membuat semua orang dan segala sesuatu berjalan dengan lancar.\nBagaimana jika secara tidak sengaja membuat perubahan yang menjadikan versi lama tidak bisa dipakai?\nSetelah Anda menyadari bahwa Anda telah melanggar spesifikasi Pemversian Semantik, perbaiki dan rilis versi minor baru yang memperbaiki masalah dan mengembalikan kompatibilitas versi lama. Ingat, memodifikasi rilis yang telah diberi versi adalah dilarang, bahkan dalam kondisi ini. Jika mau, dokumentasikan versi yang bermasalah dan memberi tahu pengguna Anda tentang masalah tersebut sehingga mereka mengetahui versi yang bermasalah.\nApa yang harus saya lakukan jika saya memperbarui dependensi saya sendiri tanpa mengubah API publik?\nHal tersebut dianggap kompatibel karena tidak mempengaruhi API publik. Perangkat lunak yang secara eksplisit bergantung pada dependensi yang sama dengan paket Anda harus memiliki spesifikasi dependensi mereka sendiri dan pembuatnya akan memberi tahu konflik yang ada. Menentukan apakah perubahan tersebut merupakan tingkat patch atau tingkat minor  tergantung pada apakah Anda memperbarui dependensi untuk memperbaiki bug atau memperkenalkan fungsionalitas baru. Saya biasanya mengharapkan kode tambahan untuk contoh yang kedua, yang dalam hal ini jelas merupakan kenaikan tingkat minor.\nApa yang harus saya lakukan jika bug yang sedang diperbaiki mengembalikan kode agar sesuai dengan API publik (misalnya, kode tidak sinkron dengan dokumentasi API publik)?\nGunakan kebijakan terbaik Anda. Jika Anda memiliki audiens yang sangat besar yang akan terpengaruh secara drastis dengan apa yang dimaksudkan oleh API publik, maka lebih baik melakukan rilis versi major, meskipun perbaikannya dapat sangat dianggap sebagai rilis patch. Ingat, Pemversian Semantik adalah segalanya tentang menyampaikan makna melalui perubahan nomor versi. Jika perubahan ini perubahan ini penting bagi pengguna Anda, gunakan nomor versi itu untuk memberi tahu mereka.\nSpesifikasi Pemversian Semantik dibuat oleh Tom Preston-Werner, pembuat Gravatars dan cofounder dari GitHub.\nTerjemahan Bahasa Indonesia ditulis oleh Aditya Purwa, Christian B. Wibowo, dan Hans5958.\nUntuk saran dan kritik, silahkan buka issue di GitHub.\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nPemversian Semantik 1.0.0-beta

Dalam pengembangan perangkat lunak, sering terjadi permasalahan dependency hell. Semakin besar sistem yang dibuat dan semakin banyak modul yang digunakan sistem kita, semakin sering permasalahan ini akan terjadi.

Dalam sistem yang saling terkait, merilis versi baru bisa menjadi mimpi buruk. Jika spesifikasi dependensi sistem terlalu ketat, bisa jadi sistem kita tidak bisa dikembangkan lagi. Jika spesifikasi dependensi sistem terlalu bebas, semakin sulit untuk berasumsi versi mana yang bisa digunakan dengan versi yang lain. Dependency hell adalah saat Anda berada pada satu atau dua masalah ini, yang menahan Anda untuk bergerak maju dengan aman dan mudah.

Sebagai solusi permasalahan ini, saya mengusulkan seperangkat aturan dan persayaratan sederhana yang menentukan bagaimana nomor versi diberikan dan bertambah. Agar sistem ini dapat bekerja, Anda harus mengumumkan API publik terlebih dahulu. Ini dapat terdiri dari dokumentasi atau diberlakukan oleh kode itu sendiri. Apapun itu, API ini harus jelas dan tepat. Setelah Anda mengidentifikasi API publik Anda, Anda mengomunikasikan perubahan pada API tersebut dengan penambahan spesifik pada nomor versi Anda. Pertimbangkan format versi X.Y.Z (Major.Minor.Patch). Perbaikan bug yang tidak memengaruhi API tersebut akan menambah versi patch, penambahan/perubahan API yang kompatibel dengan versi sebelumnya akan menambah versi minor, dan perubahan API yang tidak kompatibel dengan versi sebelumnya akan menambah versi major.

Standar ini bernama “Pemversian Semantik”. Dengan skema ini, setiap orang yang melihat angka versi bisa tahu secara umum apa yang berubah dengan sistem tersebut.

Spesifikasi Pemversian Semantik (SemVer)

Kata/frasa “HARUS” (“MUST”), “TIDAK BOLEH” (“MUST NOT”), “DIBUTUHKAN” (“REQUIRED”), “SEHARUSNYA” (“SHALL”), “JANGAN SAMPAI” (“SHALL NOT”), “SEBAIKNYA” (“SHOULD”), “SEBAIKNYA TIDAK” (“SHOULD NOT”), “DIREKOMENDASIKAN” (“RECOMMENDED”), “BISA” (“MAY”) , dan “OPSIONAL” di dokumen ini sesuai dengan RFC 2119.


  
    Perangkat lunak dengan Pemversian Semantik HARUS menentukan API public. Bisa dijelaskan dengan kode, atau ditulis di dokumentasi saja. Apapun itu harus ditulis dengan jelas dan akurat.
  
  
    Versi normal HARUS ditulis dalam bentuk X.Y.Z, dengan X, Y, dan Z adalah bilangan bulat. X adalah versi major, Y adalah minor, dan Z adalah patch. Setiap elemen HARUS bertambah secara numerik dengan kenaikan sebesar satu. Contohnya: 1.9.0 -> 1.10.0 -> 1.11.0
  
  
    Ketika nomor versi major bertambah, versi minor dan patch versi HARUS diatur ulang ke nol. Ketika nomor versi minor bertambah, nomor versi patch HARUS disetel ulang ke nol. Misalnya: 1.1.3 -> 2.0.0 dan 2.1.7 ->
2.2.0.
  
  
    Versi prarilis BISA ditulis dengan menambahkan titik dan rangkaian pengenal dengan pemisah titik tepat setelah versi patch. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda pisah [0-9A-Za-z] dan HARUS mulai dengan sebuah huruf [A-Za-z]. Versi prarilis diperbolehkan, namun memiliki presendens yang lebih rendah dibandingkan dengan versi normal. Presedens SEBAIKNYA ditentukan dari urutan leksikografik ASCII. Contoh: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Setelah sebuah paket berversi dirilis, isi dari versi tersebut TIDAK BOLEH diubah. Setiap perubahan harus dirilis sebagai versi baru.
  
  
    Versi major 0 (0.y.z) adalah untuk pengembangan awal. Apapun bisa bisa berubah kapanpun. API publik sebaiknya dianggap tidak stabil di versi ini.
  
  
    Versi 1.0.0 adalah titik awal API publik. Cara nomor versi ini dinaikkan setelah rilis ini adalah tergantung dengan API publik ini dan bagaimana ia berubah.
  
  
    Versi patch Z (x.y.Z | x > 0) HARUS dinaikkan jika ada perbaikan bug yang kompatibel dengan versi lama. Sebuah perbaikan bug didefinisikan sebagai perubahan internal yang memperbaiki perilaku yang salah.
  
  
    Versi minor Y (x.Y.z | x > 0) HARUS dinaikkan jika ada fitur baru yang kompatibel dengan versi lama dalam API publik. Ini BISA dinaikkan jika ada tambahan fungsionalitas substansial atau terjadi peningkatan di dalam kode privat. Ini BISA diubah bersama dengan perubahan tingkat patch.
  
  
    Versi major X (X.y.z | X > 0) HARUS dinaikkan jika ada perubahan yang membuat versi baru tidak kompatibel dengan versi lama pada API publik. Ini BISA diubah bersama dengan perubahan tingkat patch dan minor.
  


Spesifikasi Penandaan (SemVerTag)

Subspesifikasi ini SEBAIKNYA digunakan jika Anda menggunakan sistem kontrol versi (Git, Mercurial, SVN, dll) untuk menyimpan kode Anda. Dengan menggunaakan sistem ini, alat otomatis dapat memeriksa paket Anda dan menentukan kepatuhan SemVer dan versi yang dirilis.


  
    Saat menandai rilis dalam sistem kontrol versi, tag untuk sebuah versi HARUS “vX.Y.Z”, seperti “v3.1.0”.
  
  
    Revisi pertama yang memperkenalkan kepatuhan SemVer SEBAIKNYA diberi tag “semver”. Hal ini memungkinkan proyek yang sudah ada sebelumnya untuk mengasumsikan kepatuhan pada suatu titik dan agar alat otomatis tahu tentang hal ini.
  


Kenapa Menggunakan Pemversian Semantik?

Ini bukanlah ide baru yang revolusioner. Faktanya, kalian mungkin sudah menggunakan standar ini, hanya saja tidak terlalu ketat. Masalahnya, “tidak teralu ketat” saja tidak cukup bagus. Tanpa kepatuhan terhadap beberapa jenis spesifikasi formal, nomor versi adalah pada dasarnya tidak berguna untuk manajemen dependensi. Dengan memberikan nama dan definisi yang jelas definisi yang jelas untuk ide-ide tersebut, mengkomunikasikan maksud Anda kepada pengguna perangkat lunak Anda menjadi lebih mudah. Setelah maksud ini jelas, spesifikasi ketergantungan yang fleksibel (tetapi tidak terlalu fleksibel) akhirnya dapat dibuat.

Contoh sederhana ini menunjukkan manfaat Pemversian Semantik untuk menghilangkan “dependency hell.” Misalkan ada sebuah modul bernama “MobilPemadamKebakaran”. Modul “MobilPemadamKebakaran” membutuhkan modul lain bernama “Tangga”. Pada waktu “MobilPemadamKebakaran” dibuat, “Tangga” memiliki versi 3.1.0. Dengan menggunakan Pemversian Semantik, “MobilPemadamKebakaran” bisa dengan yakin menggunakan modul “Tangga” selama modul tersebut mempunyai versi antara 3.1.0 sampai dengan sebelum versi 4.0.0.

Sebagai pengembang yang bertanggung jawab, tentu saja Anda ingin memverifikasi bahwa peningkatan paket berfungsi seperti yang diiklankan. Dunia nyata tidaklah pasti; tidak ada yang bisa kita lakukan selain waspada. Yang bisa Anda lakukan adalah membiarkan Pemversian Semantik memberi Anda cara yang masuk akal untuk merilis dan memutakhirkan paket tanpa harus menggulirkan versi baru dari paket dependen, membuat Anda menghemat waktu dan kerumitan.

Jika menurut kalian aturan ini bagus, cara untuk memulai menggunakan pemversian semantik adalah dengan menautkan situs ini dalam README kalian supaya orang lain bisa tahu mengenai aturan ini dan mulai menggunakannya juga.

Pertanyaan Yang Sering Diajukan

Bagaimana saya tahu kapan merilis 1.0.0?

Jika perangkat lunak Anda digunakan dalam produksi, mungkin perangkat lunak Anda sudah versi 1.0.0. Jika Anda memiliki API yang stabil yang menjadi andalan pengguna, Anda harusnya sudah pada 1.0.0. Jika Anda sangat mengkhawatirkan kompatibilitas versi lama, Anda mungkin sudah pada 1.0.0.

Bukankah standar ini mencegah perkembangan yang cepat?

Versi major nol adalah tentang pengembangan yang cepat. Jika Anda mengubah API setiap hari, Anda harus tetap berada di versi 0.x.x atau di pengembangan terpisah yang bekerja pada versi major berikutnya.

Jika perubahan terkecil yang tidak kompatibel dengan API publik memerlukan kenaikkan versi major, bukankah saya akan berakhir di versi 42.0.0 dengan sangat cepat?

Ini adalah pertanyaan tentang pengembangan yang bertanggung jawab dan pandangan ke depan. Perubahan yang tidak kompatibel tidak boleh diperkenalkan dengan mudah ke perangkat lunak yang memiliki banyak kode dependen. Biaya yang harus dikeluarkan untuk meng-upgrade bisa sangat besar. Kewajiban mengganti versi major untuk merilis perubahan yang tidak kompatibel seharusnya membuat Anda memikirkan dampak dari perubahan Anda, dan mengevaluasi perbandingan biaya dan manfaat yang terkait.

Mendokumentasikan seluruh API publik sangatlah merepotkan!

Sudah tanggung jawab Anda sebagai pengembang profesional untuk mendokumentasikan perangkat lunak untuk digunakan oleh orang lain dengan benar. Mengelola kompleksitas perangkat lunak adalah bagian yang sangat penting dalam menjaga proyek tetap efisien, dan itu sulit dilakukan jika tidak ada yang tahu cara menggunakan perangkat lunak Anda, atau metode apa yang aman untuk dihubungi. Dalam jangka panjang, Pemversian Semantik, dan desakan pada API publik yang terdefinisi dengan baik dapat membuat semua orang dan segala sesuatu berjalan dengan lancar.

Bagaimana jika secara tidak sengaja membuat perubahan yang menjadikan versi lama tidak bisa dipakai?

Setelah Anda menyadari bahwa Anda telah melanggar spesifikasi Pemversian Semantik, perbaiki dan rilis versi minor baru yang memperbaiki masalah dan mengembalikan kompatibilitas versi lama. Ingat, memodifikasi rilis yang telah diberi versi adalah dilarang, bahkan dalam kondisi ini. Jika mau, dokumentasikan versi yang bermasalah dan memberi tahu pengguna Anda tentang masalah tersebut sehingga mereka mengetahui versi yang bermasalah.

Apa yang harus saya lakukan jika saya memperbarui dependensi saya sendiri tanpa mengubah API publik?

Hal tersebut dianggap kompatibel karena tidak mempengaruhi API publik. Perangkat lunak yang secara eksplisit bergantung pada dependensi yang sama dengan paket Anda harus memiliki spesifikasi dependensi mereka sendiri dan pembuatnya akan memberi tahu konflik yang ada. Menentukan apakah perubahan tersebut merupakan tingkat patch atau tingkat minor  tergantung pada apakah Anda memperbarui dependensi untuk memperbaiki bug atau memperkenalkan fungsionalitas baru. Saya biasanya mengharapkan kode tambahan untuk contoh yang kedua, yang dalam hal ini jelas merupakan kenaikan tingkat minor.

Apa yang harus saya lakukan jika bug yang sedang diperbaiki mengembalikan kode agar sesuai dengan API publik (misalnya, kode tidak sinkron dengan dokumentasi API publik)?

Gunakan kebijakan terbaik Anda. Jika Anda memiliki audiens yang sangat besar yang akan terpengaruh secara drastis dengan apa yang dimaksudkan oleh API publik, maka lebih baik melakukan rilis versi major, meskipun perbaikannya dapat sangat dianggap sebagai rilis patch. Ingat, Pemversian Semantik adalah segalanya tentang menyampaikan makna melalui perubahan nomor versi. Jika perubahan ini perubahan ini penting bagi pengguna Anda, gunakan nomor versi itu untuk memberi tahu mereka.

Tentang

Spesifikasi Pemversian Semantik dibuat oleh Tom Preston-Werner, pembuat Gravatars dan cofounder dari GitHub.

Terjemahan Bahasa Indonesia ditulis oleh Aditya Purwa, Christian B. Wibowo, dan Hans5958.

Untuk saran dan kritik, silahkan buka issue di GitHub.

Lisensi

Creative Commons ― CC BY 3.0\nPemversian Semantik 1.0.0-beta\nDalam pengembangan perangkat lunak, sering terjadi permasalahan dependency hell. Semakin besar sistem yang dibuat dan semakin banyak modul yang digunakan sistem kita, semakin sering permasalahan ini akan terjadi.\nDalam sistem yang saling terkait, merilis versi baru bisa menjadi mimpi buruk. Jika spesifikasi dependensi sistem terlalu ketat, bisa jadi sistem kita tidak bisa dikembangkan lagi. Jika spesifikasi dependensi sistem terlalu bebas, semakin sulit untuk berasumsi versi mana yang bisa digunakan dengan versi yang lain. Dependency hell adalah saat Anda berada pada satu atau dua masalah ini, yang menahan Anda untuk bergerak maju dengan aman dan mudah.\nSebagai solusi permasalahan ini, saya mengusulkan seperangkat aturan dan persayaratan sederhana yang menentukan bagaimana nomor versi diberikan dan bertambah. Agar sistem ini dapat bekerja, Anda harus mengumumkan API publik terlebih dahulu. Ini dapat terdiri dari dokumentasi atau diberlakukan oleh kode itu sendiri. Apapun itu, API ini harus jelas dan tepat. Setelah Anda mengidentifikasi API publik Anda, Anda mengomunikasikan perubahan pada API tersebut dengan penambahan spesifik pada nomor versi Anda. Pertimbangkan format versi X.Y.Z (Major.Minor.Patch). Perbaikan bug yang tidak memengaruhi API tersebut akan menambah versi patch, penambahan/perubahan API yang kompatibel dengan versi sebelumnya akan menambah versi minor, dan perubahan API yang tidak kompatibel dengan versi sebelumnya akan menambah versi major.\nStandar ini bernama “Pemversian Semantik”. Dengan skema ini, setiap orang yang melihat angka versi bisa tahu secara umum apa yang berubah dengan sistem tersebut.\nSpesifikasi Pemversian Semantik (SemVer)\nKata/frasa “HARUS” (“MUST”), “TIDAK BOLEH” (“MUST NOT”), “DIBUTUHKAN” (“REQUIRED”), “SEHARUSNYA” (“SHALL”), “JANGAN SAMPAI” (“SHALL NOT”), “SEBAIKNYA” (“SHOULD”), “SEBAIKNYA TIDAK” (“SHOULD NOT”), “DIREKOMENDASIKAN” (“RECOMMENDED”), “BISA” (“MAY”) , dan “OPSIONAL” di dokumen ini sesuai dengan RFC 2119.\nPerangkat lunak dengan Pemversian Semantik HARUS menentukan API public. Bisa dijelaskan dengan kode, atau ditulis di dokumentasi saja. Apapun itu harus ditulis dengan jelas dan akurat.\nPerangkat lunak dengan Pemversian Semantik HARUS menentukan API public. Bisa dijelaskan dengan kode, atau ditulis di dokumentasi saja. Apapun itu harus ditulis dengan jelas dan akurat.\nVersi normal HARUS ditulis dalam bentuk X.Y.Z, dengan X, Y, dan Z adalah bilangan bulat. X adalah versi major, Y adalah minor, dan Z adalah patch. Setiap elemen HARUS bertambah secara numerik dengan kenaikan sebesar satu. Contohnya: 1.9.0 -> 1.10.0 -> 1.11.0\nVersi normal HARUS ditulis dalam bentuk X.Y.Z, dengan X, Y, dan Z adalah bilangan bulat. X adalah versi major, Y adalah minor, dan Z adalah patch. Setiap elemen HARUS bertambah secara numerik dengan kenaikan sebesar satu. Contohnya: 1.9.0 -> 1.10.0 -> 1.11.0\nKetika nomor versi major bertambah, versi minor dan patch versi HARUS diatur ulang ke nol. Ketika nomor versi minor bertambah, nomor versi patch HARUS disetel ulang ke nol. Misalnya: 1.1.3 -> 2.0.0 dan 2.1.7 ->
2.2.0.\nKetika nomor versi major bertambah, versi minor dan patch versi HARUS diatur ulang ke nol. Ketika nomor versi minor bertambah, nomor versi patch HARUS disetel ulang ke nol. Misalnya: 1.1.3 -> 2.0.0 dan 2.1.7 ->
2.2.0.\nVersi prarilis BISA ditulis dengan menambahkan titik dan rangkaian pengenal dengan pemisah titik tepat setelah versi patch. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda pisah [0-9A-Za-z] dan HARUS mulai dengan sebuah huruf [A-Za-z]. Versi prarilis diperbolehkan, namun memiliki presendens yang lebih rendah dibandingkan dengan versi normal. Presedens SEBAIKNYA ditentukan dari urutan leksikografik ASCII. Contoh: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nVersi prarilis BISA ditulis dengan menambahkan titik dan rangkaian pengenal dengan pemisah titik tepat setelah versi patch. Pengenal ini HARUS terdiri dari hanya alfanumerik ASCII dan tanda pisah [0-9A-Za-z] dan HARUS mulai dengan sebuah huruf [A-Za-z]. Versi prarilis diperbolehkan, namun memiliki presendens yang lebih rendah dibandingkan dengan versi normal. Presedens SEBAIKNYA ditentukan dari urutan leksikografik ASCII. Contoh: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nSetelah sebuah paket berversi dirilis, isi dari versi tersebut TIDAK BOLEH diubah. Setiap perubahan harus dirilis sebagai versi baru.\nSetelah sebuah paket berversi dirilis, isi dari versi tersebut TIDAK BOLEH diubah. Setiap perubahan harus dirilis sebagai versi baru.\nVersi major 0 (0.y.z) adalah untuk pengembangan awal. Apapun bisa bisa berubah kapanpun. API publik sebaiknya dianggap tidak stabil di versi ini.\nVersi major 0 (0.y.z) adalah untuk pengembangan awal. Apapun bisa bisa berubah kapanpun. API publik sebaiknya dianggap tidak stabil di versi ini.\nVersi 1.0.0 adalah titik awal API publik. Cara nomor versi ini dinaikkan setelah rilis ini adalah tergantung dengan API publik ini dan bagaimana ia berubah.\nVersi 1.0.0 adalah titik awal API publik. Cara nomor versi ini dinaikkan setelah rilis ini adalah tergantung dengan API publik ini dan bagaimana ia berubah.\nVersi patch Z (x.y.Z | x > 0) HARUS dinaikkan jika ada perbaikan bug yang kompatibel dengan versi lama. Sebuah perbaikan bug didefinisikan sebagai perubahan internal yang memperbaiki perilaku yang salah.\nVersi patch Z (x.y.Z | x > 0) HARUS dinaikkan jika ada perbaikan bug yang kompatibel dengan versi lama. Sebuah perbaikan bug didefinisikan sebagai perubahan internal yang memperbaiki perilaku yang salah.\nVersi minor Y (x.Y.z | x > 0) HARUS dinaikkan jika ada fitur baru yang kompatibel dengan versi lama dalam API publik. Ini BISA dinaikkan jika ada tambahan fungsionalitas substansial atau terjadi peningkatan di dalam kode privat. Ini BISA diubah bersama dengan perubahan tingkat patch.\nVersi minor Y (x.Y.z | x > 0) HARUS dinaikkan jika ada fitur baru yang kompatibel dengan versi lama dalam API publik. Ini BISA dinaikkan jika ada tambahan fungsionalitas substansial atau terjadi peningkatan di dalam kode privat. Ini BISA diubah bersama dengan perubahan tingkat patch.\nVersi major X (X.y.z | X > 0) HARUS dinaikkan jika ada perubahan yang membuat versi baru tidak kompatibel dengan versi lama pada API publik. Ini BISA diubah bersama dengan perubahan tingkat patch dan minor.\nVersi major X (X.y.z | X > 0) HARUS dinaikkan jika ada perubahan yang membuat versi baru tidak kompatibel dengan versi lama pada API publik. Ini BISA diubah bersama dengan perubahan tingkat patch dan minor.\nSpesifikasi Penandaan (SemVerTag)\nSubspesifikasi ini SEBAIKNYA digunakan jika Anda menggunakan sistem kontrol versi (Git, Mercurial, SVN, dll) untuk menyimpan kode Anda. Dengan menggunaakan sistem ini, alat otomatis dapat memeriksa paket Anda dan menentukan kepatuhan SemVer dan versi yang dirilis.\nSaat menandai rilis dalam sistem kontrol versi, tag untuk sebuah versi HARUS “vX.Y.Z”, seperti “v3.1.0”.\nSaat menandai rilis dalam sistem kontrol versi, tag untuk sebuah versi HARUS “vX.Y.Z”, seperti “v3.1.0”.\nRevisi pertama yang memperkenalkan kepatuhan SemVer SEBAIKNYA diberi tag “semver”. Hal ini memungkinkan proyek yang sudah ada sebelumnya untuk mengasumsikan kepatuhan pada suatu titik dan agar alat otomatis tahu tentang hal ini.\nRevisi pertama yang memperkenalkan kepatuhan SemVer SEBAIKNYA diberi tag “semver”. Hal ini memungkinkan proyek yang sudah ada sebelumnya untuk mengasumsikan kepatuhan pada suatu titik dan agar alat otomatis tahu tentang hal ini.\nKenapa Menggunakan Pemversian Semantik?\nIni bukanlah ide baru yang revolusioner. Faktanya, kalian mungkin sudah menggunakan standar ini, hanya saja tidak terlalu ketat. Masalahnya, “tidak teralu ketat” saja tidak cukup bagus. Tanpa kepatuhan terhadap beberapa jenis spesifikasi formal, nomor versi adalah pada dasarnya tidak berguna untuk manajemen dependensi. Dengan memberikan nama dan definisi yang jelas definisi yang jelas untuk ide-ide tersebut, mengkomunikasikan maksud Anda kepada pengguna perangkat lunak Anda menjadi lebih mudah. Setelah maksud ini jelas, spesifikasi ketergantungan yang fleksibel (tetapi tidak terlalu fleksibel) akhirnya dapat dibuat.\nContoh sederhana ini menunjukkan manfaat Pemversian Semantik untuk menghilangkan “dependency hell.” Misalkan ada sebuah modul bernama “MobilPemadamKebakaran”. Modul “MobilPemadamKebakaran” membutuhkan modul lain bernama “Tangga”. Pada waktu “MobilPemadamKebakaran” dibuat, “Tangga” memiliki versi 3.1.0. Dengan menggunakan Pemversian Semantik, “MobilPemadamKebakaran” bisa dengan yakin menggunakan modul “Tangga” selama modul tersebut mempunyai versi antara 3.1.0 sampai dengan sebelum versi 4.0.0.\nSebagai pengembang yang bertanggung jawab, tentu saja Anda ingin memverifikasi bahwa peningkatan paket berfungsi seperti yang diiklankan. Dunia nyata tidaklah pasti; tidak ada yang bisa kita lakukan selain waspada. Yang bisa Anda lakukan adalah membiarkan Pemversian Semantik memberi Anda cara yang masuk akal untuk merilis dan memutakhirkan paket tanpa harus menggulirkan versi baru dari paket dependen, membuat Anda menghemat waktu dan kerumitan.\nJika menurut kalian aturan ini bagus, cara untuk memulai menggunakan pemversian semantik adalah dengan menautkan situs ini dalam README kalian supaya orang lain bisa tahu mengenai aturan ini dan mulai menggunakannya juga.\nPertanyaan Yang Sering Diajukan\nBagaimana saya tahu kapan merilis 1.0.0?\nJika perangkat lunak Anda digunakan dalam produksi, mungkin perangkat lunak Anda sudah versi 1.0.0. Jika Anda memiliki API yang stabil yang menjadi andalan pengguna, Anda harusnya sudah pada 1.0.0. Jika Anda sangat mengkhawatirkan kompatibilitas versi lama, Anda mungkin sudah pada 1.0.0.\nBukankah standar ini mencegah perkembangan yang cepat?\nVersi major nol adalah tentang pengembangan yang cepat. Jika Anda mengubah API setiap hari, Anda harus tetap berada di versi 0.x.x atau di pengembangan terpisah yang bekerja pada versi major berikutnya.\nJika perubahan terkecil yang tidak kompatibel dengan API publik memerlukan kenaikkan versi major, bukankah saya akan berakhir di versi 42.0.0 dengan sangat cepat?\nIni adalah pertanyaan tentang pengembangan yang bertanggung jawab dan pandangan ke depan. Perubahan yang tidak kompatibel tidak boleh diperkenalkan dengan mudah ke perangkat lunak yang memiliki banyak kode dependen. Biaya yang harus dikeluarkan untuk meng-upgrade bisa sangat besar. Kewajiban mengganti versi major untuk merilis perubahan yang tidak kompatibel seharusnya membuat Anda memikirkan dampak dari perubahan Anda, dan mengevaluasi perbandingan biaya dan manfaat yang terkait.\nMendokumentasikan seluruh API publik sangatlah merepotkan!\nSudah tanggung jawab Anda sebagai pengembang profesional untuk mendokumentasikan perangkat lunak untuk digunakan oleh orang lain dengan benar. Mengelola kompleksitas perangkat lunak adalah bagian yang sangat penting dalam menjaga proyek tetap efisien, dan itu sulit dilakukan jika tidak ada yang tahu cara menggunakan perangkat lunak Anda, atau metode apa yang aman untuk dihubungi. Dalam jangka panjang, Pemversian Semantik, dan desakan pada API publik yang terdefinisi dengan baik dapat membuat semua orang dan segala sesuatu berjalan dengan lancar.\nBagaimana jika secara tidak sengaja membuat perubahan yang menjadikan versi lama tidak bisa dipakai?\nSetelah Anda menyadari bahwa Anda telah melanggar spesifikasi Pemversian Semantik, perbaiki dan rilis versi minor baru yang memperbaiki masalah dan mengembalikan kompatibilitas versi lama. Ingat, memodifikasi rilis yang telah diberi versi adalah dilarang, bahkan dalam kondisi ini. Jika mau, dokumentasikan versi yang bermasalah dan memberi tahu pengguna Anda tentang masalah tersebut sehingga mereka mengetahui versi yang bermasalah.\nApa yang harus saya lakukan jika saya memperbarui dependensi saya sendiri tanpa mengubah API publik?\nHal tersebut dianggap kompatibel karena tidak mempengaruhi API publik. Perangkat lunak yang secara eksplisit bergantung pada dependensi yang sama dengan paket Anda harus memiliki spesifikasi dependensi mereka sendiri dan pembuatnya akan memberi tahu konflik yang ada. Menentukan apakah perubahan tersebut merupakan tingkat patch atau tingkat minor  tergantung pada apakah Anda memperbarui dependensi untuk memperbaiki bug atau memperkenalkan fungsionalitas baru. Saya biasanya mengharapkan kode tambahan untuk contoh yang kedua, yang dalam hal ini jelas merupakan kenaikan tingkat minor.\nApa yang harus saya lakukan jika bug yang sedang diperbaiki mengembalikan kode agar sesuai dengan API publik (misalnya, kode tidak sinkron dengan dokumentasi API publik)?\nGunakan kebijakan terbaik Anda. Jika Anda memiliki audiens yang sangat besar yang akan terpengaruh secara drastis dengan apa yang dimaksudkan oleh API publik, maka lebih baik melakukan rilis versi major, meskipun perbaikannya dapat sangat dianggap sebagai rilis patch. Ingat, Pemversian Semantik adalah segalanya tentang menyampaikan makna melalui perubahan nomor versi. Jika perubahan ini perubahan ini penting bagi pengguna Anda, gunakan nomor versi itu untuk memberi tahu mereka.\nSpesifikasi Pemversian Semantik dibuat oleh Tom Preston-Werner, pembuat Gravatars dan cofounder dari GitHub.\nTerjemahan Bahasa Indonesia ditulis oleh Aditya Purwa, Christian B. Wibowo, dan Hans5958.\nUntuk saran dan kritik, silahkan buka issue di GitHub.\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nVersionamento Semantico 2.0.0

Sommario

Dato un numero di versione MAJOR.MINOR.PATCH, incrementate la:


  versione MAJOR quando modificate l’API in modo non retrocompatibile
  versione MINOR quando aggiungete funzionalità in modo retrocompatibile
  versione PATCH quando correggete bug in modo retrocompatibile


Sono disponibili etichette aggiuntive per il pre-release e i metadati di build come
estensioni al formato MAJOR.MINOR.PATCH.

Introduzione

Nel mondo della gestione del software esiste un luogo terrificante chiamato
“inferno della dipendenza”. Quanto più cresce il vostro sistema e quanti più 
pacchetti integrate nel vostro software, tanto più facilmente vi ritroverete, un 
giorno, in questa valle di lacrime.

Nei sistemi con molte dipendenze, rilasciare nuove versioni di pacchetti può 
diventare rapidamente un incubo. Se le specifiche di dipendenza sono troppo 
stringenti, siete a rischio di blocco di versione (l’impossibilità di aggiornare
un pacchetto senza dover rilasciare nuove versioni di ogni pacchetto 
dipendente). Se le dipendenze sono specificate in modo troppo permissivo, sarete
inevitabilmente afflitti da promiscuità di versione (l’ipotizzare compatibilità 
con versioni future più di quanto sia ragionevole). L’inferno della dipendenza 
è dove siete quando blocco di versione e/o promiscuità di versione vi impediscono 
di far avanzare il vostro progetto in modo facile e sicuro.

Come soluzione a questo problema, propongo un semplice insieme di regole e 
requisiti che stabiliscono come i numeri di versione siano assegnati ed 
incrementati.
Queste regole sono basate su, ma non necessariamente limitate a, diffuse
pratiche comuni adottate sia in software proprietario che open source.
Affinché questo sistema funzioni, avete prima bisogno di dichiarare un’API 
pubblica. Quest’ultima può consistere di documentazione o essere imposta tramite
il codice stesso. In ogni caso, è importante che tale API sia chiara e precisa. 
Una volta identificata la vostra API pubblica, comunicatene le modifiche con 
incrementi specifici del numero di versione. Considerate un formato di 
versione X.Y.Z (Major.Minor.Patch). La correzione di bug, non influenzando
l’API, incrementa la versione Patch, aggiunte/modifiche retrocompatibili all’API
incrementano la versione Minor, e modifiche non retrocompatibili all’API
incrementano la versione Major.

Chiamo questo sistema “Versionamento Semantico”. Con queste convenzioni i numeri di 
versione, ed il modo in cui essi cambiano, comunicano significato relativamente
al codice sottostante e a cosa è stato modificato da una versione all’altra.

Specifica di Versionamento Semantico (SemVer)

Le parole chiave “DEVE” (“MUST”), “NON DEVE” (“MUST NOT”), “REQUIRED”, “SHALL”, 
“SHALL NOT”, “DOVREBBE” (“SHOULD”), “SHOULD NOT”, “RECOMMENDED”, “PUO’” (“MAY”), 
e “OPTIONAL” in questo documento sono da interpretarsi come descritto nella 
RFC 2119.


  
    Software che usa Versionamento Semantico DEVE dichiarare un’API pubblica. 
Questa API potrebbe essere dichiarata nel codice stesso oppure essere definita 
rigorosamente nella documentazione. Indipendentemente da come è dichiarata, dovrebbe
essere precisa a completa.
  
  
    Un numero di versione normale DEVE essere nella forma X.Y.Z, dove X, Y, e Z 
sono interi non negativi, e NON DEVONO contenere zeri iniziali. X è la versione
major, Y è la versione minor, e Z è la versione patch.
Ogni elemento DEVE incrementare come numero a sé. Per esempio: 
1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Una volta che un pacchetto versionato è stato rilasciato, i contenuti di
quella versione NON DEVONO essere modificati. Qualsiasi modifica DEVE essere
rilasciata come una nuova versione.
  
  
    La versione Major zero (0.y.z) è per lo sviluppo iniziale. Qualunque cosa
può cambiare in qualsiasi istante. L’API pubblica non dovrebbe essere 
considerata stabile.
  
  
    La versione 1.0.0 definisce l’API pubblica. Il modo in cui il numero di 
versione è incrementato dopo questo rilascio dipende da questa API pubblica
e da come quest’ultima cambia.
  
  
    La versione Patch Z (x.y.Z | x > 0) DEVE essere incrementata solo se sono
introdotte correzioni retrocompatibili di bug. Una correzione di un bug è
definita come una modifica interna che corregge un comportamento errato.
  
  
    La versione Minor Y (x.Y.z | x > 0) DEVE essere incrementata se nell’API 
pubblica è introdotta una nuova funzionalità retrocompatibile. Essa DEVE essere
incrementata se qualsiasi funzionalità dell’API pubblica è marcata come 
deprecata. Essa PUO’ essere incrementata se sono introdotti all’interno del 
codice privato nuove funzionalità o miglioramenti sostanziali. Essa PUO’ 
includere modifiche di livello patch. La versione Patch DEVE essere
reimpostata a 0 quando la versione Minor è incrementata.
  
  
    La versione Major X (X.y.z | X > 0) DEVE essere incrementata se nell’API 
pubblica è introdotta qualsiasi modifica non retrocompatibile. Essa PUO’ 
includere modifiche di livello minor e patch. Le versioni patch e minor DEVONO
essere reimpostate a 0 quando la versione major è incrementata.
  
  
    Una versione di pre-rilascio PUO’ essere indicata aggiungendo immediatamente 
dopo la versione patch un trattino e una serie di identificatori separati dal 
punto. Gli identificatori DEVONO essere composti solo da alfanumerici ASCII e 
trattini [0-9A-Za-z-]. Gli identificatori NON DEVONO essere vuoti. Gli
identificatori numerici NON DEVONO includere zeri iniziali. Le versioni di
pre-rilascio hanno una precedenza inferiore rispetto alla versione normale
associata. Una versione di pre-rilascio indica che la versione è instabile
e potrebbe non soddisfare i requisiti di compatibilità intesi come indicato 
dalla versione normale ad essa associata. Esempi: 1.0.0-alpha, 1.0.0-alpha.1, 
1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Metadati di build POSSONO essere indicati aggiungendo immediatamente dopo la
versione patch o pre-rilascio un segno di addizione e una serie di 
identificatori separati dal punto. Gli identificatori DEVONO essere composti 
solo da alfanumerici ASCII e trattini [0-9A-Za-z-]. Gli identificatori NON 
DEVONO essere vuoti. I metadati di build dovrebbero essere ignorati nella 
determinazione della precedenza delle versione. Perciò due versioni che 
differiscono solo per i metadati di build, hanno la stessa precedenza. Esempi: 
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    La precedenza si riferisce a come le versioni sono confrontate l’una con
l’altra quando poste in relazione d’ordine. La precedenza DEVE essere calcolata 
separando gli identificatori nell’ordine seguente: major, minor, patch e 
pre-release (i metadati di build non compaiono nella precedenza). La precedenza 
è determinata dalla prima discrepanza quando si confrontano ognuno di tali 
identificatori da sinistra a destra come segue: le versioni major, minor e 
patch sono sempre confrontate numericamente. Esempio: 1.0.0 < 2.0.0 < 2.1.0 < 
2.1.1. 
Quando major, minor, e patch sono uguali, una versione di pre-rilascio ha una 
precedenza inferiore rispetto alla versione normale. Esempio: 1.0.0-alpha < 
1.0.0. 
La precedenza per due versioni di pre-rilascio con la stessa versione major, 
minor, e patch DEVE essere determinata confrontando ognuno degli identificatori
separati dal punto da sinistra a destra finché si trova una discrepanza come 
segue: gli identificatori costituiti da sole cifre sono confrontati 
numericamente e gli identificatori con lettere o trattini sono confrontati
lessicalmente secondo l’ordinamento ASCII. Gli identificatori numerici hanno
sempre una precedenza più bassa rispetto agli identificatori non numerici. 
Un insieme più grande di identificatori ha una precedenza superiore rispetto
ad un insieme più piccolo, se tutti quanti i precedenti identificatori sono 
uguali. Esempio: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Perché usare Versionamento Semantico?

Questa non è un’idea rivoluzionaria. Infatti, probabilmente fate già qualcosa di
simile a questo. Il problema è che quel “simile” non è abbastanza buono.
Senza la conformità a qualche tipo di specifica formale, i numeri di versione
sono essenzialmente inutili per una gestione delle dipendenze. Dando un nome
ed una chiara definizione alle idee sopra, diventa semplice comunicare le vostre
intenzioni agli utenti del vostro software. Quando queste intenzioni sono chiare,
flessibili (ma non troppo flessibili) le specifiche di dipendenza possono
finalmente essere realizzate.

Un semplice esempio dimostrerà come Versionamento Semantico può rendere 
l’inferno della dipendenza una cosa del passato. Considerate una libreria
chiamata “CamionDeiPompieri”. Essa richiede un pacchetto semanticamente 
versionato di nome “Scala”. All’istante in cui è creato, Scala è alla versione 
3.1.0. Poiché CamionDeiPompieri utilizza alcune funzionalità che furono 
inizialmente introdotte in 3.1.0, potete specificare con sicurezza la dipendenza 
da Scala come maggiore o uguale a 3.1.0 ma minore di 4.0.0. Ora, quando Scala 
versione 3.1.1 e 3.2.0 diventano disponibili, potete rilasciarle al vostro sistema 
di gestione dei pacchetti e sapere che esse saranno compatibili con software 
dipendente esistente.

In qualità di sviluppatori responsabili vorrete, naturalmente, verificare che
qualsiasi aggiornamento di pacchetto funzioni come descritto. Il mondo reale è
un luogo caotico; non possiamo farci nulla se non essere vigili. Ciò che potete
fare è consentire a Versionamento Semantico di fornirvi un modo sano di 
rilasciare ed aggiornare i pacchetti senza dover propagare le nuove versioni
ai pacchetti dipendenti, facendovi risparmiare tempo e fastidio.

Se tutto questo vi suona desiderabile, tutto ciò che vi serve fare per iniziare 
ad usare Versionamento Semantico è dichiarare che state facendo così e poi 
seguire le regole. Rimandate a questo sito web dal vostro LEGGIMI (README) così altri
conosceranno le regole e potranno beneficiarne.

FAQ

Come dovrei gestire revisioni nella fase iniziale 0.y.z di sviluppo?

La cosa più semplice da fare è cominciare da 0.1.0 con il rilascio di sviluppo 
iniziale e poi incrementare la versione minor per ogni successivo rilascio.

Come faccio a sapere quando rilasciare la 1.0.0?

Se il vostro software è usato in produzione, dovrebbe probabilmente già essere
alla 1.0.0. Se avete un’API stabile dalla quale gli utenti sono diventati 
dipendenti, dovreste essere alla 1.0.0. Se vi state preoccupando molto 
relativamente alla retrocompatibilità, dovreste probabilmente già essere alla 
1.0.0.

Questo non scoraggia lo sviluppo rapido e le iterazioni veloci?

La versione Major zero riguarda completamente lo sviluppo rapido. Se state 
modificando l’API ogni giorno dovreste o essere già nella versione 0.y.z oppure 
essere su un ramo di sviluppo separato lavorando alla prossima
versione major.

Se perfino la più piccola modifica non retrocompatibile all’API pubblica comporta un colpo alla versione major, non finirei alla versione 42.0.0 molto rapidamente?

Questa è una questione di sviluppo responsabile e lungimiranza. Modifiche
incompatibili non dovrebbero essere introdotte con leggerezza a software che
ha molto codice dipendente. Il costo in cui si potrebbe incorrere per aggiornare
potrebbe essere significativo. Dover dar colpi alla versione major per 
rilasciare modifiche incompatibili significa che penserete all’impatto delle vostre 
modifiche, e valuterete il rapporto costi/benefici coinvolto.

Documentare l’intera API pubblica è troppo lavoro!

E’ vostra responsabilità come sviluppatori professionisti documentare 
appropriatamente software il cui uso è destinato ad altri. Gestire la
complessità del software è una parte enormemente importante per mantenere
un progetto efficiente, e ciò è difficile da fare se nessuno sa come usare il
vostro software, o nessuno sa con sicurezza quali metodi sono invocabili. Nel lungo 
periodo Versionamento Semantico, ed il perseverare su un’API pubblica ben 
documentata, è in grado di far andare tutto liscio.

Cosa faccio se rilascio accidentalmente una modifica non retrocompatibile come versione minor?

Non appena realizzate di aver infranto le specifiche di Versionamento Semantico,
correggete il problema e rilasciate una nuova versione minor che corregga il 
problema e ripristini la retrocompatibilità. Perfino in tali circostanze,
non è accettabile modificare una versione rilasciata. Se è appropriato,
documentate la versione illecita ed informate i vostri utenti del problema cosicché
siano consapevoli della versione illecita.

Cosa dovrei fare se aggiorno le mie dipendenze senza modificare l’API pubblica?

Ciò sarebbe considerato compatibile poiché non interessa l’API pubblica.
Software che dipendono esplicitamente dalle stesse dipendenze del vostro 
pacchetto dovrebbero avere le loro proprie specifiche di dipendenza e l’autore 
noterà qualsiasi conflitto. Determinare se la modifica sia di livello patch o
minor dipende se avete aggiornato le vostre dipendenze per correggere un bug o
per introdurre una nuova funzionalità. In quest’ultimo caso solitamente mi 
aspetto del codice aggiuntivo, ed ovviamente un incremento della versione
minor.

Cosa faccio se inavvertitamente altero l’API pubblica in un modo non conforme con la modifica al numero di versione (per esempio il codice introduce erroneamente una modifica che rompe la major in un rilascio di una patch).

Utilizzate il buon senso. Se avete una platea immensa che sarebbe drasticamente
impattata dal ripristinio del comportamento atteso dell’API pubblica, allora
potrebbe essere meglio eseguire un rilascio di una versione major, perfino se
la correzione potrebbe strettamente essere considerata il rilascio di una patch.
Ricordate, Versionamento Semantico, è finalizzato alla comunicazione di 
significato attraverso il cambiamento del numero di versione. Se tali 
modifiche sono importanti per i vostri utenti, usate il numero di versione
per informarli.

Come dovrei gestire la deprecazione di funzionalità?

Deprecare funzionalità esistenti fa parte del normale sviluppo di software ed è
spesso necessario per fare progressi in avanti. Quando deprecate parte della
vostra API pubblica, dovreste fare due cose: (1) aggiornare la vostra documentazione
per consentire agli utenti di essere consapevoli della modifica, (2) distribuire
un nuovo rilascio minor con la deprecazione all’interno. Prima di rimuovere
completamente la funzionalità nel rilascio di una nuova major dovrebbe esserci 
al minimo un rilascio minor che contenga la deprecazione cosicché gli utenti 
siano in grado di migrare tranquillamente alla nuova API.

Versionamento Semantico ha un limite alla dimensione della stringa della versione?

No, ma usate il buon senso. Per esempio, una stringa di versione di 255 caratteri 
è eccessiva. Inoltre, sistemi specifici possono imporre i loro limiti sulla 
dimensione.

“v1.2.3” è una versione semantica?

No, “v1.2.3” non è una versione semantica. Tuttavia, prefissare una versione semantica
con una “v” è un modo comune (in inglese) di indicare che si tratta di un numero di versione.
L’abbreviazione “v” per “version” si incontra spesso nel controllo di versione. Esempio:
git tag v1.2.3 -m "Release version 1.2.3", ove “v1.2.3” è un nome di tag
e la versione semantica è “1.2.3”.

Esiste una espressione regolare (RegEx) suggerita per controllare la stringa SemVer?

Ne esistono due. Una con i gruppi nominati per quei sistemi che li supportano
(PCRE [Perl Compatible Regular Expressions, i.e. Perl, PHP ed R], Python
e Go).

Vedi: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


…ed una con invece i gruppi di cattura numerati (quindi cg1 = major, cg2 = minor,
cg3 = patch, cg4 = prerelease and cg5 = buildmetadata) che è compatibile
con ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
i.e. Perl, PHP ed R), Python e Go.

Vedi: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


A riguardo

La specifica di Versionamento Semantico è scritta da Tom
Preston-Werner, inventore di Gravatars e
cofondatore di GitHub.

Traduzione a cura del Java User Group Padova:

  Tarin Gamberini (autore)
  Enrico Mezzato (revisore)
  Emanuele Gesuato (revisore)
  Anicet Foba Togue (revisore)


…e di Lorenzo L. Ancora (autore)

Se vi piacerebbe lasciare un commento, per favore aprite una segnalazione su 
GitHub.

Licenza

Creative Commons ― CC BY 3.0\nVersionamento Semantico 2.0.0\nDato un numero di versione MAJOR.MINOR.PATCH, incrementate la:\nversione MAJOR quando modificate l’API in modo non retrocompatibile\nversione MINOR quando aggiungete funzionalità in modo retrocompatibile\nversione PATCH quando correggete bug in modo retrocompatibile\nSono disponibili etichette aggiuntive per il pre-release e i metadati di build come
estensioni al formato MAJOR.MINOR.PATCH.\nNel mondo della gestione del software esiste un luogo terrificante chiamato
“inferno della dipendenza”. Quanto più cresce il vostro sistema e quanti più 
pacchetti integrate nel vostro software, tanto più facilmente vi ritroverete, un 
giorno, in questa valle di lacrime.\nNei sistemi con molte dipendenze, rilasciare nuove versioni di pacchetti può 
diventare rapidamente un incubo. Se le specifiche di dipendenza sono troppo 
stringenti, siete a rischio di blocco di versione (l’impossibilità di aggiornare
un pacchetto senza dover rilasciare nuove versioni di ogni pacchetto 
dipendente). Se le dipendenze sono specificate in modo troppo permissivo, sarete
inevitabilmente afflitti da promiscuità di versione (l’ipotizzare compatibilità 
con versioni future più di quanto sia ragionevole). L’inferno della dipendenza 
è dove siete quando blocco di versione e/o promiscuità di versione vi impediscono 
di far avanzare il vostro progetto in modo facile e sicuro.\nCome soluzione a questo problema, propongo un semplice insieme di regole e 
requisiti che stabiliscono come i numeri di versione siano assegnati ed 
incrementati.
Queste regole sono basate su, ma non necessariamente limitate a, diffuse
pratiche comuni adottate sia in software proprietario che open source.
Affinché questo sistema funzioni, avete prima bisogno di dichiarare un’API 
pubblica. Quest’ultima può consistere di documentazione o essere imposta tramite
il codice stesso. In ogni caso, è importante che tale API sia chiara e precisa. 
Una volta identificata la vostra API pubblica, comunicatene le modifiche con 
incrementi specifici del numero di versione. Considerate un formato di 
versione X.Y.Z (Major.Minor.Patch). La correzione di bug, non influenzando
l’API, incrementa la versione Patch, aggiunte/modifiche retrocompatibili all’API
incrementano la versione Minor, e modifiche non retrocompatibili all’API
incrementano la versione Major.\nChiamo questo sistema “Versionamento Semantico”. Con queste convenzioni i numeri di 
versione, ed il modo in cui essi cambiano, comunicano significato relativamente
al codice sottostante e a cosa è stato modificato da una versione all’altra.\nSpecifica di Versionamento Semantico (SemVer)\nLe parole chiave “DEVE” (“MUST”), “NON DEVE” (“MUST NOT”), “REQUIRED”, “SHALL”, 
“SHALL NOT”, “DOVREBBE” (“SHOULD”), “SHOULD NOT”, “RECOMMENDED”, “PUO’” (“MAY”), 
e “OPTIONAL” in questo documento sono da interpretarsi come descritto nella 
RFC 2119.\nSoftware che usa Versionamento Semantico DEVE dichiarare un’API pubblica. 
Questa API potrebbe essere dichiarata nel codice stesso oppure essere definita 
rigorosamente nella documentazione. Indipendentemente da come è dichiarata, dovrebbe
essere precisa a completa.\nSoftware che usa Versionamento Semantico DEVE dichiarare un’API pubblica. 
Questa API potrebbe essere dichiarata nel codice stesso oppure essere definita 
rigorosamente nella documentazione. Indipendentemente da come è dichiarata, dovrebbe
essere precisa a completa.\nUn numero di versione normale DEVE essere nella forma X.Y.Z, dove X, Y, e Z 
sono interi non negativi, e NON DEVONO contenere zeri iniziali. X è la versione
major, Y è la versione minor, e Z è la versione patch.
Ogni elemento DEVE incrementare come numero a sé. Per esempio: 
1.9.0 -> 1.10.0 -> 1.11.0.\nUn numero di versione normale DEVE essere nella forma X.Y.Z, dove X, Y, e Z 
sono interi non negativi, e NON DEVONO contenere zeri iniziali. X è la versione
major, Y è la versione minor, e Z è la versione patch.
Ogni elemento DEVE incrementare come numero a sé. Per esempio: 
1.9.0 -> 1.10.0 -> 1.11.0.\nUna volta che un pacchetto versionato è stato rilasciato, i contenuti di
quella versione NON DEVONO essere modificati. Qualsiasi modifica DEVE essere
rilasciata come una nuova versione.\nUna volta che un pacchetto versionato è stato rilasciato, i contenuti di
quella versione NON DEVONO essere modificati. Qualsiasi modifica DEVE essere
rilasciata come una nuova versione.\nLa versione Major zero (0.y.z) è per lo sviluppo iniziale. Qualunque cosa
può cambiare in qualsiasi istante. L’API pubblica non dovrebbe essere 
considerata stabile.\nLa versione Major zero (0.y.z) è per lo sviluppo iniziale. Qualunque cosa
può cambiare in qualsiasi istante. L’API pubblica non dovrebbe essere 
considerata stabile.\nLa versione 1.0.0 definisce l’API pubblica. Il modo in cui il numero di 
versione è incrementato dopo questo rilascio dipende da questa API pubblica
e da come quest’ultima cambia.\nLa versione 1.0.0 definisce l’API pubblica. Il modo in cui il numero di 
versione è incrementato dopo questo rilascio dipende da questa API pubblica
e da come quest’ultima cambia.\nLa versione Patch Z (x.y.Z | x > 0) DEVE essere incrementata solo se sono
introdotte correzioni retrocompatibili di bug. Una correzione di un bug è
definita come una modifica interna che corregge un comportamento errato.\nLa versione Patch Z (x.y.Z | x > 0) DEVE essere incrementata solo se sono
introdotte correzioni retrocompatibili di bug. Una correzione di un bug è
definita come una modifica interna che corregge un comportamento errato.\nLa versione Minor Y (x.Y.z | x > 0) DEVE essere incrementata se nell’API 
pubblica è introdotta una nuova funzionalità retrocompatibile. Essa DEVE essere
incrementata se qualsiasi funzionalità dell’API pubblica è marcata come 
deprecata. Essa PUO’ essere incrementata se sono introdotti all’interno del 
codice privato nuove funzionalità o miglioramenti sostanziali. Essa PUO’ 
includere modifiche di livello patch. La versione Patch DEVE essere
reimpostata a 0 quando la versione Minor è incrementata.\nLa versione Minor Y (x.Y.z | x > 0) DEVE essere incrementata se nell’API 
pubblica è introdotta una nuova funzionalità retrocompatibile. Essa DEVE essere
incrementata se qualsiasi funzionalità dell’API pubblica è marcata come 
deprecata. Essa PUO’ essere incrementata se sono introdotti all’interno del 
codice privato nuove funzionalità o miglioramenti sostanziali. Essa PUO’ 
includere modifiche di livello patch. La versione Patch DEVE essere
reimpostata a 0 quando la versione Minor è incrementata.\nLa versione Major X (X.y.z | X > 0) DEVE essere incrementata se nell’API 
pubblica è introdotta qualsiasi modifica non retrocompatibile. Essa PUO’ 
includere modifiche di livello minor e patch. Le versioni patch e minor DEVONO
essere reimpostate a 0 quando la versione major è incrementata.\nLa versione Major X (X.y.z | X > 0) DEVE essere incrementata se nell’API 
pubblica è introdotta qualsiasi modifica non retrocompatibile. Essa PUO’ 
includere modifiche di livello minor e patch. Le versioni patch e minor DEVONO
essere reimpostate a 0 quando la versione major è incrementata.\nUna versione di pre-rilascio PUO’ essere indicata aggiungendo immediatamente 
dopo la versione patch un trattino e una serie di identificatori separati dal 
punto. Gli identificatori DEVONO essere composti solo da alfanumerici ASCII e 
trattini [0-9A-Za-z-]. Gli identificatori NON DEVONO essere vuoti. Gli
identificatori numerici NON DEVONO includere zeri iniziali. Le versioni di
pre-rilascio hanno una precedenza inferiore rispetto alla versione normale
associata. Una versione di pre-rilascio indica che la versione è instabile
e potrebbe non soddisfare i requisiti di compatibilità intesi come indicato 
dalla versione normale ad essa associata. Esempi: 1.0.0-alpha, 1.0.0-alpha.1, 
1.0.0-0.3.7, 1.0.0-x.7.z.92.\nUna versione di pre-rilascio PUO’ essere indicata aggiungendo immediatamente 
dopo la versione patch un trattino e una serie di identificatori separati dal 
punto. Gli identificatori DEVONO essere composti solo da alfanumerici ASCII e 
trattini [0-9A-Za-z-]. Gli identificatori NON DEVONO essere vuoti. Gli
identificatori numerici NON DEVONO includere zeri iniziali. Le versioni di
pre-rilascio hanno una precedenza inferiore rispetto alla versione normale
associata. Una versione di pre-rilascio indica che la versione è instabile
e potrebbe non soddisfare i requisiti di compatibilità intesi come indicato 
dalla versione normale ad essa associata. Esempi: 1.0.0-alpha, 1.0.0-alpha.1, 
1.0.0-0.3.7, 1.0.0-x.7.z.92.\nMetadati di build POSSONO essere indicati aggiungendo immediatamente dopo la
versione patch o pre-rilascio un segno di addizione e una serie di 
identificatori separati dal punto. Gli identificatori DEVONO essere composti 
solo da alfanumerici ASCII e trattini [0-9A-Za-z-]. Gli identificatori NON 
DEVONO essere vuoti. I metadati di build dovrebbero essere ignorati nella 
determinazione della precedenza delle versione. Perciò due versioni che 
differiscono solo per i metadati di build, hanno la stessa precedenza. Esempi: 
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nMetadati di build POSSONO essere indicati aggiungendo immediatamente dopo la
versione patch o pre-rilascio un segno di addizione e una serie di 
identificatori separati dal punto. Gli identificatori DEVONO essere composti 
solo da alfanumerici ASCII e trattini [0-9A-Za-z-]. Gli identificatori NON 
DEVONO essere vuoti. I metadati di build dovrebbero essere ignorati nella 
determinazione della precedenza delle versione. Perciò due versioni che 
differiscono solo per i metadati di build, hanno la stessa precedenza. Esempi: 
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nLa precedenza si riferisce a come le versioni sono confrontate l’una con
l’altra quando poste in relazione d’ordine. La precedenza DEVE essere calcolata 
separando gli identificatori nell’ordine seguente: major, minor, patch e 
pre-release (i metadati di build non compaiono nella precedenza). La precedenza 
è determinata dalla prima discrepanza quando si confrontano ognuno di tali 
identificatori da sinistra a destra come segue: le versioni major, minor e 
patch sono sempre confrontate numericamente. Esempio: 1.0.0 < 2.0.0 < 2.1.0 < 
2.1.1. 
Quando major, minor, e patch sono uguali, una versione di pre-rilascio ha una 
precedenza inferiore rispetto alla versione normale. Esempio: 1.0.0-alpha < 
1.0.0. 
La precedenza per due versioni di pre-rilascio con la stessa versione major, 
minor, e patch DEVE essere determinata confrontando ognuno degli identificatori
separati dal punto da sinistra a destra finché si trova una discrepanza come 
segue: gli identificatori costituiti da sole cifre sono confrontati 
numericamente e gli identificatori con lettere o trattini sono confrontati
lessicalmente secondo l’ordinamento ASCII. Gli identificatori numerici hanno
sempre una precedenza più bassa rispetto agli identificatori non numerici. 
Un insieme più grande di identificatori ha una precedenza superiore rispetto
ad un insieme più piccolo, se tutti quanti i precedenti identificatori sono 
uguali. Esempio: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nLa precedenza si riferisce a come le versioni sono confrontate l’una con
l’altra quando poste in relazione d’ordine. La precedenza DEVE essere calcolata 
separando gli identificatori nell’ordine seguente: major, minor, patch e 
pre-release (i metadati di build non compaiono nella precedenza). La precedenza 
è determinata dalla prima discrepanza quando si confrontano ognuno di tali 
identificatori da sinistra a destra come segue: le versioni major, minor e 
patch sono sempre confrontate numericamente. Esempio: 1.0.0 < 2.0.0 < 2.1.0 < 
2.1.1. 
Quando major, minor, e patch sono uguali, una versione di pre-rilascio ha una 
precedenza inferiore rispetto alla versione normale. Esempio: 1.0.0-alpha < 
1.0.0. 
La precedenza per due versioni di pre-rilascio con la stessa versione major, 
minor, e patch DEVE essere determinata confrontando ognuno degli identificatori
separati dal punto da sinistra a destra finché si trova una discrepanza come 
segue: gli identificatori costituiti da sole cifre sono confrontati 
numericamente e gli identificatori con lettere o trattini sono confrontati
lessicalmente secondo l’ordinamento ASCII. Gli identificatori numerici hanno
sempre una precedenza più bassa rispetto agli identificatori non numerici. 
Un insieme più grande di identificatori ha una precedenza superiore rispetto
ad un insieme più piccolo, se tutti quanti i precedenti identificatori sono 
uguali. Esempio: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPerché usare Versionamento Semantico?\nQuesta non è un’idea rivoluzionaria. Infatti, probabilmente fate già qualcosa di
simile a questo. Il problema è che quel “simile” non è abbastanza buono.
Senza la conformità a qualche tipo di specifica formale, i numeri di versione
sono essenzialmente inutili per una gestione delle dipendenze. Dando un nome
ed una chiara definizione alle idee sopra, diventa semplice comunicare le vostre
intenzioni agli utenti del vostro software. Quando queste intenzioni sono chiare,
flessibili (ma non troppo flessibili) le specifiche di dipendenza possono
finalmente essere realizzate.\nUn semplice esempio dimostrerà come Versionamento Semantico può rendere 
l’inferno della dipendenza una cosa del passato. Considerate una libreria
chiamata “CamionDeiPompieri”. Essa richiede un pacchetto semanticamente 
versionato di nome “Scala”. All’istante in cui è creato, Scala è alla versione 
3.1.0. Poiché CamionDeiPompieri utilizza alcune funzionalità che furono 
inizialmente introdotte in 3.1.0, potete specificare con sicurezza la dipendenza 
da Scala come maggiore o uguale a 3.1.0 ma minore di 4.0.0. Ora, quando Scala 
versione 3.1.1 e 3.2.0 diventano disponibili, potete rilasciarle al vostro sistema 
di gestione dei pacchetti e sapere che esse saranno compatibili con software 
dipendente esistente.\nIn qualità di sviluppatori responsabili vorrete, naturalmente, verificare che
qualsiasi aggiornamento di pacchetto funzioni come descritto. Il mondo reale è
un luogo caotico; non possiamo farci nulla se non essere vigili. Ciò che potete
fare è consentire a Versionamento Semantico di fornirvi un modo sano di 
rilasciare ed aggiornare i pacchetti senza dover propagare le nuove versioni
ai pacchetti dipendenti, facendovi risparmiare tempo e fastidio.\nSe tutto questo vi suona desiderabile, tutto ciò che vi serve fare per iniziare 
ad usare Versionamento Semantico è dichiarare che state facendo così e poi 
seguire le regole. Rimandate a questo sito web dal vostro LEGGIMI (README) così altri
conosceranno le regole e potranno beneficiarne.\nCome dovrei gestire revisioni nella fase iniziale 0.y.z di sviluppo?\nLa cosa più semplice da fare è cominciare da 0.1.0 con il rilascio di sviluppo 
iniziale e poi incrementare la versione minor per ogni successivo rilascio.\nCome faccio a sapere quando rilasciare la 1.0.0?\nSe il vostro software è usato in produzione, dovrebbe probabilmente già essere
alla 1.0.0. Se avete un’API stabile dalla quale gli utenti sono diventati 
dipendenti, dovreste essere alla 1.0.0. Se vi state preoccupando molto 
relativamente alla retrocompatibilità, dovreste probabilmente già essere alla 
1.0.0.\nQuesto non scoraggia lo sviluppo rapido e le iterazioni veloci?\nLa versione Major zero riguarda completamente lo sviluppo rapido. Se state 
modificando l’API ogni giorno dovreste o essere già nella versione 0.y.z oppure 
essere su un ramo di sviluppo separato lavorando alla prossima
versione major.\nSe perfino la più piccola modifica non retrocompatibile all’API pubblica comporta un colpo alla versione major, non finirei alla versione 42.0.0 molto rapidamente?\nQuesta è una questione di sviluppo responsabile e lungimiranza. Modifiche
incompatibili non dovrebbero essere introdotte con leggerezza a software che
ha molto codice dipendente. Il costo in cui si potrebbe incorrere per aggiornare
potrebbe essere significativo. Dover dar colpi alla versione major per 
rilasciare modifiche incompatibili significa che penserete all’impatto delle vostre 
modifiche, e valuterete il rapporto costi/benefici coinvolto.\nDocumentare l’intera API pubblica è troppo lavoro!\nE’ vostra responsabilità come sviluppatori professionisti documentare 
appropriatamente software il cui uso è destinato ad altri. Gestire la
complessità del software è una parte enormemente importante per mantenere
un progetto efficiente, e ciò è difficile da fare se nessuno sa come usare il
vostro software, o nessuno sa con sicurezza quali metodi sono invocabili. Nel lungo 
periodo Versionamento Semantico, ed il perseverare su un’API pubblica ben 
documentata, è in grado di far andare tutto liscio.\nCosa faccio se rilascio accidentalmente una modifica non retrocompatibile come versione minor?\nNon appena realizzate di aver infranto le specifiche di Versionamento Semantico,
correggete il problema e rilasciate una nuova versione minor che corregga il 
problema e ripristini la retrocompatibilità. Perfino in tali circostanze,
non è accettabile modificare una versione rilasciata. Se è appropriato,
documentate la versione illecita ed informate i vostri utenti del problema cosicché
siano consapevoli della versione illecita.\nCosa dovrei fare se aggiorno le mie dipendenze senza modificare l’API pubblica?\nCiò sarebbe considerato compatibile poiché non interessa l’API pubblica.
Software che dipendono esplicitamente dalle stesse dipendenze del vostro 
pacchetto dovrebbero avere le loro proprie specifiche di dipendenza e l’autore 
noterà qualsiasi conflitto. Determinare se la modifica sia di livello patch o
minor dipende se avete aggiornato le vostre dipendenze per correggere un bug o
per introdurre una nuova funzionalità. In quest’ultimo caso solitamente mi 
aspetto del codice aggiuntivo, ed ovviamente un incremento della versione
minor.\nCosa faccio se inavvertitamente altero l’API pubblica in un modo non conforme con la modifica al numero di versione (per esempio il codice introduce erroneamente una modifica che rompe la major in un rilascio di una patch).\nUtilizzate il buon senso. Se avete una platea immensa che sarebbe drasticamente
impattata dal ripristinio del comportamento atteso dell’API pubblica, allora
potrebbe essere meglio eseguire un rilascio di una versione major, perfino se
la correzione potrebbe strettamente essere considerata il rilascio di una patch.
Ricordate, Versionamento Semantico, è finalizzato alla comunicazione di 
significato attraverso il cambiamento del numero di versione. Se tali 
modifiche sono importanti per i vostri utenti, usate il numero di versione
per informarli.\nCome dovrei gestire la deprecazione di funzionalità?\nDeprecare funzionalità esistenti fa parte del normale sviluppo di software ed è
spesso necessario per fare progressi in avanti. Quando deprecate parte della
vostra API pubblica, dovreste fare due cose: (1) aggiornare la vostra documentazione
per consentire agli utenti di essere consapevoli della modifica, (2) distribuire
un nuovo rilascio minor con la deprecazione all’interno. Prima di rimuovere
completamente la funzionalità nel rilascio di una nuova major dovrebbe esserci 
al minimo un rilascio minor che contenga la deprecazione cosicché gli utenti 
siano in grado di migrare tranquillamente alla nuova API.\nVersionamento Semantico ha un limite alla dimensione della stringa della versione?\nNo, ma usate il buon senso. Per esempio, una stringa di versione di 255 caratteri 
è eccessiva. Inoltre, sistemi specifici possono imporre i loro limiti sulla 
dimensione.\n“v1.2.3” è una versione semantica?\nNo, “v1.2.3” non è una versione semantica. Tuttavia, prefissare una versione semantica
con una “v” è un modo comune (in inglese) di indicare che si tratta di un numero di versione.
L’abbreviazione “v” per “version” si incontra spesso nel controllo di versione. Esempio:
git tag v1.2.3 -m "Release version 1.2.3", ove “v1.2.3” è un nome di tag
e la versione semantica è “1.2.3”.\nEsiste una espressione regolare (RegEx) suggerita per controllare la stringa SemVer?\nNe esistono due. Una con i gruppi nominati per quei sistemi che li supportano
(PCRE [Perl Compatible Regular Expressions, i.e. Perl, PHP ed R], Python
e Go).\nVedi: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n…ed una con invece i gruppi di cattura numerati (quindi cg1 = major, cg2 = minor,
cg3 = patch, cg4 = prerelease and cg5 = buildmetadata) che è compatibile
con ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
i.e. Perl, PHP ed R), Python e Go.\nVedi: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nLa specifica di Versionamento Semantico è scritta da Tom
Preston-Werner, inventore di Gravatars e
cofondatore di GitHub.\nTraduzione a cura del Java User Group Padova:\nJava User Group Padova\nTarin Gamberini (autore)\nEnrico Mezzato (revisore)\nEmanuele Gesuato (revisore)\nAnicet Foba Togue (revisore)\n…e di Lorenzo L. Ancora (autore)\nSe vi piacerebbe lasciare un commento, per favore aprite una segnalazione su 
GitHub.\naprite una segnalazione su 
GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSemantic Versioning 2.0.0-rc.1

Nel mondo della gestione del software esiste un posto terribile chiamato
“inferno delle dipendenze”. Più cresce il sistema, più crescono i pacchetti
da integrare in esso e più è probabile ritrovarsi, un giorno, in questa
valle di lacrime.

Nei sistemi con molte dipendenze, il rilascio di nuove versioni dei package
può diventare presto un incubo. Se le specifiche sulle dipendenze sono troppo
stringenti, si corre il rischio di finire quanto prima in un cosiddetto
version lock (ossia l’impossibilità di aggiornare un package senza dover
anche rilasciare le nuove versioni di ciascun altro package ad esso dipendente).
Se invece le dipendenze sono troppo lasche, si verrà inevitabilmente colti dal
fenomeno della version promiscuity (assumendo una compatibilità con più versioni future
di quanto non sia ragionevole).
L’inferno delle dipendenze si ha appunto quando ci si trova in una di queste
due situazioni estreme ― version lock e/o version promiscuity ― che impedisce
l’aggiornamento facile e sicuro del progetto.

Come soluzione a questo problema, propongo un semplice insieme di regole
e requisiti che determinino come i numeri di versione vengano assegnati e incrementati.
Affinché questo metodo funzioni, si deve innanzitutto dichiarare un API pubblica.
Questa può essere semplicemente documentazione o meglio ancora codice che ne
valida i vincoli. A prescindere, l’importante è che un API simile sia chiara e precisa.
Una volta identificate le tue API pubbliche, si comunicano le modifiche ad esse
attraverso incrementi specifici al numero di versione.
Si consideri un formato di versione del tipo X.Y.Z (Major.Minor.Patch).
Le risoluzioni ad anomalie che non intaccano le firme delle API causano un incremento della
sola componente patch del numero di versione, aggiunte/modifiche retrocompatibili delle API
causano un incremento della componente minor del numero di versione version, e infine
modifiche non retrocompatibili delle API si traducono nella modifica della componente
major del numero di versione.

Chiamo questo metodo “Semantic Versioning.” Seguendo questo sistema, i numeri
di versione e il modo in cui cambiano nel tempo assume un significato ben preciso
sul tipo di modifiche avvenute sul codice.

Specifiche del Semantic Versioning (SemVer)

Le parole chiave “DEVE” (“MUST”), “NON DEVE” (“MUST NOT”), “OBBLIGATORIO” (“REQUIRED”), “SHALL”, “SHALL NOT”, “DOVREBBE” (“SHOULD”),
“NON DOVREBBE” (“SHOULD NOT”), “CONSIGLIATO” (“RECOMMENDED”), “PUO’” (“MAY”), e “OPZIONALE” (“OPTIONAL”) in questo documento sono da intendersi
secondo quanto descritto nell’RFC 2119.


  
    Il software che utilizza il Semantic Versioning DEVE dichiarare una API pubblica. Questa API
può essere dichiarata nel codice stesso oppure esistere esclusivamente nella documentazione.
Comunuqe sia, dovrebbe essere precisa e completa.
  
  
    Un numero di versione normale DEVE essere della forma X.Y.Z dove X, Y, e Z sono
interi non negativi. X è il numero di versione major, Y è il minor, e Z
è quello di patch. Ognuno di questi numeri DEVE aumentare numericamente per incrementi di
uno. Per esempio: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Una volta che un package versionato è stato rilasciato, i contenuti di tale versione
NON DEVONO essere modificati. Qualsiasi modifica deve essere rilasciata come nuova versione.
  
  
    La versione major zero (0.y.z) serve per lo sviluppo iniziale. Tutto può cambiare in qualunque
momento. L’API pubblica non dovrebbe essere considerata stabile.
  
  
    La versione 1.0.0 definisce l’API pubblica. Il modo in cui il numero di versione si
incrementa dopo questa release dipende dalle API pubbliche specifiche e da come cambiano.
  
  
    La verione patch Z (x.y.Z | x > 0) DEVE essere incrementata solamente se le modifiche
introdotte sono tutte risoluzioni di anomalie retrocompatibili. Si definisce risoluzione di anomalia
una modifica al codice interno che corregge un comportamento non corretto del software.
  
  
    La versione minor Y (x.Y.z | x > 0) DEVE essere incrementata quando vengono introdotte
nuove funzionalità retrocompatibili alle API pubbliche. DEVE essere incrementata se una
qualunque delle funzionalità esposte dalle API pubbliche viene contrassegnata come
deprecata. PUO’ essere incrementata qualora siano introdotte sostanziali nuove funzionalità o
miglioramenti nel codice. PUO’ anche includere modifiche a livello di patch. La versione patch
DEVE essere riportata a 0 quando la versione minor viene incrementata.
  
  
    La versione major X (X.y.z | X > 0) DEVE essere incrementata qualora una qualsiasi
modifica non retrocompatibile sia introdotta nelle API pubbliche. PUO’ includere
modifiche di livello minor e patch. Le versioni patch e minor DEVONO essere riportate a 0
quando la versione major viene incrementata.
  
  
    Una versione di pre-release PUO’ essere contrassegnata aggiungendo ― subito dopo la versione patch ―
un trattino seguito da una serie di identificatori separati da punti. Gli identificatori
DEVONO essere composti esclusivamente da caratteri ASCII alfanumerici e trattini [0-9A-Za-z-].
Le versioni di pre-release soddisfano i requisiti della versione normale, ma hanno rispetto
ad essa una precedenza minore. Esempi: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.
  
  
    Una versione di build PUO’ essere contrassegnata aggiungendo ― subito dopo la versione patch
o di pre-release ― un segno più seguito da una serie di identificatori separati da punti.
Gli identificatori DEVONO essere composti esclusivamente da caratteri ASCII alfanumerici e
trattini [0-9A-Za-z-]. Le versioni di build soddisfano i requisiti della versione normale ed
hanno rispetto ad essa una precedenza maggiore. Esempi: 1.0.0+build.1, 1.3.7+build.11.e0f985a.
  
  
    La precedenza DEVE essere calcolata separando le versioni in major, minor, patch,
identificatori di pre-release e identificatori di build in questo ordine.
Le versioni major, minor, e patch vengono sempre confrontate numericamente.
La precedenza fra versioni di pre-release e di build DEVE essere determinata
per comparazione di ciascun identificatore separato da punto in questo modo:
gli identificatori costituiti da soli caratteri numerici sono confrontati
numericamente e gli identificatori costituiti da soli caratteri letterari
o trattini sono confrontti lessicalmente secondo i criteri di ordinamento ASCII.
Gli identificatori numerici hanno sempre precedenza minore rispetto a quelli non
numerici. Esempi: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta.2 < 1.0.0-beta.11 <
1.0.0-rc.1 < 1.0.0-rc.1+build.1 < 1.0.0 < 1.0.0+0.3.7 < 1.3.7+build <
1.3.7+build.2.b8f12d7 < 1.3.7+build.11.e0f985a.
  


Perché usare il Semantic Versioning?

Non si tratta di un’idea rivoluzionaria. Infatti, probabilmente, state già
utilizzando convenzioni simili a questa. Il problema è che l’approssimazione
della similitudine non è sufficiente. Fintanto che non sono conformi ad una
qualche specifica formale, i numeri di versione sono essenzialmente inutili
ai fini di una gestione delle dipendenze. Dando un nome ed una definizione
precisa alle idee di cui sopra, diventa facile comunicare le proprie intenzioni
agli utenti del vostro software. Una volta che queste intenzioni sono chiare,
si possono finalmente produrre specifiche di dipendenza flessibili (ma non troppo).

Un semplice esempio dimostrerà come il Semantic Versioning può rendere l’inferno
delle dipendenze un qualcosa di legato al passato. Si consideri una libreria
chiamata “Firetruck.” Questa richiede un package chiamato “Ladder”, versionato
semanticamente. All’epoca in cui è stata creata Firetruck, Ladder era alla versione
3.1.0. Dal momento che Firetruck utilizza alcune delle funzionalità che erano
state originariamente introdotte nella 3.1.0, si può tranquillamente indicare in
modo sicuro la dipendenza verso Ladder come maggiore o uguale a 3.1.0, ma minore
di 4.0.0. Ora, nel momento in cui diventano disponibili le versioni 3.1.1 e 3.2.0
della libreria Ladder, le si possono mettere a disposizione del proprio sistema
di gestione dei pacchetti sapendo che saranno compatibili con il software già
esistente dipendente da Ladder.

Da bravo sviluppatore, naturalmente, vorrai controllare che ciascun aggiornamento
di package funzioni come pubblicizzato. Il mondo reale è un luogo disordinato;
non ci possiamo fare nulla se non essere vigili. Ciò che puoi fare è lasciare che
il Semantic Versioning ti fornisca un modo sano per rilasciare e aggiornare
i package, senza essere costretti a lanciare nuove versioni dei pacchetti di dipendenza,
facendoti risparmiare tempo e fatica.

Se tutto ciò ti appare desiderabile, tutto ciò che devi fare per iniziare ad usare il
Semantic Versioning è di dichiarare che lo stai facendo e poi iniziare a eguire le regole.
Metti anche un collegamento a questo sito web all’interno del tuo README, affinché anche
altri possano apprendere le regole e possano trarne a loro volta benefici.

FAQ

Come mi dovrei trattare le revisioni 0.y.z nella fase iniziale dello sviluppo?

La cosa più semplice da fare è quella di cominciare con un rilascio iniziale di sviluppo alla 0.1.0
e incrementare sucessivamente la versione minor ad ogni nuovo rilascio.

Quando decido di passare alla release 1.0.0?

Se il tuo software è usato in produzione, dovrebbe probabilmente già essere in versione 1.0.0.
Se si hanno delle API stabili su cui gli utenti possono cominciare a stabilire delle dipendenze,
allora si dovrebbe già essere in 1.0.0.
Se ci si stanno ponendo dubbi sulla retrocomaptibilità, allora si dovrebbe già essere in 1.0.0.

Tutto ciò non disincentiva lo sviluppo rapido e le iterazioni veloci?

La versione major zero è tutta oriantata allo sviluppo rapido. Se si stanno cambiando quotidianamente
le API, o si è ancora in version 0.x.x, oppure si è in un ramo di sviluppo separato al lavoro sulla prossima
versione major.

Se anche la minima modifica non retrocompatibile alle API pubbliche richiede l’avanzamento di versione major, non si rischia di finire alla versione 42.0.0 troppo in fretta?

Qui si tratta di una questione di sviluppo responsabile e lungimiranza.
Le modifiche che introducono incompatibilità non dovrebbero essere introdotte
alla leggera nel software che ha molte dipendenze con altro codice. Il costo
nel quale si potrebbe incappare per un eventuale aggiornamento dell’altro
software potrebbe essere non trascurabile.
Il fatto di dover portare avanti la versione major al ogni rilascio di modifiche incompatibili
implica che si sia indotti a pensare molto bene all’impatto delle proprie scelte e a valutare
altrettanto bene il rapporto costo/beneficio del cambiamento.

La documentazione dei tutte le API pubbliche è un lavoro troppo oneroso!

Rientra nelle responsabilità di uno sviluppatore professionista la corretta documentazione
del software che si intende fornire a disposizione di altri. La gestione della complessità
del software è una grossa e importante parte del compito di mantenere efficiente un progetto
ed è difficile farlo se nessuno sa come si usa il vostro software, o quali metodi possono
essere invocati in modo sicuro. Nel lungo termine, il Semantic Versioning, e la disciplina
nel mantenere un ben definito insieme di API pubbliche, può fare in modo che tutto
proceda in modo liscio.

Cosa facico se per sbaglio rilascio una modifica non retrocompatibile come una versione minor?

Non appena ci si accorge di aver violato la specifica del Semantic Versioning, si deve
correggere il problema e rilasciare una nuova versione minor che ripristini la
retrocompatibilità. Si tenga sempre presente che è inaccettabile cambiare le versioni
già rilasciate, anhe in questa circostana. Se è il caso, tuttalpiù, si documenti opportunamente
la versione errata e si informino gli utenti del problema, affinché siano al corrente del
problema.

Cosa dovrei fare se aggiorno le mie stesse dipendenze senza cambiare l’interfaccia pubblica delle mie API?

Un’operazione del genere è da considerarsi compatibilie, in quanto non intacca le API pubbliche.
Il software che ha dipendenze esplicite nei confronti delle medesime dipendenze del vostro package
dovrebbe avere le proprie specifiche di dipendenza e l’autore noterà eventuali conflitti.
Stabilire se la modifica debba considerarsi a livello di patch o di minor dipende sostanzialmente
dalle ragioni per cui si è deciso di procedere all’aggiornamento di dipendenze sul proprio package:
se lo si è fatto per correggere un’anomalia, piuttosto che per introdurre nuove funzionalità.
Tipicamente mi aspetterei ulteriore codice nel secondo caso, per cui in tal caso si tratterebbe
ovviamente di una nuova versione minor.

Che cosa dovrei fare se è il codice correttivo dell’anomalia risolta a fare in modo che il codice sia aderente alle API pubbliche (es. il codice era erroneamente disallineato rispetto alla documentazione delle API pubbliche)?

Si usi il buon senso. Se si ha un audience così vasta per il proprio package che
la modificha avrebbe un impatto evidentemente molto importante, riportando
il comportamento ad una situazione coerente con ciò che era inteso dalle specifiche
della documentazione pubblica delle API, allora potrebbe valer la pena di rilasciare
il tutto come una nuova versione major, anche se tecnicamente si tratterebbe solo
di una correzione di livello patch.
Si ricordi che il Semantic Versioning è funzionale alla definizione di un significato
condiviso sul cambio del numero i versione. Se queste modifiche sono importanti per i
vostri utenti, si utilizzi il numero di versione in modo opportuno per informarli in
merito.

Come dovrei trattare le funzionalità deprecate?

La deprecazione di parti esistenti di funzionalità è un processo normale dello sviluppo
del software e spesso si rende necessario per realizzare dei progressi. Quando si
depreca una parte delle proprie API pubbliche, si devono fare due cose:
(1) aggiornare la documentazione per notificare gli utenti circa il cambiamento
(2) preventivare un nuovo rilascio di versione minor contenente la deprecazione.
Prima di rimuovere completamente la funzionalità in un ulteriore nuovo rilascio major,
dovrebbe intercorrere almeno una minor release contenente la deprecazione, al fine di permettere
agli utenti della vostra libreria una transizione non traumatica alle nuove API.

About

Le specifiche di Semantic Versioning sono state scirtte da Tom
Preston-Werner, inventore di Gravatars e
co-fodatore di GitHub.
La traduzione in italiano è stata curata da Andrea Salicetti, socio
e sviluppatore di Blomming.

Se volete lasciare un feedback, aprite una segnalazione su GitHub.

Licenza

Creative Commons ― CC BY 3.0
http://creativecommons.org/licenses/by/3.0/\nSemantic Versioning 2.0.0-rc.1\nNel mondo della gestione del software esiste un posto terribile chiamato
“inferno delle dipendenze”. Più cresce il sistema, più crescono i pacchetti
da integrare in esso e più è probabile ritrovarsi, un giorno, in questa
valle di lacrime.\nNei sistemi con molte dipendenze, il rilascio di nuove versioni dei package
può diventare presto un incubo. Se le specifiche sulle dipendenze sono troppo
stringenti, si corre il rischio di finire quanto prima in un cosiddetto
version lock (ossia l’impossibilità di aggiornare un package senza dover
anche rilasciare le nuove versioni di ciascun altro package ad esso dipendente).
Se invece le dipendenze sono troppo lasche, si verrà inevitabilmente colti dal
fenomeno della version promiscuity (assumendo una compatibilità con più versioni future
di quanto non sia ragionevole).
L’inferno delle dipendenze si ha appunto quando ci si trova in una di queste
due situazioni estreme ― version lock e/o version promiscuity ― che impedisce
l’aggiornamento facile e sicuro del progetto.\nCome soluzione a questo problema, propongo un semplice insieme di regole
e requisiti che determinino come i numeri di versione vengano assegnati e incrementati.
Affinché questo metodo funzioni, si deve innanzitutto dichiarare un API pubblica.
Questa può essere semplicemente documentazione o meglio ancora codice che ne
valida i vincoli. A prescindere, l’importante è che un API simile sia chiara e precisa.
Una volta identificate le tue API pubbliche, si comunicano le modifiche ad esse
attraverso incrementi specifici al numero di versione.
Si consideri un formato di versione del tipo X.Y.Z (Major.Minor.Patch).
Le risoluzioni ad anomalie che non intaccano le firme delle API causano un incremento della
sola componente patch del numero di versione, aggiunte/modifiche retrocompatibili delle API
causano un incremento della componente minor del numero di versione version, e infine
modifiche non retrocompatibili delle API si traducono nella modifica della componente
major del numero di versione.\nChiamo questo metodo “Semantic Versioning.” Seguendo questo sistema, i numeri
di versione e il modo in cui cambiano nel tempo assume un significato ben preciso
sul tipo di modifiche avvenute sul codice.\nSpecifiche del Semantic Versioning (SemVer)\nLe parole chiave “DEVE” (“MUST”), “NON DEVE” (“MUST NOT”), “OBBLIGATORIO” (“REQUIRED”), “SHALL”, “SHALL NOT”, “DOVREBBE” (“SHOULD”),
“NON DOVREBBE” (“SHOULD NOT”), “CONSIGLIATO” (“RECOMMENDED”), “PUO’” (“MAY”), e “OPZIONALE” (“OPTIONAL”) in questo documento sono da intendersi
secondo quanto descritto nell’RFC 2119.\nIl software che utilizza il Semantic Versioning DEVE dichiarare una API pubblica. Questa API
può essere dichiarata nel codice stesso oppure esistere esclusivamente nella documentazione.
Comunuqe sia, dovrebbe essere precisa e completa.\nIl software che utilizza il Semantic Versioning DEVE dichiarare una API pubblica. Questa API
può essere dichiarata nel codice stesso oppure esistere esclusivamente nella documentazione.
Comunuqe sia, dovrebbe essere precisa e completa.\nUn numero di versione normale DEVE essere della forma X.Y.Z dove X, Y, e Z sono
interi non negativi. X è il numero di versione major, Y è il minor, e Z
è quello di patch. Ognuno di questi numeri DEVE aumentare numericamente per incrementi di
uno. Per esempio: 1.9.0 -> 1.10.0 -> 1.11.0.\nUn numero di versione normale DEVE essere della forma X.Y.Z dove X, Y, e Z sono
interi non negativi. X è il numero di versione major, Y è il minor, e Z
è quello di patch. Ognuno di questi numeri DEVE aumentare numericamente per incrementi di
uno. Per esempio: 1.9.0 -> 1.10.0 -> 1.11.0.\nUna volta che un package versionato è stato rilasciato, i contenuti di tale versione
NON DEVONO essere modificati. Qualsiasi modifica deve essere rilasciata come nuova versione.\nUna volta che un package versionato è stato rilasciato, i contenuti di tale versione
NON DEVONO essere modificati. Qualsiasi modifica deve essere rilasciata come nuova versione.\nLa versione major zero (0.y.z) serve per lo sviluppo iniziale. Tutto può cambiare in qualunque
momento. L’API pubblica non dovrebbe essere considerata stabile.\nLa versione major zero (0.y.z) serve per lo sviluppo iniziale. Tutto può cambiare in qualunque
momento. L’API pubblica non dovrebbe essere considerata stabile.\nLa versione 1.0.0 definisce l’API pubblica. Il modo in cui il numero di versione si
incrementa dopo questa release dipende dalle API pubbliche specifiche e da come cambiano.\nLa versione 1.0.0 definisce l’API pubblica. Il modo in cui il numero di versione si
incrementa dopo questa release dipende dalle API pubbliche specifiche e da come cambiano.\nLa verione patch Z (x.y.Z | x > 0) DEVE essere incrementata solamente se le modifiche
introdotte sono tutte risoluzioni di anomalie retrocompatibili. Si definisce risoluzione di anomalia
una modifica al codice interno che corregge un comportamento non corretto del software.\nLa verione patch Z (x.y.Z | x > 0) DEVE essere incrementata solamente se le modifiche
introdotte sono tutte risoluzioni di anomalie retrocompatibili. Si definisce risoluzione di anomalia
una modifica al codice interno che corregge un comportamento non corretto del software.\nLa versione minor Y (x.Y.z | x > 0) DEVE essere incrementata quando vengono introdotte
nuove funzionalità retrocompatibili alle API pubbliche. DEVE essere incrementata se una
qualunque delle funzionalità esposte dalle API pubbliche viene contrassegnata come
deprecata. PUO’ essere incrementata qualora siano introdotte sostanziali nuove funzionalità o
miglioramenti nel codice. PUO’ anche includere modifiche a livello di patch. La versione patch
DEVE essere riportata a 0 quando la versione minor viene incrementata.\nLa versione minor Y (x.Y.z | x > 0) DEVE essere incrementata quando vengono introdotte
nuove funzionalità retrocompatibili alle API pubbliche. DEVE essere incrementata se una
qualunque delle funzionalità esposte dalle API pubbliche viene contrassegnata come
deprecata. PUO’ essere incrementata qualora siano introdotte sostanziali nuove funzionalità o
miglioramenti nel codice. PUO’ anche includere modifiche a livello di patch. La versione patch
DEVE essere riportata a 0 quando la versione minor viene incrementata.\nLa versione major X (X.y.z | X > 0) DEVE essere incrementata qualora una qualsiasi
modifica non retrocompatibile sia introdotta nelle API pubbliche. PUO’ includere
modifiche di livello minor e patch. Le versioni patch e minor DEVONO essere riportate a 0
quando la versione major viene incrementata.\nLa versione major X (X.y.z | X > 0) DEVE essere incrementata qualora una qualsiasi
modifica non retrocompatibile sia introdotta nelle API pubbliche. PUO’ includere
modifiche di livello minor e patch. Le versioni patch e minor DEVONO essere riportate a 0
quando la versione major viene incrementata.\nUna versione di pre-release PUO’ essere contrassegnata aggiungendo ― subito dopo la versione patch ―
un trattino seguito da una serie di identificatori separati da punti. Gli identificatori
DEVONO essere composti esclusivamente da caratteri ASCII alfanumerici e trattini [0-9A-Za-z-].
Le versioni di pre-release soddisfano i requisiti della versione normale, ma hanno rispetto
ad essa una precedenza minore. Esempi: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.\nUna versione di pre-release PUO’ essere contrassegnata aggiungendo ― subito dopo la versione patch ―
un trattino seguito da una serie di identificatori separati da punti. Gli identificatori
DEVONO essere composti esclusivamente da caratteri ASCII alfanumerici e trattini [0-9A-Za-z-].
Le versioni di pre-release soddisfano i requisiti della versione normale, ma hanno rispetto
ad essa una precedenza minore. Esempi: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.\nUna versione di build PUO’ essere contrassegnata aggiungendo ― subito dopo la versione patch
o di pre-release ― un segno più seguito da una serie di identificatori separati da punti.
Gli identificatori DEVONO essere composti esclusivamente da caratteri ASCII alfanumerici e
trattini [0-9A-Za-z-]. Le versioni di build soddisfano i requisiti della versione normale ed
hanno rispetto ad essa una precedenza maggiore. Esempi: 1.0.0+build.1, 1.3.7+build.11.e0f985a.\nUna versione di build PUO’ essere contrassegnata aggiungendo ― subito dopo la versione patch
o di pre-release ― un segno più seguito da una serie di identificatori separati da punti.
Gli identificatori DEVONO essere composti esclusivamente da caratteri ASCII alfanumerici e
trattini [0-9A-Za-z-]. Le versioni di build soddisfano i requisiti della versione normale ed
hanno rispetto ad essa una precedenza maggiore. Esempi: 1.0.0+build.1, 1.3.7+build.11.e0f985a.\nLa precedenza DEVE essere calcolata separando le versioni in major, minor, patch,
identificatori di pre-release e identificatori di build in questo ordine.
Le versioni major, minor, e patch vengono sempre confrontate numericamente.
La precedenza fra versioni di pre-release e di build DEVE essere determinata
per comparazione di ciascun identificatore separato da punto in questo modo:
gli identificatori costituiti da soli caratteri numerici sono confrontati
numericamente e gli identificatori costituiti da soli caratteri letterari
o trattini sono confrontti lessicalmente secondo i criteri di ordinamento ASCII.
Gli identificatori numerici hanno sempre precedenza minore rispetto a quelli non
numerici. Esempi: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta.2 < 1.0.0-beta.11 <
1.0.0-rc.1 < 1.0.0-rc.1+build.1 < 1.0.0 < 1.0.0+0.3.7 < 1.3.7+build <
1.3.7+build.2.b8f12d7 < 1.3.7+build.11.e0f985a.\nLa precedenza DEVE essere calcolata separando le versioni in major, minor, patch,
identificatori di pre-release e identificatori di build in questo ordine.
Le versioni major, minor, e patch vengono sempre confrontate numericamente.
La precedenza fra versioni di pre-release e di build DEVE essere determinata
per comparazione di ciascun identificatore separato da punto in questo modo:
gli identificatori costituiti da soli caratteri numerici sono confrontati
numericamente e gli identificatori costituiti da soli caratteri letterari
o trattini sono confrontti lessicalmente secondo i criteri di ordinamento ASCII.
Gli identificatori numerici hanno sempre precedenza minore rispetto a quelli non
numerici. Esempi: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta.2 < 1.0.0-beta.11 <
1.0.0-rc.1 < 1.0.0-rc.1+build.1 < 1.0.0 < 1.0.0+0.3.7 < 1.3.7+build <
1.3.7+build.2.b8f12d7 < 1.3.7+build.11.e0f985a.\nPerché usare il Semantic Versioning?\nNon si tratta di un’idea rivoluzionaria. Infatti, probabilmente, state già
utilizzando convenzioni simili a questa. Il problema è che l’approssimazione
della similitudine non è sufficiente. Fintanto che non sono conformi ad una
qualche specifica formale, i numeri di versione sono essenzialmente inutili
ai fini di una gestione delle dipendenze. Dando un nome ed una definizione
precisa alle idee di cui sopra, diventa facile comunicare le proprie intenzioni
agli utenti del vostro software. Una volta che queste intenzioni sono chiare,
si possono finalmente produrre specifiche di dipendenza flessibili (ma non troppo).\nUn semplice esempio dimostrerà come il Semantic Versioning può rendere l’inferno
delle dipendenze un qualcosa di legato al passato. Si consideri una libreria
chiamata “Firetruck.” Questa richiede un package chiamato “Ladder”, versionato
semanticamente. All’epoca in cui è stata creata Firetruck, Ladder era alla versione
3.1.0. Dal momento che Firetruck utilizza alcune delle funzionalità che erano
state originariamente introdotte nella 3.1.0, si può tranquillamente indicare in
modo sicuro la dipendenza verso Ladder come maggiore o uguale a 3.1.0, ma minore
di 4.0.0. Ora, nel momento in cui diventano disponibili le versioni 3.1.1 e 3.2.0
della libreria Ladder, le si possono mettere a disposizione del proprio sistema
di gestione dei pacchetti sapendo che saranno compatibili con il software già
esistente dipendente da Ladder.\nDa bravo sviluppatore, naturalmente, vorrai controllare che ciascun aggiornamento
di package funzioni come pubblicizzato. Il mondo reale è un luogo disordinato;
non ci possiamo fare nulla se non essere vigili. Ciò che puoi fare è lasciare che
il Semantic Versioning ti fornisca un modo sano per rilasciare e aggiornare
i package, senza essere costretti a lanciare nuove versioni dei pacchetti di dipendenza,
facendoti risparmiare tempo e fatica.\nSe tutto ciò ti appare desiderabile, tutto ciò che devi fare per iniziare ad usare il
Semantic Versioning è di dichiarare che lo stai facendo e poi iniziare a eguire le regole.
Metti anche un collegamento a questo sito web all’interno del tuo README, affinché anche
altri possano apprendere le regole e possano trarne a loro volta benefici.\nCome mi dovrei trattare le revisioni 0.y.z nella fase iniziale dello sviluppo?\nLa cosa più semplice da fare è quella di cominciare con un rilascio iniziale di sviluppo alla 0.1.0
e incrementare sucessivamente la versione minor ad ogni nuovo rilascio.\nQuando decido di passare alla release 1.0.0?\nSe il tuo software è usato in produzione, dovrebbe probabilmente già essere in versione 1.0.0.
Se si hanno delle API stabili su cui gli utenti possono cominciare a stabilire delle dipendenze,
allora si dovrebbe già essere in 1.0.0.
Se ci si stanno ponendo dubbi sulla retrocomaptibilità, allora si dovrebbe già essere in 1.0.0.\nTutto ciò non disincentiva lo sviluppo rapido e le iterazioni veloci?\nLa versione major zero è tutta oriantata allo sviluppo rapido. Se si stanno cambiando quotidianamente
le API, o si è ancora in version 0.x.x, oppure si è in un ramo di sviluppo separato al lavoro sulla prossima
versione major.\nSe anche la minima modifica non retrocompatibile alle API pubbliche richiede l’avanzamento di versione major, non si rischia di finire alla versione 42.0.0 troppo in fretta?\nQui si tratta di una questione di sviluppo responsabile e lungimiranza.
Le modifiche che introducono incompatibilità non dovrebbero essere introdotte
alla leggera nel software che ha molte dipendenze con altro codice. Il costo
nel quale si potrebbe incappare per un eventuale aggiornamento dell’altro
software potrebbe essere non trascurabile.
Il fatto di dover portare avanti la versione major al ogni rilascio di modifiche incompatibili
implica che si sia indotti a pensare molto bene all’impatto delle proprie scelte e a valutare
altrettanto bene il rapporto costo/beneficio del cambiamento.\nLa documentazione dei tutte le API pubbliche è un lavoro troppo oneroso!\nRientra nelle responsabilità di uno sviluppatore professionista la corretta documentazione
del software che si intende fornire a disposizione di altri. La gestione della complessità
del software è una grossa e importante parte del compito di mantenere efficiente un progetto
ed è difficile farlo se nessuno sa come si usa il vostro software, o quali metodi possono
essere invocati in modo sicuro. Nel lungo termine, il Semantic Versioning, e la disciplina
nel mantenere un ben definito insieme di API pubbliche, può fare in modo che tutto
proceda in modo liscio.\nCosa facico se per sbaglio rilascio una modifica non retrocompatibile come una versione minor?\nNon appena ci si accorge di aver violato la specifica del Semantic Versioning, si deve
correggere il problema e rilasciare una nuova versione minor che ripristini la
retrocompatibilità. Si tenga sempre presente che è inaccettabile cambiare le versioni
già rilasciate, anhe in questa circostana. Se è il caso, tuttalpiù, si documenti opportunamente
la versione errata e si informino gli utenti del problema, affinché siano al corrente del
problema.\nCosa dovrei fare se aggiorno le mie stesse dipendenze senza cambiare l’interfaccia pubblica delle mie API?\nUn’operazione del genere è da considerarsi compatibilie, in quanto non intacca le API pubbliche.
Il software che ha dipendenze esplicite nei confronti delle medesime dipendenze del vostro package
dovrebbe avere le proprie specifiche di dipendenza e l’autore noterà eventuali conflitti.
Stabilire se la modifica debba considerarsi a livello di patch o di minor dipende sostanzialmente
dalle ragioni per cui si è deciso di procedere all’aggiornamento di dipendenze sul proprio package:
se lo si è fatto per correggere un’anomalia, piuttosto che per introdurre nuove funzionalità.
Tipicamente mi aspetterei ulteriore codice nel secondo caso, per cui in tal caso si tratterebbe
ovviamente di una nuova versione minor.\nChe cosa dovrei fare se è il codice correttivo dell’anomalia risolta a fare in modo che il codice sia aderente alle API pubbliche (es. il codice era erroneamente disallineato rispetto alla documentazione delle API pubbliche)?\nSi usi il buon senso. Se si ha un audience così vasta per il proprio package che
la modificha avrebbe un impatto evidentemente molto importante, riportando
il comportamento ad una situazione coerente con ciò che era inteso dalle specifiche
della documentazione pubblica delle API, allora potrebbe valer la pena di rilasciare
il tutto come una nuova versione major, anche se tecnicamente si tratterebbe solo
di una correzione di livello patch.
Si ricordi che il Semantic Versioning è funzionale alla definizione di un significato
condiviso sul cambio del numero i versione. Se queste modifiche sono importanti per i
vostri utenti, si utilizzi il numero di versione in modo opportuno per informarli in
merito.\nCome dovrei trattare le funzionalità deprecate?\nLa deprecazione di parti esistenti di funzionalità è un processo normale dello sviluppo
del software e spesso si rende necessario per realizzare dei progressi. Quando si
depreca una parte delle proprie API pubbliche, si devono fare due cose:
(1) aggiornare la documentazione per notificare gli utenti circa il cambiamento
(2) preventivare un nuovo rilascio di versione minor contenente la deprecazione.
Prima di rimuovere completamente la funzionalità in un ulteriore nuovo rilascio major,
dovrebbe intercorrere almeno una minor release contenente la deprecazione, al fine di permettere
agli utenti della vostra libreria una transizione non traumatica alle nuove API.\nLe specifiche di Semantic Versioning sono state scirtte da Tom
Preston-Werner, inventore di Gravatars e
co-fodatore di GitHub.
La traduzione in italiano è stata curata da Andrea Salicetti, socio
e sviluppatore di Blomming.\nSe volete lasciare un feedback, aprite una segnalazione su GitHub.\naprite una segnalazione su GitHub\nCreative Commons ― CC BY 3.0
http://creativecommons.org/licenses/by/3.0/\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nセマンティック バージョニング 2.0.0

概要

　バージョンナンバーは、メジャー.マイナー.パッチ とし、バージョンを上げるには、


  APIの変更に互換性のない場合はメジャーバージョンを、
  後方互換性があり機能性を追加した場合はマイナーバージョンを、
  後方互換性を伴うバグ修正をした場合はパッチバージョンを上げます。


　プレリリースやビルドナンバーなどのラベルに関しては、メジャー.マイナー.パッチ の形式を拡張する形で利用することができます。

導入

　ソフトウェア・マネージメントの世界には、「依存性地獄」と呼ばれる恐ろしいものがあります。あなたのシステムが大きく成長すればするほど、さまざまなパッケージを組み込めば組み込むほど、自分が地獄の底にいることにいつか気づくでしょう。

　多くの依存性を有しているシステムにとって、新しいバージョンがリリースされることは悪夢でしかありません。厳密に依存関係を指定してしまうと、システムはバージョン・ロック（すべての依存パッケージを新しくしない限り、アップグレードできないこと）の危機にさらされてしまいます。反対に、依存指定を緩く管理しすぎると、バージョンが複雑に絡まり合い、痛い目にあうことは避けられないでしょう（合理性よりも将来のバージョンとの互換性を気にすることになる）。依存性地獄とは、あなたのプロジェクトでバージョン・ロックまたはバージョン混乱に陥ることで、プロジェクトに支障をきたすことを指します。

　この問題の解決策として、私はシンプルなルールセットとバージョン・ナンバーをどのように割り当て、バージョンを上げていくのかについての要件を提案します。これらのルールは既存のクローズドまたはオープンソースプロジェクトで普及している一般的な（必ずしもそうであるとは限りませんが）プラクティスをもとに作られています。このシステムを利用するために、まずはパブリックなAPIを宣言する必要があります。これはドキュメントに記載しても、コード自体で表現しても構いません。とにかく、APIが明確かつ正確であることは非常に重要です。パブリックなAPIを宣言したら、それを変更する際にはルールに従ってバージョン番号を上げなければなりません。つまり、X.Y.Z（メジャー.マイナー.パッチ）のバージョン形式を遵守しなければなりません。APIに影響を及ぼさないバグ修正はパッチバージョンを、後方互換性を保ちつつAPIを変更・追加した場合はマイナーバージョンを、後方互換性のないAPIの変更はメジャーバージョンを上げます。

　私はこのシステムを『セマンティック バージョニング』と呼び、このスキームに従えば、あるバージョンのコードが次のバージョンへの変更された際に何が変更されたのかユーザーに伝えることができます。

セマンティック バージョニング仕様書 (SemVer)

　この文書における各キーワード「しなければならない（MUST）」、「してはならない（MUST NOT）」、「要求されている（REQUIRED）」、「することになる（SHALL）」、「することはない（SHALL NOT）」、「する必要がある（SHOULD）」、「しないほうがよい（SHOULD NOT）」、「推奨される（RECOMMENDED）」、「してもよい（MAY）」、「選択できる（OPTIONAL）」は、RFC 2119に記載されている内容に従い解釈してください。


  
    セマンティック バージョニングを適用するソフトウェアはパブリックAPIを宣言しなければなりません（MUST）。このAPIはコード自体で表現されているかもしれませんし、明確に文書として存在してるかもしれません。どちらにせよ、正確かつ漏れがないようにするべきです（SHOULD）。
  
  
    通常のバージョンナンバーは、X.Y.Zの形式にしなければなりません（MUST）。このときX、Y、Zは非負の整数であり（MUST）、各数値の先頭にゼロを配置してはなりません（MUST NOT）。Xはメジャーバージョン、Yはマイナーバージョン、Zはパッチバージョンを表します。各バージョンは数値的にバージョンアップしなければなりません（MUST）。例：1.9.0 -> 1.10.0 -> 1.11.0。
  
  
    一度パッケージをリリースしたのなら、そのバージョンのパッケージのコンテンツは修正してはなりません（MUST NOT）。いかなる修正も新しいバージョンとしてリリースしなければなりません（MUST）。
  
  
    メジャーバージョンのゼロ（0.y.z）は初期段階の開発用です。いつでも、いかなる変更も起こりえます（MAY）。この時のパブリックAPIは安定していると考えるべきではありません（SHOULD NOT）。
  
  
    バージョン1.0.0はパブリックAPIを定義します。このリリース後のバージョンナンバーの上げ方に関しては、パブリックAPIがどのくらい変更されるのかによって決まります。
  
  
    パッチバージョン Z （x.y.Z | x > 0）は、後方互換性を保ったバグ修正を取り込んだ場合のみ、上げなければなりません（MUST）。バグ修正とは間違った振る舞いを修正する内部の変更のことを指します。
  
  
    マイナーバージョン Y （x.Y.z | x > 0）は、後方互換性を保ちつつ機能性をパブリックAPIに追加した場合、上げなければなりません（MUST）。また、いかなるパブリックAPIも廃止予定としたのなら、上げなければなりません（MUST）。プライベートコード内での新しい機能の追加や改善を取り込んだ場合は、上げてもよいです（MAY）。その際にパッチレベルの変更も含めてもよいです（MAY）。マイナーバージョンを上げた際にはパッチバージョンを0にリセットしなければなりません（MUST）。
  
  
    メジャーバージョン X （X.y.z | X > 0）は、パブリックAPIに対して後方互換性を持たない変更が取り込まれた場合、上げなければなりません（MUST）。その際にマイナーおよびパッチレベルの変更も含めてもよいです（MAY）。メジャーバージョンを上げた際には、パッチおよびマイナーバージョンを0にリセットしなければなりません（MUST）。
  
  
    プレリリースバージョンは、パッチバージョンの直後にハイフンとドットで区切られた識別子を追加することで表現してもよいです（MAY）。識別子は必ずASCII英数字とハイフン [0-9A-Za-z-] でなければなりません（MUST）。識別子は空であってはなりません（MUST NOT）。数値の識別子はゼロから始めてはなりません（MUST NOT）。プレリリースバージョンは関連する通常のバージョンよりも低い優先度です。プレリリースバージョンは、不安定であり、関連する通常のバージョンが示す要件と互換性を満たさない可能性があります。例：1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92。
  
  
    ビルドメタデータはパッチまたはプレリリースバージョンの直後にプラス記号とドットで区切られた識別子を追加することで表現してもよいです（MAY）。識別子は必ずASCII英数字とハイフン [0-9A-Za-z-] でなければなりません（MUST）。識別子は空であってはなりません（MUST NOT）。バージョンの優先度を決める際にはビルドメタデータは無視されなければなりません（MUST）。つまり、2つのビルドメタデータだけが違うバージョンは、同じ優先度ということです。例：1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85。
  
  
    バージョン同士をどのように比較するのかは優先度によって決まります。優先度はメジャー、マイナー、パッチ、プレリリース識別子の順番（ビルドメタデータは優先度に関して考慮しない）で分けて評価されなければなりません（MUST）。優先度は、各識別子を左から右に比較して最初の違いによって評価します。以下のように、メジャー、マイナー、パッチバージョンと常に数値的に比較します。例：1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。メジャー、マイナー、パッチが同じ場合、プレリリースバージョンを持っている方が通常のバージョンよりも低い優先度です。例：1.0.0-alpha < 1.0.0。同じ、メジャー、マイナー、パッチを持つプレリリースバージョンの優先度の決定は、ドットで区切れた識別子を左から右に、異なるところが見つかるまで比較し決定しなければなりません（MUST）。数値のみで構成される識別子は数値的に比較され、文字列やハイフンを含む識別子はASCIIソート順に辞書的に比較されます。数値的な識別子は常に数値的でない識別子よりも低い優先度です。もし先行する識別子が同じ場合、プレリリースのフィールドが小さいセットよりも大きいセットのほうが高い優先度です。例：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。
  


SemVerバージョンを表すバッカス・ナウア記法
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


なぜセマンティック バージョニングを使用するのか？

　このアイデアは新しいものでもなければ、革新的なものでもありません。実際、みなさんも似たような取り組みを既におこなっているかもしれません。問題は「似ている」のでは不十分だということです。正式な仕様書による取り決めがなければ、バージョンナンバーは依存性の管理において基本的には無意味です。上記のアイデアに対して名前と正確な定義を与えることよって、あなたの開発するソフトウェアにおいて、あなたの意図がユーザーに対して伝わりやすくなることでしょう。一度、これらの意図を正確にしてしまえば、柔軟な（しかし、柔軟すぎてはいけない）依存性の仕様を作ることができます。

　単純な例として、セマンティック バージョニングがどのように依存性地獄を過去のものとするかについて説明します。「Firetruck」と呼ばれるライブラリについて考えてみましょう。それはセマンティック バージョニングされた「Ladder」というパッケージを必要とします。Firetruckを作成した時、Ladderはバージョン3.1.0でした。Firetruckは、バージョン3.1.0時に導入されたいくつかの機能を使用しているので、Ladderが3.1.0以上4.0.0未満の範囲で安全に依存性を指定できます。Ladderのバージョン3.1.1と3.2.0が利用可能になった時、それらをパッケージ管理に取り込んでリリースすることができ、それらが既存の依存するソフトウェアと互換性があるということは明確です。

　賢明な開発者であれば、もちろんパッケージがアップグレードされたのならその機能を使ってみたいと思うはずでしょう。ただ、現実は混沌としていて、我々ができることといったら、慎重になることくらいです。セマンティック バージョニングを実践することで、新しい依存パッケージを巻き込むことなく、まともな方法でリリース、アップグレードすることができ、手間と時間を節約してくれることでしょう。

　もし全面的に同意できると感じたのなら、セマンティック バージョニングを実践していることを宣言し、ルールを守って下さい。それからあなたのREADMEからこのWebサイトにリンクしてください、そうすれば、他の人がこのルールを知り、役立てることができるでしょう。

FAQ

0.y.zのような初期の開発フェーズにおけるバージョンの取り扱いはどのようにすべきでしょうか？

　一番簡単な方法は0.1.0からで開発版をリリースし、その後のリリースのたびにマイナーバージョンを上げていけばよいでしょう。

1.0.0のリリースはいつすべきでしょうか？

　もし既にプロダクション用途であなたのソフトウェアが利用されているのなら、それは1.0.0であるべきでしょう。またもし安定したAPIを持ち、それに依存しているユーザーが複数いるのなら、それは1.0.0であるべきでしょう。もし後方互換性について多大な心配をしているのなら、それは1.0.0であるべきでしょう。

高速開発や高速イテレーションに悪影響を与えませんか？

　メジャーバージョンがゼロの場合、それは高速開発を意味しています。もし、毎日APIを変更しているのなら、0.y.zのバージョンのままにすべきか、開発ブランチとして切り分け、次のメジャーバージョンアップのために開発すべきです。

パブリックAPIに対して後方互換性を保たない、ほんの些細な変更があった際もメジャーバージョンアップをしなければならないのなら、42.0.0のようなバージョンにすぐになってしまわないですか？

　これは責任ある開発と深い洞察のある質問です。多くの依存されているコードを持つソフトウェアにおいて、非互換な変更を気軽に取り込むべきではありません。アップグレードする度にかかるコストは無視できないものでしょう。非互換な変更をリリースするためにメジャーバージョンを上げることは、変更における悪影響を思い知ることになるでしょう。加えて、費用対効果を評価して判断すべきでしょう。

すべてのパブリックAPIに関してドキュメントを書くのは重労働です。

　ユーザーに使用されることを前提としたソフトウェアに適切なドキュメントを用意することはプロフェッショナルな開発者としての当然の責任です。ソフトウェアの複雑性を管理することはプロジェクトをスムーズに続けていくために非常に重要なことで、もしあなたのソフトウェアの使い方や、どのメソッドが安全に呼び出せるのかを誰も知らないのは望ましい状況とは言えません。セマンティック バージョニングと適切に定義されたパブリックAPIを宣言することは長期的に見ればメリットが大きいでしょう。

もし誤って後方互換性のない変更をマイナーバージョンとしてリリースした場合、どうすればよいでしょうか？

　セマンティック バージョニングの仕様に違反したのならすぐに問題を修正してください。つまり後方互換性を復元し、新しくマイナーバージョンをリリースして下さい。このような状況下においてもリリースされたバージョンナンバーを修正してはなりません。適切な対応が完了したのなら、次は違反したバージョンを記録し、それをユーザーに知らせましょう。

もし、パブリックAPIの変更なしに自分のパッケージの依存性をアップデートしてしまったら、どうすべきでしょうか？

　それ自体はパブリックAPIに影響しませんので安心してください。パッケージとして明らかに同じ依存性を持つソフトウェアは自身の依存仕様を定義すべきですし、作成者はいかなるコンフリクトも見逃さないでしょう。その変更がパッチレベルなのかマイナーレベルなのかどうかは、パッケージの依存性をアップデートした理由がバグを修正するためか新しい機能を実装するためかどうかに依存します。後者のケースの場合は明らかにマイナーレベルの変更でしょう。

もしうっかりパブリックAPIをセマンティック バージョニングに対応していない形で変更したらどうなるでしょうか？（例：パッチリリースで主要なバグが発生した場合）

　最善の判断をしてください。もしパブリックAPIの動作が変わることで大いに影響するユーザーがいる場合、厳密にはパッチリリースであると考慮されるかもしれませんが、その後にメジャーバージョンをリリースするのがベストかもしれません。セマンティック バージョニングはバージョンがどのように変更されるのかということを伝えるためのものであるということを注意して下さい。

どのように非推奨機能を扱えばよいでしょうか？

　既存機能を廃止予定にするのはソフトウェア開発においては普通の事であり、開発を進める上で頻繁に必要となります。パブリックAPIの一部を非推奨にしたい場合、2つのことをすべきです。第一にユーザーに知らせるためにドキュメントを更新して下さい。次に非推奨機能を残したまま新しいマイナーバージョンをリリースして下さい。完全に非推奨機能を削除しメジャーバージョンをリリースする前に、ユーザーがスムーズに新しいAPIに移行できるように少なくとも1回のマイナーバージョン（非推奨機能を含んだ）をリリースして下さい。

SemVerのバージョン文字列に限度はありますか？

　いいえ、ありませんが良識ある判断をしてください。例えば255文字のバージョン文字列は過剰と言えるでしょうし、特定のシステムではそれ独自の文字列の限界値があることでしょう。

『v1.2.3』はセマンティック バージョンでしょうか？

　いいえ、『v1.2.3』はセマンティック バージョンではありません。しかしながら、セマンティック バージョンに接頭辞の『v』を付けるのは英語ではバージョン番号であることを示す一般的な方法です。バージョン管理では、『バージョン』を『v』と略すことがよくあります。たとえば git tag v1.2.3 -m" Release version 1.2.3 " では『v1.2.3』はタグ名であり、セマンティック バージョンは『1.2.3』です。

SemVer文字列をチェックするために推奨される正規表現（RegEx）はありますか？

　二つあります。一つは名前付きグループをサポートするシステム（PCRE [Perl Compatible Regular Expressions, 例: Perl, PHP and R]、Python、Go）のための正規表現です。

参考: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


　もう一つは番号付きキャプチャグループを使った正規表現です（したがって、cg1 = メジャー、cg2 = マイナー、cg3 = パッチ、cg4 = プレリリース、cg5 = ビルドメタデータを意味します）。これはECMA Script（JavaScript）、PCRE（Perl Compatible Regular Expressions, 例: Perl, PHP and R）、Python、Goにおいて互換性があります。

参考: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


著者について

セマンティック バージョニング仕様書の著者はTom Preston-Werner氏です。彼はGravatarの考案者であり、GitHubの共同創設者でもあります。

もしフィードバックがある場合は、GitHub上でissueを立てて下さい。

ライセンス

Creative Commons ― CC BY 3.0\nセマンティック バージョニング 2.0.0\nバージョンナンバーは、メジャー.マイナー.パッチ とし、バージョンを上げるには、\nAPIの変更に互換性のない場合はメジャーバージョンを、\n後方互換性があり機能性を追加した場合はマイナーバージョンを、\n後方互換性を伴うバグ修正をした場合はパッチバージョンを上げます。\nプレリリースやビルドナンバーなどのラベルに関しては、メジャー.マイナー.パッチ の形式を拡張する形で利用することができます。\nソフトウェア・マネージメントの世界には、「依存性地獄」と呼ばれる恐ろしいものがあります。あなたのシステムが大きく成長すればするほど、さまざまなパッケージを組み込めば組み込むほど、自分が地獄の底にいることにいつか気づくでしょう。\n多くの依存性を有しているシステムにとって、新しいバージョンがリリースされることは悪夢でしかありません。厳密に依存関係を指定してしまうと、システムはバージョン・ロック（すべての依存パッケージを新しくしない限り、アップグレードできないこと）の危機にさらされてしまいます。反対に、依存指定を緩く管理しすぎると、バージョンが複雑に絡まり合い、痛い目にあうことは避けられないでしょう（合理性よりも将来のバージョンとの互換性を気にすることになる）。依存性地獄とは、あなたのプロジェクトでバージョン・ロックまたはバージョン混乱に陥ることで、プロジェクトに支障をきたすことを指します。\nこの問題の解決策として、私はシンプルなルールセットとバージョン・ナンバーをどのように割り当て、バージョンを上げていくのかについての要件を提案します。これらのルールは既存のクローズドまたはオープンソースプロジェクトで普及している一般的な（必ずしもそうであるとは限りませんが）プラクティスをもとに作られています。このシステムを利用するために、まずはパブリックなAPIを宣言する必要があります。これはドキュメントに記載しても、コード自体で表現しても構いません。とにかく、APIが明確かつ正確であることは非常に重要です。パブリックなAPIを宣言したら、それを変更する際にはルールに従ってバージョン番号を上げなければなりません。つまり、X.Y.Z（メジャー.マイナー.パッチ）のバージョン形式を遵守しなければなりません。APIに影響を及ぼさないバグ修正はパッチバージョンを、後方互換性を保ちつつAPIを変更・追加した場合はマイナーバージョンを、後方互換性のないAPIの変更はメジャーバージョンを上げます。\n私はこのシステムを『セマンティック バージョニング』と呼び、このスキームに従えば、あるバージョンのコードが次のバージョンへの変更された際に何が変更されたのかユーザーに伝えることができます。\nセマンティック バージョニング仕様書 (SemVer)\nこの文書における各キーワード「しなければならない（MUST）」、「してはならない（MUST NOT）」、「要求されている（REQUIRED）」、「することになる（SHALL）」、「することはない（SHALL NOT）」、「する必要がある（SHOULD）」、「しないほうがよい（SHOULD NOT）」、「推奨される（RECOMMENDED）」、「してもよい（MAY）」、「選択できる（OPTIONAL）」は、RFC 2119に記載されている内容に従い解釈してください。\nセマンティック バージョニングを適用するソフトウェアはパブリックAPIを宣言しなければなりません（MUST）。このAPIはコード自体で表現されているかもしれませんし、明確に文書として存在してるかもしれません。どちらにせよ、正確かつ漏れがないようにするべきです（SHOULD）。\nセマンティック バージョニングを適用するソフトウェアはパブリックAPIを宣言しなければなりません（MUST）。このAPIはコード自体で表現されているかもしれませんし、明確に文書として存在してるかもしれません。どちらにせよ、正確かつ漏れがないようにするべきです（SHOULD）。\n通常のバージョンナンバーは、X.Y.Zの形式にしなければなりません（MUST）。このときX、Y、Zは非負の整数であり（MUST）、各数値の先頭にゼロを配置してはなりません（MUST NOT）。Xはメジャーバージョン、Yはマイナーバージョン、Zはパッチバージョンを表します。各バージョンは数値的にバージョンアップしなければなりません（MUST）。例：1.9.0 -> 1.10.0 -> 1.11.0。\n通常のバージョンナンバーは、X.Y.Zの形式にしなければなりません（MUST）。このときX、Y、Zは非負の整数であり（MUST）、各数値の先頭にゼロを配置してはなりません（MUST NOT）。Xはメジャーバージョン、Yはマイナーバージョン、Zはパッチバージョンを表します。各バージョンは数値的にバージョンアップしなければなりません（MUST）。例：1.9.0 -> 1.10.0 -> 1.11.0。\n一度パッケージをリリースしたのなら、そのバージョンのパッケージのコンテンツは修正してはなりません（MUST NOT）。いかなる修正も新しいバージョンとしてリリースしなければなりません（MUST）。\n一度パッケージをリリースしたのなら、そのバージョンのパッケージのコンテンツは修正してはなりません（MUST NOT）。いかなる修正も新しいバージョンとしてリリースしなければなりません（MUST）。\nメジャーバージョンのゼロ（0.y.z）は初期段階の開発用です。いつでも、いかなる変更も起こりえます（MAY）。この時のパブリックAPIは安定していると考えるべきではありません（SHOULD NOT）。\nメジャーバージョンのゼロ（0.y.z）は初期段階の開発用です。いつでも、いかなる変更も起こりえます（MAY）。この時のパブリックAPIは安定していると考えるべきではありません（SHOULD NOT）。\nバージョン1.0.0はパブリックAPIを定義します。このリリース後のバージョンナンバーの上げ方に関しては、パブリックAPIがどのくらい変更されるのかによって決まります。\nバージョン1.0.0はパブリックAPIを定義します。このリリース後のバージョンナンバーの上げ方に関しては、パブリックAPIがどのくらい変更されるのかによって決まります。\nパッチバージョン Z （x.y.Z | x > 0）は、後方互換性を保ったバグ修正を取り込んだ場合のみ、上げなければなりません（MUST）。バグ修正とは間違った振る舞いを修正する内部の変更のことを指します。\nパッチバージョン Z （x.y.Z | x > 0）は、後方互換性を保ったバグ修正を取り込んだ場合のみ、上げなければなりません（MUST）。バグ修正とは間違った振る舞いを修正する内部の変更のことを指します。\nマイナーバージョン Y （x.Y.z | x > 0）は、後方互換性を保ちつつ機能性をパブリックAPIに追加した場合、上げなければなりません（MUST）。また、いかなるパブリックAPIも廃止予定としたのなら、上げなければなりません（MUST）。プライベートコード内での新しい機能の追加や改善を取り込んだ場合は、上げてもよいです（MAY）。その際にパッチレベルの変更も含めてもよいです（MAY）。マイナーバージョンを上げた際にはパッチバージョンを0にリセットしなければなりません（MUST）。\nマイナーバージョン Y （x.Y.z | x > 0）は、後方互換性を保ちつつ機能性をパブリックAPIに追加した場合、上げなければなりません（MUST）。また、いかなるパブリックAPIも廃止予定としたのなら、上げなければなりません（MUST）。プライベートコード内での新しい機能の追加や改善を取り込んだ場合は、上げてもよいです（MAY）。その際にパッチレベルの変更も含めてもよいです（MAY）。マイナーバージョンを上げた際にはパッチバージョンを0にリセットしなければなりません（MUST）。\nメジャーバージョン X （X.y.z | X > 0）は、パブリックAPIに対して後方互換性を持たない変更が取り込まれた場合、上げなければなりません（MUST）。その際にマイナーおよびパッチレベルの変更も含めてもよいです（MAY）。メジャーバージョンを上げた際には、パッチおよびマイナーバージョンを0にリセットしなければなりません（MUST）。\nメジャーバージョン X （X.y.z | X > 0）は、パブリックAPIに対して後方互換性を持たない変更が取り込まれた場合、上げなければなりません（MUST）。その際にマイナーおよびパッチレベルの変更も含めてもよいです（MAY）。メジャーバージョンを上げた際には、パッチおよびマイナーバージョンを0にリセットしなければなりません（MUST）。\nプレリリースバージョンは、パッチバージョンの直後にハイフンとドットで区切られた識別子を追加することで表現してもよいです（MAY）。識別子は必ずASCII英数字とハイフン [0-9A-Za-z-] でなければなりません（MUST）。識別子は空であってはなりません（MUST NOT）。数値の識別子はゼロから始めてはなりません（MUST NOT）。プレリリースバージョンは関連する通常のバージョンよりも低い優先度です。プレリリースバージョンは、不安定であり、関連する通常のバージョンが示す要件と互換性を満たさない可能性があります。例：1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92。\nプレリリースバージョンは、パッチバージョンの直後にハイフンとドットで区切られた識別子を追加することで表現してもよいです（MAY）。識別子は必ずASCII英数字とハイフン [0-9A-Za-z-] でなければなりません（MUST）。識別子は空であってはなりません（MUST NOT）。数値の識別子はゼロから始めてはなりません（MUST NOT）。プレリリースバージョンは関連する通常のバージョンよりも低い優先度です。プレリリースバージョンは、不安定であり、関連する通常のバージョンが示す要件と互換性を満たさない可能性があります。例：1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92。\nビルドメタデータはパッチまたはプレリリースバージョンの直後にプラス記号とドットで区切られた識別子を追加することで表現してもよいです（MAY）。識別子は必ずASCII英数字とハイフン [0-9A-Za-z-] でなければなりません（MUST）。識別子は空であってはなりません（MUST NOT）。バージョンの優先度を決める際にはビルドメタデータは無視されなければなりません（MUST）。つまり、2つのビルドメタデータだけが違うバージョンは、同じ優先度ということです。例：1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85。\nビルドメタデータはパッチまたはプレリリースバージョンの直後にプラス記号とドットで区切られた識別子を追加することで表現してもよいです（MAY）。識別子は必ずASCII英数字とハイフン [0-9A-Za-z-] でなければなりません（MUST）。識別子は空であってはなりません（MUST NOT）。バージョンの優先度を決める際にはビルドメタデータは無視されなければなりません（MUST）。つまり、2つのビルドメタデータだけが違うバージョンは、同じ優先度ということです。例：1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85。\nバージョン同士をどのように比較するのかは優先度によって決まります。優先度はメジャー、マイナー、パッチ、プレリリース識別子の順番（ビルドメタデータは優先度に関して考慮しない）で分けて評価されなければなりません（MUST）。優先度は、各識別子を左から右に比較して最初の違いによって評価します。以下のように、メジャー、マイナー、パッチバージョンと常に数値的に比較します。例：1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。メジャー、マイナー、パッチが同じ場合、プレリリースバージョンを持っている方が通常のバージョンよりも低い優先度です。例：1.0.0-alpha < 1.0.0。同じ、メジャー、マイナー、パッチを持つプレリリースバージョンの優先度の決定は、ドットで区切れた識別子を左から右に、異なるところが見つかるまで比較し決定しなければなりません（MUST）。数値のみで構成される識別子は数値的に比較され、文字列やハイフンを含む識別子はASCIIソート順に辞書的に比較されます。数値的な識別子は常に数値的でない識別子よりも低い優先度です。もし先行する識別子が同じ場合、プレリリースのフィールドが小さいセットよりも大きいセットのほうが高い優先度です。例：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。\nバージョン同士をどのように比較するのかは優先度によって決まります。優先度はメジャー、マイナー、パッチ、プレリリース識別子の順番（ビルドメタデータは優先度に関して考慮しない）で分けて評価されなければなりません（MUST）。優先度は、各識別子を左から右に比較して最初の違いによって評価します。以下のように、メジャー、マイナー、パッチバージョンと常に数値的に比較します。例：1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。メジャー、マイナー、パッチが同じ場合、プレリリースバージョンを持っている方が通常のバージョンよりも低い優先度です。例：1.0.0-alpha < 1.0.0。同じ、メジャー、マイナー、パッチを持つプレリリースバージョンの優先度の決定は、ドットで区切れた識別子を左から右に、異なるところが見つかるまで比較し決定しなければなりません（MUST）。数値のみで構成される識別子は数値的に比較され、文字列やハイフンを含む識別子はASCIIソート順に辞書的に比較されます。数値的な識別子は常に数値的でない識別子よりも低い優先度です。もし先行する識別子が同じ場合、プレリリースのフィールドが小さいセットよりも大きいセットのほうが高い優先度です。例：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。\nSemVerバージョンを表すバッカス・ナウア記法\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nなぜセマンティック バージョニングを使用するのか？\nこのアイデアは新しいものでもなければ、革新的なものでもありません。実際、みなさんも似たような取り組みを既におこなっているかもしれません。問題は「似ている」のでは不十分だということです。正式な仕様書による取り決めがなければ、バージョンナンバーは依存性の管理において基本的には無意味です。上記のアイデアに対して名前と正確な定義を与えることよって、あなたの開発するソフトウェアにおいて、あなたの意図がユーザーに対して伝わりやすくなることでしょう。一度、これらの意図を正確にしてしまえば、柔軟な（しかし、柔軟すぎてはいけない）依存性の仕様を作ることができます。\n単純な例として、セマンティック バージョニングがどのように依存性地獄を過去のものとするかについて説明します。「Firetruck」と呼ばれるライブラリについて考えてみましょう。それはセマンティック バージョニングされた「Ladder」というパッケージを必要とします。Firetruckを作成した時、Ladderはバージョン3.1.0でした。Firetruckは、バージョン3.1.0時に導入されたいくつかの機能を使用しているので、Ladderが3.1.0以上4.0.0未満の範囲で安全に依存性を指定できます。Ladderのバージョン3.1.1と3.2.0が利用可能になった時、それらをパッケージ管理に取り込んでリリースすることができ、それらが既存の依存するソフトウェアと互換性があるということは明確です。\n賢明な開発者であれば、もちろんパッケージがアップグレードされたのならその機能を使ってみたいと思うはずでしょう。ただ、現実は混沌としていて、我々ができることといったら、慎重になることくらいです。セマンティック バージョニングを実践することで、新しい依存パッケージを巻き込むことなく、まともな方法でリリース、アップグレードすることができ、手間と時間を節約してくれることでしょう。\nもし全面的に同意できると感じたのなら、セマンティック バージョニングを実践していることを宣言し、ルールを守って下さい。それからあなたのREADMEからこのWebサイトにリンクしてください、そうすれば、他の人がこのルールを知り、役立てることができるでしょう。\n0.y.zのような初期の開発フェーズにおけるバージョンの取り扱いはどのようにすべきでしょうか？\n一番簡単な方法は0.1.0からで開発版をリリースし、その後のリリースのたびにマイナーバージョンを上げていけばよいでしょう。\n1.0.0のリリースはいつすべきでしょうか？\nもし既にプロダクション用途であなたのソフトウェアが利用されているのなら、それは1.0.0であるべきでしょう。またもし安定したAPIを持ち、それに依存しているユーザーが複数いるのなら、それは1.0.0であるべきでしょう。もし後方互換性について多大な心配をしているのなら、それは1.0.0であるべきでしょう。\n高速開発や高速イテレーションに悪影響を与えませんか？\nメジャーバージョンがゼロの場合、それは高速開発を意味しています。もし、毎日APIを変更しているのなら、0.y.zのバージョンのままにすべきか、開発ブランチとして切り分け、次のメジャーバージョンアップのために開発すべきです。\nパブリックAPIに対して後方互換性を保たない、ほんの些細な変更があった際もメジャーバージョンアップをしなければならないのなら、42.0.0のようなバージョンにすぐになってしまわないですか？\nこれは責任ある開発と深い洞察のある質問です。多くの依存されているコードを持つソフトウェアにおいて、非互換な変更を気軽に取り込むべきではありません。アップグレードする度にかかるコストは無視できないものでしょう。非互換な変更をリリースするためにメジャーバージョンを上げることは、変更における悪影響を思い知ることになるでしょう。加えて、費用対効果を評価して判断すべきでしょう。\nすべてのパブリックAPIに関してドキュメントを書くのは重労働です。\nユーザーに使用されることを前提としたソフトウェアに適切なドキュメントを用意することはプロフェッショナルな開発者としての当然の責任です。ソフトウェアの複雑性を管理することはプロジェクトをスムーズに続けていくために非常に重要なことで、もしあなたのソフトウェアの使い方や、どのメソッドが安全に呼び出せるのかを誰も知らないのは望ましい状況とは言えません。セマンティック バージョニングと適切に定義されたパブリックAPIを宣言することは長期的に見ればメリットが大きいでしょう。\nもし誤って後方互換性のない変更をマイナーバージョンとしてリリースした場合、どうすればよいでしょうか？\nセマンティック バージョニングの仕様に違反したのならすぐに問題を修正してください。つまり後方互換性を復元し、新しくマイナーバージョンをリリースして下さい。このような状況下においてもリリースされたバージョンナンバーを修正してはなりません。適切な対応が完了したのなら、次は違反したバージョンを記録し、それをユーザーに知らせましょう。\nもし、パブリックAPIの変更なしに自分のパッケージの依存性をアップデートしてしまったら、どうすべきでしょうか？\nそれ自体はパブリックAPIに影響しませんので安心してください。パッケージとして明らかに同じ依存性を持つソフトウェアは自身の依存仕様を定義すべきですし、作成者はいかなるコンフリクトも見逃さないでしょう。その変更がパッチレベルなのかマイナーレベルなのかどうかは、パッケージの依存性をアップデートした理由がバグを修正するためか新しい機能を実装するためかどうかに依存します。後者のケースの場合は明らかにマイナーレベルの変更でしょう。\nもしうっかりパブリックAPIをセマンティック バージョニングに対応していない形で変更したらどうなるでしょうか？（例：パッチリリースで主要なバグが発生した場合）\n最善の判断をしてください。もしパブリックAPIの動作が変わることで大いに影響するユーザーがいる場合、厳密にはパッチリリースであると考慮されるかもしれませんが、その後にメジャーバージョンをリリースするのがベストかもしれません。セマンティック バージョニングはバージョンがどのように変更されるのかということを伝えるためのものであるということを注意して下さい。\nどのように非推奨機能を扱えばよいでしょうか？\n既存機能を廃止予定にするのはソフトウェア開発においては普通の事であり、開発を進める上で頻繁に必要となります。パブリックAPIの一部を非推奨にしたい場合、2つのことをすべきです。第一にユーザーに知らせるためにドキュメントを更新して下さい。次に非推奨機能を残したまま新しいマイナーバージョンをリリースして下さい。完全に非推奨機能を削除しメジャーバージョンをリリースする前に、ユーザーがスムーズに新しいAPIに移行できるように少なくとも1回のマイナーバージョン（非推奨機能を含んだ）をリリースして下さい。\nSemVerのバージョン文字列に限度はありますか？\nいいえ、ありませんが良識ある判断をしてください。例えば255文字のバージョン文字列は過剰と言えるでしょうし、特定のシステムではそれ独自の文字列の限界値があることでしょう。\n『v1.2.3』はセマンティック バージョンでしょうか？\nいいえ、『v1.2.3』はセマンティック バージョンではありません。しかしながら、セマンティック バージョンに接頭辞の『v』を付けるのは英語ではバージョン番号であることを示す一般的な方法です。バージョン管理では、『バージョン』を『v』と略すことがよくあります。たとえば git tag v1.2.3 -m" Release version 1.2.3 " では『v1.2.3』はタグ名であり、セマンティック バージョンは『1.2.3』です。\nSemVer文字列をチェックするために推奨される正規表現（RegEx）はありますか？\n二つあります。一つは名前付きグループをサポートするシステム（PCRE [Perl Compatible Regular Expressions, 例: Perl, PHP and R]、Python、Go）のための正規表現です。\n参考: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nもう一つは番号付きキャプチャグループを使った正規表現です（したがって、cg1 = メジャー、cg2 = マイナー、cg3 = パッチ、cg4 = プレリリース、cg5 = ビルドメタデータを意味します）。これはECMA Script（JavaScript）、PCRE（Perl Compatible Regular Expressions, 例: Perl, PHP and R）、Python、Goにおいて互換性があります。\n参考: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nセマンティック バージョニング仕様書の著者はTom Preston-Werner氏です。彼はGravatarの考案者であり、GitHubの共同創設者でもあります。\nもしフィードバックがある場合は、GitHub上でissueを立てて下さい。\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nსემანტიკური ვერსიონირება 2.0.0

მოკლედ

როდესაც გვაქვს ვერსიის ნომერი მაჟორული.მინორული.პატჩი, უნდა გაიზარდოს:


  მაჟორული ვერსია, როდესაც შეტანილია არა უკუთავსებადი ცვლილებები API-ში.
  მინორული ვერსია, როდესაც ემატება ახალი ფუნქციონალი, უკუთავსებადობის დაურღვევლად.
  პატჩ-ვერსია, როდესაც ემატება უკუთავსებადი ჩასწორებები.


პრე-რელიზის და ბილდის მეტა-მონაცემების დამატებითი აღნიშვნები შესაძლებელია მიემატოს 
ფორმატს მაჟორული.მინორული.პატჩი

შესავალი

პროგრამული უზრუნველყოფის შემუშავების მართვის პროცესში არსებობს ცნება 
“დამოკიდებულებათა ჯოჯოხეთი” (dependency hell). რაც უფრო იზრდება სისტემა და 
რაც უფრო მეტი ბიბლიოთეკის ინტეგრირება ხდება პროექტში, მით უფრო იზრდება ამ 
სიტუაციაში მოხვედრის ალბათობა.

სისტემაში სადაც ბევრი დამოკიდებულებაა, ახალი ვერსიის გამოშვება შეიძლება 
გადაიქცეს დიდ თავის ტკივილად. თუ დამოკიდებულებების სპეციფიკაცია ზედმეტად მკაცრია, 
არსებობს ახალი ვერსიის გამოშვების ბლოკირების საფრთხე (შეუძლებელია პაკეტის განახლება 
თითოეული დამოკიდებული ბიბლიოთეკის განახლების გარეშე). თუ დამოკიდებულებების სპეციფიკაცია 
ზედმეტად თავისუფალია, ადრე თუ გვიან აუცილებლად დადგება ვერსიების შეუსაბამობის 
პრობლემა (უსაფუძვლო იმედი მომავალ ვერსიებთან თავსებადობისა).
“დამოკიდებულებათა ჯოჯოხეთი” არის მდგომარეობა როდესაც დამოკიდებულებების არსებობა 
ხელს უშლის პროექტის წინსვლას და განვითარებას.

ამ პრობლემის მოგვარებისთვის გთავაზობთ უბრალო წესების და მოთხოვნების კრებულს, 
რომელიც განსაზღვრავს როგორ ენიჭება და იცვლება ვერსიის ნომრები.
იმისათვის რომ ამ სისტემამ იმუშაოს, თქვენ უნდა განსაზღვროთ გარე (public) API.
ის შეიძლება აღიწეროს როგორც დოკუმენტაციაში, ასევე თავად კოდის მეშვეობით. მთავარია, 
რომ ეს API იყოს გასაგები და ზუსტი. მას შემდეგ რაც ერთხელ აღწერთ გარე API-ს, 
მასში ცვლილებების შესახებ მის მომხმარებლებს თქვენ ამცნობთ სპეციალური ვერსიის 
ნომრის გაზრდის მეშვეობით. განვიხილოთ ვერსიის ფორმატი X.Y.Z (მაჟორული, მინორული, პატჩი). 
ბაგ-ფიქსები რომელთაც არ აქვთ გავლენა API-ზე, ზრდის პატჩ-ვერსიას, უკუთავსებადი 
დამატებები და ცვლილებები ზრდის მინორულ ვერსიას, ხოლო არა უკუთავსებადი ცვლილებები 
ზრდის მაჟორულ ვერსიას.

ამას ვუწოდებ “სემანტიკურ ვერსიონირებას” (Semantic Versioning). ამ სქემის მიხედვით
ვერსიის ნომრები და მათი ცვლილება აღწერს იმას, თუ როგორ შეიცვალა და რა შეიცვალა 
კოდში ერთი ვერსიიდან მეორემდე.

სემანტიკური ვერსიონირების სპეციფიკაცია (SemVer)
სიტყვები “უნდა” (MUST), “არ უნდა” (MUST NOT), “აუცილებელია” (REQUIRED),
“სასურველია” (SHOULD), “არ არის სასურველი” (SHOULD NOT), “რეკომენდირებულია” (RECOMMENDED),
“შეიძლება” (MAY) და “არასავალდებულოა” (OPTIONAL) ამ დოკუმენტში უნდა იქნეს 
ინტერპრეტირებული შესაბამისად RFC 2119 სპეციფიკაციისა.


  
    პროგრამული უზრუნველყოფა რომელიც იყენებს სემანტიკურ ვერსიონირებას, 
“უნდა” აღწერდეს გარე API-ს. ეს API შეიძლება იყოს აღწერილი თვითონ კოდში, 
ან მკაცრად იყოს განსაზღვრული დოკუმენტაციაში. API როგორც არ უნდა იყოს აღწერილი, 
იგი უნდა იყოს ზუსტი და ამომწურავი.
  
  
    ვერსიის ჩვეულებრივი ნომერი “უნდა” იყოს ფორმატში X.Y.Z, სადაც X, Y და Z — 
არის არაუარყოფითი მთელი რიცხვები და “არ უნდა” იწყებოდეს ნულით. X არის მაჟორული ვერსია, 
Y — მინორული ვერსია და Z — პატჩ-ვერსია. თითოეული ელემენტი “უნდა” იზრდებოდეს რიცხვობრივად.
მაგალითად: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    პაკეტის ახალი ვერსიის რელიზის შემდეგ ამ ვერსიის შემადგენლობა “არ უნდა” შეიცვალოს.
ნებისმიერი ცვლილების გამოშვება “უნდა” მოხდეს ახალი ვერსიით.
  
  
    მაჟორული ვერსია ნული (0.y.z) განკუთვნილია საწყისი სამუშაოებისთვის.
ყველაფერი შეიძლება შეიცვალოს ნებისმიერ მომენტში. გარე API არ შეიძლება 
განიხილოს როგორც სტაბილური.
  
  
    ვერსია 1.0.0 განსაზღვრავს გარე API-ს. ამ რელიზის შემდეგ ვერსიის ნომრები იზრდება
იმის მიხედვით თუ როგორ იცვლება გარე API.
  
  
    პატჩ-ვერსია Z (x.y.Z | x > 0) “უნდა” გაიზარდოს მხოლოდ იმ შემთხვევაში, 
თუ შეიცავს უკუთავსებად ბაგ-ფიქსებს. განსაზღვრება ბაგ-ფიქსი ნიშნავს
შიდა ცვლილებებს, რომელიც აღმოფხვრის კოდის არაკორექტულად მუშაობას.
  
  
    მინორული ვერსია (x.Y.z | x > 0) “უნდა” გაიზარდოს იმ შემთხვევაში,
თუ გარე API-ში წარმოდგენილია ახალი უკუთავსებადი ფუნქციონალი. “უნდა” გაიზარდოს 
იმ შემთხვევაში, თუ გარე API-ს რომელიმე ფუნქციონალი მოინიშნა როგორც მოძველებული 
(deprecated). “შეიძლება” გაიზარდოს ახალი ფუნქციონალის რეალიზაციისას ან
მნიშვნელოვანი ცვლილებებისას პრივატულ კოდში. ასევე იგი “შეიძლება” შეიცავდეს 
ცვლილებებს რომელიც დამახასიათებელია პატჩებისთვის. პატჩ-ვერსია “უნდა” განულდეს,
როდესაც იზრდება მინორული ვერსია.
  
  
    მაჟორული ვერსია X (X.y.z | X > 0) “უნდა” გაიზარდოს იმ შემთხვევაში, 
თუ გარე API-ში წარმოდგენილია რაიმე არა უკუთავსებადი ცვლილებები.
იგი “შეიძლება” შეიცავდეს ასევე ცვლილებებს, რომელიც დამახასიათებელია 
მინორული ვერსიებისთვის და პატჩებისთვის. როდესაც იზრდება მაჟორული ვერსია,
მინორული ვერსია და პატჩ-ვერსია “უნდა” განულდეს.
  
  
    წინა სარელიზო ვერსია “შეიძლება” იყოს აღნიშნული დეფისის და წერტილებით 
გამოყოფილი იდენტიფიკატორების სერიის დამატებით, რომელიც მოსდევს პატჩ-ვერსიას.
იდენტიფიკატორები “უნდა” შეიცავდეს მხოლოდ ASCII ასობგერით-ციფრულ სიმბოლოებს 
და დეფისს [0-9A-Za-z-]. იდენტიფიკატორები “არ უნდა” იყოს ცარიელი. ციფრული
იდენტიფიკატორები “არ უნდა” იწყებოდეს ნულით. წინა სარელიზო ვერსია მიანიშნებს
იმაზე, რომ ეს ვერსია არ არის სტაბილური და შეიძლება არ აკმაყოფილებდეს 
თავსებადობის მოთხოვნებს, რომელიც აღნიშნულია შესაბამისი ნორმალური ვერსიებით. 
მაგალითები: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    ბილდის მეტა-მონაცემები “შეიძლება” იყოს აღნიშნული პლუს ნიშნის და 
წერტილით გამოყოფილი იდენტიფიკატორების დამატებით პატჩ-ვერსიის ან წინა 
სარელიზო ვერსიის შემდეგ. იდენტიფიკატორები “უნდა” შეიცავდეს მხოლოდ ASCII 
ასობგერით-ციფრულ სიმბოლოებს და დეფისს [0-9A-Za-z-]. იდენტიფიკატორები “არ უნდა” 
იყოს ცარიელი. “რეკომენდირებულია” ბილდის მეტა-მონაცემების დაიგნორება, როდესაც
ძირითადი ვერსიები ერთი და იგივეა და ხდება ვერსიის პრიორიტეტის განსაზღვრა.
მაგალითები: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    პრიორიტეტი განსაზღვრავს თუ როგორ შეესაბამება ვერსიები ერთმანეთს სორტირების დროს.
ვერსიის პრიორიტეტი “უნდა” გამოითვალოს ვერსიის ნომრების მაჟორულ, მინორულ, 
პატჩ და წინა სარელიზო ვერსიებად დაყოფით (ბილდის მეტა-მონაცემები ამ გათვლაში არ ფიგურირებს).
პრიორიტეტი განისაზღვრება თითოეული იდენტიფიკატორის შედარებისას მარცხნიდან მარჯვნივ:
მაჟორული, მინორული და პატჩ ვერსია დარდება რიცხვობრივად. მაგალითად: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
როდესაც მაჟორული, მინორული და პატჩ-ვერსია ექვივალენტურია, წინა სარელიზო ვერსიას გაჩნია
ნორმალურ ვერსიაზე ნაკლები პრიორიტეტი. მაგალითად: 1.0.0-alpha < 1.0.0.
როდესაც ორ წინა სარელიზო ვერსიას გააჩნია ერთნაირი მაჟორული, მინორული და
პატჩ-ვერსია, მათ შორის პრიორიტეტი “უნდა” განისაზღვროს თითოეული წერტილით გამოყოფილი 
იდენტიფიკატორის მარცხნიდან მარჯვნივ შედარებით მანამდე, სანამ არ იქნება ნაპოვნი 
შემდეგი სახის განსხვავებები: იდენტიფიკატორები რომლებიც შედგება მხოლოდ ციფრებით, 
დარდება რიცხვობრივად; ასო-ბგერითი იდენტიფიკატორები ან დეფისები დარდება ლექსიკურად
ASCII სტანდარტის მიხედვით. რიცხვობრივ იდენტიფიკატორებს ყოველთვის გააჩნია დაბალი 
პრიორიტეტი ასო-ბგერით იდენტიფიკატორებთან მიმართებაში. როდესაც შესადარებელი 
იდენტიფიკატორები ტოლია, სიმბოლოების მეტ რაოდენობას გააჩნია უფრო მაღალი პრიორიტეტი. 
მაგალითი: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


რატომ უნდა გამოვიყენოთ სემანტიკური ვერსიონირება?

ეს არ გახლავთ ახალი ან რევოლუციური იდეა. ალბათ თქვენ უკვე იყენებთ რაიმე მსგავსს.
პრობლემა გახლავთ ის, რომ “მსგავსი” არ ნიშნავს საკმარისად კარგს. ფორმალური სპეციფიკაციის 
გარეშე ვერსიის ნომრები ფაქტიურად გამოუსადეგარია დამოკიდებულებების სამართავად.
ვერსიონირების იდეის ნათლად ფორმულირების და განსაზღვრის შემდეგ გაცილებით იოლი 
ხდება თქვენი პროგრამული უზრუნველყოფის მომხმარებლებს ამცნოთ გეგმების შესახებ.
როდესაც ეს გეგმები ნათელია და მოქნილი (არა ზედმეტად), შესაძლებელი ხდება 
დამოკიდებულებების სპეციფიკაციის შექმნა.

უბრალო მაგალითზე მოვახდინოთ დემონსტრირება თუ როგორ შეუძლია სემანტიკურ ვერსიონირებას 
“დამოკიდებულებათა ჯოჯოხეთი” აქციოს წარსულად. წარმოვიდგინოთ ბიბლიოთეკა სახელად 
“Firetruck”. მას ჭირდება სემანტიკურად ვერსიონირებული პაკეტი სახელად “Ladder”.
როდესაც შეიქმნა Firetruck, პაკეტი Ladder იყო 3.1.0 ვერსია. იქიდან გამომდინარე, რომ
Firetruck იყენებს ფუნქციონალს, რომელიც პირველად გაჩნდა 3.1.0 ვერსიაში, თქვენ მშვიდად 
შეგიძლიათ გამოაცხადოთ დამოკიდებულება Ladder პაკეტზე ვერსიით მინიმუმ 3.1.0 მაგრამ 
ნაკლები ვიდრე 4.0.0.
შემდეგ, როდესაც Ladder ხელმისაწვდომი გახდება ვერსიებით 3.1.1 და 3.2.0, თქვენ შეგეძლებათ 
მისი ინტეგრირება თქვენ სისტემაში და თან გეცოდინებათ, რომ იგი თავსებადია მიმდინარე 
ფუნქციონალთან.

როგორც პასუხისმგებლიან დეველოპერს, თქვენ რა თქმა უნდა გინდათ იყოთ დარწმუნებული 
იმაში, რომ ყველა განახლება ფუნქციონირებს ისე, როგორც გამოცხადებულია. რეალურ სამყაროში 
სრული ქაოსია და ამას ვერაფერს ვუზავთ. თქვენ რაც შეგიძლიათ გააკეთოთ, ეს არის სემანტიკურ 
ვერსიონირებას მიცეთ საშუალება დაგეხმაროთ რელიზების გამოშვებაში, მათზე დამოკიდებული 
პაკეტების განახლების გარეშე. ეს დაგიზოგავთ ბევრ დროს და ნერვებს.

თუ ეს მიმზიდველად ჟღერს, მაშინ ყველაფერი რაც გჭირდებათ, არის სემანტიკური 
ვერსიონირების გამოყენების დაწყება, გამოცხადება რომ იყენებთ მას, და მასში აღწერილი წესების დაცვა.
დაამატეთ ამ საიტის ბმული თქვენ README ფაილში, რათა მომხმარებლებმა იცოდნენ წესები 
და მიიღონ სრული სარგებელი აქედან.

ხშირად დასმული კითხვები (FAQ)

როგორ უნდა ვიმუშაო რევიზიებთან 0.y.z დეველოპმენტის საწყის ეტაპზე?

ყველაზე მარტივი — დაიწყოთ დეველოპმენტი 0.1.0 ვერსიიდან და შემდეგ გაზარდოთ მინორული 
ვერსია ყოველი შემდეგი რელიზის დროს.

როგორ უნდა მივხვდე რომ 1.0.0 რელიზის გამოშვების დროა?

თუ თქვენი პროგრამული უზრუნველყოფა გამოიყენება პროდაქშენზე, დიდი ალბათობით იგი 
უნდა იყოს 1.0.0 ვერსია. თუ თქვენ გაქვთ სტაბილური API, რომელზეც დამოკიდებული არიან 
მომხმარებლები, მაშინ ვერსია უნდა იყოს 1.0.0. თუ თქვენ იწყებთ შიშს უკუთავსებადობაზე, მაშინ დიდი 
ალბათობით თქვენი პროგრამული უზრუნველყოფის ვერსია უკვე არის 1.0.0.

ხელს ხომ არ უშლის სწრაფ დეველოპმენტს (Rapid Development) და მოკლე იტერაციებს (Fast Iteration)?

მაჟორული ვერსია 0 ზუსტადაც რომ ნიშნავს სწრაფ დეველოპმენტს. თუ თქვენ ცვლით API-ს ყოველ დღე,
უნდა გაჩერდეთ ვერსიაზე 0.y.z ან უნდა იმუშაოთ განსხვავებულ ტოტზე (branch) შემდეგი 
მაჟორული ვერსიის რელიზისთვის.

გარე API-ში ძალიან უმნიშვნელო არა უკუთავსებადი ცვლილებებიც საჭიროებს ახალი მაჟორული ვერსიის გამოშვებას? ეს ხომ არ გამოიწვევს იმას, რომ ძალიან მალე ვერსიის ნომერი გახდება 42.0.0?

წინდახედული და პასუხისმგებლიანი კითხვაა. არა უკუთავსებადი ცვლილებები არ შეიძლება რომ 
წარმოდგენილი იყოს როგორც უმნიშვნელო ცვლილებები, მითუმეტეს როდესაც ამ API-ზე დამოკიდებულია 
კიდევ სხვა კოდი. განახლების ღირებულება შეიძლება დიდი აღმოჩნდეს. არა უკუთავსებადი ცვლილებების 
შემთხვევაში, მაჟორული ვერსიის გაზრდის პრაქტიკა ნიშნავს, რომ თქვენ მოგიწევთ ფიქრი ცვლილებების 
შესახებ და ღირებულება/სარგებელის შეფარდების გათვალისწინება.

სრული API-ს დოკუმენტირება ძალიან დიდი სამუშაოა!

პროგრამული უზრუნველყოფის სწორი დოკუმენტირება არის თქვენი პასუხისმგებლობა, როგორც 
პროფესიონალი დეველოპერის. მითუმეტეს, როდესაც ეს პროგრამული უზრუნველყოფა გათვლილია ფართო 
აუდიტორიაზე. პროგრამული უზრუნველყოფის კომპლექსურობის მართვა არის მნიშვნელოვანი ნაწილი 
პროექტის მაღალი ეფექტურობის შენარჩუნებისთვის. და ეს ძალიან რთულია, როდესაც მომხმარებელმა 
არ იცის როგორ გამოიყენოს თქვენი პროგრამული უზრუნველყოფა ან რომელი მეთოდის გამოძახება 
შეუძლია უსაფრთხოდ. ხანგრძლივ პერსპექტივაში სემანტიკური ვერსიონირება და გარე API-ს ხარისხიანი 
დოკუმენტირებისადმი დაჟინებული სწრაფვა დაგეხმარებათ შეუფერხებლად მუშაობაში.

როგორ მოვიქცე თუ შემთხვევით არა უკუთავსებადი ცვლილებები დავარელიზე როგორც მინორული ვერსია?

როგორც კი აღმოაჩენთ, რომ დაარღვიეთ სემანტიკური ვერსიონირების სპეციფიკაცია, გაასწორეთ 
პრობლემა და გამოუშვით ახალი მინორული ვერსია, რომელიც აღადგენს უკუთავსებადობას. ასეთ 
ვითარებაშიც კი დაუშვებელია უკვე გამოშვებული რელიზის მოდიფიცირება. თუ საჭიროდ ჩათვლით, 
სასურველია ასევე დოკუმენტაციაში უკუთავსებადობის დარღვევის მითითება იმ კონკრეტული ვერსიისთვის 
და მომხმარებლების ინფორმირება იმის თაობაზე რომ ვერსიების მიმდევრობა დარღვეულია.

რა უნდა გავაკეთო, თუ ვანახლებ საკუთარ დამოკიდებულებებს გარე API-ს ცვლილების გარეშე?

ეს შეიძლება განიხილოს როგორც თავსებადი ცვლილებები, რაკი მას გავლენა არ აქვს გარე API-ზე.
პროგრამულ უზრუნველყოფას რომელიც თავისმხრივ დამოკიდებულია იმავე დამოკიდებულებებზე, 
უნდა გააჩნდეს საკუთარი დამოკიდებულებების სპეციფიკაციები და შესაბამისად ავტორი შეიტყობს შესაძლო 
კონფლიქტების შესახებ. ცვლილებები უნდა აღიწეროს როგორც პატჩ-ვერსია თუ მინორული, ეს
განისაზღვრება იმით, დამოკიდებულებები განახლდა ხარვეზის გასწორების გამო თუ დაემატა ახალი 
ფუნქციონალი. უკანასკნელის შემთხვევაში, როგორც წესი ემატება ახალი კოდი და შესაბამისად 
ახლდება მინორული ვერსია.

რა უნდა გავაკეთო, თუ შემთხვევით შევცვალე გარე API და არასწორად გავზარდე ვერსიის ნომერი (მაგალითად კოდი შეიცავს არა უკუთავსებად ცვლილებებს პატჩ-ვერსიაში)?

მოიქეცით თქვენი შეხედულებისამებრ. თუ თქვენი აუდიტორია საკმაოდ დიდია და გახდა საჭირო API-ს 
ძველი ფუნქციონალის დაბრუნება, მაშინ სასურველია ახალი მაჟორული ვერსიის გამოშვება, მიუხედავად 
იმისა, რომ ცვლილებები შეიცავს პატჩ-რელიზის შესაბამის ჩასწორებებს. დაიხსომეთ, სემანტიკურ 
ვერსიონირებაში ვერსიის ნომრები იცვლება სპეციფიკაციის მკაცრი დაცვით. თუ ცვლილებები 
მნიშვნელოვანია თქვენი მომხმარებლებისთვის, გამოიყენეთ ვერსიის ნომერი მათი ინფორმირებისთვის.

როგორ მოვიქცე მოძველებულ ფუნქციონალთან მიმართებაში?

ფუნქციონალის მოძველებულად გამოცხადება — ეს ჩვეულებრივი ამბავია დეველოპმენტის პროცესში
და ხშირად აუცილებელიც კია პროდუქტის განსავითარებლად. როდესაც გარე API-ს რაიმე ნაწილს 
აცხადებთ მოძველებულად, თქვენ უნდა გააკეთოთ ორი რამ: (1) განაახლოთ თქვენი დოკუმენტაცია, 
რათა მომხმარებლებმა შეიტყონ ამ ცვლილების შესახებ; (2) გამოუშვათ ახალი რელიზი მინორული 
ვერსიის გაზრდით. მანამ, სანამ მთლიანად ამოიღებთ კოდიდან მოძველებულ ფუნქციონალს და 
დაარელიზებთ მაჟორულ ვერსიას, უნდა არსებობდეს მინიმუმ ერთი მინორული რელიზი, რომელიც 
შეიცავს ფუნქციონალის მოძველებულად გამოცხადებას. ეს აუცილებელია იმისათვის, რომ 
მომხმარებლებმა უმტკივნეულოდ შეძლონ ახალ API-ზე გადასვლა.

სემანტიკურ ვერსიონირებას თუ გააჩნია ვერსიაში შესაძლო სიმბოლოების ლიმიტი?

არა, თუმცა იხელმძღვანელეთ საღი აზრით. ალბათ დამეთანხმებით 255 სიმბოლო ვერსიის აღწერაში ზედმეტია.
ასევე, ზოგიერთ სისტემას შეიძლება გააჩნდეს საკუთარი შეზღუდვები ხაზის დასაშვები სიგრძის მიმართ.

ავტორის შესახებ

სემანტიკური ვერსიონირების სპეციფიკაციის ავტორია
ტომ პრესტონ-ვერნერი, Gravatar-ის დამფუძნებელი
და GitHub-ის თანადამფუძნებელი.

თუ გსურთ დატოვოთ თქვენი გამოხმაურება, გთხოვთ შექმნათ
დაამატოთ თემა GitHub-ზე.

ქართული თარგმანი


  Avtandil Kikabidze aka LONGMAN (author)


ლიცენზია

Creative Commons — CC BY 3.0\nსემანტიკური ვერსიონირება 2.0.0\nროდესაც გვაქვს ვერსიის ნომერი მაჟორული.მინორული.პატჩი, უნდა გაიზარდოს:\nმაჟორული ვერსია, როდესაც შეტანილია არა უკუთავსებადი ცვლილებები API-ში.\nმინორული ვერსია, როდესაც ემატება ახალი ფუნქციონალი, უკუთავსებადობის დაურღვევლად.\nპატჩ-ვერსია, როდესაც ემატება უკუთავსებადი ჩასწორებები.\nპრე-რელიზის და ბილდის მეტა-მონაცემების დამატებითი აღნიშვნები შესაძლებელია მიემატოს 
ფორმატს მაჟორული.მინორული.პატჩი\nპროგრამული უზრუნველყოფის შემუშავების მართვის პროცესში არსებობს ცნება 
“დამოკიდებულებათა ჯოჯოხეთი” (dependency hell). რაც უფრო იზრდება სისტემა და 
რაც უფრო მეტი ბიბლიოთეკის ინტეგრირება ხდება პროექტში, მით უფრო იზრდება ამ 
სიტუაციაში მოხვედრის ალბათობა.\nსისტემაში სადაც ბევრი დამოკიდებულებაა, ახალი ვერსიის გამოშვება შეიძლება 
გადაიქცეს დიდ თავის ტკივილად. თუ დამოკიდებულებების სპეციფიკაცია ზედმეტად მკაცრია, 
არსებობს ახალი ვერსიის გამოშვების ბლოკირების საფრთხე (შეუძლებელია პაკეტის განახლება 
თითოეული დამოკიდებული ბიბლიოთეკის განახლების გარეშე). თუ დამოკიდებულებების სპეციფიკაცია 
ზედმეტად თავისუფალია, ადრე თუ გვიან აუცილებლად დადგება ვერსიების შეუსაბამობის 
პრობლემა (უსაფუძვლო იმედი მომავალ ვერსიებთან თავსებადობისა).
“დამოკიდებულებათა ჯოჯოხეთი” არის მდგომარეობა როდესაც დამოკიდებულებების არსებობა 
ხელს უშლის პროექტის წინსვლას და განვითარებას.\nამ პრობლემის მოგვარებისთვის გთავაზობთ უბრალო წესების და მოთხოვნების კრებულს, 
რომელიც განსაზღვრავს როგორ ენიჭება და იცვლება ვერსიის ნომრები.
იმისათვის რომ ამ სისტემამ იმუშაოს, თქვენ უნდა განსაზღვროთ გარე (public) API.
ის შეიძლება აღიწეროს როგორც დოკუმენტაციაში, ასევე თავად კოდის მეშვეობით. მთავარია, 
რომ ეს API იყოს გასაგები და ზუსტი. მას შემდეგ რაც ერთხელ აღწერთ გარე API-ს, 
მასში ცვლილებების შესახებ მის მომხმარებლებს თქვენ ამცნობთ სპეციალური ვერსიის 
ნომრის გაზრდის მეშვეობით. განვიხილოთ ვერსიის ფორმატი X.Y.Z (მაჟორული, მინორული, პატჩი). 
ბაგ-ფიქსები რომელთაც არ აქვთ გავლენა API-ზე, ზრდის პატჩ-ვერსიას, უკუთავსებადი 
დამატებები და ცვლილებები ზრდის მინორულ ვერსიას, ხოლო არა უკუთავსებადი ცვლილებები 
ზრდის მაჟორულ ვერსიას.\nამას ვუწოდებ “სემანტიკურ ვერსიონირებას” (Semantic Versioning). ამ სქემის მიხედვით
ვერსიის ნომრები და მათი ცვლილება აღწერს იმას, თუ როგორ შეიცვალა და რა შეიცვალა 
კოდში ერთი ვერსიიდან მეორემდე.\nსემანტიკური ვერსიონირების სპეციფიკაცია (SemVer)\nსიტყვები “უნდა” (MUST), “არ უნდა” (MUST NOT), “აუცილებელია” (REQUIRED),
“სასურველია” (SHOULD), “არ არის სასურველი” (SHOULD NOT), “რეკომენდირებულია” (RECOMMENDED),
“შეიძლება” (MAY) და “არასავალდებულოა” (OPTIONAL) ამ დოკუმენტში უნდა იქნეს 
ინტერპრეტირებული შესაბამისად RFC 2119 სპეციფიკაციისა.\nპროგრამული უზრუნველყოფა რომელიც იყენებს სემანტიკურ ვერსიონირებას, 
“უნდა” აღწერდეს გარე API-ს. ეს API შეიძლება იყოს აღწერილი თვითონ კოდში, 
ან მკაცრად იყოს განსაზღვრული დოკუმენტაციაში. API როგორც არ უნდა იყოს აღწერილი, 
იგი უნდა იყოს ზუსტი და ამომწურავი.\nპროგრამული უზრუნველყოფა რომელიც იყენებს სემანტიკურ ვერსიონირებას, 
“უნდა” აღწერდეს გარე API-ს. ეს API შეიძლება იყოს აღწერილი თვითონ კოდში, 
ან მკაცრად იყოს განსაზღვრული დოკუმენტაციაში. API როგორც არ უნდა იყოს აღწერილი, 
იგი უნდა იყოს ზუსტი და ამომწურავი.\nვერსიის ჩვეულებრივი ნომერი “უნდა” იყოს ფორმატში X.Y.Z, სადაც X, Y და Z — 
არის არაუარყოფითი მთელი რიცხვები და “არ უნდა” იწყებოდეს ნულით. X არის მაჟორული ვერსია, 
Y — მინორული ვერსია და Z — პატჩ-ვერსია. თითოეული ელემენტი “უნდა” იზრდებოდეს რიცხვობრივად.
მაგალითად: 1.9.0 -> 1.10.0 -> 1.11.0.\nვერსიის ჩვეულებრივი ნომერი “უნდა” იყოს ფორმატში X.Y.Z, სადაც X, Y და Z — 
არის არაუარყოფითი მთელი რიცხვები და “არ უნდა” იწყებოდეს ნულით. X არის მაჟორული ვერსია, 
Y — მინორული ვერსია და Z — პატჩ-ვერსია. თითოეული ელემენტი “უნდა” იზრდებოდეს რიცხვობრივად.
მაგალითად: 1.9.0 -> 1.10.0 -> 1.11.0.\nპაკეტის ახალი ვერსიის რელიზის შემდეგ ამ ვერსიის შემადგენლობა “არ უნდა” შეიცვალოს.
ნებისმიერი ცვლილების გამოშვება “უნდა” მოხდეს ახალი ვერსიით.\nპაკეტის ახალი ვერსიის რელიზის შემდეგ ამ ვერსიის შემადგენლობა “არ უნდა” შეიცვალოს.
ნებისმიერი ცვლილების გამოშვება “უნდა” მოხდეს ახალი ვერსიით.\nმაჟორული ვერსია ნული (0.y.z) განკუთვნილია საწყისი სამუშაოებისთვის.
ყველაფერი შეიძლება შეიცვალოს ნებისმიერ მომენტში. გარე API არ შეიძლება 
განიხილოს როგორც სტაბილური.\nმაჟორული ვერსია ნული (0.y.z) განკუთვნილია საწყისი სამუშაოებისთვის.
ყველაფერი შეიძლება შეიცვალოს ნებისმიერ მომენტში. გარე API არ შეიძლება 
განიხილოს როგორც სტაბილური.\nვერსია 1.0.0 განსაზღვრავს გარე API-ს. ამ რელიზის შემდეგ ვერსიის ნომრები იზრდება
იმის მიხედვით თუ როგორ იცვლება გარე API.\nვერსია 1.0.0 განსაზღვრავს გარე API-ს. ამ რელიზის შემდეგ ვერსიის ნომრები იზრდება
იმის მიხედვით თუ როგორ იცვლება გარე API.\nპატჩ-ვერსია Z (x.y.Z | x > 0) “უნდა” გაიზარდოს მხოლოდ იმ შემთხვევაში, 
თუ შეიცავს უკუთავსებად ბაგ-ფიქსებს. განსაზღვრება ბაგ-ფიქსი ნიშნავს
შიდა ცვლილებებს, რომელიც აღმოფხვრის კოდის არაკორექტულად მუშაობას.\nპატჩ-ვერსია Z (x.y.Z | x > 0) “უნდა” გაიზარდოს მხოლოდ იმ შემთხვევაში, 
თუ შეიცავს უკუთავსებად ბაგ-ფიქსებს. განსაზღვრება ბაგ-ფიქსი ნიშნავს
შიდა ცვლილებებს, რომელიც აღმოფხვრის კოდის არაკორექტულად მუშაობას.\nმინორული ვერსია (x.Y.z | x > 0) “უნდა” გაიზარდოს იმ შემთხვევაში,
თუ გარე API-ში წარმოდგენილია ახალი უკუთავსებადი ფუნქციონალი. “უნდა” გაიზარდოს 
იმ შემთხვევაში, თუ გარე API-ს რომელიმე ფუნქციონალი მოინიშნა როგორც მოძველებული 
(deprecated). “შეიძლება” გაიზარდოს ახალი ფუნქციონალის რეალიზაციისას ან
მნიშვნელოვანი ცვლილებებისას პრივატულ კოდში. ასევე იგი “შეიძლება” შეიცავდეს 
ცვლილებებს რომელიც დამახასიათებელია პატჩებისთვის. პატჩ-ვერსია “უნდა” განულდეს,
როდესაც იზრდება მინორული ვერსია.\nმინორული ვერსია (x.Y.z | x > 0) “უნდა” გაიზარდოს იმ შემთხვევაში,
თუ გარე API-ში წარმოდგენილია ახალი უკუთავსებადი ფუნქციონალი. “უნდა” გაიზარდოს 
იმ შემთხვევაში, თუ გარე API-ს რომელიმე ფუნქციონალი მოინიშნა როგორც მოძველებული 
(deprecated). “შეიძლება” გაიზარდოს ახალი ფუნქციონალის რეალიზაციისას ან
მნიშვნელოვანი ცვლილებებისას პრივატულ კოდში. ასევე იგი “შეიძლება” შეიცავდეს 
ცვლილებებს რომელიც დამახასიათებელია პატჩებისთვის. პატჩ-ვერსია “უნდა” განულდეს,
როდესაც იზრდება მინორული ვერსია.\nმაჟორული ვერსია X (X.y.z | X > 0) “უნდა” გაიზარდოს იმ შემთხვევაში, 
თუ გარე API-ში წარმოდგენილია რაიმე არა უკუთავსებადი ცვლილებები.
იგი “შეიძლება” შეიცავდეს ასევე ცვლილებებს, რომელიც დამახასიათებელია 
მინორული ვერსიებისთვის და პატჩებისთვის. როდესაც იზრდება მაჟორული ვერსია,
მინორული ვერსია და პატჩ-ვერსია “უნდა” განულდეს.\nმაჟორული ვერსია X (X.y.z | X > 0) “უნდა” გაიზარდოს იმ შემთხვევაში, 
თუ გარე API-ში წარმოდგენილია რაიმე არა უკუთავსებადი ცვლილებები.
იგი “შეიძლება” შეიცავდეს ასევე ცვლილებებს, რომელიც დამახასიათებელია 
მინორული ვერსიებისთვის და პატჩებისთვის. როდესაც იზრდება მაჟორული ვერსია,
მინორული ვერსია და პატჩ-ვერსია “უნდა” განულდეს.\nწინა სარელიზო ვერსია “შეიძლება” იყოს აღნიშნული დეფისის და წერტილებით 
გამოყოფილი იდენტიფიკატორების სერიის დამატებით, რომელიც მოსდევს პატჩ-ვერსიას.
იდენტიფიკატორები “უნდა” შეიცავდეს მხოლოდ ASCII ასობგერით-ციფრულ სიმბოლოებს 
და დეფისს [0-9A-Za-z-]. იდენტიფიკატორები “არ უნდა” იყოს ცარიელი. ციფრული
იდენტიფიკატორები “არ უნდა” იწყებოდეს ნულით. წინა სარელიზო ვერსია მიანიშნებს
იმაზე, რომ ეს ვერსია არ არის სტაბილური და შეიძლება არ აკმაყოფილებდეს 
თავსებადობის მოთხოვნებს, რომელიც აღნიშნულია შესაბამისი ნორმალური ვერსიებით. 
მაგალითები: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nწინა სარელიზო ვერსია “შეიძლება” იყოს აღნიშნული დეფისის და წერტილებით 
გამოყოფილი იდენტიფიკატორების სერიის დამატებით, რომელიც მოსდევს პატჩ-ვერსიას.
იდენტიფიკატორები “უნდა” შეიცავდეს მხოლოდ ASCII ასობგერით-ციფრულ სიმბოლოებს 
და დეფისს [0-9A-Za-z-]. იდენტიფიკატორები “არ უნდა” იყოს ცარიელი. ციფრული
იდენტიფიკატორები “არ უნდა” იწყებოდეს ნულით. წინა სარელიზო ვერსია მიანიშნებს
იმაზე, რომ ეს ვერსია არ არის სტაბილური და შეიძლება არ აკმაყოფილებდეს 
თავსებადობის მოთხოვნებს, რომელიც აღნიშნულია შესაბამისი ნორმალური ვერსიებით. 
მაგალითები: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nბილდის მეტა-მონაცემები “შეიძლება” იყოს აღნიშნული პლუს ნიშნის და 
წერტილით გამოყოფილი იდენტიფიკატორების დამატებით პატჩ-ვერსიის ან წინა 
სარელიზო ვერსიის შემდეგ. იდენტიფიკატორები “უნდა” შეიცავდეს მხოლოდ ASCII 
ასობგერით-ციფრულ სიმბოლოებს და დეფისს [0-9A-Za-z-]. იდენტიფიკატორები “არ უნდა” 
იყოს ცარიელი. “რეკომენდირებულია” ბილდის მეტა-მონაცემების დაიგნორება, როდესაც
ძირითადი ვერსიები ერთი და იგივეა და ხდება ვერსიის პრიორიტეტის განსაზღვრა.
მაგალითები: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nბილდის მეტა-მონაცემები “შეიძლება” იყოს აღნიშნული პლუს ნიშნის და 
წერტილით გამოყოფილი იდენტიფიკატორების დამატებით პატჩ-ვერსიის ან წინა 
სარელიზო ვერსიის შემდეგ. იდენტიფიკატორები “უნდა” შეიცავდეს მხოლოდ ASCII 
ასობგერით-ციფრულ სიმბოლოებს და დეფისს [0-9A-Za-z-]. იდენტიფიკატორები “არ უნდა” 
იყოს ცარიელი. “რეკომენდირებულია” ბილდის მეტა-მონაცემების დაიგნორება, როდესაც
ძირითადი ვერსიები ერთი და იგივეა და ხდება ვერსიის პრიორიტეტის განსაზღვრა.
მაგალითები: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nპრიორიტეტი განსაზღვრავს თუ როგორ შეესაბამება ვერსიები ერთმანეთს სორტირების დროს.
ვერსიის პრიორიტეტი “უნდა” გამოითვალოს ვერსიის ნომრების მაჟორულ, მინორულ, 
პატჩ და წინა სარელიზო ვერსიებად დაყოფით (ბილდის მეტა-მონაცემები ამ გათვლაში არ ფიგურირებს).
პრიორიტეტი განისაზღვრება თითოეული იდენტიფიკატორის შედარებისას მარცხნიდან მარჯვნივ:
მაჟორული, მინორული და პატჩ ვერსია დარდება რიცხვობრივად. მაგალითად: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
როდესაც მაჟორული, მინორული და პატჩ-ვერსია ექვივალენტურია, წინა სარელიზო ვერსიას გაჩნია
ნორმალურ ვერსიაზე ნაკლები პრიორიტეტი. მაგალითად: 1.0.0-alpha < 1.0.0.
როდესაც ორ წინა სარელიზო ვერსიას გააჩნია ერთნაირი მაჟორული, მინორული და
პატჩ-ვერსია, მათ შორის პრიორიტეტი “უნდა” განისაზღვროს თითოეული წერტილით გამოყოფილი 
იდენტიფიკატორის მარცხნიდან მარჯვნივ შედარებით მანამდე, სანამ არ იქნება ნაპოვნი 
შემდეგი სახის განსხვავებები: იდენტიფიკატორები რომლებიც შედგება მხოლოდ ციფრებით, 
დარდება რიცხვობრივად; ასო-ბგერითი იდენტიფიკატორები ან დეფისები დარდება ლექსიკურად
ASCII სტანდარტის მიხედვით. რიცხვობრივ იდენტიფიკატორებს ყოველთვის გააჩნია დაბალი 
პრიორიტეტი ასო-ბგერით იდენტიფიკატორებთან მიმართებაში. როდესაც შესადარებელი 
იდენტიფიკატორები ტოლია, სიმბოლოების მეტ რაოდენობას გააჩნია უფრო მაღალი პრიორიტეტი. 
მაგალითი: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nპრიორიტეტი განსაზღვრავს თუ როგორ შეესაბამება ვერსიები ერთმანეთს სორტირების დროს.
ვერსიის პრიორიტეტი “უნდა” გამოითვალოს ვერსიის ნომრების მაჟორულ, მინორულ, 
პატჩ და წინა სარელიზო ვერსიებად დაყოფით (ბილდის მეტა-მონაცემები ამ გათვლაში არ ფიგურირებს).
პრიორიტეტი განისაზღვრება თითოეული იდენტიფიკატორის შედარებისას მარცხნიდან მარჯვნივ:
მაჟორული, მინორული და პატჩ ვერსია დარდება რიცხვობრივად. მაგალითად: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
როდესაც მაჟორული, მინორული და პატჩ-ვერსია ექვივალენტურია, წინა სარელიზო ვერსიას გაჩნია
ნორმალურ ვერსიაზე ნაკლები პრიორიტეტი. მაგალითად: 1.0.0-alpha < 1.0.0.
როდესაც ორ წინა სარელიზო ვერსიას გააჩნია ერთნაირი მაჟორული, მინორული და
პატჩ-ვერსია, მათ შორის პრიორიტეტი “უნდა” განისაზღვროს თითოეული წერტილით გამოყოფილი 
იდენტიფიკატორის მარცხნიდან მარჯვნივ შედარებით მანამდე, სანამ არ იქნება ნაპოვნი 
შემდეგი სახის განსხვავებები: იდენტიფიკატორები რომლებიც შედგება მხოლოდ ციფრებით, 
დარდება რიცხვობრივად; ასო-ბგერითი იდენტიფიკატორები ან დეფისები დარდება ლექსიკურად
ASCII სტანდარტის მიხედვით. რიცხვობრივ იდენტიფიკატორებს ყოველთვის გააჩნია დაბალი 
პრიორიტეტი ასო-ბგერით იდენტიფიკატორებთან მიმართებაში. როდესაც შესადარებელი 
იდენტიფიკატორები ტოლია, სიმბოლოების მეტ რაოდენობას გააჩნია უფრო მაღალი პრიორიტეტი. 
მაგალითი: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nრატომ უნდა გამოვიყენოთ სემანტიკური ვერსიონირება?\nეს არ გახლავთ ახალი ან რევოლუციური იდეა. ალბათ თქვენ უკვე იყენებთ რაიმე მსგავსს.
პრობლემა გახლავთ ის, რომ “მსგავსი” არ ნიშნავს საკმარისად კარგს. ფორმალური სპეციფიკაციის 
გარეშე ვერსიის ნომრები ფაქტიურად გამოუსადეგარია დამოკიდებულებების სამართავად.
ვერსიონირების იდეის ნათლად ფორმულირების და განსაზღვრის შემდეგ გაცილებით იოლი 
ხდება თქვენი პროგრამული უზრუნველყოფის მომხმარებლებს ამცნოთ გეგმების შესახებ.
როდესაც ეს გეგმები ნათელია და მოქნილი (არა ზედმეტად), შესაძლებელი ხდება 
დამოკიდებულებების სპეციფიკაციის შექმნა.\nუბრალო მაგალითზე მოვახდინოთ დემონსტრირება თუ როგორ შეუძლია სემანტიკურ ვერსიონირებას 
“დამოკიდებულებათა ჯოჯოხეთი” აქციოს წარსულად. წარმოვიდგინოთ ბიბლიოთეკა სახელად 
“Firetruck”. მას ჭირდება სემანტიკურად ვერსიონირებული პაკეტი სახელად “Ladder”.
როდესაც შეიქმნა Firetruck, პაკეტი Ladder იყო 3.1.0 ვერსია. იქიდან გამომდინარე, რომ
Firetruck იყენებს ფუნქციონალს, რომელიც პირველად გაჩნდა 3.1.0 ვერსიაში, თქვენ მშვიდად 
შეგიძლიათ გამოაცხადოთ დამოკიდებულება Ladder პაკეტზე ვერსიით მინიმუმ 3.1.0 მაგრამ 
ნაკლები ვიდრე 4.0.0.
შემდეგ, როდესაც Ladder ხელმისაწვდომი გახდება ვერსიებით 3.1.1 და 3.2.0, თქვენ შეგეძლებათ 
მისი ინტეგრირება თქვენ სისტემაში და თან გეცოდინებათ, რომ იგი თავსებადია მიმდინარე 
ფუნქციონალთან.\nროგორც პასუხისმგებლიან დეველოპერს, თქვენ რა თქმა უნდა გინდათ იყოთ დარწმუნებული 
იმაში, რომ ყველა განახლება ფუნქციონირებს ისე, როგორც გამოცხადებულია. რეალურ სამყაროში 
სრული ქაოსია და ამას ვერაფერს ვუზავთ. თქვენ რაც შეგიძლიათ გააკეთოთ, ეს არის სემანტიკურ 
ვერსიონირებას მიცეთ საშუალება დაგეხმაროთ რელიზების გამოშვებაში, მათზე დამოკიდებული 
პაკეტების განახლების გარეშე. ეს დაგიზოგავთ ბევრ დროს და ნერვებს.\nთუ ეს მიმზიდველად ჟღერს, მაშინ ყველაფერი რაც გჭირდებათ, არის სემანტიკური 
ვერსიონირების გამოყენების დაწყება, გამოცხადება რომ იყენებთ მას, და მასში აღწერილი წესების დაცვა.
დაამატეთ ამ საიტის ბმული თქვენ README ფაილში, რათა მომხმარებლებმა იცოდნენ წესები 
და მიიღონ სრული სარგებელი აქედან.\nხშირად დასმული კითხვები (FAQ)\nროგორ უნდა ვიმუშაო რევიზიებთან 0.y.z დეველოპმენტის საწყის ეტაპზე?\nყველაზე მარტივი — დაიწყოთ დეველოპმენტი 0.1.0 ვერსიიდან და შემდეგ გაზარდოთ მინორული 
ვერსია ყოველი შემდეგი რელიზის დროს.\nროგორ უნდა მივხვდე რომ 1.0.0 რელიზის გამოშვების დროა?\nთუ თქვენი პროგრამული უზრუნველყოფა გამოიყენება პროდაქშენზე, დიდი ალბათობით იგი 
უნდა იყოს 1.0.0 ვერსია. თუ თქვენ გაქვთ სტაბილური API, რომელზეც დამოკიდებული არიან 
მომხმარებლები, მაშინ ვერსია უნდა იყოს 1.0.0. თუ თქვენ იწყებთ შიშს უკუთავსებადობაზე, მაშინ დიდი 
ალბათობით თქვენი პროგრამული უზრუნველყოფის ვერსია უკვე არის 1.0.0.\nხელს ხომ არ უშლის სწრაფ დეველოპმენტს (Rapid Development) და მოკლე იტერაციებს (Fast Iteration)?\nმაჟორული ვერსია 0 ზუსტადაც რომ ნიშნავს სწრაფ დეველოპმენტს. თუ თქვენ ცვლით API-ს ყოველ დღე,
უნდა გაჩერდეთ ვერსიაზე 0.y.z ან უნდა იმუშაოთ განსხვავებულ ტოტზე (branch) შემდეგი 
მაჟორული ვერსიის რელიზისთვის.\nგარე API-ში ძალიან უმნიშვნელო არა უკუთავსებადი ცვლილებებიც საჭიროებს ახალი მაჟორული ვერსიის გამოშვებას? ეს ხომ არ გამოიწვევს იმას, რომ ძალიან მალე ვერსიის ნომერი გახდება 42.0.0?\nწინდახედული და პასუხისმგებლიანი კითხვაა. არა უკუთავსებადი ცვლილებები არ შეიძლება რომ 
წარმოდგენილი იყოს როგორც უმნიშვნელო ცვლილებები, მითუმეტეს როდესაც ამ API-ზე დამოკიდებულია 
კიდევ სხვა კოდი. განახლების ღირებულება შეიძლება დიდი აღმოჩნდეს. არა უკუთავსებადი ცვლილებების 
შემთხვევაში, მაჟორული ვერსიის გაზრდის პრაქტიკა ნიშნავს, რომ თქვენ მოგიწევთ ფიქრი ცვლილებების 
შესახებ და ღირებულება/სარგებელის შეფარდების გათვალისწინება.\nსრული API-ს დოკუმენტირება ძალიან დიდი სამუშაოა!\nპროგრამული უზრუნველყოფის სწორი დოკუმენტირება არის თქვენი პასუხისმგებლობა, როგორც 
პროფესიონალი დეველოპერის. მითუმეტეს, როდესაც ეს პროგრამული უზრუნველყოფა გათვლილია ფართო 
აუდიტორიაზე. პროგრამული უზრუნველყოფის კომპლექსურობის მართვა არის მნიშვნელოვანი ნაწილი 
პროექტის მაღალი ეფექტურობის შენარჩუნებისთვის. და ეს ძალიან რთულია, როდესაც მომხმარებელმა 
არ იცის როგორ გამოიყენოს თქვენი პროგრამული უზრუნველყოფა ან რომელი მეთოდის გამოძახება 
შეუძლია უსაფრთხოდ. ხანგრძლივ პერსპექტივაში სემანტიკური ვერსიონირება და გარე API-ს ხარისხიანი 
დოკუმენტირებისადმი დაჟინებული სწრაფვა დაგეხმარებათ შეუფერხებლად მუშაობაში.\nროგორ მოვიქცე თუ შემთხვევით არა უკუთავსებადი ცვლილებები დავარელიზე როგორც მინორული ვერსია?\nროგორც კი აღმოაჩენთ, რომ დაარღვიეთ სემანტიკური ვერსიონირების სპეციფიკაცია, გაასწორეთ 
პრობლემა და გამოუშვით ახალი მინორული ვერსია, რომელიც აღადგენს უკუთავსებადობას. ასეთ 
ვითარებაშიც კი დაუშვებელია უკვე გამოშვებული რელიზის მოდიფიცირება. თუ საჭიროდ ჩათვლით, 
სასურველია ასევე დოკუმენტაციაში უკუთავსებადობის დარღვევის მითითება იმ კონკრეტული ვერსიისთვის 
და მომხმარებლების ინფორმირება იმის თაობაზე რომ ვერსიების მიმდევრობა დარღვეულია.\nრა უნდა გავაკეთო, თუ ვანახლებ საკუთარ დამოკიდებულებებს გარე API-ს ცვლილების გარეშე?\nეს შეიძლება განიხილოს როგორც თავსებადი ცვლილებები, რაკი მას გავლენა არ აქვს გარე API-ზე.
პროგრამულ უზრუნველყოფას რომელიც თავისმხრივ დამოკიდებულია იმავე დამოკიდებულებებზე, 
უნდა გააჩნდეს საკუთარი დამოკიდებულებების სპეციფიკაციები და შესაბამისად ავტორი შეიტყობს შესაძლო 
კონფლიქტების შესახებ. ცვლილებები უნდა აღიწეროს როგორც პატჩ-ვერსია თუ მინორული, ეს
განისაზღვრება იმით, დამოკიდებულებები განახლდა ხარვეზის გასწორების გამო თუ დაემატა ახალი 
ფუნქციონალი. უკანასკნელის შემთხვევაში, როგორც წესი ემატება ახალი კოდი და შესაბამისად 
ახლდება მინორული ვერსია.\nრა უნდა გავაკეთო, თუ შემთხვევით შევცვალე გარე API და არასწორად გავზარდე ვერსიის ნომერი (მაგალითად კოდი შეიცავს არა უკუთავსებად ცვლილებებს პატჩ-ვერსიაში)?\nმოიქეცით თქვენი შეხედულებისამებრ. თუ თქვენი აუდიტორია საკმაოდ დიდია და გახდა საჭირო API-ს 
ძველი ფუნქციონალის დაბრუნება, მაშინ სასურველია ახალი მაჟორული ვერსიის გამოშვება, მიუხედავად 
იმისა, რომ ცვლილებები შეიცავს პატჩ-რელიზის შესაბამის ჩასწორებებს. დაიხსომეთ, სემანტიკურ 
ვერსიონირებაში ვერსიის ნომრები იცვლება სპეციფიკაციის მკაცრი დაცვით. თუ ცვლილებები 
მნიშვნელოვანია თქვენი მომხმარებლებისთვის, გამოიყენეთ ვერსიის ნომერი მათი ინფორმირებისთვის.\nროგორ მოვიქცე მოძველებულ ფუნქციონალთან მიმართებაში?\nფუნქციონალის მოძველებულად გამოცხადება — ეს ჩვეულებრივი ამბავია დეველოპმენტის პროცესში
და ხშირად აუცილებელიც კია პროდუქტის განსავითარებლად. როდესაც გარე API-ს რაიმე ნაწილს 
აცხადებთ მოძველებულად, თქვენ უნდა გააკეთოთ ორი რამ: (1) განაახლოთ თქვენი დოკუმენტაცია, 
რათა მომხმარებლებმა შეიტყონ ამ ცვლილების შესახებ; (2) გამოუშვათ ახალი რელიზი მინორული 
ვერსიის გაზრდით. მანამ, სანამ მთლიანად ამოიღებთ კოდიდან მოძველებულ ფუნქციონალს და 
დაარელიზებთ მაჟორულ ვერსიას, უნდა არსებობდეს მინიმუმ ერთი მინორული რელიზი, რომელიც 
შეიცავს ფუნქციონალის მოძველებულად გამოცხადებას. ეს აუცილებელია იმისათვის, რომ 
მომხმარებლებმა უმტკივნეულოდ შეძლონ ახალ API-ზე გადასვლა.\nსემანტიკურ ვერსიონირებას თუ გააჩნია ვერსიაში შესაძლო სიმბოლოების ლიმიტი?\nარა, თუმცა იხელმძღვანელეთ საღი აზრით. ალბათ დამეთანხმებით 255 სიმბოლო ვერსიის აღწერაში ზედმეტია.
ასევე, ზოგიერთ სისტემას შეიძლება გააჩნდეს საკუთარი შეზღუდვები ხაზის დასაშვები სიგრძის მიმართ.\nსემანტიკური ვერსიონირების სპეციფიკაციის ავტორია
ტომ პრესტონ-ვერნერი, Gravatar-ის დამფუძნებელი
და GitHub-ის თანადამფუძნებელი.\nთუ გსურთ დატოვოთ თქვენი გამოხმაურება, გთხოვთ შექმნათ
დაამატოთ თემა GitHub-ზე.\nდაამატოთ თემა GitHub-ზე\nAvtandil Kikabidze aka LONGMAN (author)\nAvtandil Kikabidze aka LONGMAN\nCreative Commons — CC BY 3.0\nCreative Commons — CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nAsefrek anamkan n yileqman 2.0.0

Agzul

Mi ara tesɛum uṭṭun n ulqem s talɣa MAJOR.MINOR.PATCH, ilaq ad tesnernim:


  alqem MAJOR mi ara tgem abeddel n API yemyagin d wayen yezrin,
  alqem MINOR mi ara ternum timahilin yemɛaban d wayen yezrin,
  alqem PATCH mi ara tgem iseɣtiyen n tuccḍiwin yemɛaban d wayen yezrin.


Llant tecraḍ nniḍen i yileqman send tuffɣa (pre-release) d yidfersefka n usali
(build metadata) i irennun d isiɣzaf i talɣa MAJOR.MINOR.PATCH.

Tazwart

Deg umaḍal n usnefli n yiseɣẓanen, tella yiwet n tegnit ttkukrun-tt medden
ssawalen-as “times n teglin” (seg Teglizit “dependency hell”). Simal yettimɣur
unagraw-nwen, simal trennum iwemmusen i useɣẓan-nwen, simal yettaẓ-d wass deg
ur as-tettafem ara akk ixef-is deg wanu-a yesbelɛen asirem.

Deg unagraw deg i caḍent teglin, asufeɣ n yileqman imaynuten n kra yisger yezmer
ad yuɣal awal sin am yir targit. Ma yella ilugan n tigelt bezzaf ḥersen, tzemrem
ad tesweḥlem ileqman-nwen (ur tettizmirem ara ad tleqmem isger war ma
tessufɣem-d ileqman imaynuten n yal isger uɣur yurez). Ma yella tiglin bezzaf
serrḥent, iban ad d-teɣlim deg uceṛṛeɛ n ulqem (aqbal s tmara n umɛabi d
yileqman i d-itteddun nnig wayen ilaqen). Ma ur ken-yeǧǧi ara usewḥel n
yileqman neɣ aceṛṛeɛ n yileqman ad tseddum asenfar-nwen ar zdat s tefses
d tɣellist, ad d-tafem iman-nwen deg “tmes n teglin”.

Akken ad yefru wugur-a, summreɣ-d kra n yilugan d tmariwin ara awen-d-yinin amek
ara tesbeddem neɣ ad tesnernim uṭṭunen n yileqman. Ilugan-a bnan ― ɣas akken
mačči ala ɣef waya ― ɣef tsemras i nennum, yellan yakan ttwaseqdacent s waṭas
ama deg useɣẓan uslig ama deg win yeldin. Akken ad yeddu unagraw-a, ilaq ad
tesbeddem API tazayezt (agrudem n usihel n yesnasen). Aya yezmer ad yili s
usedles neɣ ad yettwaseyyef deg tengalt yakan. Akken yebɣu yili, API-a ilaq ad
tettwafham yerna ad temqet. Mi dayen tesbeddem-tt, ad tessawalem ɣef
ubeddel-is s usnerni n wuṭṭun-nwen n ulqem. Ma nesɛa alqem s talɣa X.Y.Z
(Major.Minor.Patch), iseɣtiyen ur nettbeddil ara API ad snernin alqem patch,
abeddel d usegmu n API yemɛaban d wayen yezrin ad snernin minor, abeddel n API
yemyagin d wayen yezrin ad yesnerni alqem major.

Semmaɣ-as i unagraw-a “aleqqem anamkan”. S unagraw-a, uṭṭunen n ulqem d wamek s
i ttnernin ttaken anamek i tengalt uɣur cudden d wayen yettbeddilen seg ulqem
ar wayeḍ.

Asefru n uleqqem anamkan (SemVer)

Awalen yufraren “ILAQ” (MUST/SHALL), “UR ILAQ ARA” (MUST NOT/SHALL NOT),
“YETTUḤETTMEM” (REQUIRED), “YEWWI-D” (SHOULD), “UR D-YEWWI ARA” (SHOULD NOT),
“YELHA” (RECOMMENDED), “YEZMER” (MAY), “AXETRAN” (OPTIONAL) i d-yeddan deg
wezmam-a, yewwi-d ad ttwafehmen akken i ten-id-mlan deg
RFC 2119.


  
    Aseɣẓan yesseqdacen aleqqem anamkan ILAQ ad yesbedd API tazayezt. API-a
tezmer ad tili deg tengalt yakan neɣ ad d-tettwasefhem akken iwata deg
yiseftar. Akken tebɣu tili, ILAQ ad tettwafham yerna ad temqet.
  
  
    Uṭṭun amagnu n ulqem ILAQ ad yili s talɣa X.Y.Z anda X, Y d Z d ummiden ur
nelli d uzdiren, UR ILAQ ARA ad gebren ilmawen ur nesɛi anamek. X d alqem
ameqran (major), Y d alqem ameẓyan (minor), ma d Z d alqem n useɣti (patch). Yal
aferdis ILAQ ad yettnerni s wudem umḍin. Amedya: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Ma dayen yeffeɣ-d yisger s kra ulqem, ayen yellan deg ulqem-a UR ILAQ ARA ad
ibeddel. Ma yella-d kra ubeddel, ILAQ ad d-yeffeɣ deg ulqem amaynut.
  
  
    Ilem deg ulqem ameqran (0.y.z) yemmug i usnefli amezwaru. Kullec YEZMER ad
ibeddel seg teswiɛt ar tayeḍ. API tazayezt UR D-YEWWI ARA ad tettwaḥsab terked.
  
  
    D alqem 1.0.0 i yesbeddayen API tazayezt. Abrid ara yaɣ usnerni n wuṭṭun n
ulqem segmi ara d-yeffeɣ, yeqqen ɣer API-nni tazayezt d wamek i tettbeddil.
  
  
    Alqem n useɣti Z (x.y.Z | x > 0) ILAQ ad yennerni ma yella d iseɣtiyen kan
yemɛaban d wayen yezrin i d-ikecmen. Aseɣti n ubug d abeddel agensas i
yettseggimen tikli yeccḍen.
  
  
    Alqem ameẓyan Y (x.Y.z | x > 0) ILAQ ad yennerni ma yella tekcem-d tmahilt
tamaynut yemɛaban d wayen yezrin ɣer API tazayezt. ILAQ daɣen ad yennerni ma
yella kra n tmahilt n API tazayezt tettwacreḍ d tin ara yettwakksen. YEZMER ad
yennerni ma tekcem-d tmahilt tamynut neɣ aseggem meqqren i yerzan tanglat
tusligt kan. YEZMER ad d-yeglu s ubeddel deg uswir n useɣti. Mi ara yennerni
ulqem ameẓyan, alqem n useɣti ILAQ ad yuɣal ar 0.
  
  
    Alqem ameqran X (X.y.z | X > 0) ILAQ ad yennerni ma nessekcem kra ubeddel
yemyagin d wayen yezrin ar API tazayezt. YEZMER daɣen ad d-yeglu s ubeddel deg
uswir ameẓyan neɣ n useɣti. Alqem n useɣti d ulqem ameẓyan ILAQ ad uɣalen ar 0
mi ara yennerni ulqem ameqran.
  
  
    Alqem send tuffɣa YEZMER ad d-iban s tmerna n ujerrid d umazrar n yiferdisen
yebḍan s tenqiḍt deffir kan ulqem n useɣti. Iferdisen-a UR ILAQ ad gebren ala
isekkilen igmumḍinen ASCII d ujerrid [0-9A-Za-z-]. Iferdisen-a UR ILAQ ARA ad
ilin d ilmawen. Iferdisen umḍinen UR ILAQ ARA ad gebren ilmawen ur nesɛi anamek.
Alqem send tuffɣa yettas-d ddaw ulqem amagnu i icudden ɣur-s. Alqem send tuffɣa
d alqem ur nerkid ara yerna yezmer ur yettqadar ara tiwtilin n umɛabi i yeɛnan
alqem amagnu i icudden ɣur-s. Imedyaten: 1.0.0-alpha, 1.0.0-alpha.1,
1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Idfersefka n usali ZEMREN ad d-binen s tmerna n uzmul “+” d umazrar n
yiferdisen yebḍan s tenqiḍt, deffir kan ulqem n useɣti neɣ n ulqem send
tuffɣa. Iferdisen-a UR ILAQ ad gebren ala isekkilen igmumḍinen ASCII d ujerrid
[0-9A-Za-z-]. Iferdisen-a UR ILAQ ARA ad ilin d ilmawen. Idfersefka n usali
ILAQ ad ttwazeglen deg umyizwer n yileqman. Ɣef waya, ma llan sin n yileqman
mgaraden kan deg yidfersefka n usali, atenan kifkif-iten deg umyizwer.
Imedyaten:  1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    Amyizwer ger yileqman yemmal-d amek ara ttwasettfen wa deffir wa. Amyizwer
ILAQ ad yettwaḥsab s beṭṭu n ulqem aferdis aferdis: ameqran, ameẓyan, n useɣti
d send tuffɣa s umyizwer-a (idfersefka ur ttekkin ara deg umyizwer). Amyizwer
yettili-d akken kan ara d-naf amgirred amenzu mi ara nesmenyif ger yiferdisen-a
yiwen yiwen seg uzelmaḍ ar uyeffus akka: alqem ameqran, alqem ameẓyan d ulqem
n useɣti nesmenyif-iten dima s wudem umḍin. Amedya: 1.0.0 < 2.0.0 < 2.1.0 <
2.1.1. Mi ara yilin yiferdisen imeqranen d yimeẓyanen d wid n useɣti d imegduya,
alqem send tuffɣa ad d-yezg ddaw ulqem amagnu. Amedya: 1.0.0-alpha < 1.0.0.
Amyizwer ger sin n yileqman send tuffɣa i iɛedlen aferdis ameqran d umeẓyan
d win n useɣti ILAQ ad yili s usmenyif n yal aferdis iḥazen s tenqiḍt seg
uzelmaḍ ar uyeffus alamma nufa-d amgirred akka: asmenyif n yiferdisen igebren
ala uṭṭunen ad d-yili s wudem umḍin, ma d asmenyif n yiferdisen yesɛan
isekkilen d yijerriden ad yili s umyizwer ASCII deg ugemmay. Alqem send tuffɣa
i umi ggten yiferdisen ad d-yezg ddaw n win yesɛan ciṭṭuḥ, ma ɛedlen akk
iferdisen-nni yezwaren. Amedya: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta
< 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Iwacu ad nseqdec aleqqem anamkan?

Aya mačči d takti tamaynut neɣ d tin ara ibeddlen tudert. Tidet kan, yezmer
txeddmem yakan ayen iqerben ar waya. Ugur d wa: “iqreben” ur icaḍ ara. War
amtawi d kra n ulugen unṣib, ad uɣalen wuṭṭunen n yileqman ur nfiɛen ara i
usefrek n teglin. S usbeddi n yisem d unamek ibanen i tikta i d-nefka da, ad
yishil ad tesfehmem ayen i tgemnem i widak yesseqdacen aseɣẓan-nwen. Mi ara ibin
wayen tgemnem, tzemrem ad d-txedmem aslugen iserḥen (d acu mačči bezzaf)
n tiglin.

Atan umedya ameẓyan ara d-iseknen amek ara yerr uleqqem anamkan “times n teglin”
d tamsalt yefran. Ad d-nini nesɛa tamkarḍit isem-is “AkamyunUsexsi”. Tettuḥwaǧ
isger iteddun s uleqqem anamkan semman-as “Tasellumt”. Ass deg i d-yennulfa
AkamyunUsexsi, Tasellumt tella deg ulqem 3.1.0. Ma yesseqdac AkamyunUsexsi kra
n tmahilt i d-ikecmmen deg 3.1.0, tzemrem ad d-tinim war aɣbel belli alqem
n tagelt Tasellumt ilaq ad yili nnig n 3.1.0 maca ddaw n 4.0.0. Imir, asmi
ara d-ffɣen yileqman 3.1.1 d 3.2.0 n Tasellumt, tzemrem ad ten-ternum ar
unagraw-nwen n usefrek n yisegran yerna teẓram ad mɛaban d useɣẓan-nni i
ten-yuḥwaǧen.

Win yellan d aneflay amasay, iban ad yebɣu ad isefqed kra ubeddel i d-yellan
deg yisger ma itteddu akken iwata. Deg tilawt, timsal mačči d iger iberzen;
ulac ayen i nezmer ad nexdem mgal aya nnig uḥader. Ayen i tzemrem ad txedmem,
d aseqdec n uleqqem anamkan ara awen-d-yefken abrid yelhan i usufeɣ d uleqqem
n yisegran war ma tcelɛem-d deg usufeɣ n teglin, s wakka ad d-trebḥem akud
yerna ad tekksem aɣbel.

Ma yella yeffeɣ fell-awen akk waya, tuḥwaǧem kan ad d-tinim belli tseqdacem-t
yerna ad tḍefrem ilugan akken ad tebdum aseqdec n uleqqem anamkan. Rnut aseɣwen
ar usmel-a deg README-nwen akken ad walin wiyaḍ ilugan yerna ad d-sfaydin
seg-sen.

Isteqsiyen imezga

Amek i ilaq ad sferkeɣ abeddel deg uḥric amenzu n usnefli 0.y.z?

Abrid isehlen akk d beddu n usnefli amenzu seg ulqem 0.1.0, syin akkin ad
tesnernayem alqem ameẓyan i yal asufeɣ amaynut.

Amek ara nẓer melmi ara d-nessufeɣ alqem 1.0.0?

Ma yella useɣẓan-nwen yettwaseqdec deg ufares, ahat yewwi-d ad yili s ulqem
1.0.0. Ma yella tesɛam API irekden uɣur bdan ttwarzen iseqdacen, ilaq ad tilim
s ulqem 1.0.0. Ma tebdam tcelɛem-d deg umɛabi d wayen yezrin, ilaq ad tilim
yakan deg ulqem 1.0.0.

Wissen aya ma ur yettekkes ara afud i usnefli arurad d wallusen wezzilen?

Alqem ameqran ilem (0) yemmug i usnefli arurad. Ma tettbeddilem API yal ass,
ilaq ad teqqimem deg ulqem 0.y.z neɣ deg ufurek iḥazen i usnefli ad tqeddcem
ɣef ulqem ameqran i d-iteddun.

Ma kra n ubeddel meẓẓiyen yemyagin d wayen yezrin deg API tazayezt yuḥwaǧ anserni n ulqem, ur nettaweḍ ara awal sin ar ulqem 42.0.0?

Aya d tamsalt n usnefli s tmasit d uwali ar zdat. Abeddel ara yerẓen amɛabi ur
ilaq ara ad d-yekcem kan akka ar useɣẓan uɣur teqqen aṭas n tengalt. Asali ar
ulqem amaynut yezmer ad d-yekker ɣlay. Ma tesnernam alqem ameqran akken ad
d-tessufɣem abeddel ur nemɛaba ara, aql-iken tettmeyyizem ɣef wayen ara d-yeglu
ubeddel-nwen, yerna tettakem azal i wassaɣ yellan ger tseglut d wayen i d-tesqam.

Asefter n API tazayezt akken ma tella d axeddim meqqren mliḥ!

Yewwi-d fell-awen s yisem-nwen d ineflayen imsaduren ad tesdelsem aseɣẓan-nwen
yemmugen akken ad tesqedcen wiyaḍ. Asefrek n umcubbak n useɣẓan d ayen yesɛan
azal meqqren akken ad yeqqim usenfar ifaz. Yuɛer ad naweḍ ar waya ma yella yiwen
ur yeẓri amek ara iseqdec aseɣẓan, neɣ anti tarrayin i umi yezmer ad isiwel.
Syin akkin, aleqqem anamkan d usbeddi igerrzen n API tazayezt ad ǧǧen yal yiwen
ad yeddu ɣer zdat war uguren.

Dacu i ilaq ad nexedem ma yella nessufeɣ-d s tuccḍa abeddel ur nemɛaba ara d wayen yezrin deg ulqem ameẓyan?

Akken kan ara d-takim belli terẓam asefru n uleqqem anamkan, ilaq ad tesseɣtim
ugur yerna ad d-tessufɣem alqem ameẓyan amaynut ara d-yerren amɛabi d wayen
yezrin. Ula deg tegnit am ta, ur ilaq ara ad tbeddlem ileqman i d-yeffɣen. Ma
twalam ilaq, sdelset alqem-nni yeccḍen, tesɛelmem iseqdacen-nwen s wugur-a i
d-yellan.

Dacu i ilaq ad nexdem mi ara nelqem tiglin-nneɣ war ma nbeddel API tazayezt?

Aya yezmer ad yettusemma d abddel yemɛaban imi ur yettnal ara API tazayezt.
Iseɣẓanen yurzen ɣer teglin yecban tid n uwemmus-nwen ahat ad sɛun asefru-nsen
n teglin, ihi amsekar-nsent ad ifiq ma yella kra n wugur. Akken ad teẓrem ma
ad yili ubeddel deg uswir n useɣti neɣ deg uswir ameẓyan, ilaq ad twalim ma
tessulim tiglin-nwen akken ad tesseɣtim abug neɣ akken ad d-teskecmem tamahilt
tamynut. Tezga tettili-d tmerna n tengalt deg tegnit-nni tis snat, d ayen i
yuḥwaǧen bla ccekk asnerni n ulqem ameẓyan.

Amek ara nexdem ma nbeddel s tuccḍa API tazayezt s wudem ur nemɛaba ara d ubeddel n wuṭṭun n ulqem (md. tessekcem-d tengalt abeddel meqqren yerẓan amɛabi deg ulqem n useɣti)?

D kunwi i yeẓran. Ma llan aṭas i ken-yeṭṭafaren, ara tḥazem mliḥ s tuɣalin ar
deffir ma terram API tazayezt akken tella, ahat yif-it ma tessufɣem-d alqem
ameqran, ɣas akken abeddel-nwen icaḍ-as uleqqem n useɣti. Ur tettut ara belli
aleqqem anamkan yemmug akken ad yefk anamek i usnerni n wuṭṭunen n yileqman.
Ma yella ubeddel i d-yellan yesɛa azal meqqren i yiseqdacen-nwen, sbinet-asen
-t-id s wuṭṭun n ulqem.

Amek ara nsefrek acraḍ n tukksa n tmahilin?

Acraḍ n tmahilin send ad ttwakksent d tigawt yuzzlen deg usnefli n useɣẓan yerna
d ayen i as-ilaqen tikwal akken ad yaẓ ɣer zdat. Mi ara tcerḍeḍ aḥric deg
API-nwen tazayezt ad yettwakkes, ɣur-wen snat n tɣawsiwin ad tent-txedmem: (1)
ad tleqmem iseftar-nwen akken ad ẓren iseqdacen-nwen, (2) ad d-tessufɣem alqem
ameẓyan amaynut deg ara d-tseddum acraḍ n tukksa. Send ad tekksem akk kra
tamahilt deg ulqem ameqran amaynut, ilaq ad d-tessufɣem ma drus yiwen ulqem
ameẓyan i d-immalen tukksa-a akken iseqdacen ad ɛeddin dac dac ɣer API tamaynut.

Yesɛa uleqqem anamkan kra n tilist ɣef teɣzi n wuṭṭun n ulqem?

Ala, dacu meyyez akken i iwata. Ahat uṭṭun n ulqem n 255 n yisekkilen (d amedya
kan) bezzaf ɣezzif. Yerna, kra n yinagrawen ttseyyifen tilisa ɣef teɣzi n uzrar
n wuṭṭun n ulqem.

“v1.2.3” d alqem anamkan?

Ala, “v1.2.3” mačči d alqem anamkan. Maca, timerna n “v” (seg Teglizit) deg
tazwara n ulqem anamkan akken ad d-ibin belli d uṭṭun n ulqem, d ayen yuzzlen
s waṭas. Nettmagar-d aṭas asemẓi n “version” s “v” deg usefrek n yileqman.
Amedya: git tag v1.2.3 -m "Asufeɣ n ulqem 1.2.3", anda “v1.2.3” d isem
n tecreḍt, ma yella d alqem anamkan d “1.2.3”.

Tella kra n tenfalit talugant (RegEx) i usentem n uzrar n ulqem anamkan?

Llant snat. Yiwet s yigrawen yettusemman tetteddu deg yinagrawen i asen-izemren
(PCRE [Perl Compatible Regular Expressions, am Perl, PHP d R], Python akked Go).

Wali: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Tella tayeḍ s yigrawen n tuṭṭfiwin s wuṭṭunen (agraw1 = major, agraw2 = minor,
agraw3 = patch, agraw4 = prerelease ma d agraw5 = buildmetadata) temɛaba d ECMA
Script (JavaScript), PCRE (Perl Compatible Regular Expressions, am Perl, PHP
d R), Python akked Go.

Wali: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Ayen yerzan

Asefru n uleqqem anamkan yura-t Tom Preston-Werner,
win i d-yesnulfan Gravatar yerna yettekki deg usufeɣ n GitHub.

Ma tebɣam ad d-teǧǧem iwenniten, ldit atiki deg GitHub
ma ulac aɣilif.

Turagt

Creative Commons ― CC BY 3.0\nAsefrek anamkan n yileqman 2.0.0\nMi ara tesɛum uṭṭun n ulqem s talɣa MAJOR.MINOR.PATCH, ilaq ad tesnernim:\nalqem MAJOR mi ara tgem abeddel n API yemyagin d wayen yezrin,\nalqem MINOR mi ara ternum timahilin yemɛaban d wayen yezrin,\nalqem PATCH mi ara tgem iseɣtiyen n tuccḍiwin yemɛaban d wayen yezrin.\nLlant tecraḍ nniḍen i yileqman send tuffɣa (pre-release) d yidfersefka n usali
(build metadata) i irennun d isiɣzaf i talɣa MAJOR.MINOR.PATCH.\nDeg umaḍal n usnefli n yiseɣẓanen, tella yiwet n tegnit ttkukrun-tt medden
ssawalen-as “times n teglin” (seg Teglizit “dependency hell”). Simal yettimɣur
unagraw-nwen, simal trennum iwemmusen i useɣẓan-nwen, simal yettaẓ-d wass deg
ur as-tettafem ara akk ixef-is deg wanu-a yesbelɛen asirem.\nDeg unagraw deg i caḍent teglin, asufeɣ n yileqman imaynuten n kra yisger yezmer
ad yuɣal awal sin am yir targit. Ma yella ilugan n tigelt bezzaf ḥersen, tzemrem
ad tesweḥlem ileqman-nwen (ur tettizmirem ara ad tleqmem isger war ma
tessufɣem-d ileqman imaynuten n yal isger uɣur yurez). Ma yella tiglin bezzaf
serrḥent, iban ad d-teɣlim deg uceṛṛeɛ n ulqem (aqbal s tmara n umɛabi d
yileqman i d-itteddun nnig wayen ilaqen). Ma ur ken-yeǧǧi ara usewḥel n
yileqman neɣ aceṛṛeɛ n yileqman ad tseddum asenfar-nwen ar zdat s tefses
d tɣellist, ad d-tafem iman-nwen deg “tmes n teglin”.\nAkken ad yefru wugur-a, summreɣ-d kra n yilugan d tmariwin ara awen-d-yinin amek
ara tesbeddem neɣ ad tesnernim uṭṭunen n yileqman. Ilugan-a bnan ― ɣas akken
mačči ala ɣef waya ― ɣef tsemras i nennum, yellan yakan ttwaseqdacent s waṭas
ama deg useɣẓan uslig ama deg win yeldin. Akken ad yeddu unagraw-a, ilaq ad
tesbeddem API tazayezt (agrudem n usihel n yesnasen). Aya yezmer ad yili s
usedles neɣ ad yettwaseyyef deg tengalt yakan. Akken yebɣu yili, API-a ilaq ad
tettwafham yerna ad temqet. Mi dayen tesbeddem-tt, ad tessawalem ɣef
ubeddel-is s usnerni n wuṭṭun-nwen n ulqem. Ma nesɛa alqem s talɣa X.Y.Z
(Major.Minor.Patch), iseɣtiyen ur nettbeddil ara API ad snernin alqem patch,
abeddel d usegmu n API yemɛaban d wayen yezrin ad snernin minor, abeddel n API
yemyagin d wayen yezrin ad yesnerni alqem major.\nSemmaɣ-as i unagraw-a “aleqqem anamkan”. S unagraw-a, uṭṭunen n ulqem d wamek s
i ttnernin ttaken anamek i tengalt uɣur cudden d wayen yettbeddilen seg ulqem
ar wayeḍ.\nAsefru n uleqqem anamkan (SemVer)\nAwalen yufraren “ILAQ” (MUST/SHALL), “UR ILAQ ARA” (MUST NOT/SHALL NOT),
“YETTUḤETTMEM” (REQUIRED), “YEWWI-D” (SHOULD), “UR D-YEWWI ARA” (SHOULD NOT),
“YELHA” (RECOMMENDED), “YEZMER” (MAY), “AXETRAN” (OPTIONAL) i d-yeddan deg
wezmam-a, yewwi-d ad ttwafehmen akken i ten-id-mlan deg
RFC 2119.\nAseɣẓan yesseqdacen aleqqem anamkan ILAQ ad yesbedd API tazayezt. API-a
tezmer ad tili deg tengalt yakan neɣ ad d-tettwasefhem akken iwata deg
yiseftar. Akken tebɣu tili, ILAQ ad tettwafham yerna ad temqet.\nAseɣẓan yesseqdacen aleqqem anamkan ILAQ ad yesbedd API tazayezt. API-a
tezmer ad tili deg tengalt yakan neɣ ad d-tettwasefhem akken iwata deg
yiseftar. Akken tebɣu tili, ILAQ ad tettwafham yerna ad temqet.\nUṭṭun amagnu n ulqem ILAQ ad yili s talɣa X.Y.Z anda X, Y d Z d ummiden ur
nelli d uzdiren, UR ILAQ ARA ad gebren ilmawen ur nesɛi anamek. X d alqem
ameqran (major), Y d alqem ameẓyan (minor), ma d Z d alqem n useɣti (patch). Yal
aferdis ILAQ ad yettnerni s wudem umḍin. Amedya: 1.9.0 -> 1.10.0 -> 1.11.0.\nUṭṭun amagnu n ulqem ILAQ ad yili s talɣa X.Y.Z anda X, Y d Z d ummiden ur
nelli d uzdiren, UR ILAQ ARA ad gebren ilmawen ur nesɛi anamek. X d alqem
ameqran (major), Y d alqem ameẓyan (minor), ma d Z d alqem n useɣti (patch). Yal
aferdis ILAQ ad yettnerni s wudem umḍin. Amedya: 1.9.0 -> 1.10.0 -> 1.11.0.\nMa dayen yeffeɣ-d yisger s kra ulqem, ayen yellan deg ulqem-a UR ILAQ ARA ad
ibeddel. Ma yella-d kra ubeddel, ILAQ ad d-yeffeɣ deg ulqem amaynut.\nMa dayen yeffeɣ-d yisger s kra ulqem, ayen yellan deg ulqem-a UR ILAQ ARA ad
ibeddel. Ma yella-d kra ubeddel, ILAQ ad d-yeffeɣ deg ulqem amaynut.\nIlem deg ulqem ameqran (0.y.z) yemmug i usnefli amezwaru. Kullec YEZMER ad
ibeddel seg teswiɛt ar tayeḍ. API tazayezt UR D-YEWWI ARA ad tettwaḥsab terked.\nIlem deg ulqem ameqran (0.y.z) yemmug i usnefli amezwaru. Kullec YEZMER ad
ibeddel seg teswiɛt ar tayeḍ. API tazayezt UR D-YEWWI ARA ad tettwaḥsab terked.\nD alqem 1.0.0 i yesbeddayen API tazayezt. Abrid ara yaɣ usnerni n wuṭṭun n
ulqem segmi ara d-yeffeɣ, yeqqen ɣer API-nni tazayezt d wamek i tettbeddil.\nD alqem 1.0.0 i yesbeddayen API tazayezt. Abrid ara yaɣ usnerni n wuṭṭun n
ulqem segmi ara d-yeffeɣ, yeqqen ɣer API-nni tazayezt d wamek i tettbeddil.\nAlqem n useɣti Z (x.y.Z | x > 0) ILAQ ad yennerni ma yella d iseɣtiyen kan
yemɛaban d wayen yezrin i d-ikecmen. Aseɣti n ubug d abeddel agensas i
yettseggimen tikli yeccḍen.\nAlqem n useɣti Z (x.y.Z | x > 0) ILAQ ad yennerni ma yella d iseɣtiyen kan
yemɛaban d wayen yezrin i d-ikecmen. Aseɣti n ubug d abeddel agensas i
yettseggimen tikli yeccḍen.\nAlqem ameẓyan Y (x.Y.z | x > 0) ILAQ ad yennerni ma yella tekcem-d tmahilt
tamaynut yemɛaban d wayen yezrin ɣer API tazayezt. ILAQ daɣen ad yennerni ma
yella kra n tmahilt n API tazayezt tettwacreḍ d tin ara yettwakksen. YEZMER ad
yennerni ma tekcem-d tmahilt tamynut neɣ aseggem meqqren i yerzan tanglat
tusligt kan. YEZMER ad d-yeglu s ubeddel deg uswir n useɣti. Mi ara yennerni
ulqem ameẓyan, alqem n useɣti ILAQ ad yuɣal ar 0.\nAlqem ameẓyan Y (x.Y.z | x > 0) ILAQ ad yennerni ma yella tekcem-d tmahilt
tamaynut yemɛaban d wayen yezrin ɣer API tazayezt. ILAQ daɣen ad yennerni ma
yella kra n tmahilt n API tazayezt tettwacreḍ d tin ara yettwakksen. YEZMER ad
yennerni ma tekcem-d tmahilt tamynut neɣ aseggem meqqren i yerzan tanglat
tusligt kan. YEZMER ad d-yeglu s ubeddel deg uswir n useɣti. Mi ara yennerni
ulqem ameẓyan, alqem n useɣti ILAQ ad yuɣal ar 0.\nAlqem ameqran X (X.y.z | X > 0) ILAQ ad yennerni ma nessekcem kra ubeddel
yemyagin d wayen yezrin ar API tazayezt. YEZMER daɣen ad d-yeglu s ubeddel deg
uswir ameẓyan neɣ n useɣti. Alqem n useɣti d ulqem ameẓyan ILAQ ad uɣalen ar 0
mi ara yennerni ulqem ameqran.\nAlqem ameqran X (X.y.z | X > 0) ILAQ ad yennerni ma nessekcem kra ubeddel
yemyagin d wayen yezrin ar API tazayezt. YEZMER daɣen ad d-yeglu s ubeddel deg
uswir ameẓyan neɣ n useɣti. Alqem n useɣti d ulqem ameẓyan ILAQ ad uɣalen ar 0
mi ara yennerni ulqem ameqran.\nAlqem send tuffɣa YEZMER ad d-iban s tmerna n ujerrid d umazrar n yiferdisen
yebḍan s tenqiḍt deffir kan ulqem n useɣti. Iferdisen-a UR ILAQ ad gebren ala
isekkilen igmumḍinen ASCII d ujerrid [0-9A-Za-z-]. Iferdisen-a UR ILAQ ARA ad
ilin d ilmawen. Iferdisen umḍinen UR ILAQ ARA ad gebren ilmawen ur nesɛi anamek.
Alqem send tuffɣa yettas-d ddaw ulqem amagnu i icudden ɣur-s. Alqem send tuffɣa
d alqem ur nerkid ara yerna yezmer ur yettqadar ara tiwtilin n umɛabi i yeɛnan
alqem amagnu i icudden ɣur-s. Imedyaten: 1.0.0-alpha, 1.0.0-alpha.1,
1.0.0-0.3.7, 1.0.0-x.7.z.92.\nAlqem send tuffɣa YEZMER ad d-iban s tmerna n ujerrid d umazrar n yiferdisen
yebḍan s tenqiḍt deffir kan ulqem n useɣti. Iferdisen-a UR ILAQ ad gebren ala
isekkilen igmumḍinen ASCII d ujerrid [0-9A-Za-z-]. Iferdisen-a UR ILAQ ARA ad
ilin d ilmawen. Iferdisen umḍinen UR ILAQ ARA ad gebren ilmawen ur nesɛi anamek.
Alqem send tuffɣa yettas-d ddaw ulqem amagnu i icudden ɣur-s. Alqem send tuffɣa
d alqem ur nerkid ara yerna yezmer ur yettqadar ara tiwtilin n umɛabi i yeɛnan
alqem amagnu i icudden ɣur-s. Imedyaten: 1.0.0-alpha, 1.0.0-alpha.1,
1.0.0-0.3.7, 1.0.0-x.7.z.92.\nIdfersefka n usali ZEMREN ad d-binen s tmerna n uzmul “+” d umazrar n
yiferdisen yebḍan s tenqiḍt, deffir kan ulqem n useɣti neɣ n ulqem send
tuffɣa. Iferdisen-a UR ILAQ ad gebren ala isekkilen igmumḍinen ASCII d ujerrid
[0-9A-Za-z-]. Iferdisen-a UR ILAQ ARA ad ilin d ilmawen. Idfersefka n usali
ILAQ ad ttwazeglen deg umyizwer n yileqman. Ɣef waya, ma llan sin n yileqman
mgaraden kan deg yidfersefka n usali, atenan kifkif-iten deg umyizwer.
Imedyaten:  1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nIdfersefka n usali ZEMREN ad d-binen s tmerna n uzmul “+” d umazrar n
yiferdisen yebḍan s tenqiḍt, deffir kan ulqem n useɣti neɣ n ulqem send
tuffɣa. Iferdisen-a UR ILAQ ad gebren ala isekkilen igmumḍinen ASCII d ujerrid
[0-9A-Za-z-]. Iferdisen-a UR ILAQ ARA ad ilin d ilmawen. Idfersefka n usali
ILAQ ad ttwazeglen deg umyizwer n yileqman. Ɣef waya, ma llan sin n yileqman
mgaraden kan deg yidfersefka n usali, atenan kifkif-iten deg umyizwer.
Imedyaten:  1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nAmyizwer ger yileqman yemmal-d amek ara ttwasettfen wa deffir wa. Amyizwer
ILAQ ad yettwaḥsab s beṭṭu n ulqem aferdis aferdis: ameqran, ameẓyan, n useɣti
d send tuffɣa s umyizwer-a (idfersefka ur ttekkin ara deg umyizwer). Amyizwer
yettili-d akken kan ara d-naf amgirred amenzu mi ara nesmenyif ger yiferdisen-a
yiwen yiwen seg uzelmaḍ ar uyeffus akka: alqem ameqran, alqem ameẓyan d ulqem
n useɣti nesmenyif-iten dima s wudem umḍin. Amedya: 1.0.0 < 2.0.0 < 2.1.0 <
2.1.1. Mi ara yilin yiferdisen imeqranen d yimeẓyanen d wid n useɣti d imegduya,
alqem send tuffɣa ad d-yezg ddaw ulqem amagnu. Amedya: 1.0.0-alpha < 1.0.0.
Amyizwer ger sin n yileqman send tuffɣa i iɛedlen aferdis ameqran d umeẓyan
d win n useɣti ILAQ ad yili s usmenyif n yal aferdis iḥazen s tenqiḍt seg
uzelmaḍ ar uyeffus alamma nufa-d amgirred akka: asmenyif n yiferdisen igebren
ala uṭṭunen ad d-yili s wudem umḍin, ma d asmenyif n yiferdisen yesɛan
isekkilen d yijerriden ad yili s umyizwer ASCII deg ugemmay. Alqem send tuffɣa
i umi ggten yiferdisen ad d-yezg ddaw n win yesɛan ciṭṭuḥ, ma ɛedlen akk
iferdisen-nni yezwaren. Amedya: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta
< 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nAmyizwer ger yileqman yemmal-d amek ara ttwasettfen wa deffir wa. Amyizwer
ILAQ ad yettwaḥsab s beṭṭu n ulqem aferdis aferdis: ameqran, ameẓyan, n useɣti
d send tuffɣa s umyizwer-a (idfersefka ur ttekkin ara deg umyizwer). Amyizwer
yettili-d akken kan ara d-naf amgirred amenzu mi ara nesmenyif ger yiferdisen-a
yiwen yiwen seg uzelmaḍ ar uyeffus akka: alqem ameqran, alqem ameẓyan d ulqem
n useɣti nesmenyif-iten dima s wudem umḍin. Amedya: 1.0.0 < 2.0.0 < 2.1.0 <
2.1.1. Mi ara yilin yiferdisen imeqranen d yimeẓyanen d wid n useɣti d imegduya,
alqem send tuffɣa ad d-yezg ddaw ulqem amagnu. Amedya: 1.0.0-alpha < 1.0.0.
Amyizwer ger sin n yileqman send tuffɣa i iɛedlen aferdis ameqran d umeẓyan
d win n useɣti ILAQ ad yili s usmenyif n yal aferdis iḥazen s tenqiḍt seg
uzelmaḍ ar uyeffus alamma nufa-d amgirred akka: asmenyif n yiferdisen igebren
ala uṭṭunen ad d-yili s wudem umḍin, ma d asmenyif n yiferdisen yesɛan
isekkilen d yijerriden ad yili s umyizwer ASCII deg ugemmay. Alqem send tuffɣa
i umi ggten yiferdisen ad d-yezg ddaw n win yesɛan ciṭṭuḥ, ma ɛedlen akk
iferdisen-nni yezwaren. Amedya: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta
< 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nIwacu ad nseqdec aleqqem anamkan?\nAya mačči d takti tamaynut neɣ d tin ara ibeddlen tudert. Tidet kan, yezmer
txeddmem yakan ayen iqerben ar waya. Ugur d wa: “iqreben” ur icaḍ ara. War
amtawi d kra n ulugen unṣib, ad uɣalen wuṭṭunen n yileqman ur nfiɛen ara i
usefrek n teglin. S usbeddi n yisem d unamek ibanen i tikta i d-nefka da, ad
yishil ad tesfehmem ayen i tgemnem i widak yesseqdacen aseɣẓan-nwen. Mi ara ibin
wayen tgemnem, tzemrem ad d-txedmem aslugen iserḥen (d acu mačči bezzaf)
n tiglin.\nAtan umedya ameẓyan ara d-iseknen amek ara yerr uleqqem anamkan “times n teglin”
d tamsalt yefran. Ad d-nini nesɛa tamkarḍit isem-is “AkamyunUsexsi”. Tettuḥwaǧ
isger iteddun s uleqqem anamkan semman-as “Tasellumt”. Ass deg i d-yennulfa
AkamyunUsexsi, Tasellumt tella deg ulqem 3.1.0. Ma yesseqdac AkamyunUsexsi kra
n tmahilt i d-ikecmmen deg 3.1.0, tzemrem ad d-tinim war aɣbel belli alqem
n tagelt Tasellumt ilaq ad yili nnig n 3.1.0 maca ddaw n 4.0.0. Imir, asmi
ara d-ffɣen yileqman 3.1.1 d 3.2.0 n Tasellumt, tzemrem ad ten-ternum ar
unagraw-nwen n usefrek n yisegran yerna teẓram ad mɛaban d useɣẓan-nni i
ten-yuḥwaǧen.\nWin yellan d aneflay amasay, iban ad yebɣu ad isefqed kra ubeddel i d-yellan
deg yisger ma itteddu akken iwata. Deg tilawt, timsal mačči d iger iberzen;
ulac ayen i nezmer ad nexdem mgal aya nnig uḥader. Ayen i tzemrem ad txedmem,
d aseqdec n uleqqem anamkan ara awen-d-yefken abrid yelhan i usufeɣ d uleqqem
n yisegran war ma tcelɛem-d deg usufeɣ n teglin, s wakka ad d-trebḥem akud
yerna ad tekksem aɣbel.\nMa yella yeffeɣ fell-awen akk waya, tuḥwaǧem kan ad d-tinim belli tseqdacem-t
yerna ad tḍefrem ilugan akken ad tebdum aseqdec n uleqqem anamkan. Rnut aseɣwen
ar usmel-a deg README-nwen akken ad walin wiyaḍ ilugan yerna ad d-sfaydin
seg-sen.\nAmek i ilaq ad sferkeɣ abeddel deg uḥric amenzu n usnefli 0.y.z?\nAbrid isehlen akk d beddu n usnefli amenzu seg ulqem 0.1.0, syin akkin ad
tesnernayem alqem ameẓyan i yal asufeɣ amaynut.\nAmek ara nẓer melmi ara d-nessufeɣ alqem 1.0.0?\nMa yella useɣẓan-nwen yettwaseqdec deg ufares, ahat yewwi-d ad yili s ulqem
1.0.0. Ma yella tesɛam API irekden uɣur bdan ttwarzen iseqdacen, ilaq ad tilim
s ulqem 1.0.0. Ma tebdam tcelɛem-d deg umɛabi d wayen yezrin, ilaq ad tilim
yakan deg ulqem 1.0.0.\nWissen aya ma ur yettekkes ara afud i usnefli arurad d wallusen wezzilen?\nAlqem ameqran ilem (0) yemmug i usnefli arurad. Ma tettbeddilem API yal ass,
ilaq ad teqqimem deg ulqem 0.y.z neɣ deg ufurek iḥazen i usnefli ad tqeddcem
ɣef ulqem ameqran i d-iteddun.\nMa kra n ubeddel meẓẓiyen yemyagin d wayen yezrin deg API tazayezt yuḥwaǧ anserni n ulqem, ur nettaweḍ ara awal sin ar ulqem 42.0.0?\nAya d tamsalt n usnefli s tmasit d uwali ar zdat. Abeddel ara yerẓen amɛabi ur
ilaq ara ad d-yekcem kan akka ar useɣẓan uɣur teqqen aṭas n tengalt. Asali ar
ulqem amaynut yezmer ad d-yekker ɣlay. Ma tesnernam alqem ameqran akken ad
d-tessufɣem abeddel ur nemɛaba ara, aql-iken tettmeyyizem ɣef wayen ara d-yeglu
ubeddel-nwen, yerna tettakem azal i wassaɣ yellan ger tseglut d wayen i d-tesqam.\nAsefter n API tazayezt akken ma tella d axeddim meqqren mliḥ!\nYewwi-d fell-awen s yisem-nwen d ineflayen imsaduren ad tesdelsem aseɣẓan-nwen
yemmugen akken ad tesqedcen wiyaḍ. Asefrek n umcubbak n useɣẓan d ayen yesɛan
azal meqqren akken ad yeqqim usenfar ifaz. Yuɛer ad naweḍ ar waya ma yella yiwen
ur yeẓri amek ara iseqdec aseɣẓan, neɣ anti tarrayin i umi yezmer ad isiwel.
Syin akkin, aleqqem anamkan d usbeddi igerrzen n API tazayezt ad ǧǧen yal yiwen
ad yeddu ɣer zdat war uguren.\nDacu i ilaq ad nexedem ma yella nessufeɣ-d s tuccḍa abeddel ur nemɛaba ara d wayen yezrin deg ulqem ameẓyan?\nAkken kan ara d-takim belli terẓam asefru n uleqqem anamkan, ilaq ad tesseɣtim
ugur yerna ad d-tessufɣem alqem ameẓyan amaynut ara d-yerren amɛabi d wayen
yezrin. Ula deg tegnit am ta, ur ilaq ara ad tbeddlem ileqman i d-yeffɣen. Ma
twalam ilaq, sdelset alqem-nni yeccḍen, tesɛelmem iseqdacen-nwen s wugur-a i
d-yellan.\nDacu i ilaq ad nexdem mi ara nelqem tiglin-nneɣ war ma nbeddel API tazayezt?\nAya yezmer ad yettusemma d abddel yemɛaban imi ur yettnal ara API tazayezt.
Iseɣẓanen yurzen ɣer teglin yecban tid n uwemmus-nwen ahat ad sɛun asefru-nsen
n teglin, ihi amsekar-nsent ad ifiq ma yella kra n wugur. Akken ad teẓrem ma
ad yili ubeddel deg uswir n useɣti neɣ deg uswir ameẓyan, ilaq ad twalim ma
tessulim tiglin-nwen akken ad tesseɣtim abug neɣ akken ad d-teskecmem tamahilt
tamynut. Tezga tettili-d tmerna n tengalt deg tegnit-nni tis snat, d ayen i
yuḥwaǧen bla ccekk asnerni n ulqem ameẓyan.\nAmek ara nexdem ma nbeddel s tuccḍa API tazayezt s wudem ur nemɛaba ara d ubeddel n wuṭṭun n ulqem (md. tessekcem-d tengalt abeddel meqqren yerẓan amɛabi deg ulqem n useɣti)?\nD kunwi i yeẓran. Ma llan aṭas i ken-yeṭṭafaren, ara tḥazem mliḥ s tuɣalin ar
deffir ma terram API tazayezt akken tella, ahat yif-it ma tessufɣem-d alqem
ameqran, ɣas akken abeddel-nwen icaḍ-as uleqqem n useɣti. Ur tettut ara belli
aleqqem anamkan yemmug akken ad yefk anamek i usnerni n wuṭṭunen n yileqman.
Ma yella ubeddel i d-yellan yesɛa azal meqqren i yiseqdacen-nwen, sbinet-asen
-t-id s wuṭṭun n ulqem.\nAmek ara nsefrek acraḍ n tukksa n tmahilin?\nAcraḍ n tmahilin send ad ttwakksent d tigawt yuzzlen deg usnefli n useɣẓan yerna
d ayen i as-ilaqen tikwal akken ad yaẓ ɣer zdat. Mi ara tcerḍeḍ aḥric deg
API-nwen tazayezt ad yettwakkes, ɣur-wen snat n tɣawsiwin ad tent-txedmem: (1)
ad tleqmem iseftar-nwen akken ad ẓren iseqdacen-nwen, (2) ad d-tessufɣem alqem
ameẓyan amaynut deg ara d-tseddum acraḍ n tukksa. Send ad tekksem akk kra
tamahilt deg ulqem ameqran amaynut, ilaq ad d-tessufɣem ma drus yiwen ulqem
ameẓyan i d-immalen tukksa-a akken iseqdacen ad ɛeddin dac dac ɣer API tamaynut.\nYesɛa uleqqem anamkan kra n tilist ɣef teɣzi n wuṭṭun n ulqem?\nAla, dacu meyyez akken i iwata. Ahat uṭṭun n ulqem n 255 n yisekkilen (d amedya
kan) bezzaf ɣezzif. Yerna, kra n yinagrawen ttseyyifen tilisa ɣef teɣzi n uzrar
n wuṭṭun n ulqem.\n“v1.2.3” d alqem anamkan?\nAla, “v1.2.3” mačči d alqem anamkan. Maca, timerna n “v” (seg Teglizit) deg
tazwara n ulqem anamkan akken ad d-ibin belli d uṭṭun n ulqem, d ayen yuzzlen
s waṭas. Nettmagar-d aṭas asemẓi n “version” s “v” deg usefrek n yileqman.
Amedya: git tag v1.2.3 -m "Asufeɣ n ulqem 1.2.3", anda “v1.2.3” d isem
n tecreḍt, ma yella d alqem anamkan d “1.2.3”.\nTella kra n tenfalit talugant (RegEx) i usentem n uzrar n ulqem anamkan?\nLlant snat. Yiwet s yigrawen yettusemman tetteddu deg yinagrawen i asen-izemren
(PCRE [Perl Compatible Regular Expressions, am Perl, PHP d R], Python akked Go).\nWali: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nTella tayeḍ s yigrawen n tuṭṭfiwin s wuṭṭunen (agraw1 = major, agraw2 = minor,
agraw3 = patch, agraw4 = prerelease ma d agraw5 = buildmetadata) temɛaba d ECMA
Script (JavaScript), PCRE (Perl Compatible Regular Expressions, am Perl, PHP
d R), Python akked Go.\nWali: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nAsefru n uleqqem anamkan yura-t Tom Preston-Werner,
win i d-yesnulfan Gravatar yerna yettekki deg usufeɣ n GitHub.\nMa tebɣam ad d-teǧǧem iwenniten, ldit atiki deg GitHub
ma ulac aɣilif.\nldit atiki deg GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\n유의적 버전 2.0.0-ko2

요약

버전을 주.부.수 숫자로 하고:


  기존 버전과 호환되지 않게 API가 바뀌면 “주(主) 버전”을 올리고,
  기존 버전과 호환되면서 새로운 기능을 추가할 때는 “부(部) 버전”을 올리고,
  기존 버전과 호환되면서 버그를 수정한 것이라면 “수(修) 버전”을 올린다.


주.부.수 형식에 정식배포 전 버전이나 빌드 메타데이터를 위한 라벨을 덧붙이는 방법도 있다.

머리말

소프트웨어 관리의 세계에는 “의존성 지옥”이라 불리는 성가신 문제가 있다. 시스템 규모가 커질수록, 그리고 더 많은 패키지를 가져다 쓸수록, 언젠가, 이 절망의 늪에 빠진 자신을 발견하기 쉽다.

의존성이 높은 시스템에서는, 새 패키지 버전을 배포하는 일이 금방 끔찍해지곤 한다. 의존성 명세를 너무 엄격하게 관리하면, 버전에 갇히게 될 위험이 있다(의존하는 모든 패키지의 새 버전을 배포하지 않고는 업그레이드할 수 없게 된다). 의존성을 너무 느슨하게 관리하면, 버전이 엉켜서 괴롭게 될 것이다(지나치게 나중 버전까지 호환될 거라 가정한 경우). 버전에 갇히거나 엉켜서 쉽고 안전하게 프로젝트를 계속 진행할 수 없다면 의존성 지옥에 빠진 것이다.

이 문제의 해결책으로, 버전 번호를 어떻게 정하고 올려야 하는지를 명시하는 규칙과 요구사항을 제안한다. 이 규칙들은 기존 오픈 소스/비공개 소스 소프트웨어에 널리 활용되는 규칙을 바탕으로 했으나, 반드시 따르고자 제약을 받지는 않았다. 이 시스템이 동작하려면, 먼저 공개(public) API를 선언해야 한다. 문서와 소스 코드 자체로 드러낼 수 있다. 어떤 방식이든 API가 명확해야 한다. 한번 공개 API를 정의하고 나면, 버전 번호를 올리는 방식을 통해 API가 어떻게 바뀌는지 표현한다. 버전을 X.Y.Z (주.부.수) 형식으로 정한다. API에 영향이 없는 버그 수정은 수(修)버전을 올리고, API가 호환되면서 바꾸거나 추가하는 경우에는 부(部)버전을 올리고, API가 호환되지 않는 변경이라면 주(主)버전을 올린다.

이 체계를 “유의적 버전”이라고 부르고자 한다. 이 체계를 따르면, 버전 번호와 그 번호를 바꾸는 방법을 통해 특정 버전에서 다음 버전으로 넘어가면서 코드가 어떻게 바뀌는지를 드러낸다.

유의적 버전 명세 (SemVer)

이하 “반드시(MUST, REQUIRED, SHALL) ~한다”, “절대 ~해서는 안 된다(MUST NOT, SHALL NOT)”, “될 수 있으면(SHOULD, RECOMMENDED) ~한다”, “~하지 않는 게 좋다(SHOULD NOT)”, “할 수 있다(MAY, OPTIONAL)”의 표현은 RFC 2119에 기술한 대로 해석한다.


  
    유의적 버전을 쓰는 소프트웨어는 반드시 공개 API를 선언한다. 이 API는 코드 자체로 선언하거나 문서로 엄격히 명시해야 한다. 어떤 방식으로든, 정확하고 이해하기 쉬워야 한다.
  
  
    보통 버전 번호는 반드시 X.Y.Z의 형태로 하고, X, Y, Z는 각각 자연수(음이 아닌 정수)이고, 절대로 0이 앞에 붙어서는 안 된다. X는 주(主)버전 번호이고, Y는 부(部)버전 번호이며, Z는 수(修)버전 번호이다. 각각은 반드시 증가하는 수여야 한다. 예: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    특정 버전으로 패키지를 배포하고 나면, 그 버전의 내용은 절대 변경하지 말아야 한다. 변경분이 있다면 반드시 새로운 버전으로 배포하도록 한다.
  
  
    주버전 0(0.y.z)은 초기 개발을 위해서 쓴다. 아무 때나 마음대로 바꿀 수 있다. 이 공개 API는 안정판으로 보지 않는 게 좋다.
  
  
    1.0.0 버전은 공개 API를 정의한다. 이후의 버전 번호는 이때 배포한 공개 API에서 어떻게 바뀌는지에 따라 올린다.
  
  
    수버전 Z (x.y.Z | x > 0)는 반드시 그전 버전 API와 호환되는 버그 수정의 경우에만 올린다. 버그 수정은 잘못된 내부 기능을 고치는 것이라 정의한다.
  
  
    공개 API에 기존과 호환되는 새로운 기능을 추가할 때는 반드시 부버전 Y(x.Y.z | x > 0)를 올린다. 공개 API의 일부를 앞으로 제거할 것(deprecate)으로 표시한 경우에도 반드시 올리도록 한다. 내부 비공개 코드에 새로운 기능이 대폭 추가되거나 개선사항이 있을 때도 올릴 수 있다. 부버전을 올릴 때 수버전을 올릴 때만큼의 변화를 포함할 수도 있다. 부버전이 올라가면 수버전은 반드시 0에서 다시 시작한다.
  
  
    공개 API에 기존과 호환되지 않는 변화가 있을 때는 반드시 주버전 X(X.y.z | X > 0)를 올린다. 부버전이나 수버전급 변화를 포함할 수 있다. 주버전 번호를 올릴 때는 반드시 부버전과 수버전을 0으로 초기화 한다.
  
  
    수버전 바로 뒤에 붙임표(-)를 붙이고 마침표(.)로 구분된 식별자를 더해서 정식 배포를 앞둔 (pre-release) 버전을 표기할 수 있다. 식별자는 반드시 아스키(ASCII) 문자, 숫자, 붙임표로만 구성한다[0-9A-Za-z-]. 식별자는 반드시 한 글자 이상으로 한다. 숫자 식별자의 경우 절대 앞에 0을 붙인 숫자로 표기하지 않는다. 정식배포 전 버전은 관련한 보통 버전보다 우선순위가 낮다. 정식배포 전 버전은 아직 불안정하며 연관된 일반 버전에 대해 호환성 요구사항이 충족되지 않을 수도 있다. 예: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    빌드 메타데이터는 수버전이나 정식배포 전 식별자 뒤에 더하기(+) 기호를 붙인 뒤에 마침표로 구분된 식별자를 덧붙여서 표현할 수 있다. 식별자는 반드시 아스키 문자와 숫자와 붙임표로만 구성한다 [0-9A-Za-z-]. 식별자는 반드시 한 글자 이상으로 한다. 빌드 메타데이터는 버전 간의 우선순위를 판단하고자 할 때 반드시 무시해야 한다. 그러므로, 빌드 메타데이터만 다른 두 버전의 우선순위는 같다. 예: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    우선순위는 버전의 순서를 정렬할 때 서로를 어떻게 비교할지를 나타낸다. 우선순위는 반드시 주, 부, 수 버전, 그리고 정식배포 전 버전의 식별자를 나누어 계산하도록 한다 (빌드 메타데이터는 우선순위에 영향을 주지 않는다). 우선순위는 다음의 순서로 차례로 비교하면서, 차이가 나는 부분이 나타나면 결정된다: 주, 부, 수는 숫자로 비교한다. 예: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. 주, 부, 수버전이 같을 경우, 정식배포 전 버전이 표기된 경우의 우선순위가 더 낮다. 예: 1.0.0-alpha < 1.0.0. 주, 부, 수버전이 같은 두 배포 전 버전 간의 우선순위는 반드시 마침표로 구분된 식별자를 각각 차례로 비교하면서 차이점을 찾는다: 숫자로만 구성된 식별자는 수의 크기로 비교하고 알파벳이나 붙임표가 포함된 경우에는 아스키 문자열 정렬을 하도록 한다. 숫자로만 구성된 식별자는 어떤 경우에도 문자와 붙임표가 있는 식별자보다 낮은 우선순위로 여긴다. 앞선 식별자가 모두 같은 배포 전 버전의 경우에는 필드 수가 많은 쪽이 더 높은 우선순위를 가진다. 예: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


유효한 유의적 버전의 BNF(Backus-Naur Form) 문법
<유의적 버전> ::= <버전 몸통>
             | <버전 몸통> "-" <배포 전 버전>
             | <버전 몸통> "+" <빌드>
             | <버전 몸통> "-" <배포 전 버전> "+" <빌드>

<버전 몸통> ::= <주> "." <부> "." <수>

<주> ::= <숫자 식별자>

<부> ::= <숫자 식별자>

<수> ::= <숫자 식별자>

<배포 전 버전> ::= <마침표로 구분된 배포 전 식별자들>

<마침표로 구분된 배포 전 식별자들> ::= <배포 전 식별자>
                              | <배포 전 식별자> "." <마침표로 구분된 배포 전 식별자들>

<빌드> ::= <마침표로 구분된 빌드 식별자들>

<마침표로 구분된 빌드 식별자들> ::= <빌드 식별자>
                            | <빌드 식별자> "." <마침표로 구분된 빌드 식별자들>

<배포 전 식별자> ::= <숫자와 알파벳으로 구성된 식별자>
                | <숫자 식별자>

<빌드 식별자> ::= <숫자와 알파벳으로 구성된 식별자>
             | <숫자들>

<숫자와 알파벳으로 구성된 식별자> ::= <숫자 아닌 것>
                             | <숫자 아닌 것> <식별자 문자들>
                             | <식별자 문자들> <숫자 아닌 것>
                             | <식별자 문자들> <숫자 아닌 것> <식별자 문자들>

<숫자 식별자> ::= "0"
             | <양의 숫자>
             | <양의 숫자> <숫자들>

<식별자 문자들> ::= <식별자 문자>
               | <식별자 문자> <식별자 문자들>

<식별자 문자> ::= <숫자>
             | <숫자 아닌 것>

<숫자 아닌 것> ::= <문자>
              | "-"

<숫자들> ::= <숫자>
         | <숫자> <숫자들>

<숫자> ::= "0"
        | <양의 숫자>

<양의 숫자> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<문자> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
        | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
        | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
        | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
        | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
        | "y" | "z"


유의적 버전을 써야 하는 이유

유의적 버전은 혁신적인 아이디어가 아니다. 사실, 이미 이와 비슷한 방식으로 버전을 정해서 쓰고 있었을 수 있다. 문제는 이와 “비슷한” 방식으로는 충분치 않다는 점이다. 어떠한 형태로 정식 명세를 정해서 따르지 않는다면, 버전 번호는 의존성 관리에서 무의미하다. 이상의 아이디어에 이름을 정하고 명시적인 정의를 내림으로써, 소프트웨어 사용자에게 제작자의 의도를 전달하기 쉬워진다. 의도가 명확해야만, (너무 지나치지는 않은) 융통성 있는 의존성 명세를 만들 수 있다.

유의적 버전으로 어떻게 의존성 지옥을 벗어날 수 있는지 간단한 예를 들어보자. “Firetruck”이라는 라이브러리가 있다고 하자. 이 라이브러리는 유의적 버전이 붙은 “Ladder”라는 패키지에 의존한다. Firetruck을 만들었을 때, Ladder는 버전 3.1.0이었다. Firetruck이 3.1.0에 처음으로 추가된 기능을 사용했기 때문에, Ladder의 의존성을 3.1.0 이상, 4.0.0 미만으로 지정할 수 있다. 이제, Ladder의 3.1.1 버전과 3.2.0 버전이 공개된다면, 패키지 관리 시스템에 그 버전을 넣을 수 있고 기존 소프트웨어와 호환될 것이라고 알 수 있다.

물론, 책임감 있는 개발자로서 패키지가 업그레이드된 부분이 홍보된 대로 잘 동작하는지 검증하고자 할 것이다. 실상은 지저분하다; 조심해서 관리하는 것 외에는 달리 도리가 없다. 유의적 버전을 사용함으로써 의존하는 패키지들의 새 버전들과 씨름하지 않고, 시간 낭비와 소란 없이 패키지를 공개하고 업그레이드할 수 있다.

만약 이상의 내용이 그럴싸하다면, 유의적 버전을 쓰기 시작하기 위해서 할 일은, 그렇게 하고자 마음먹고 규칙을 따르기만 하면 된다. 여러분의 README 파일에 이 웹사이트의 링크를 추가해서 다른 사람들도 유용하게 쓸 수 있게 하자.

FAQ

초기 개발 단계에 0.y.z 버전 관리는 어떻게 할까?

가장 간단한 방법은 최초 개발 배포를 0.1.0으로 하고, 이후 배포마다 부버전을 올리는 것이다.

언제 1.0.0을 배포해야 할지 어떻게 알 수 있나?

소프트웨어가 실 서비스에 쓰이기 시작했다면 이미 1.0.0이라고 여길 수 있다. 사용자들이 믿고 쓸 수 있는 안정한 API가 있다면 1.0.0일 것이다. 하위 버전 호환성에 대해 우려하기 시작했다면 이미 1.0.0일 수 있다.

유의적 버전 짓기가 신속한 개발과 빠른 이터레이션에 방해가 되지는 않을까?

주버전 0이 신속한 개발을 위한 것이다. 만약 API를 매일같이 바꾸고 있다면 0.y.z 버전을 쓰거나 별도의 다음번 주버전 배포를 앞둔 개발 브랜치를 써야 한다.

공개 API의 아주 사소한 부분이 하위호환이 되지 않는다고 주버전을 매번 올려야 한다면, 어느새 버전 42.0.0이 되어버리지는 않나?

책임감 있고 선견지명이 있는 질문이다. 의존하는 코드가 많은 소프트웨어에, 호환되지 않는 변화를 가볍게 도입해서는 안 된다. 관련해서 업그레이드하는 데 필요한 비용이 어마어마해질 수 있다. 호환되지 않는 변경분을 배포하기 위해 주버전을 올리려면, 바뀌는 부분에 인한 여파와 그 비용과 혜택을 충분히 평가해야 한다.

공개 API 전체를 문서로 만드는 것은 일이 너무 많다!

프로 개발자로서 다른 사람들이 쓰게 하려고 만든 소프트웨어를 적절히 문서로 만드는 것은 책임이다. 프로젝트를 효율적으로 유지하기 위해 소프트웨어의 복잡성을 관리하는 일은 매우 중요한 일이고, 남이 소프트웨어를 어떻게 쓰는지 모르거나 어떤 메소드들을 안전하게 호출할 수 있는 건지 모른다면 어려울 것이다. 장기적으로 볼 때, 유의적 버전과 잘 정의한 공개 API는 관련된 모든 사람과 모든 것이 순조롭게 지낼 수 있게 한다.

부버전을 올리는데 실수로 호환되지 않는 변경이 들어갔다면 어떻게 해야 하나?

유의적 버전 명세를 어겼다는 사실을 알게 되면, 즉시 문제를 해결하고 호환성이 깨진 부분을 복구해서 새 부버전을 배포한다. 이 경우라도 이미 배포된 버전을 변경해서는 안 된다. 필요한 경우라면 문제가 되는 버전을 문서로 표시해서 사용자들로 하여금 주의하도록 한다.

공개 API는 유지한 채 내부의 의존성을 바꾼다면 어떻게 할까?

공개 API에 영향을 주지 않으므로 호환된다고 여긴다. 당신의 패키지와 똑같은 의존성을 명시한 소프트웨어는 별도로 의존성 명세가 있어야 하고 작성자는 충돌을 눈치챌 것이다. 변화가 수버전 수준인지 부버전 수준인지 결정하는 것은 버그를 수정하고자 한 작업인지, 새로운 기능을 추가하기 위해서인지에 달려있다. 후자의 경우, 추가적인 코드를 예상할 것이며, 그렇다면 당연히 부버전을 증가해야 할 것이다.

실수로 버전 증가와 맞지 않게 공개 API 변경을 했다면 어떻게 하나? (수버전 배포에서 잘못된 코드가 들어가서 깨지게 된 경우)

스스로 최선의 판단을 하자. 공개 API가 원래 의도했던 대로 사용될 수 있게 바꾸는 작업에 영향을 받는 대규모 사용자층이 있다면, 수정사항이 엄밀히 따지자면 수버전 배포로 여겨져야 한다 하더라도, 주버전 배포를 하는 것이 최선일 것이다. 유의적 버전은 어떻게 버전 번호가 바뀌는지 의미를 전달하는 것이 전부임을 잊지 말자. 변경이 사용자에게 중요한 의미가 있다면, 버전 번호로 잘 알릴 수 있도록 한다.

제거하는 기능들에 대해서는 어떻게 할까?

기존의 기능들을 사용하지 못하게 없애는 것은 소프트웨어 개발과정의 자연스러운 일부분이며, 때로는 앞으로 나아가기 위해 필수적인 일이기도 하다. 공개 API의 일부를 제거하고자 하다면 다음의 두 가지 일을 해야 한다: (1) 문서를 업데이트해서 사용자들에게 변화를 알리도록 한다. (2) 해당 기능이 제거될 거라 표시된 새 부버전을 적절한 시기에 배포한다. 새 주버전에서 완전히 기능을 제거하기 전에, 제거될 것이라 표시한 부버전 배포를 최소한 한 번은 진행해서 사용자들이 원활하게 새로운 API를 사용할 수 있도록 해야 한다.

유의적 버전의 버전 문자열 길이에 제한이 있나?

없지만, 잘 판단 하자. 예를 들어, 255자 버전 문자열은 아마도 지나치게 긴 것일 것이다. 또, 몇몇 시스템은 문자열 길이에 대해 나름의 제한이 있을 것이다.

“v1.2.3”은 유의적 버전 인가?

“v1.2.3”은 유의적 버전이 아니다. 그러나, 버전 숫자를 나타내기 위해 유의적 버전의 접두어로 “v”를 붙이기도 한다. 버전 관리 도구에서 “version”의 축약어로 “v”로 사용하는 것을 흔하게 볼 수 있다. 예: git tag v1.2.3 -m "Release version 1.2.3" 에서 “v1.2.3”은 tag name이고 유의적 버전은 “1.2.3” 이다.

유의적 버전을 확인할 수 있는 정규식(RegEx)이 있나?

두가지 방법이 있다. 첫번째는 캡처 그룹 이름 지정 방식의 정규식이다(PCRE [Perl Compatible Regular Expressions, i.e. Perl, PHP and R], Python, Go 지원).

See: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


두번째는 캡처 그룹 이름 지정 방식을 지원하지 않는 경우의 정규식이다.

See: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


작성자

유의적 버전 명세는 그라바타(Gravatars)의 창시자이자 깃헙(GitHub)의 공동창업자인 톰 프레스턴-베르너(Tom
Preston-Werner)가 작성했다.

원문에 대한 의견을 남기고자 한다면, 원문 깃헙에 이슈를 작성해 주기 바란다.

한국어 번역은 김대현이 했고, 관련한 의견은 한국어판 깃헙에 이슈로 남겨주기 바란다.

라이선스

Creative Commons ― CC BY 3.0
http://creativecommons.org/licenses/by/3.0/\n기존 버전과 호환되지 않게 API가 바뀌면 “주(主) 버전”을 올리고,\n기존 버전과 호환되면서 새로운 기능을 추가할 때는 “부(部) 버전”을 올리고,\n기존 버전과 호환되면서 버그를 수정한 것이라면 “수(修) 버전”을 올린다.\n주.부.수 형식에 정식배포 전 버전이나 빌드 메타데이터를 위한 라벨을 덧붙이는 방법도 있다.\n소프트웨어 관리의 세계에는 “의존성 지옥”이라 불리는 성가신 문제가 있다. 시스템 규모가 커질수록, 그리고 더 많은 패키지를 가져다 쓸수록, 언젠가, 이 절망의 늪에 빠진 자신을 발견하기 쉽다.\n의존성이 높은 시스템에서는, 새 패키지 버전을 배포하는 일이 금방 끔찍해지곤 한다. 의존성 명세를 너무 엄격하게 관리하면, 버전에 갇히게 될 위험이 있다(의존하는 모든 패키지의 새 버전을 배포하지 않고는 업그레이드할 수 없게 된다). 의존성을 너무 느슨하게 관리하면, 버전이 엉켜서 괴롭게 될 것이다(지나치게 나중 버전까지 호환될 거라 가정한 경우). 버전에 갇히거나 엉켜서 쉽고 안전하게 프로젝트를 계속 진행할 수 없다면 의존성 지옥에 빠진 것이다.\n이 문제의 해결책으로, 버전 번호를 어떻게 정하고 올려야 하는지를 명시하는 규칙과 요구사항을 제안한다. 이 규칙들은 기존 오픈 소스/비공개 소스 소프트웨어에 널리 활용되는 규칙을 바탕으로 했으나, 반드시 따르고자 제약을 받지는 않았다. 이 시스템이 동작하려면, 먼저 공개(public) API를 선언해야 한다. 문서와 소스 코드 자체로 드러낼 수 있다. 어떤 방식이든 API가 명확해야 한다. 한번 공개 API를 정의하고 나면, 버전 번호를 올리는 방식을 통해 API가 어떻게 바뀌는지 표현한다. 버전을 X.Y.Z (주.부.수) 형식으로 정한다. API에 영향이 없는 버그 수정은 수(修)버전을 올리고, API가 호환되면서 바꾸거나 추가하는 경우에는 부(部)버전을 올리고, API가 호환되지 않는 변경이라면 주(主)버전을 올린다.\n이 체계를 “유의적 버전”이라고 부르고자 한다. 이 체계를 따르면, 버전 번호와 그 번호를 바꾸는 방법을 통해 특정 버전에서 다음 버전으로 넘어가면서 코드가 어떻게 바뀌는지를 드러낸다.\n이하 “반드시(MUST, REQUIRED, SHALL) ~한다”, “절대 ~해서는 안 된다(MUST NOT, SHALL NOT)”, “될 수 있으면(SHOULD, RECOMMENDED) ~한다”, “~하지 않는 게 좋다(SHOULD NOT)”, “할 수 있다(MAY, OPTIONAL)”의 표현은 RFC 2119에 기술한 대로 해석한다.\n유의적 버전을 쓰는 소프트웨어는 반드시 공개 API를 선언한다. 이 API는 코드 자체로 선언하거나 문서로 엄격히 명시해야 한다. 어떤 방식으로든, 정확하고 이해하기 쉬워야 한다.\n유의적 버전을 쓰는 소프트웨어는 반드시 공개 API를 선언한다. 이 API는 코드 자체로 선언하거나 문서로 엄격히 명시해야 한다. 어떤 방식으로든, 정확하고 이해하기 쉬워야 한다.\n보통 버전 번호는 반드시 X.Y.Z의 형태로 하고, X, Y, Z는 각각 자연수(음이 아닌 정수)이고, 절대로 0이 앞에 붙어서는 안 된다. X는 주(主)버전 번호이고, Y는 부(部)버전 번호이며, Z는 수(修)버전 번호이다. 각각은 반드시 증가하는 수여야 한다. 예: 1.9.0 -> 1.10.0 -> 1.11.0.\n보통 버전 번호는 반드시 X.Y.Z의 형태로 하고, X, Y, Z는 각각 자연수(음이 아닌 정수)이고, 절대로 0이 앞에 붙어서는 안 된다. X는 주(主)버전 번호이고, Y는 부(部)버전 번호이며, Z는 수(修)버전 번호이다. 각각은 반드시 증가하는 수여야 한다. 예: 1.9.0 -> 1.10.0 -> 1.11.0.\n특정 버전으로 패키지를 배포하고 나면, 그 버전의 내용은 절대 변경하지 말아야 한다. 변경분이 있다면 반드시 새로운 버전으로 배포하도록 한다.\n특정 버전으로 패키지를 배포하고 나면, 그 버전의 내용은 절대 변경하지 말아야 한다. 변경분이 있다면 반드시 새로운 버전으로 배포하도록 한다.\n주버전 0(0.y.z)은 초기 개발을 위해서 쓴다. 아무 때나 마음대로 바꿀 수 있다. 이 공개 API는 안정판으로 보지 않는 게 좋다.\n주버전 0(0.y.z)은 초기 개발을 위해서 쓴다. 아무 때나 마음대로 바꿀 수 있다. 이 공개 API는 안정판으로 보지 않는 게 좋다.\n1.0.0 버전은 공개 API를 정의한다. 이후의 버전 번호는 이때 배포한 공개 API에서 어떻게 바뀌는지에 따라 올린다.\n1.0.0 버전은 공개 API를 정의한다. 이후의 버전 번호는 이때 배포한 공개 API에서 어떻게 바뀌는지에 따라 올린다.\n수버전 Z (x.y.Z | x > 0)는 반드시 그전 버전 API와 호환되는 버그 수정의 경우에만 올린다. 버그 수정은 잘못된 내부 기능을 고치는 것이라 정의한다.\n수버전 Z (x.y.Z | x > 0)는 반드시 그전 버전 API와 호환되는 버그 수정의 경우에만 올린다. 버그 수정은 잘못된 내부 기능을 고치는 것이라 정의한다.\n공개 API에 기존과 호환되는 새로운 기능을 추가할 때는 반드시 부버전 Y(x.Y.z | x > 0)를 올린다. 공개 API의 일부를 앞으로 제거할 것(deprecate)으로 표시한 경우에도 반드시 올리도록 한다. 내부 비공개 코드에 새로운 기능이 대폭 추가되거나 개선사항이 있을 때도 올릴 수 있다. 부버전을 올릴 때 수버전을 올릴 때만큼의 변화를 포함할 수도 있다. 부버전이 올라가면 수버전은 반드시 0에서 다시 시작한다.\n공개 API에 기존과 호환되는 새로운 기능을 추가할 때는 반드시 부버전 Y(x.Y.z | x > 0)를 올린다. 공개 API의 일부를 앞으로 제거할 것(deprecate)으로 표시한 경우에도 반드시 올리도록 한다. 내부 비공개 코드에 새로운 기능이 대폭 추가되거나 개선사항이 있을 때도 올릴 수 있다. 부버전을 올릴 때 수버전을 올릴 때만큼의 변화를 포함할 수도 있다. 부버전이 올라가면 수버전은 반드시 0에서 다시 시작한다.\n공개 API에 기존과 호환되지 않는 변화가 있을 때는 반드시 주버전 X(X.y.z | X > 0)를 올린다. 부버전이나 수버전급 변화를 포함할 수 있다. 주버전 번호를 올릴 때는 반드시 부버전과 수버전을 0으로 초기화 한다.\n공개 API에 기존과 호환되지 않는 변화가 있을 때는 반드시 주버전 X(X.y.z | X > 0)를 올린다. 부버전이나 수버전급 변화를 포함할 수 있다. 주버전 번호를 올릴 때는 반드시 부버전과 수버전을 0으로 초기화 한다.\n수버전 바로 뒤에 붙임표(-)를 붙이고 마침표(.)로 구분된 식별자를 더해서 정식 배포를 앞둔 (pre-release) 버전을 표기할 수 있다. 식별자는 반드시 아스키(ASCII) 문자, 숫자, 붙임표로만 구성한다[0-9A-Za-z-]. 식별자는 반드시 한 글자 이상으로 한다. 숫자 식별자의 경우 절대 앞에 0을 붙인 숫자로 표기하지 않는다. 정식배포 전 버전은 관련한 보통 버전보다 우선순위가 낮다. 정식배포 전 버전은 아직 불안정하며 연관된 일반 버전에 대해 호환성 요구사항이 충족되지 않을 수도 있다. 예: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\n수버전 바로 뒤에 붙임표(-)를 붙이고 마침표(.)로 구분된 식별자를 더해서 정식 배포를 앞둔 (pre-release) 버전을 표기할 수 있다. 식별자는 반드시 아스키(ASCII) 문자, 숫자, 붙임표로만 구성한다[0-9A-Za-z-]. 식별자는 반드시 한 글자 이상으로 한다. 숫자 식별자의 경우 절대 앞에 0을 붙인 숫자로 표기하지 않는다. 정식배포 전 버전은 관련한 보통 버전보다 우선순위가 낮다. 정식배포 전 버전은 아직 불안정하며 연관된 일반 버전에 대해 호환성 요구사항이 충족되지 않을 수도 있다. 예: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\n빌드 메타데이터는 수버전이나 정식배포 전 식별자 뒤에 더하기(+) 기호를 붙인 뒤에 마침표로 구분된 식별자를 덧붙여서 표현할 수 있다. 식별자는 반드시 아스키 문자와 숫자와 붙임표로만 구성한다 [0-9A-Za-z-]. 식별자는 반드시 한 글자 이상으로 한다. 빌드 메타데이터는 버전 간의 우선순위를 판단하고자 할 때 반드시 무시해야 한다. 그러므로, 빌드 메타데이터만 다른 두 버전의 우선순위는 같다. 예: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\n빌드 메타데이터는 수버전이나 정식배포 전 식별자 뒤에 더하기(+) 기호를 붙인 뒤에 마침표로 구분된 식별자를 덧붙여서 표현할 수 있다. 식별자는 반드시 아스키 문자와 숫자와 붙임표로만 구성한다 [0-9A-Za-z-]. 식별자는 반드시 한 글자 이상으로 한다. 빌드 메타데이터는 버전 간의 우선순위를 판단하고자 할 때 반드시 무시해야 한다. 그러므로, 빌드 메타데이터만 다른 두 버전의 우선순위는 같다. 예: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\n우선순위는 버전의 순서를 정렬할 때 서로를 어떻게 비교할지를 나타낸다. 우선순위는 반드시 주, 부, 수 버전, 그리고 정식배포 전 버전의 식별자를 나누어 계산하도록 한다 (빌드 메타데이터는 우선순위에 영향을 주지 않는다). 우선순위는 다음의 순서로 차례로 비교하면서, 차이가 나는 부분이 나타나면 결정된다: 주, 부, 수는 숫자로 비교한다. 예: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. 주, 부, 수버전이 같을 경우, 정식배포 전 버전이 표기된 경우의 우선순위가 더 낮다. 예: 1.0.0-alpha < 1.0.0. 주, 부, 수버전이 같은 두 배포 전 버전 간의 우선순위는 반드시 마침표로 구분된 식별자를 각각 차례로 비교하면서 차이점을 찾는다: 숫자로만 구성된 식별자는 수의 크기로 비교하고 알파벳이나 붙임표가 포함된 경우에는 아스키 문자열 정렬을 하도록 한다. 숫자로만 구성된 식별자는 어떤 경우에도 문자와 붙임표가 있는 식별자보다 낮은 우선순위로 여긴다. 앞선 식별자가 모두 같은 배포 전 버전의 경우에는 필드 수가 많은 쪽이 더 높은 우선순위를 가진다. 예: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\n우선순위는 버전의 순서를 정렬할 때 서로를 어떻게 비교할지를 나타낸다. 우선순위는 반드시 주, 부, 수 버전, 그리고 정식배포 전 버전의 식별자를 나누어 계산하도록 한다 (빌드 메타데이터는 우선순위에 영향을 주지 않는다). 우선순위는 다음의 순서로 차례로 비교하면서, 차이가 나는 부분이 나타나면 결정된다: 주, 부, 수는 숫자로 비교한다. 예: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. 주, 부, 수버전이 같을 경우, 정식배포 전 버전이 표기된 경우의 우선순위가 더 낮다. 예: 1.0.0-alpha < 1.0.0. 주, 부, 수버전이 같은 두 배포 전 버전 간의 우선순위는 반드시 마침표로 구분된 식별자를 각각 차례로 비교하면서 차이점을 찾는다: 숫자로만 구성된 식별자는 수의 크기로 비교하고 알파벳이나 붙임표가 포함된 경우에는 아스키 문자열 정렬을 하도록 한다. 숫자로만 구성된 식별자는 어떤 경우에도 문자와 붙임표가 있는 식별자보다 낮은 우선순위로 여긴다. 앞선 식별자가 모두 같은 배포 전 버전의 경우에는 필드 수가 많은 쪽이 더 높은 우선순위를 가진다. 예: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\n유효한 유의적 버전의 BNF(Backus-Naur Form) 문법\n<유의적 버전> ::= <버전 몸통>
             | <버전 몸통> "-" <배포 전 버전>
             | <버전 몸통> "+" <빌드>
             | <버전 몸통> "-" <배포 전 버전> "+" <빌드>

<버전 몸통> ::= <주> "." <부> "." <수>

<주> ::= <숫자 식별자>

<부> ::= <숫자 식별자>

<수> ::= <숫자 식별자>

<배포 전 버전> ::= <마침표로 구분된 배포 전 식별자들>

<마침표로 구분된 배포 전 식별자들> ::= <배포 전 식별자>
                              | <배포 전 식별자> "." <마침표로 구분된 배포 전 식별자들>

<빌드> ::= <마침표로 구분된 빌드 식별자들>

<마침표로 구분된 빌드 식별자들> ::= <빌드 식별자>
                            | <빌드 식별자> "." <마침표로 구분된 빌드 식별자들>

<배포 전 식별자> ::= <숫자와 알파벳으로 구성된 식별자>
                | <숫자 식별자>

<빌드 식별자> ::= <숫자와 알파벳으로 구성된 식별자>
             | <숫자들>

<숫자와 알파벳으로 구성된 식별자> ::= <숫자 아닌 것>
                             | <숫자 아닌 것> <식별자 문자들>
                             | <식별자 문자들> <숫자 아닌 것>
                             | <식별자 문자들> <숫자 아닌 것> <식별자 문자들>

<숫자 식별자> ::= "0"
             | <양의 숫자>
             | <양의 숫자> <숫자들>

<식별자 문자들> ::= <식별자 문자>
               | <식별자 문자> <식별자 문자들>

<식별자 문자> ::= <숫자>
             | <숫자 아닌 것>

<숫자 아닌 것> ::= <문자>
              | "-"

<숫자들> ::= <숫자>
         | <숫자> <숫자들>

<숫자> ::= "0"
        | <양의 숫자>

<양의 숫자> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<문자> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
        | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
        | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
        | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
        | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
        | "y" | "z"\n<유의적 버전> ::= <버전 몸통>
             | <버전 몸통> "-" <배포 전 버전>
             | <버전 몸통> "+" <빌드>
             | <버전 몸통> "-" <배포 전 버전> "+" <빌드>

<버전 몸통> ::= <주> "." <부> "." <수>

<주> ::= <숫자 식별자>

<부> ::= <숫자 식별자>

<수> ::= <숫자 식별자>

<배포 전 버전> ::= <마침표로 구분된 배포 전 식별자들>

<마침표로 구분된 배포 전 식별자들> ::= <배포 전 식별자>
                              | <배포 전 식별자> "." <마침표로 구분된 배포 전 식별자들>

<빌드> ::= <마침표로 구분된 빌드 식별자들>

<마침표로 구분된 빌드 식별자들> ::= <빌드 식별자>
                            | <빌드 식별자> "." <마침표로 구분된 빌드 식별자들>

<배포 전 식별자> ::= <숫자와 알파벳으로 구성된 식별자>
                | <숫자 식별자>

<빌드 식별자> ::= <숫자와 알파벳으로 구성된 식별자>
             | <숫자들>

<숫자와 알파벳으로 구성된 식별자> ::= <숫자 아닌 것>
                             | <숫자 아닌 것> <식별자 문자들>
                             | <식별자 문자들> <숫자 아닌 것>
                             | <식별자 문자들> <숫자 아닌 것> <식별자 문자들>

<숫자 식별자> ::= "0"
             | <양의 숫자>
             | <양의 숫자> <숫자들>

<식별자 문자들> ::= <식별자 문자>
               | <식별자 문자> <식별자 문자들>

<식별자 문자> ::= <숫자>
             | <숫자 아닌 것>

<숫자 아닌 것> ::= <문자>
              | "-"

<숫자들> ::= <숫자>
         | <숫자> <숫자들>

<숫자> ::= "0"
        | <양의 숫자>

<양의 숫자> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<문자> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
        | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
        | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
        | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
        | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
        | "y" | "z"\n유의적 버전은 혁신적인 아이디어가 아니다. 사실, 이미 이와 비슷한 방식으로 버전을 정해서 쓰고 있었을 수 있다. 문제는 이와 “비슷한” 방식으로는 충분치 않다는 점이다. 어떠한 형태로 정식 명세를 정해서 따르지 않는다면, 버전 번호는 의존성 관리에서 무의미하다. 이상의 아이디어에 이름을 정하고 명시적인 정의를 내림으로써, 소프트웨어 사용자에게 제작자의 의도를 전달하기 쉬워진다. 의도가 명확해야만, (너무 지나치지는 않은) 융통성 있는 의존성 명세를 만들 수 있다.\n유의적 버전으로 어떻게 의존성 지옥을 벗어날 수 있는지 간단한 예를 들어보자. “Firetruck”이라는 라이브러리가 있다고 하자. 이 라이브러리는 유의적 버전이 붙은 “Ladder”라는 패키지에 의존한다. Firetruck을 만들었을 때, Ladder는 버전 3.1.0이었다. Firetruck이 3.1.0에 처음으로 추가된 기능을 사용했기 때문에, Ladder의 의존성을 3.1.0 이상, 4.0.0 미만으로 지정할 수 있다. 이제, Ladder의 3.1.1 버전과 3.2.0 버전이 공개된다면, 패키지 관리 시스템에 그 버전을 넣을 수 있고 기존 소프트웨어와 호환될 것이라고 알 수 있다.\n물론, 책임감 있는 개발자로서 패키지가 업그레이드된 부분이 홍보된 대로 잘 동작하는지 검증하고자 할 것이다. 실상은 지저분하다; 조심해서 관리하는 것 외에는 달리 도리가 없다. 유의적 버전을 사용함으로써 의존하는 패키지들의 새 버전들과 씨름하지 않고, 시간 낭비와 소란 없이 패키지를 공개하고 업그레이드할 수 있다.\n만약 이상의 내용이 그럴싸하다면, 유의적 버전을 쓰기 시작하기 위해서 할 일은, 그렇게 하고자 마음먹고 규칙을 따르기만 하면 된다. 여러분의 README 파일에 이 웹사이트의 링크를 추가해서 다른 사람들도 유용하게 쓸 수 있게 하자.\n초기 개발 단계에 0.y.z 버전 관리는 어떻게 할까?\n가장 간단한 방법은 최초 개발 배포를 0.1.0으로 하고, 이후 배포마다 부버전을 올리는 것이다.\n언제 1.0.0을 배포해야 할지 어떻게 알 수 있나?\n소프트웨어가 실 서비스에 쓰이기 시작했다면 이미 1.0.0이라고 여길 수 있다. 사용자들이 믿고 쓸 수 있는 안정한 API가 있다면 1.0.0일 것이다. 하위 버전 호환성에 대해 우려하기 시작했다면 이미 1.0.0일 수 있다.\n유의적 버전 짓기가 신속한 개발과 빠른 이터레이션에 방해가 되지는 않을까?\n주버전 0이 신속한 개발을 위한 것이다. 만약 API를 매일같이 바꾸고 있다면 0.y.z 버전을 쓰거나 별도의 다음번 주버전 배포를 앞둔 개발 브랜치를 써야 한다.\n공개 API의 아주 사소한 부분이 하위호환이 되지 않는다고 주버전을 매번 올려야 한다면, 어느새 버전 42.0.0이 되어버리지는 않나?\n책임감 있고 선견지명이 있는 질문이다. 의존하는 코드가 많은 소프트웨어에, 호환되지 않는 변화를 가볍게 도입해서는 안 된다. 관련해서 업그레이드하는 데 필요한 비용이 어마어마해질 수 있다. 호환되지 않는 변경분을 배포하기 위해 주버전을 올리려면, 바뀌는 부분에 인한 여파와 그 비용과 혜택을 충분히 평가해야 한다.\n공개 API 전체를 문서로 만드는 것은 일이 너무 많다!\n프로 개발자로서 다른 사람들이 쓰게 하려고 만든 소프트웨어를 적절히 문서로 만드는 것은 책임이다. 프로젝트를 효율적으로 유지하기 위해 소프트웨어의 복잡성을 관리하는 일은 매우 중요한 일이고, 남이 소프트웨어를 어떻게 쓰는지 모르거나 어떤 메소드들을 안전하게 호출할 수 있는 건지 모른다면 어려울 것이다. 장기적으로 볼 때, 유의적 버전과 잘 정의한 공개 API는 관련된 모든 사람과 모든 것이 순조롭게 지낼 수 있게 한다.\n부버전을 올리는데 실수로 호환되지 않는 변경이 들어갔다면 어떻게 해야 하나?\n유의적 버전 명세를 어겼다는 사실을 알게 되면, 즉시 문제를 해결하고 호환성이 깨진 부분을 복구해서 새 부버전을 배포한다. 이 경우라도 이미 배포된 버전을 변경해서는 안 된다. 필요한 경우라면 문제가 되는 버전을 문서로 표시해서 사용자들로 하여금 주의하도록 한다.\n공개 API는 유지한 채 내부의 의존성을 바꾼다면 어떻게 할까?\n공개 API에 영향을 주지 않으므로 호환된다고 여긴다. 당신의 패키지와 똑같은 의존성을 명시한 소프트웨어는 별도로 의존성 명세가 있어야 하고 작성자는 충돌을 눈치챌 것이다. 변화가 수버전 수준인지 부버전 수준인지 결정하는 것은 버그를 수정하고자 한 작업인지, 새로운 기능을 추가하기 위해서인지에 달려있다. 후자의 경우, 추가적인 코드를 예상할 것이며, 그렇다면 당연히 부버전을 증가해야 할 것이다.\n실수로 버전 증가와 맞지 않게 공개 API 변경을 했다면 어떻게 하나? (수버전 배포에서 잘못된 코드가 들어가서 깨지게 된 경우)\n스스로 최선의 판단을 하자. 공개 API가 원래 의도했던 대로 사용될 수 있게 바꾸는 작업에 영향을 받는 대규모 사용자층이 있다면, 수정사항이 엄밀히 따지자면 수버전 배포로 여겨져야 한다 하더라도, 주버전 배포를 하는 것이 최선일 것이다. 유의적 버전은 어떻게 버전 번호가 바뀌는지 의미를 전달하는 것이 전부임을 잊지 말자. 변경이 사용자에게 중요한 의미가 있다면, 버전 번호로 잘 알릴 수 있도록 한다.\n제거하는 기능들에 대해서는 어떻게 할까?\n기존의 기능들을 사용하지 못하게 없애는 것은 소프트웨어 개발과정의 자연스러운 일부분이며, 때로는 앞으로 나아가기 위해 필수적인 일이기도 하다. 공개 API의 일부를 제거하고자 하다면 다음의 두 가지 일을 해야 한다: (1) 문서를 업데이트해서 사용자들에게 변화를 알리도록 한다. (2) 해당 기능이 제거될 거라 표시된 새 부버전을 적절한 시기에 배포한다. 새 주버전에서 완전히 기능을 제거하기 전에, 제거될 것이라 표시한 부버전 배포를 최소한 한 번은 진행해서 사용자들이 원활하게 새로운 API를 사용할 수 있도록 해야 한다.\n유의적 버전의 버전 문자열 길이에 제한이 있나?\n없지만, 잘 판단 하자. 예를 들어, 255자 버전 문자열은 아마도 지나치게 긴 것일 것이다. 또, 몇몇 시스템은 문자열 길이에 대해 나름의 제한이 있을 것이다.\n“v1.2.3”은 유의적 버전이 아니다. 그러나, 버전 숫자를 나타내기 위해 유의적 버전의 접두어로 “v”를 붙이기도 한다. 버전 관리 도구에서 “version”의 축약어로 “v”로 사용하는 것을 흔하게 볼 수 있다. 예: git tag v1.2.3 -m "Release version 1.2.3" 에서 “v1.2.3”은 tag name이고 유의적 버전은 “1.2.3” 이다.\n유의적 버전을 확인할 수 있는 정규식(RegEx)이 있나?\n두가지 방법이 있다. 첫번째는 캡처 그룹 이름 지정 방식의 정규식이다(PCRE [Perl Compatible Regular Expressions, i.e. Perl, PHP and R], Python, Go 지원).\nSee: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n두번째는 캡처 그룹 이름 지정 방식을 지원하지 않는 경우의 정규식이다.\nSee: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n유의적 버전 명세는 그라바타(Gravatars)의 창시자이자 깃헙(GitHub)의 공동창업자인 톰 프레스턴-베르너(Tom
Preston-Werner)가 작성했다.\n톰 프레스턴-베르너(Tom
Preston-Werner)\n원문에 대한 의견을 남기고자 한다면, 원문 깃헙에 이슈를 작성해 주기 바란다.\n한국어 번역은 김대현이 했고, 관련한 의견은 한국어판 깃헙에 이슈로 남겨주기 바란다.\nCreative Commons ― CC BY 3.0
http://creativecommons.org/licenses/by/3.0/\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSemantisch Versioneren 2.0.0

Samenvatting

Gegeven een versienummer in de vorm MAJEUR.MINEUR.PATCH, worden de individuele elementen als volgt verhoogd:


  MAJEUR wordt verhoogd bij incompatibele API-wijzigingen,
  MINEUR wordt verhoogd bij het toevoegen van functionaliteit die compatibel is met de vorige versie, en
  PATCH wordt verhoogd bij compatibele bugfixes.


Er zijn aanvullende labels beschikbaar voor pre-release en build-metadata om toe te voegen aan het MAJEUR.MINEUR.PATCH-formaat.

Introductie

In de wereld van softwarebeheer bestaat er een gevreesde plek genaamd “dependency hell” oftewel de “hel van afhankelijkheden”. Hoe groter een systeem wordt en hoe meer packages er worden geïntegreerd in de software, des te aannemelijker is het dat je op een zekere dag belandt op deze mistroostige plek.

Het uitbrengen van een nieuwe packageversie kan al snel een nachtmerrie worden als systemen te maken hebben met een hoop afhankelijkheden. Als de afhankelijkheden te strikt gespecificeerd zijn, ontstaat het gevaar op “version lock”: het is dan niet meer mogelijk om een package te upgraden zonder dat alle afhankelijke packages ook een versie verhoogd moeten worden. Als de afhankelijkheden te losjes zijn gespecificeerd, zul je onvermijdelijk worden gebeten door het fenomeen versievermenging: de verwachting dat er meer compatibiliteit is met toekomstige versies dan je redelijkerwijs mag verwachten. Je bevindt je in de hel van afhankelijkheden wanneer “version lock” en/of versievermenging zodanig in de weg zitten dat je project niet makkelijk en veilig kan worden voortgezet.

Als oplossing voor dit probleem stel ik een simpele set van regels en voorwaarden voor die beschrijven hoe versienummers toegewezen en verhoogd worden. Deze regels zijn gebaseerd op, maar niet noodzakelijk beperkt tot reeds bestaande en wijdverspreide gebruiken in zowel gesloten als opensource-software. Om dit systeem succesvol te laten zijn, is het als eerste nodig om je API publiek te declareren. Of deze nu bestaat uit documentatie of wordt afgedwongen door de code zelf maakt niet uit: het belangrijkste is dat de API duidelijk en exact is. Zodra je je publieke API geïdentificeerd hebt, worden wijzigingen gecommuniceerd met specifieke verhogingen in het versienummer. Gebruik een versieformaat van X.Y.Z (Majeur.Mineur.Patch). Bugfixes zonder effect op de API verhogen de patchversie, toevoegingen en wijzigingen aan de API die compatibel zijn met de vorige versie verhogen de mineurversie en wijzigingen aan de API die niet compatibel zijn met de vorige versie verhogen de majeurversie.

Ik noem dit systeem “Semantisch Versioneren”, waarmee versienummers en de manier waarop ze veranderen en verhoogd worden duiding geven over de onderliggende code en wat er is aangepast tussen de verschillende versies.

Specificatie Semantisch Versioneren (SemVer)

De termen “MOET” (“MUST”), “MAG NIET” (“MUST NOT”), “VERPLICHT” (“REQUIRED”), “ZAL” (“SHALL”), “ZAL NIET” (“SHALL NOT”), “ZOU MOETEN” (“SHOULD”), “ZOU NIET MOETEN” (“SHOULD NOT”), “AANBEVOLEN” (“RECOMMENDED”), “MAG” (“MAY”), “OPTIONEEL” (“OPTIONAL”) in dit document dienen te worden geïnterpreteerd zoals beschreven in RFC 2119.


  
    Software die gebruikmaakt van Semantisch Versioneren MOET een publieke API declareren. Deze API kan worden gepubliceerd in de code of strikt uit documentatie bestaan. Ongeacht de vorm is het de bedoeling dat deze nauwkeurig en uitgebreid ZOU MOETEN zijn.
  
  
    Een normaal versienummer MOET de structuur X.Y.Z. hebben, waar X, Y en Z een niet-negatief geheel getal zijn. Voorloopnullen MOGEN NIET aanwezig zijn. X is de majeurversie, Y is de mineurversie en Z is de patchversie. Elk element MOET numeriek ophogen. Bijvoorbeeld: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Wanneer een geversioneerd package is gepubliceerd, MAG de inhoud NIET worden aangepast. Alle wijzigingen MOETEN worden gepubliceerd als een nieuwe versie.
  
  
    Majeurversie nul (0.y.z) is voor de eerste ontwikkelfase. Alles MAG op ieder moment veranderen. De publieke API ZOU NIET als stabiel MOETEN worden beschouwd.
  
  
    Versie 1.0.0 definieert de publieke API. De manier waarop het versienummer wordt verhoogd na deze release is afhankelijk van de publieke API en hoe deze verandert.
  
  
    
      
        
          Patchversie Z (x.y.Z
          x > 0) MOET worden verhoogd als wijzigingen zijn doorgevoerd die compatibel zijn met de vorige versie. De definitie van een bugfix is een interne wijziging welke foutief gedrag corrigeert.
        
      
    
  
  
    
      
        
          Mineurversie Y (x.Y.z
          x > 0) MOET worden verhoogd als nieuwe, met de vorige versie compatibele wijzigingen worden gedaan aan de publieke API. Het MOET worden verhoogd op het moment dat publieke-API-functionaliteit wordt uitgefaseerd. Het MAG worden verhoogd als substantiële nieuwe functionaliteit of verbeteringen worden doorgevoerd in de afgeschermde code. Het MAG ook wijzigingen van niveau patch bevatten. De patchversie MOET op 0 worden teruggezet wanneer een mineurversie is verhoogd.
        
      
    
  
  
    
      
        
          Majeurversie X (X.y.z
          X > 0) MOET worden verhoogd als wijzigingen worden doorgevoerd niet compatibel zijn met de publieke API. Het MAG ook wijzigingen van niveau mineur en patch bevatten. De patch- en mineurversie MOETEN op 0 worden teruggezet wanneer majeurversie is verhoogd.
        
      
    
  
  
    Een prerelease-versie MAG worden aangeduid met de toevoeging van een koppelteken en een serie van puntgescheiden id’s direct volgend op de patchversie. Id’s MOETEN slechts bestaan uit alfanumerieke ASCII karakters en koppeltekens [0-9A-Za-z-]. Id’s MOGEN NIET leeg zijn. Voorloopnullen MOGEN NIET aanwezig zijn in numerieke id’s. Prerelease-versies hebben een lagere prioriteit dan de bijbehorende reguliere versie. Een prerelease-versie impliceert instabiel te zijn en voldoet mogelijk niet aan de voorgenomen compatibiliteitseisen zoals aangeduid bij de bijbehorende reguliere versie. Voorbeelden: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92, 1.0.0-x-y-z.–.
  
  
    Build-metadata MAG worden aangeduid door het toevoegen van een plusteken en een serie van puntgescheiden id’s direct volgend op de patch- of prereleaseversie. Id’s MOETEN slechts bestaan uit alfanumerieke ASCII-karakters en koppeltekens [0-9A-Za-z-]. Id’s MOGEN NIET leeg zijn. Build-metadata MOET genegeerd worden wanneer versieprioriteit wordt bepaald. Kortom, twee verschillende versies welke alleen verschillen in build-metadata hebben dezelfde prioriteit. Voorbeelden: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3—-117B344092BD.
  
  
    Prioriteit refereert naar hoe versies in relatie tot elkaar staan wanneer ze zijn gesorteerd.

    
      
        Prioriteit MOET worden berekend door de versie te scheiden in de majeur-, mineur-, patch- en prerelease-id’s, in die volgorde. (Build-metadata wordt niet meegenomen in het bepalen van prioriteit).
      
      
        De prioriteit wordt bepaald door het eerste gevonden verschil wanneer elk van de id’s van links naar rechts onderling vergeleken worden, op de volgende manier: majeur, mineur en patchversies worden altijd numeriek vergeleken. Voorbeeld: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Wanneer majeur, mineur en patch gelijk zijn, heeft een prerelease-versie lagere prioriteit dan een normale versie. Voorbeeld: 1.0.0-alpha < 1.0.0.
      
      
        Prioriteit voor twee prerelease-versies met dezelfde majeur-, mineur- en patchversie MOET worden bepaald door vergelijking van elk puntgescheiden id van links naar rechts tot een verschil is gevonden, en wel zo:

        
          
            Id’s alleen bestaand uit cijfers worden numeriek vergeleken.
          
          
            Id’s met letters of koppeltekens worden lexicaal vergeleken in de ASCII-volgorde.
          
          
            Numerieke id’s hebben altijd een lagere prioriteit dan niet-numerieke id’s.
          
          
            Een grote reeks met prerelease-velden heeft een hogere prioriteit dan een kleinere als alle voorafgaande id’s gelijk zijn. Voorbeeld:: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
          
        
      
    
  


Backus–Naur Form grammatica voor geldige SemVer-versies
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


Waarom semantisch versioneren?

Dit is geen nieuw of revolutionair idee, waarschijnlijk gebruik je al iets wat hier erg op lijkt. En daar gaat het nu juist om: dat is niet goed genoeg. Zonder je aan een formele specificatie te houden zijn versienummers in essentie nutteloos voor afhankelijkheidsbeheer. Door de bovenstaande ideeën een naam te geven en ze helder te definiëren, is het makkelijker om je bedoelingen over te brengen aan de gebruikers van je software. Pas als deze bedoelingen helder en flexibel (maar niet te flexibel) zijn, kunnen eindelijk specificaties over afhankelijkheid worden gemaakt.

Een eenvoudig voorbeeld toont aan hoe Semantisch Versioneren voorgoed afrekent met de hel van afhankelijkheden. Denk aan een softwarebibliotheek genaamd “Brandweerwagen”. Deze heeft een SemVer-package genaamd “Ladder” nodig. Op het moment dat Brandweerwagen uitgebracht wordt, zit Ladder op versie 3.1.0. Omdat Brandweerwagen functionaliteit gebruikt die is geïntroduceerd in versie 3.1.0, kun je veilig vastleggen dat de afhankelijkheid van Ladder groter dan of gelijk is aan 3.1.0 maar kleiner dan 4.0.0. Als Ladder-versie 3.1.1 en 3.2.0 beschikbaar komen, kunnen deze worden gepubliceerd naar het package-beheersysteem wetend dat ze compatibel zijn met huidige, afhankelijke software.

Als een verantwoordelijke ontwikkelaar wil je natuurlijk nagaan dat alle package-upgrades functioneren zoals beschreven. De echte wereld is turbulent; daar kunnen we niets aan doen anders dan waakzaam zijn. Je kunt Semantisch Versioneren gebruiken als een verstandige en logische manier om packages uit te brengen en bij te werken, zonder nieuwe versies van afhankelijke packages uit te moeten brengen. Dat bespaart tijd en gedoe.

Als bovenstaande aantrekkelijk klinkt, is het enige wat je hoeft te doen verklaren dat je Semantisch Versioneert en dan de regels volgen. Verwijs naar deze website vanuit je README zodat anderen deze regels ook kennen en er profijt van kunnen hebben.

FAQ

Hoe kan ik omgaan met correcties in de 0.y.z eerste ontwikkelfase?

Het makkelijkst is om de release van de eerste ontwikkelfase te starten met 0.1.0 en vervolgens met een mineurversie ophogen voor elke volgende release.

Hoe weet ik wanneer ik versie 1.0.0 kan uitbrengen?

Als de software reeds in productie gebruikt wordt, is hij waarschijnlijk al versie 1.0.0. Als je een stabiele API hebt waar gebruikers van afhankelijk zijn, dan dien je op versie 1.0.0 te zitten. Bij zorgen over compatibiliteit met vorige versies is het ook hoog tijd voor versie 1.0.0.

Werkt dit niet ontmoedigend voor snel ontwikkelen en snelle iteraties?

Bij majeurversie nul draait het om snelle ontwikkeling. Als je de API dagelijks wijzigt zou je nog op versie 0.y.z moeten zitten of op een aparte ontwikkelbranch voor de volgende majeurversie.

Als zelfs kleine niet-compatibele wijzigingen aan de publieke API zorgen voor een verhoging van de majeurversie, zit ik dan niet binnen afzienbare tijd op versie 42.0.0?

Het gaat hier om verantwoordelijk ontwikkelen en voortschrijdend inzicht. Niet-compatibele wijzigingen dienen niet licht opgevat te worden als het om software gaat waar veel van afhankelijk is. De ontwikkelkosten voor een upgrade kunnen significant zijn. Een majeurversie verhogen voor het uitbrengen van niet-compatibele wijzigingen betekent dat je moet nadenken over de impact van de wijzigingen en daarbij de kosten en baten in overweging moet nemen.

Het is veel te veel werk om de volledige publieke API te documenteren!

Het is je verantwoordelijkheid als professioneel ontwikkelaar om software die door anderen gebruikt wordt adequaat te documenteren. Een essentieel onderdeel van een efficiënt softwareproject is om de complexiteit beheersbaar te houden, wat bijzonder lastig wordt als niemand weet hoe je software gebruikt moet worden en welke methoden veilig zijn aan te roepen. Op de lange duur zorgen Semantisch Versioneren en het hameren op een goed gedocumenteerde API ervoor dat de zaken soepel lopen.

Wat als ik per ongeluk een niet-compatibele wijziging uitbreng als een mineurversie?

Als je je realiseert dat je de regels van Semantisch Versioneren overtreden hebt, breng dan zo snel mogelijk een nieuwe mineurversie uit die het probleem oplost en de incompatibiliteit met de vorige versie repareert. Zelfs onder deze omstandigheden is het onacceptabel dat reeds uitgebrachte versies gewijzigd worden. Indien toepasselijk, documenteer de foute versie en informeer je gebruikers over het probleem zodat ze er rekening mee kunnen houden.

Wat moet ik doen als ik mijn eigen afhankelijkheden bijwerk zonder wijzigingen aan de publieke API?

Dit wordt beschouwd als compatibel omdat het geen effect heeft op de publieke API. Software die expliciet afhankelijk is van dezelfde afhankelijkheden als jouw package, dient eigen specificaties over deze afhankelijkheden te hebben waarbij de maker conflicten zal opmerken. Bepalen of de wijziging van het niveau patch of mineur is hangt af van het feit of je afhankelijkheden zijn bijgewerkt om een bug op te lossen of om nieuwe functionaliteit uit te brengen. Voor het tweede is er meestal nieuwe code toegevoegd, wat het zonder twijfel een mineure wijziging maakt.

Wat als ik per ongeluk de publieke API aanpas op een manier die niet strookt met de wijziging in het versienummer (bijvoorbeeld: de code introduceert een majeure niet-compatibele wijziging in een patchrelease)?

Gebruik je gezond verstand. Bij een groot publiek dat veel hinder ondervindt als het gedrag van de publieke API weer wordt aangepast, kan het de beste keus zijn om een majeure versie uit te brengen ook al is de wijziging eigenlijk een patch. Onthoud dat Semantisch Versioneren vooral gaat over het geven van betekenis aan de manier waarop het versienummer verandert. Als deze wijzigingen belangrijk zijn voor je gebruikers, zet dan het versienummer in om ze hierover te informeren.

Hoe moet ik omgaan met uitgefaseerde functionaliteit?

Het uitfaseren van bestaande functionaliteit is een normaal onderdeel van softwareontwikkeling en is vaak vereist om voortgang te maken. Als een deel van je publieke API uitgefaseerd wordt, dienen er twee dingen te veranderen: (1) werk documentatie bij zodat gebruikers op de hoogte zijn van de wijziging, (2) breng een nieuwe mineurversie uit waaruit duidelijk wordt dat de functionaliteit wordt uitgefaseerd. Voordat je met een majeure versie de functionaliteit helemaal verwijdert, dient er tenminste één mineurversie uitgebracht te zijn die duidelijk maakt dat de functionaliteit wordt uitgefaseerd, zodat gebruikers een soepele overgang hebben naar de nieuwe API.

Is er binnen SemVer een limiet op het aantal tekens van de versienaam?

Nee, maar hou het realistisch. Een versie die 255 karakters bevat is waarschijnlijk overdreven. Bepaalde systemen kunnen ook eigen limieten stellen aan de lengte van de versienaam.

Is “v1.2.3” een semantische versie?

Nee, “v.1.2.3” is geen semantische versie. Echter, het prefixen van een semantische versie met de letter “v” is een veel voorkomende manier (in het Engels) om aan te geven dat het een versienummer betreft. Het afkorten van “versie” met “v” wordt vaak gezien bij versiebeheer. Voorbeeld: git tag v1.2.3 -m "Release version 1.2.3", in dit geval is “v.1.2.3” een naamtag en de semantische versie is “1.2.3”.

Bestaat er een reguliere expressie (RegEx) om een SemVer-tekenreeks te controleren?

Er zijn er twee. De ene bevat named groups voor systemen die dit ondersteunen (PCRE [Perl Compatible Regular Expressions, zoals Perl, PHP and R], Python
en Go).

Zie ook: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


En een met numbered capture groups (dus cg1 = majeur, cg2 = mineur, cg3 = patch, cg4 = prerelease and cg5 = buildmetadata) die compatibel is met ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,zoals Perl, PHP and R), Python and Go.

Zie ook: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Over

De specificatie van Semantisch Versioneren is oorspronkelijk geschreven door Tom Preston-Werner, uitvinder van Gravatar en medeoprichter van GitHub.

Feedback kan achtergelaten worden door een issue op GitHub te openen.

Vertaling door: Niek van Galen (auteur), Pieter Edelman (redacteur), Alexander Henket (redacteur)

Licentie

Creative Commons ― CC BY 3.0\nSemantisch Versioneren 2.0.0\nGegeven een versienummer in de vorm MAJEUR.MINEUR.PATCH, worden de individuele elementen als volgt verhoogd:\nMAJEUR wordt verhoogd bij incompatibele API-wijzigingen,\nMINEUR wordt verhoogd bij het toevoegen van functionaliteit die compatibel is met de vorige versie, en\nPATCH wordt verhoogd bij compatibele bugfixes.\nEr zijn aanvullende labels beschikbaar voor pre-release en build-metadata om toe te voegen aan het MAJEUR.MINEUR.PATCH-formaat.\nIn de wereld van softwarebeheer bestaat er een gevreesde plek genaamd “dependency hell” oftewel de “hel van afhankelijkheden”. Hoe groter een systeem wordt en hoe meer packages er worden geïntegreerd in de software, des te aannemelijker is het dat je op een zekere dag belandt op deze mistroostige plek.\nHet uitbrengen van een nieuwe packageversie kan al snel een nachtmerrie worden als systemen te maken hebben met een hoop afhankelijkheden. Als de afhankelijkheden te strikt gespecificeerd zijn, ontstaat het gevaar op “version lock”: het is dan niet meer mogelijk om een package te upgraden zonder dat alle afhankelijke packages ook een versie verhoogd moeten worden. Als de afhankelijkheden te losjes zijn gespecificeerd, zul je onvermijdelijk worden gebeten door het fenomeen versievermenging: de verwachting dat er meer compatibiliteit is met toekomstige versies dan je redelijkerwijs mag verwachten. Je bevindt je in de hel van afhankelijkheden wanneer “version lock” en/of versievermenging zodanig in de weg zitten dat je project niet makkelijk en veilig kan worden voortgezet.\nAls oplossing voor dit probleem stel ik een simpele set van regels en voorwaarden voor die beschrijven hoe versienummers toegewezen en verhoogd worden. Deze regels zijn gebaseerd op, maar niet noodzakelijk beperkt tot reeds bestaande en wijdverspreide gebruiken in zowel gesloten als opensource-software. Om dit systeem succesvol te laten zijn, is het als eerste nodig om je API publiek te declareren. Of deze nu bestaat uit documentatie of wordt afgedwongen door de code zelf maakt niet uit: het belangrijkste is dat de API duidelijk en exact is. Zodra je je publieke API geïdentificeerd hebt, worden wijzigingen gecommuniceerd met specifieke verhogingen in het versienummer. Gebruik een versieformaat van X.Y.Z (Majeur.Mineur.Patch). Bugfixes zonder effect op de API verhogen de patchversie, toevoegingen en wijzigingen aan de API die compatibel zijn met de vorige versie verhogen de mineurversie en wijzigingen aan de API die niet compatibel zijn met de vorige versie verhogen de majeurversie.\nIk noem dit systeem “Semantisch Versioneren”, waarmee versienummers en de manier waarop ze veranderen en verhoogd worden duiding geven over de onderliggende code en wat er is aangepast tussen de verschillende versies.\nSpecificatie Semantisch Versioneren (SemVer)\nDe termen “MOET” (“MUST”), “MAG NIET” (“MUST NOT”), “VERPLICHT” (“REQUIRED”), “ZAL” (“SHALL”), “ZAL NIET” (“SHALL NOT”), “ZOU MOETEN” (“SHOULD”), “ZOU NIET MOETEN” (“SHOULD NOT”), “AANBEVOLEN” (“RECOMMENDED”), “MAG” (“MAY”), “OPTIONEEL” (“OPTIONAL”) in dit document dienen te worden geïnterpreteerd zoals beschreven in RFC 2119.\nSoftware die gebruikmaakt van Semantisch Versioneren MOET een publieke API declareren. Deze API kan worden gepubliceerd in de code of strikt uit documentatie bestaan. Ongeacht de vorm is het de bedoeling dat deze nauwkeurig en uitgebreid ZOU MOETEN zijn.\nSoftware die gebruikmaakt van Semantisch Versioneren MOET een publieke API declareren. Deze API kan worden gepubliceerd in de code of strikt uit documentatie bestaan. Ongeacht de vorm is het de bedoeling dat deze nauwkeurig en uitgebreid ZOU MOETEN zijn.\nEen normaal versienummer MOET de structuur X.Y.Z. hebben, waar X, Y en Z een niet-negatief geheel getal zijn. Voorloopnullen MOGEN NIET aanwezig zijn. X is de majeurversie, Y is de mineurversie en Z is de patchversie. Elk element MOET numeriek ophogen. Bijvoorbeeld: 1.9.0 -> 1.10.0 -> 1.11.0.\nEen normaal versienummer MOET de structuur X.Y.Z. hebben, waar X, Y en Z een niet-negatief geheel getal zijn. Voorloopnullen MOGEN NIET aanwezig zijn. X is de majeurversie, Y is de mineurversie en Z is de patchversie. Elk element MOET numeriek ophogen. Bijvoorbeeld: 1.9.0 -> 1.10.0 -> 1.11.0.\nWanneer een geversioneerd package is gepubliceerd, MAG de inhoud NIET worden aangepast. Alle wijzigingen MOETEN worden gepubliceerd als een nieuwe versie.\nWanneer een geversioneerd package is gepubliceerd, MAG de inhoud NIET worden aangepast. Alle wijzigingen MOETEN worden gepubliceerd als een nieuwe versie.\nMajeurversie nul (0.y.z) is voor de eerste ontwikkelfase. Alles MAG op ieder moment veranderen. De publieke API ZOU NIET als stabiel MOETEN worden beschouwd.\nMajeurversie nul (0.y.z) is voor de eerste ontwikkelfase. Alles MAG op ieder moment veranderen. De publieke API ZOU NIET als stabiel MOETEN worden beschouwd.\nVersie 1.0.0 definieert de publieke API. De manier waarop het versienummer wordt verhoogd na deze release is afhankelijk van de publieke API en hoe deze verandert.\nVersie 1.0.0 definieert de publieke API. De manier waarop het versienummer wordt verhoogd na deze release is afhankelijk van de publieke API en hoe deze verandert.\nPatchversie Z (x.y.Z
          x > 0) MOET worden verhoogd als wijzigingen zijn doorgevoerd die compatibel zijn met de vorige versie. De definitie van een bugfix is een interne wijziging welke foutief gedrag corrigeert.\nx > 0) MOET worden verhoogd als wijzigingen zijn doorgevoerd die compatibel zijn met de vorige versie. De definitie van een bugfix is een interne wijziging welke foutief gedrag corrigeert.\nMineurversie Y (x.Y.z
          x > 0) MOET worden verhoogd als nieuwe, met de vorige versie compatibele wijzigingen worden gedaan aan de publieke API. Het MOET worden verhoogd op het moment dat publieke-API-functionaliteit wordt uitgefaseerd. Het MAG worden verhoogd als substantiële nieuwe functionaliteit of verbeteringen worden doorgevoerd in de afgeschermde code. Het MAG ook wijzigingen van niveau patch bevatten. De patchversie MOET op 0 worden teruggezet wanneer een mineurversie is verhoogd.\nMineurversie Y (x.Y.z\nx > 0) MOET worden verhoogd als nieuwe, met de vorige versie compatibele wijzigingen worden gedaan aan de publieke API. Het MOET worden verhoogd op het moment dat publieke-API-functionaliteit wordt uitgefaseerd. Het MAG worden verhoogd als substantiële nieuwe functionaliteit of verbeteringen worden doorgevoerd in de afgeschermde code. Het MAG ook wijzigingen van niveau patch bevatten. De patchversie MOET op 0 worden teruggezet wanneer een mineurversie is verhoogd.\nMajeurversie X (X.y.z
          X > 0) MOET worden verhoogd als wijzigingen worden doorgevoerd niet compatibel zijn met de publieke API. Het MAG ook wijzigingen van niveau mineur en patch bevatten. De patch- en mineurversie MOETEN op 0 worden teruggezet wanneer majeurversie is verhoogd.\nMajeurversie X (X.y.z\nX > 0) MOET worden verhoogd als wijzigingen worden doorgevoerd niet compatibel zijn met de publieke API. Het MAG ook wijzigingen van niveau mineur en patch bevatten. De patch- en mineurversie MOETEN op 0 worden teruggezet wanneer majeurversie is verhoogd.\nEen prerelease-versie MAG worden aangeduid met de toevoeging van een koppelteken en een serie van puntgescheiden id’s direct volgend op de patchversie. Id’s MOETEN slechts bestaan uit alfanumerieke ASCII karakters en koppeltekens [0-9A-Za-z-]. Id’s MOGEN NIET leeg zijn. Voorloopnullen MOGEN NIET aanwezig zijn in numerieke id’s. Prerelease-versies hebben een lagere prioriteit dan de bijbehorende reguliere versie. Een prerelease-versie impliceert instabiel te zijn en voldoet mogelijk niet aan de voorgenomen compatibiliteitseisen zoals aangeduid bij de bijbehorende reguliere versie. Voorbeelden: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92, 1.0.0-x-y-z.–.\nEen prerelease-versie MAG worden aangeduid met de toevoeging van een koppelteken en een serie van puntgescheiden id’s direct volgend op de patchversie. Id’s MOETEN slechts bestaan uit alfanumerieke ASCII karakters en koppeltekens [0-9A-Za-z-]. Id’s MOGEN NIET leeg zijn. Voorloopnullen MOGEN NIET aanwezig zijn in numerieke id’s. Prerelease-versies hebben een lagere prioriteit dan de bijbehorende reguliere versie. Een prerelease-versie impliceert instabiel te zijn en voldoet mogelijk niet aan de voorgenomen compatibiliteitseisen zoals aangeduid bij de bijbehorende reguliere versie. Voorbeelden: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92, 1.0.0-x-y-z.–.\nBuild-metadata MAG worden aangeduid door het toevoegen van een plusteken en een serie van puntgescheiden id’s direct volgend op de patch- of prereleaseversie. Id’s MOETEN slechts bestaan uit alfanumerieke ASCII-karakters en koppeltekens [0-9A-Za-z-]. Id’s MOGEN NIET leeg zijn. Build-metadata MOET genegeerd worden wanneer versieprioriteit wordt bepaald. Kortom, twee verschillende versies welke alleen verschillen in build-metadata hebben dezelfde prioriteit. Voorbeelden: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3—-117B344092BD.\nBuild-metadata MAG worden aangeduid door het toevoegen van een plusteken en een serie van puntgescheiden id’s direct volgend op de patch- of prereleaseversie. Id’s MOETEN slechts bestaan uit alfanumerieke ASCII-karakters en koppeltekens [0-9A-Za-z-]. Id’s MOGEN NIET leeg zijn. Build-metadata MOET genegeerd worden wanneer versieprioriteit wordt bepaald. Kortom, twee verschillende versies welke alleen verschillen in build-metadata hebben dezelfde prioriteit. Voorbeelden: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3—-117B344092BD.\nPrioriteit refereert naar hoe versies in relatie tot elkaar staan wanneer ze zijn gesorteerd.

    
      
        Prioriteit MOET worden berekend door de versie te scheiden in de majeur-, mineur-, patch- en prerelease-id’s, in die volgorde. (Build-metadata wordt niet meegenomen in het bepalen van prioriteit).
      
      
        De prioriteit wordt bepaald door het eerste gevonden verschil wanneer elk van de id’s van links naar rechts onderling vergeleken worden, op de volgende manier: majeur, mineur en patchversies worden altijd numeriek vergeleken. Voorbeeld: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Wanneer majeur, mineur en patch gelijk zijn, heeft een prerelease-versie lagere prioriteit dan een normale versie. Voorbeeld: 1.0.0-alpha < 1.0.0.
      
      
        Prioriteit voor twee prerelease-versies met dezelfde majeur-, mineur- en patchversie MOET worden bepaald door vergelijking van elk puntgescheiden id van links naar rechts tot een verschil is gevonden, en wel zo:

        
          
            Id’s alleen bestaand uit cijfers worden numeriek vergeleken.
          
          
            Id’s met letters of koppeltekens worden lexicaal vergeleken in de ASCII-volgorde.
          
          
            Numerieke id’s hebben altijd een lagere prioriteit dan niet-numerieke id’s.
          
          
            Een grote reeks met prerelease-velden heeft een hogere prioriteit dan een kleinere als alle voorafgaande id’s gelijk zijn. Voorbeeld:: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPrioriteit refereert naar hoe versies in relatie tot elkaar staan wanneer ze zijn gesorteerd.\nPrioriteit MOET worden berekend door de versie te scheiden in de majeur-, mineur-, patch- en prerelease-id’s, in die volgorde. (Build-metadata wordt niet meegenomen in het bepalen van prioriteit).\nPrioriteit MOET worden berekend door de versie te scheiden in de majeur-, mineur-, patch- en prerelease-id’s, in die volgorde. (Build-metadata wordt niet meegenomen in het bepalen van prioriteit).\nDe prioriteit wordt bepaald door het eerste gevonden verschil wanneer elk van de id’s van links naar rechts onderling vergeleken worden, op de volgende manier: majeur, mineur en patchversies worden altijd numeriek vergeleken. Voorbeeld: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nDe prioriteit wordt bepaald door het eerste gevonden verschil wanneer elk van de id’s van links naar rechts onderling vergeleken worden, op de volgende manier: majeur, mineur en patchversies worden altijd numeriek vergeleken. Voorbeeld: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nWanneer majeur, mineur en patch gelijk zijn, heeft een prerelease-versie lagere prioriteit dan een normale versie. Voorbeeld: 1.0.0-alpha < 1.0.0.\nWanneer majeur, mineur en patch gelijk zijn, heeft een prerelease-versie lagere prioriteit dan een normale versie. Voorbeeld: 1.0.0-alpha < 1.0.0.\nPrioriteit voor twee prerelease-versies met dezelfde majeur-, mineur- en patchversie MOET worden bepaald door vergelijking van elk puntgescheiden id van links naar rechts tot een verschil is gevonden, en wel zo:

        
          
            Id’s alleen bestaand uit cijfers worden numeriek vergeleken.
          
          
            Id’s met letters of koppeltekens worden lexicaal vergeleken in de ASCII-volgorde.
          
          
            Numerieke id’s hebben altijd een lagere prioriteit dan niet-numerieke id’s.
          
          
            Een grote reeks met prerelease-velden heeft een hogere prioriteit dan een kleinere als alle voorafgaande id’s gelijk zijn. Voorbeeld:: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPrioriteit voor twee prerelease-versies met dezelfde majeur-, mineur- en patchversie MOET worden bepaald door vergelijking van elk puntgescheiden id van links naar rechts tot een verschil is gevonden, en wel zo:\nId’s alleen bestaand uit cijfers worden numeriek vergeleken.\nId’s alleen bestaand uit cijfers worden numeriek vergeleken.\nId’s met letters of koppeltekens worden lexicaal vergeleken in de ASCII-volgorde.\nId’s met letters of koppeltekens worden lexicaal vergeleken in de ASCII-volgorde.\nNumerieke id’s hebben altijd een lagere prioriteit dan niet-numerieke id’s.\nNumerieke id’s hebben altijd een lagere prioriteit dan niet-numerieke id’s.\nEen grote reeks met prerelease-velden heeft een hogere prioriteit dan een kleinere als alle voorafgaande id’s gelijk zijn. Voorbeeld:: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nEen grote reeks met prerelease-velden heeft een hogere prioriteit dan een kleinere als alle voorafgaande id’s gelijk zijn. Voorbeeld:: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nBackus–Naur Form grammatica voor geldige SemVer-versies\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nWaarom semantisch versioneren?\nDit is geen nieuw of revolutionair idee, waarschijnlijk gebruik je al iets wat hier erg op lijkt. En daar gaat het nu juist om: dat is niet goed genoeg. Zonder je aan een formele specificatie te houden zijn versienummers in essentie nutteloos voor afhankelijkheidsbeheer. Door de bovenstaande ideeën een naam te geven en ze helder te definiëren, is het makkelijker om je bedoelingen over te brengen aan de gebruikers van je software. Pas als deze bedoelingen helder en flexibel (maar niet te flexibel) zijn, kunnen eindelijk specificaties over afhankelijkheid worden gemaakt.\nEen eenvoudig voorbeeld toont aan hoe Semantisch Versioneren voorgoed afrekent met de hel van afhankelijkheden. Denk aan een softwarebibliotheek genaamd “Brandweerwagen”. Deze heeft een SemVer-package genaamd “Ladder” nodig. Op het moment dat Brandweerwagen uitgebracht wordt, zit Ladder op versie 3.1.0. Omdat Brandweerwagen functionaliteit gebruikt die is geïntroduceerd in versie 3.1.0, kun je veilig vastleggen dat de afhankelijkheid van Ladder groter dan of gelijk is aan 3.1.0 maar kleiner dan 4.0.0. Als Ladder-versie 3.1.1 en 3.2.0 beschikbaar komen, kunnen deze worden gepubliceerd naar het package-beheersysteem wetend dat ze compatibel zijn met huidige, afhankelijke software.\nAls een verantwoordelijke ontwikkelaar wil je natuurlijk nagaan dat alle package-upgrades functioneren zoals beschreven. De echte wereld is turbulent; daar kunnen we niets aan doen anders dan waakzaam zijn. Je kunt Semantisch Versioneren gebruiken als een verstandige en logische manier om packages uit te brengen en bij te werken, zonder nieuwe versies van afhankelijke packages uit te moeten brengen. Dat bespaart tijd en gedoe.\nAls bovenstaande aantrekkelijk klinkt, is het enige wat je hoeft te doen verklaren dat je Semantisch Versioneert en dan de regels volgen. Verwijs naar deze website vanuit je README zodat anderen deze regels ook kennen en er profijt van kunnen hebben.\nHoe kan ik omgaan met correcties in de 0.y.z eerste ontwikkelfase?\nHet makkelijkst is om de release van de eerste ontwikkelfase te starten met 0.1.0 en vervolgens met een mineurversie ophogen voor elke volgende release.\nHoe weet ik wanneer ik versie 1.0.0 kan uitbrengen?\nAls de software reeds in productie gebruikt wordt, is hij waarschijnlijk al versie 1.0.0. Als je een stabiele API hebt waar gebruikers van afhankelijk zijn, dan dien je op versie 1.0.0 te zitten. Bij zorgen over compatibiliteit met vorige versies is het ook hoog tijd voor versie 1.0.0.\nWerkt dit niet ontmoedigend voor snel ontwikkelen en snelle iteraties?\nBij majeurversie nul draait het om snelle ontwikkeling. Als je de API dagelijks wijzigt zou je nog op versie 0.y.z moeten zitten of op een aparte ontwikkelbranch voor de volgende majeurversie.\nAls zelfs kleine niet-compatibele wijzigingen aan de publieke API zorgen voor een verhoging van de majeurversie, zit ik dan niet binnen afzienbare tijd op versie 42.0.0?\nHet gaat hier om verantwoordelijk ontwikkelen en voortschrijdend inzicht. Niet-compatibele wijzigingen dienen niet licht opgevat te worden als het om software gaat waar veel van afhankelijk is. De ontwikkelkosten voor een upgrade kunnen significant zijn. Een majeurversie verhogen voor het uitbrengen van niet-compatibele wijzigingen betekent dat je moet nadenken over de impact van de wijzigingen en daarbij de kosten en baten in overweging moet nemen.\nHet is veel te veel werk om de volledige publieke API te documenteren!\nHet is je verantwoordelijkheid als professioneel ontwikkelaar om software die door anderen gebruikt wordt adequaat te documenteren. Een essentieel onderdeel van een efficiënt softwareproject is om de complexiteit beheersbaar te houden, wat bijzonder lastig wordt als niemand weet hoe je software gebruikt moet worden en welke methoden veilig zijn aan te roepen. Op de lange duur zorgen Semantisch Versioneren en het hameren op een goed gedocumenteerde API ervoor dat de zaken soepel lopen.\nWat als ik per ongeluk een niet-compatibele wijziging uitbreng als een mineurversie?\nAls je je realiseert dat je de regels van Semantisch Versioneren overtreden hebt, breng dan zo snel mogelijk een nieuwe mineurversie uit die het probleem oplost en de incompatibiliteit met de vorige versie repareert. Zelfs onder deze omstandigheden is het onacceptabel dat reeds uitgebrachte versies gewijzigd worden. Indien toepasselijk, documenteer de foute versie en informeer je gebruikers over het probleem zodat ze er rekening mee kunnen houden.\nWat moet ik doen als ik mijn eigen afhankelijkheden bijwerk zonder wijzigingen aan de publieke API?\nDit wordt beschouwd als compatibel omdat het geen effect heeft op de publieke API. Software die expliciet afhankelijk is van dezelfde afhankelijkheden als jouw package, dient eigen specificaties over deze afhankelijkheden te hebben waarbij de maker conflicten zal opmerken. Bepalen of de wijziging van het niveau patch of mineur is hangt af van het feit of je afhankelijkheden zijn bijgewerkt om een bug op te lossen of om nieuwe functionaliteit uit te brengen. Voor het tweede is er meestal nieuwe code toegevoegd, wat het zonder twijfel een mineure wijziging maakt.\nWat als ik per ongeluk de publieke API aanpas op een manier die niet strookt met de wijziging in het versienummer (bijvoorbeeld: de code introduceert een majeure niet-compatibele wijziging in een patchrelease)?\nGebruik je gezond verstand. Bij een groot publiek dat veel hinder ondervindt als het gedrag van de publieke API weer wordt aangepast, kan het de beste keus zijn om een majeure versie uit te brengen ook al is de wijziging eigenlijk een patch. Onthoud dat Semantisch Versioneren vooral gaat over het geven van betekenis aan de manier waarop het versienummer verandert. Als deze wijzigingen belangrijk zijn voor je gebruikers, zet dan het versienummer in om ze hierover te informeren.\nHoe moet ik omgaan met uitgefaseerde functionaliteit?\nHet uitfaseren van bestaande functionaliteit is een normaal onderdeel van softwareontwikkeling en is vaak vereist om voortgang te maken. Als een deel van je publieke API uitgefaseerd wordt, dienen er twee dingen te veranderen: (1) werk documentatie bij zodat gebruikers op de hoogte zijn van de wijziging, (2) breng een nieuwe mineurversie uit waaruit duidelijk wordt dat de functionaliteit wordt uitgefaseerd. Voordat je met een majeure versie de functionaliteit helemaal verwijdert, dient er tenminste één mineurversie uitgebracht te zijn die duidelijk maakt dat de functionaliteit wordt uitgefaseerd, zodat gebruikers een soepele overgang hebben naar de nieuwe API.\nIs er binnen SemVer een limiet op het aantal tekens van de versienaam?\nNee, maar hou het realistisch. Een versie die 255 karakters bevat is waarschijnlijk overdreven. Bepaalde systemen kunnen ook eigen limieten stellen aan de lengte van de versienaam.\nIs “v1.2.3” een semantische versie?\nNee, “v.1.2.3” is geen semantische versie. Echter, het prefixen van een semantische versie met de letter “v” is een veel voorkomende manier (in het Engels) om aan te geven dat het een versienummer betreft. Het afkorten van “versie” met “v” wordt vaak gezien bij versiebeheer. Voorbeeld: git tag v1.2.3 -m "Release version 1.2.3", in dit geval is “v.1.2.3” een naamtag en de semantische versie is “1.2.3”.\nBestaat er een reguliere expressie (RegEx) om een SemVer-tekenreeks te controleren?\nEr zijn er twee. De ene bevat named groups voor systemen die dit ondersteunen (PCRE [Perl Compatible Regular Expressions, zoals Perl, PHP and R], Python
en Go).\nZie ook: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nEn een met numbered capture groups (dus cg1 = majeur, cg2 = mineur, cg3 = patch, cg4 = prerelease and cg5 = buildmetadata) die compatibel is met ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,zoals Perl, PHP and R), Python and Go.\nZie ook: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nDe specificatie van Semantisch Versioneren is oorspronkelijk geschreven door Tom Preston-Werner, uitvinder van Gravatar en medeoprichter van GitHub.\nFeedback kan achtergelaten worden door een issue op GitHub te openen.\neen issue op GitHub te openen\nVertaling door: Niek van Galen (auteur), Pieter Edelman (redacteur), Alexander Henket (redacteur)\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nWersjonowanie semantyczne 2.0.0

Streszczenie

Dla numeru wersji MAJOR.MINOR.PATCH, zwiększaj:


  wersję MAJOR, gdy dokonujesz zmian niekompatybilnych z API,
  wersję MINOR, gdy dodajesz nową funkcjonalność, która jest kompatybilna
z poprzednimi wersjami,
  wersję PATCH, gdy naprawiasz błąd nie zrywając kompatybilności z poprzednimi
wersjami.


Dodatkowe oznaczenia dla wydania przedpremierowego lub meta-danych buildu są
dostępne jako rozszerzenia formatu MAJOR.MINOR.PATCH.

Wprowadzenie

W świecie zarządzania oprogramowaniem istnieje przerażające miejsce nazywane
„piekłem zależności”. Im bardziej twój system rośnie i im więcej pakietów
integrujesz w swoim oprogramowaniu, tym większe jest prawdopodobieństwo, że
pewnego dnia znajdziesz się w tej otchłani rozpaczy.

W systemach z wieloma zależnościami, wydawanie nowych wersji pakietu może szybko
stać się koszmarem. Jeśli zależności są określone zbyt wąsko, jesteś zagrożony
blokadą wersji (niemożnością zaktualizowania pakietu bez konieczności wydania
nowych wersji każdego zależnego pakietu). Jeśli zależności są określone zbyt
luźno, nieuchronnie natniesz się na „rozwiązłość wersji” (założenie
kompatybilności z większą liczbą kolejnych wersji niż jest to rozsądne). Piekłem
zależności jest sytuacja, w której blokada wersji i/lub rozwiązłość wersji
uniemożliwiają wygodny i bezpieczny rozwój twojego projektu.

Jako rozwiązanie tego problemu proponuję prosty zbiór zasad i wymogów, które
regulują jak przypisywać i zwiększać numery wersji. Zasady te są oparte, ale
niekoniecznie ograniczone, na istniejących wcześniej, szeroko rozpowszechnionych
praktykach, stosowanych zarówno w zamkniętym, jak i otwartym oprogramowaniu. Aby
ten system działał, musisz najpierw określić publiczne API. Może to być
dokumentacja lub może wymusić je sam kod źródłowy. Niezależnie od sposobu
określenia, ważne jest, by to API było przejrzyste i precyzyjne. Kiedy już masz
swoje publiczne API, komunikujesz zmiany w nim określonymi zwiększeniami w swoim
numerze wersji. Rozważmy format wersji X.Y.Z (major.minor.patch). Naprawy błędów
nieingerujących w API zwiększają wersję patch, kompatybilne wstecz
dodatki/zmiany w API zwiększają wersję minor, a niekompatybilne wstecz zmiany
w API zwiększają wersję major.

Nazywam ten system „wersjonowaniem semantycznym”. W tym układzie numery wersji
i sposób, w jaki się zmieniają, przenoszą informacje o kodzie pod spodem i co
było zmieniane z wersji na wersję.

Specyfikacja wersjonowania semantycznego (SemVer)

Terminy „MUSI” („MUST”), „NIE MOŻE” („MUST NOT”), „WYMAGANY” („REQUIRED”), „MA
BYĆ” („SHALL”), „NIE BĘDZIE” („SHALL NOT”), „POWINIEN” („SHOULD”), „NIE
POWINIEN” („SHOULD NOT”), „ZALECANY” („RECOMMENDED”), „MOŻE” („MAY”)
i „OPCJONALNY” („OPTIONAL”) w tym dokumencie należy interpretować jak opisano
w RFC 2119.


  
    Oprogramowanie używające wersjonowania semantycznego MUSI określać swoje
publiczne API. API to może być zadeklarowane w samym kodzie lub może istnieć
w samej dokumentacji. Jakkolwiek jest zdefiniowane, powinno być precyzyjne
i wyczerpujące.
  
  
    Standardowy numer wersji MUSI przyjąć formę X.Y.Z, gdzie X, Y i Z są
nieujemnymi liczbami całkowitymi i NIE MOGĄ zawierać wiodących zer. X jest
wersją major, Y wersją minor, a Z wersją patch. Każdy składnik MUSI rosnąć
numerycznie. Przykładowo: 1.9.0 → 1.10.0 → 1.11.0.
  
  
    Po wydaniu wersjonowanego pakietu zawartość tej wersji NIE MOŻE być
modyfikowana. Jakiekolwiek zmiany MUSZĄ być wydane jako nowa wersja.
  
  
    Wersja major zero (0.y.z) jest przeznaczona dla początkowej fazy rozwoju.
Wszystko może ulec zmianie w dowolnym momencie. Publiczne API nie powinno być
traktowane jako stabilne.
  
  
    Wersja 1.0.0 określa publiczne API. Sposób, w jaki numer wersji jest
zwiększany po tym wydaniu, zależy od tego publicznego API i jak się ono zmienia.
  
  
    Wersja patch Z (x.y.Z | x > 0) MUSI zostać zwiększona, jeśli wprowadza się
tylko kompatybilne wstecz naprawy błędów. Naprawa błędu definiowana jest jako
zmiana wewnętrzna, która usuwa nieprawidłowe działanie.
  
  
    Wersja minor Y (x.Y.z | x > 0) MUSI zostać zwiększona, jeśli nowa,
kompatybilna wstecz funkcjonalność zostaje wprowadzona do publicznego API. MUSI
zostać zwiększona, jeśli jakakolwiek funkcjonalność publicznego API zostaje
zdezaprobowana. MOŻE zostać zwiększona, jeśli wprowadzone zostają nowe znaczące
funkcjonalności lub ulepszenia w obrębie prywatnego kodu. MOŻE ona zawierać
zmiany na poziomie patch. Numer wersji patch MUSI być ustawiony na 0, gdy wersja
minor jest zwiększana.
  
  
    Wersja major X (X.y.z | X > 0) MUSI zostać zwiększona, jeżeli do publicznego
API są wprowadzane jakiekolwiek wstecznie niekompatybilne zmiany. MOŻE zawierać
zmiany na poziomie minor oraz patch. Numery wersji minor oraz patch MUSZĄ być
ustawione na 0, gdy wersja major jest zwiększana.
  
  
    Wydanie przedpremierowe MOŻE być oznaczone przez dołączenie dywizu oraz
zbioru identyfikatorów rozdzielonych kropkami, zaraz za numerem wersji
patch. Identyfikatory MUSZĄ składać się wyłącznie ze znaków alfanumerycznych
ASCII oraz myślników [0-9A-Za-z-]. Identyfikatory NIE MOGĄ być puste. Numeryczne
identyfikatory NIE MOGĄ zawierać wiodących zer. Wydania przedpremierowe
poprzedzają powiązane z nimi wersje standardowe. Wydanie przedpremierowe
wskazuje na niestabilność wersji i możliwość niespełniania wymogów
kompatybilności, które cechują powiązaną z nią standardową wersję. Przykłady:
1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Meta-dane buildu MOGĄ być oznaczone przez dołączenie znaku plus oraz zbioru
identyfikatorów rozdzielonych kropkami, zaraz za numerem wersji patch lub
wydania przedpremierowego. Identyfikatory MUSZĄ składać się wyłącznie ze znaków
alfanumerycznych ASCII oraz myślników [0-9A-Za-z-]. Identyfikatory NIE MOGĄ być
puste. Meta-dane buildu POWINNY być ignorowane przy ustalaniu kolejności wersji.
Zatem dwie wersje różniące się tylko meta-danymi buildu mają ten sam stopień
pierwszeństwa. Przykłady: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85.
  
  
    Pierwszeństwo odnosi się do sposobu porównywania wersji między sobą podczas
ich porządkowania. Pierwszeństwo MUSI być ustalane w rozdzieleniu wersji na
identyfikatory major, minor, patch oraz identyfikator przedpremierowy w podanej
kolejności (meta-dane buildu nie decydują o pierwszeństwie). Pierwszeństwo jest
ustalane przez pierwszą różnicę wykrytą podczas porównania każdego
z identyfikatorów od lewej do prawej: wersje major, minor, patch są zawsze
porównywane numerycznie. Przykład: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Gdy numery
wersji major, minor i patch są równe, wydanie przedpremierowe poprzedza wersję
standardową. Przykładowo: 1.0.0-alpha < 1.0.0. Pierwszeństwo dwóch wydań
przedpremierowych z takimi samymi numerami wersji major, minor i patch MUSI być
ustalane przez porównywanie każdego z identyfikatorów rozdzielonych kropkami
w kierunku od lewej do prawej, póki nie zostanie wykryta różnica w taki sposób:
identyfikatory złożone z samych cyfr porównywane są numerycznie,
a identyfikatory z literami lub dywizami porównywane są leksykalnie w kolejności
ASCII. Identyfikatory numeryczne zawsze poprzedzają identyfikatory
nienumeryczne. Większy zbiór przedpremierowych pól poprzedza mniejszy zbiór,
o ile wszystkie poprzedzające identyfikatory są sobie równe. Przykład:
1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 <
1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Gramatyka poprawnej wersji SemVer w zapisie BNF
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


Dlaczego warto stosować wersjonowanie semantyczne?

To nie jest nowy ani rewolucyjny pomysł. W zasadzie prawdopodobnie już
posługujesz się prawie tą samą metodą. Problem w tym, że „prawie” robi różnicę.
Bez zgodności z jakimś rodzajem formalnej specyfikacji, numery wersji są
całkowicie nieprzydatne przy zarządzaniu zależnościami. Poprzez nadanie nazwy
i jasnych definicji powyższym pomysłom, łatwiejszym staje się przekazywanie
twoich intencji użytkownikom twojego oprogramowania. Gdy te intencje są jasne,
wreszcie da się robić elastyczne (ale nie zbyt elastyczne) specyfikacje
zależności.

Prosty przykład może udowodnić, w jaki sposób wersjonowanie semantyczne może
zamienić piekło zależności w relikt przeszłości. Rozważmy bibliotekę nazwaną
„Wóz strażacki”. Wymaga ona wersjonowanego semantycznie pakietu o nazwie
„Drabina”. W czasie, gdy Wóz strażacki jest tworzony, Drabina jest w wersji
3.1.0. Jako że Wóz strażacki korzysta z funkcjonalności, które zostały
wprowadzone po raz pierwszy w wersji 3.1.0, możesz bezpiecznie założyć, że
wymagana wersja Drabiny jest większa lub równa 3.1.0, ale mniejsza niż 4.0.0.
Teraz gdy staną się dostępne wersje Drabiny 3.1.1 lub 3.2.0, możesz puścić je
w swoim systemie zarządzania pakietami ze świadomością, że będą one kompatybilne
z istniejącym zależnym oprogramowaniem.

Jako odpowiedzialny programista musisz oczywiście zweryfikować, że każde
aktualizacje pakietów działają, jak powinny. Prawdziwy świat potrafi dać w kość;
nic nie możemy z tym zrobić poza zachowaniem czujności. To, co ty możesz zrobić,
to pozwolić by wersjonowanie semantyczne dostarczyło ci rozsądną metodę
wydawania i aktualizowania pakietów bez konieczności wydawania nowych
wersji pakietów zależnych, oszczędzającą ci czas i wysiłek.

Jeśli to wszystko brzmi zachęcająco, wszystko, co musisz zrobić, aby korzystać
z wersjonowania semantycznego, to zadeklarować się, że będziesz to robić,
a następnie przestrzegać zasad. Podlinkuj tę stronę w swoim README, aby inni
znali te zasady i mogli z nich korzystać.

Często zadawane pytania

Jak powinienem zajmować się wersjami w 0.y.z początkowej fazie rozwoju?

Najprościej jest zacząć swoje wydanie początkowej fazy rozwoju od 0.1.0,
a następnie zwiększać wersję minor dla każdego kolejnego wydania.

Skąd mam wiedzieć, kiedy wydać 1.0.0?

Jeśli twoje oprogramowanie jest w użyciu w produkcji, powinno prawdopodobnie już
być 1.0.0. Jeśli masz stabilne API, z którego zaczęli korzystać użytkownicy,
powinieneś mieć 1.0.0. Jeśli dużo się martwisz o kompatybilność wstecz,
powinieneś prawdopodobnie już mieć 1.0.0.

Czy nie opóźnia to szybkiego rozwoju i szybkiej iteracji?

W wersji major zero chodzi o szybki rozwój. Jeśli zmieniasz API codziennie,
powinieneś albo być wciąż w wersji 0.y.z, albo w oddzielnej gałęzi rozwoju,
pracując nad nową wersją major.

Jeśli nawet najmniejsze niekompatybilne wstecz zmiany w publicznym API wymagają podbicia wersji major, czy bardzo szybko nie skończę na wersji 42.0.0?

To jest kwestia odpowiedzialnego programowania i dalekowzroczności.
Niekompatybilne zmiany nie powinny być wprowadzane z lekkością do
oprogramowania, które jest zależnością w wielu miejscach. Koszt, który trzeba
ponieść, by zaktualizować pakiet, może być znamienny. Konieczność podbijania
wersji major przy wprowadzaniu niekompatybilnych zmian powoduje, że będziesz
myślał przez pryzmat siły oddziaływania swoich zmian i szacował stosunek
poniesionych kosztów do zysków.

Stworzenie dokumentacji całego publicznego API to zbyt dużo pracy!

Jako profesjonalny programista jesteś odpowiedzialny za prawidłową dokumentację
oprogramowania, które jest przeznaczone do użytku przez innych. Zarządzanie
złożonością oprogramowania jest niezwykle ważną częścią utrzymania sprawności
projektu, a jest to trudne do zrobienia, jeśli nikt nie wie, jak używać twojego
oprogramowania albo z których metod jest bezpiecznie korzystać. Na dłuższą metę
wersjonowanie semantyczne oraz obstawanie przy dobrze zdefiniowanym publicznym
API pozwoli wszystkim i wszystkiemu działać płynnie.

Co zrobić, jeśli przez przypadek wypuściłem niekompatybilną wstecz zmianę jako wersję minor?

Jak tylko odkryjesz, że zaburzyłeś specyfikację semantycznego wersjonowania,
napraw ten błąd i wydaj nową wersję minor, która niweluje błąd i przywraca
wsteczną kompatybilność. Nawet w takich okolicznościach niedopuszczalne jest
modyfikowanie wydanej wersji. Jeśli możesz, opisz błędną wersję i poinformuj
użytkowników o problemie, aby byli świadomi, że ta wersja jest błędna.

Co powinienem zrobić, jeśli aktualizuję własne zależności bez zmiany publicznego API?

Taka aktualizacja jest uznawana za kompatybilną, gdyż nie narusza publicznego
API. Oprogramowanie, które opiera się na tych samych zależnościach co twój
pakiet, powinno mieć własną specyfikację zależności, a jego autor zauważy
konflikt. Ustalenie, czy zmiana jest na poziomie patch lub, czy jest modyfikacją
na poziomie minor, zależy od tego, czy zaktualizowałeś zależności w celu naprawy
błędu, czy w celu wprowadzenia nowej funkcjonalności. Zazwyczaj spodziewałbym
się dodatkowego kodu w tym drugim przypadku, co oczywiście oznacza zwiększenie
wersji minor.

Co zrobić, gdy nieumyślnie zmieniłem publiczne API w taki sposób, że nie jest już zgodne ze zmianą numeru wersji (tj. kod nieprawidłowo wprowadza zmianę major w wydaniu patch)?

Postępuj zgodnie z rozsądkiem. Jeśli oprogramowanie używane jest przez wielu
użytkowników, dla których zmiana publicznego API do poprzednio zamierzonego
stanu może być dużym uderzeniem, lepiej jest wypuścić nową wersję major, nawet
jeśli problem mógłby być rozwiązany wydaniem wersji patch. Należy pamiętać, że
w semantycznym wersjonowaniu chodzi przede wszystkim o przekazanie znaczenia
zmiany poprzez zmianę numeru wersji. Jeśli zmiany są ważne dla użytkowników,
poinformuj ich o tym poprzez numer wersji.

Jak powinienem radzić sobie z dezaprobowaniem funkcjonalności?

Dezaprobowanie istniejącej funkcjonalności jest normalną częścią programowania
i często jest konieczne, by móc rozwijać oprogramowanie. Gdy wycofujesz część
swojego publicznego API, powinieneś zrobić dwie rzeczy: (1) zaktualizować
dokumentację, by użytkownicy wiedzieli o tej zmianie, (2) wypuścić nowe wydanie
minor z informacją o zdezaprobowaniu. Zanim całkowicie usuniesz funkcjonalność
w nowym wydaniu major, powinno być co najmniej jedno wydanie minor zawierające
informację o zdezaprobowaniu, aby użytkownicy mogli płynnie przejść na nowe API.

Czy SemVer ma limit długości na oznaczenie wersji?

Nie, ale miej zdrowy rozsądek. Na przykład numer wersji długi na 255 znaków to
prawdopodobnie przesada. Ponadto konkretne systemy mogą narzucać swoje własne
ograniczenia na rozmiar tego ciągu znaków.

Czy ciąg „v1.2.3” spełnia zasady?

Nie, „v1.2.3” nie jest zgodne z wersjonowaniem semantycznym. Jednak przedrostek „v” jest
zazwyczaj używany w języku angielskim do oznaczenia, że mamy do czynienia z numerem wersji.
Skrót „v” od angielskiego słowa „version” jest często spotykany w systemach kontroli wersji.
Przykładowo, w przypadku git tag v1.2.3 -m "Release version 1.2.3", „v1.2.3” jest nazwą taga,
a semantyczna wersja to „1.2.3”.

Czy istnieje sugerowane wyrażenie regularne (RegEx) do weryfikacji porawności SemVer?

Istnieją dwa. Pierwsze wykorzystuje grupy nazwane i jest przeznaczone dla systemów, które wspierają tę funkcjonalność (
PCRE [Perl Compatible Regular Expressions, np. Perl, PHP i R], Python czy Go).

Patrz: https://regex101.com/r/Ly7O1x/3/
^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Druga wykorzystuje numerowane grupy przechwytujące (wzór gp1 = major, gp2 = minor, gp3 = patch, gp4 = przedpremierowa i gp5 =
meta-dane buildu) i jest kompatybilna z ECMA Script (JavaScript), PCRE [Perl Compatible Regular Expressions, np. Perl, PHP i R],
Python czy Go.

Patrz: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


O specyfikacji

Autorem specyfikacji wersjonowania semantycznego jest
Tom Preston-Werner, wynalazca Gravatara
i współzałożyciel GitHuba.

Jeśli chcesz podzielić się opinią, prosimy
o otworzenie zgłoszenia na GitHubie.

Licencja

Creative Commons – CC BY 3.0.\nWersjonowanie semantyczne 2.0.0\nDla numeru wersji MAJOR.MINOR.PATCH, zwiększaj:\nwersję MAJOR, gdy dokonujesz zmian niekompatybilnych z API,\nwersję MINOR, gdy dodajesz nową funkcjonalność, która jest kompatybilna
z poprzednimi wersjami,\nwersję PATCH, gdy naprawiasz błąd nie zrywając kompatybilności z poprzednimi
wersjami.\nDodatkowe oznaczenia dla wydania przedpremierowego lub meta-danych buildu są
dostępne jako rozszerzenia formatu MAJOR.MINOR.PATCH.\nW świecie zarządzania oprogramowaniem istnieje przerażające miejsce nazywane
„piekłem zależności”. Im bardziej twój system rośnie i im więcej pakietów
integrujesz w swoim oprogramowaniu, tym większe jest prawdopodobieństwo, że
pewnego dnia znajdziesz się w tej otchłani rozpaczy.\nW systemach z wieloma zależnościami, wydawanie nowych wersji pakietu może szybko
stać się koszmarem. Jeśli zależności są określone zbyt wąsko, jesteś zagrożony
blokadą wersji (niemożnością zaktualizowania pakietu bez konieczności wydania
nowych wersji każdego zależnego pakietu). Jeśli zależności są określone zbyt
luźno, nieuchronnie natniesz się na „rozwiązłość wersji” (założenie
kompatybilności z większą liczbą kolejnych wersji niż jest to rozsądne). Piekłem
zależności jest sytuacja, w której blokada wersji i/lub rozwiązłość wersji
uniemożliwiają wygodny i bezpieczny rozwój twojego projektu.\nJako rozwiązanie tego problemu proponuję prosty zbiór zasad i wymogów, które
regulują jak przypisywać i zwiększać numery wersji. Zasady te są oparte, ale
niekoniecznie ograniczone, na istniejących wcześniej, szeroko rozpowszechnionych
praktykach, stosowanych zarówno w zamkniętym, jak i otwartym oprogramowaniu. Aby
ten system działał, musisz najpierw określić publiczne API. Może to być
dokumentacja lub może wymusić je sam kod źródłowy. Niezależnie od sposobu
określenia, ważne jest, by to API było przejrzyste i precyzyjne. Kiedy już masz
swoje publiczne API, komunikujesz zmiany w nim określonymi zwiększeniami w swoim
numerze wersji. Rozważmy format wersji X.Y.Z (major.minor.patch). Naprawy błędów
nieingerujących w API zwiększają wersję patch, kompatybilne wstecz
dodatki/zmiany w API zwiększają wersję minor, a niekompatybilne wstecz zmiany
w API zwiększają wersję major.\nNazywam ten system „wersjonowaniem semantycznym”. W tym układzie numery wersji
i sposób, w jaki się zmieniają, przenoszą informacje o kodzie pod spodem i co
było zmieniane z wersji na wersję.\nSpecyfikacja wersjonowania semantycznego (SemVer)\nTerminy „MUSI” („MUST”), „NIE MOŻE” („MUST NOT”), „WYMAGANY” („REQUIRED”), „MA
BYĆ” („SHALL”), „NIE BĘDZIE” („SHALL NOT”), „POWINIEN” („SHOULD”), „NIE
POWINIEN” („SHOULD NOT”), „ZALECANY” („RECOMMENDED”), „MOŻE” („MAY”)
i „OPCJONALNY” („OPTIONAL”) w tym dokumencie należy interpretować jak opisano
w RFC 2119.\nOprogramowanie używające wersjonowania semantycznego MUSI określać swoje
publiczne API. API to może być zadeklarowane w samym kodzie lub może istnieć
w samej dokumentacji. Jakkolwiek jest zdefiniowane, powinno być precyzyjne
i wyczerpujące.\nOprogramowanie używające wersjonowania semantycznego MUSI określać swoje
publiczne API. API to może być zadeklarowane w samym kodzie lub może istnieć
w samej dokumentacji. Jakkolwiek jest zdefiniowane, powinno być precyzyjne
i wyczerpujące.\nStandardowy numer wersji MUSI przyjąć formę X.Y.Z, gdzie X, Y i Z są
nieujemnymi liczbami całkowitymi i NIE MOGĄ zawierać wiodących zer. X jest
wersją major, Y wersją minor, a Z wersją patch. Każdy składnik MUSI rosnąć
numerycznie. Przykładowo: 1.9.0 → 1.10.0 → 1.11.0.\nStandardowy numer wersji MUSI przyjąć formę X.Y.Z, gdzie X, Y i Z są
nieujemnymi liczbami całkowitymi i NIE MOGĄ zawierać wiodących zer. X jest
wersją major, Y wersją minor, a Z wersją patch. Każdy składnik MUSI rosnąć
numerycznie. Przykładowo: 1.9.0 → 1.10.0 → 1.11.0.\nPo wydaniu wersjonowanego pakietu zawartość tej wersji NIE MOŻE być
modyfikowana. Jakiekolwiek zmiany MUSZĄ być wydane jako nowa wersja.\nPo wydaniu wersjonowanego pakietu zawartość tej wersji NIE MOŻE być
modyfikowana. Jakiekolwiek zmiany MUSZĄ być wydane jako nowa wersja.\nWersja major zero (0.y.z) jest przeznaczona dla początkowej fazy rozwoju.
Wszystko może ulec zmianie w dowolnym momencie. Publiczne API nie powinno być
traktowane jako stabilne.\nWersja major zero (0.y.z) jest przeznaczona dla początkowej fazy rozwoju.
Wszystko może ulec zmianie w dowolnym momencie. Publiczne API nie powinno być
traktowane jako stabilne.\nWersja 1.0.0 określa publiczne API. Sposób, w jaki numer wersji jest
zwiększany po tym wydaniu, zależy od tego publicznego API i jak się ono zmienia.\nWersja 1.0.0 określa publiczne API. Sposób, w jaki numer wersji jest
zwiększany po tym wydaniu, zależy od tego publicznego API i jak się ono zmienia.\nWersja patch Z (x.y.Z | x > 0) MUSI zostać zwiększona, jeśli wprowadza się
tylko kompatybilne wstecz naprawy błędów. Naprawa błędu definiowana jest jako
zmiana wewnętrzna, która usuwa nieprawidłowe działanie.\nWersja patch Z (x.y.Z | x > 0) MUSI zostać zwiększona, jeśli wprowadza się
tylko kompatybilne wstecz naprawy błędów. Naprawa błędu definiowana jest jako
zmiana wewnętrzna, która usuwa nieprawidłowe działanie.\nWersja minor Y (x.Y.z | x > 0) MUSI zostać zwiększona, jeśli nowa,
kompatybilna wstecz funkcjonalność zostaje wprowadzona do publicznego API. MUSI
zostać zwiększona, jeśli jakakolwiek funkcjonalność publicznego API zostaje
zdezaprobowana. MOŻE zostać zwiększona, jeśli wprowadzone zostają nowe znaczące
funkcjonalności lub ulepszenia w obrębie prywatnego kodu. MOŻE ona zawierać
zmiany na poziomie patch. Numer wersji patch MUSI być ustawiony na 0, gdy wersja
minor jest zwiększana.\nWersja minor Y (x.Y.z | x > 0) MUSI zostać zwiększona, jeśli nowa,
kompatybilna wstecz funkcjonalność zostaje wprowadzona do publicznego API. MUSI
zostać zwiększona, jeśli jakakolwiek funkcjonalność publicznego API zostaje
zdezaprobowana. MOŻE zostać zwiększona, jeśli wprowadzone zostają nowe znaczące
funkcjonalności lub ulepszenia w obrębie prywatnego kodu. MOŻE ona zawierać
zmiany na poziomie patch. Numer wersji patch MUSI być ustawiony na 0, gdy wersja
minor jest zwiększana.\nWersja major X (X.y.z | X > 0) MUSI zostać zwiększona, jeżeli do publicznego
API są wprowadzane jakiekolwiek wstecznie niekompatybilne zmiany. MOŻE zawierać
zmiany na poziomie minor oraz patch. Numery wersji minor oraz patch MUSZĄ być
ustawione na 0, gdy wersja major jest zwiększana.\nWersja major X (X.y.z | X > 0) MUSI zostać zwiększona, jeżeli do publicznego
API są wprowadzane jakiekolwiek wstecznie niekompatybilne zmiany. MOŻE zawierać
zmiany na poziomie minor oraz patch. Numery wersji minor oraz patch MUSZĄ być
ustawione na 0, gdy wersja major jest zwiększana.\nWydanie przedpremierowe MOŻE być oznaczone przez dołączenie dywizu oraz
zbioru identyfikatorów rozdzielonych kropkami, zaraz za numerem wersji
patch. Identyfikatory MUSZĄ składać się wyłącznie ze znaków alfanumerycznych
ASCII oraz myślników [0-9A-Za-z-]. Identyfikatory NIE MOGĄ być puste. Numeryczne
identyfikatory NIE MOGĄ zawierać wiodących zer. Wydania przedpremierowe
poprzedzają powiązane z nimi wersje standardowe. Wydanie przedpremierowe
wskazuje na niestabilność wersji i możliwość niespełniania wymogów
kompatybilności, które cechują powiązaną z nią standardową wersję. Przykłady:
1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nWydanie przedpremierowe MOŻE być oznaczone przez dołączenie dywizu oraz
zbioru identyfikatorów rozdzielonych kropkami, zaraz za numerem wersji
patch. Identyfikatory MUSZĄ składać się wyłącznie ze znaków alfanumerycznych
ASCII oraz myślników [0-9A-Za-z-]. Identyfikatory NIE MOGĄ być puste. Numeryczne
identyfikatory NIE MOGĄ zawierać wiodących zer. Wydania przedpremierowe
poprzedzają powiązane z nimi wersje standardowe. Wydanie przedpremierowe
wskazuje na niestabilność wersji i możliwość niespełniania wymogów
kompatybilności, które cechują powiązaną z nią standardową wersję. Przykłady:
1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nMeta-dane buildu MOGĄ być oznaczone przez dołączenie znaku plus oraz zbioru
identyfikatorów rozdzielonych kropkami, zaraz za numerem wersji patch lub
wydania przedpremierowego. Identyfikatory MUSZĄ składać się wyłącznie ze znaków
alfanumerycznych ASCII oraz myślników [0-9A-Za-z-]. Identyfikatory NIE MOGĄ być
puste. Meta-dane buildu POWINNY być ignorowane przy ustalaniu kolejności wersji.
Zatem dwie wersje różniące się tylko meta-danymi buildu mają ten sam stopień
pierwszeństwa. Przykłady: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85.\nMeta-dane buildu MOGĄ być oznaczone przez dołączenie znaku plus oraz zbioru
identyfikatorów rozdzielonych kropkami, zaraz za numerem wersji patch lub
wydania przedpremierowego. Identyfikatory MUSZĄ składać się wyłącznie ze znaków
alfanumerycznych ASCII oraz myślników [0-9A-Za-z-]. Identyfikatory NIE MOGĄ być
puste. Meta-dane buildu POWINNY być ignorowane przy ustalaniu kolejności wersji.
Zatem dwie wersje różniące się tylko meta-danymi buildu mają ten sam stopień
pierwszeństwa. Przykłady: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85.\nPierwszeństwo odnosi się do sposobu porównywania wersji między sobą podczas
ich porządkowania. Pierwszeństwo MUSI być ustalane w rozdzieleniu wersji na
identyfikatory major, minor, patch oraz identyfikator przedpremierowy w podanej
kolejności (meta-dane buildu nie decydują o pierwszeństwie). Pierwszeństwo jest
ustalane przez pierwszą różnicę wykrytą podczas porównania każdego
z identyfikatorów od lewej do prawej: wersje major, minor, patch są zawsze
porównywane numerycznie. Przykład: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Gdy numery
wersji major, minor i patch są równe, wydanie przedpremierowe poprzedza wersję
standardową. Przykładowo: 1.0.0-alpha < 1.0.0. Pierwszeństwo dwóch wydań
przedpremierowych z takimi samymi numerami wersji major, minor i patch MUSI być
ustalane przez porównywanie każdego z identyfikatorów rozdzielonych kropkami
w kierunku od lewej do prawej, póki nie zostanie wykryta różnica w taki sposób:
identyfikatory złożone z samych cyfr porównywane są numerycznie,
a identyfikatory z literami lub dywizami porównywane są leksykalnie w kolejności
ASCII. Identyfikatory numeryczne zawsze poprzedzają identyfikatory
nienumeryczne. Większy zbiór przedpremierowych pól poprzedza mniejszy zbiór,
o ile wszystkie poprzedzające identyfikatory są sobie równe. Przykład:
1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 <
1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPierwszeństwo odnosi się do sposobu porównywania wersji między sobą podczas
ich porządkowania. Pierwszeństwo MUSI być ustalane w rozdzieleniu wersji na
identyfikatory major, minor, patch oraz identyfikator przedpremierowy w podanej
kolejności (meta-dane buildu nie decydują o pierwszeństwie). Pierwszeństwo jest
ustalane przez pierwszą różnicę wykrytą podczas porównania każdego
z identyfikatorów od lewej do prawej: wersje major, minor, patch są zawsze
porównywane numerycznie. Przykład: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Gdy numery
wersji major, minor i patch są równe, wydanie przedpremierowe poprzedza wersję
standardową. Przykładowo: 1.0.0-alpha < 1.0.0. Pierwszeństwo dwóch wydań
przedpremierowych z takimi samymi numerami wersji major, minor i patch MUSI być
ustalane przez porównywanie każdego z identyfikatorów rozdzielonych kropkami
w kierunku od lewej do prawej, póki nie zostanie wykryta różnica w taki sposób:
identyfikatory złożone z samych cyfr porównywane są numerycznie,
a identyfikatory z literami lub dywizami porównywane są leksykalnie w kolejności
ASCII. Identyfikatory numeryczne zawsze poprzedzają identyfikatory
nienumeryczne. Większy zbiór przedpremierowych pól poprzedza mniejszy zbiór,
o ile wszystkie poprzedzające identyfikatory są sobie równe. Przykład:
1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 <
1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nGramatyka poprawnej wersji SemVer w zapisie BNF\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nDlaczego warto stosować wersjonowanie semantyczne?\nTo nie jest nowy ani rewolucyjny pomysł. W zasadzie prawdopodobnie już
posługujesz się prawie tą samą metodą. Problem w tym, że „prawie” robi różnicę.
Bez zgodności z jakimś rodzajem formalnej specyfikacji, numery wersji są
całkowicie nieprzydatne przy zarządzaniu zależnościami. Poprzez nadanie nazwy
i jasnych definicji powyższym pomysłom, łatwiejszym staje się przekazywanie
twoich intencji użytkownikom twojego oprogramowania. Gdy te intencje są jasne,
wreszcie da się robić elastyczne (ale nie zbyt elastyczne) specyfikacje
zależności.\nProsty przykład może udowodnić, w jaki sposób wersjonowanie semantyczne może
zamienić piekło zależności w relikt przeszłości. Rozważmy bibliotekę nazwaną
„Wóz strażacki”. Wymaga ona wersjonowanego semantycznie pakietu o nazwie
„Drabina”. W czasie, gdy Wóz strażacki jest tworzony, Drabina jest w wersji
3.1.0. Jako że Wóz strażacki korzysta z funkcjonalności, które zostały
wprowadzone po raz pierwszy w wersji 3.1.0, możesz bezpiecznie założyć, że
wymagana wersja Drabiny jest większa lub równa 3.1.0, ale mniejsza niż 4.0.0.
Teraz gdy staną się dostępne wersje Drabiny 3.1.1 lub 3.2.0, możesz puścić je
w swoim systemie zarządzania pakietami ze świadomością, że będą one kompatybilne
z istniejącym zależnym oprogramowaniem.\nJako odpowiedzialny programista musisz oczywiście zweryfikować, że każde
aktualizacje pakietów działają, jak powinny. Prawdziwy świat potrafi dać w kość;
nic nie możemy z tym zrobić poza zachowaniem czujności. To, co ty możesz zrobić,
to pozwolić by wersjonowanie semantyczne dostarczyło ci rozsądną metodę
wydawania i aktualizowania pakietów bez konieczności wydawania nowych
wersji pakietów zależnych, oszczędzającą ci czas i wysiłek.\nJeśli to wszystko brzmi zachęcająco, wszystko, co musisz zrobić, aby korzystać
z wersjonowania semantycznego, to zadeklarować się, że będziesz to robić,
a następnie przestrzegać zasad. Podlinkuj tę stronę w swoim README, aby inni
znali te zasady i mogli z nich korzystać.\nCzęsto zadawane pytania\nJak powinienem zajmować się wersjami w 0.y.z początkowej fazie rozwoju?\nNajprościej jest zacząć swoje wydanie początkowej fazy rozwoju od 0.1.0,
a następnie zwiększać wersję minor dla każdego kolejnego wydania.\nSkąd mam wiedzieć, kiedy wydać 1.0.0?\nJeśli twoje oprogramowanie jest w użyciu w produkcji, powinno prawdopodobnie już
być 1.0.0. Jeśli masz stabilne API, z którego zaczęli korzystać użytkownicy,
powinieneś mieć 1.0.0. Jeśli dużo się martwisz o kompatybilność wstecz,
powinieneś prawdopodobnie już mieć 1.0.0.\nCzy nie opóźnia to szybkiego rozwoju i szybkiej iteracji?\nW wersji major zero chodzi o szybki rozwój. Jeśli zmieniasz API codziennie,
powinieneś albo być wciąż w wersji 0.y.z, albo w oddzielnej gałęzi rozwoju,
pracując nad nową wersją major.\nJeśli nawet najmniejsze niekompatybilne wstecz zmiany w publicznym API wymagają podbicia wersji major, czy bardzo szybko nie skończę na wersji 42.0.0?\nTo jest kwestia odpowiedzialnego programowania i dalekowzroczności.
Niekompatybilne zmiany nie powinny być wprowadzane z lekkością do
oprogramowania, które jest zależnością w wielu miejscach. Koszt, który trzeba
ponieść, by zaktualizować pakiet, może być znamienny. Konieczność podbijania
wersji major przy wprowadzaniu niekompatybilnych zmian powoduje, że będziesz
myślał przez pryzmat siły oddziaływania swoich zmian i szacował stosunek
poniesionych kosztów do zysków.\nStworzenie dokumentacji całego publicznego API to zbyt dużo pracy!\nJako profesjonalny programista jesteś odpowiedzialny za prawidłową dokumentację
oprogramowania, które jest przeznaczone do użytku przez innych. Zarządzanie
złożonością oprogramowania jest niezwykle ważną częścią utrzymania sprawności
projektu, a jest to trudne do zrobienia, jeśli nikt nie wie, jak używać twojego
oprogramowania albo z których metod jest bezpiecznie korzystać. Na dłuższą metę
wersjonowanie semantyczne oraz obstawanie przy dobrze zdefiniowanym publicznym
API pozwoli wszystkim i wszystkiemu działać płynnie.\nCo zrobić, jeśli przez przypadek wypuściłem niekompatybilną wstecz zmianę jako wersję minor?\nJak tylko odkryjesz, że zaburzyłeś specyfikację semantycznego wersjonowania,
napraw ten błąd i wydaj nową wersję minor, która niweluje błąd i przywraca
wsteczną kompatybilność. Nawet w takich okolicznościach niedopuszczalne jest
modyfikowanie wydanej wersji. Jeśli możesz, opisz błędną wersję i poinformuj
użytkowników o problemie, aby byli świadomi, że ta wersja jest błędna.\nCo powinienem zrobić, jeśli aktualizuję własne zależności bez zmiany publicznego API?\nTaka aktualizacja jest uznawana za kompatybilną, gdyż nie narusza publicznego
API. Oprogramowanie, które opiera się na tych samych zależnościach co twój
pakiet, powinno mieć własną specyfikację zależności, a jego autor zauważy
konflikt. Ustalenie, czy zmiana jest na poziomie patch lub, czy jest modyfikacją
na poziomie minor, zależy od tego, czy zaktualizowałeś zależności w celu naprawy
błędu, czy w celu wprowadzenia nowej funkcjonalności. Zazwyczaj spodziewałbym
się dodatkowego kodu w tym drugim przypadku, co oczywiście oznacza zwiększenie
wersji minor.\nCo zrobić, gdy nieumyślnie zmieniłem publiczne API w taki sposób, że nie jest już zgodne ze zmianą numeru wersji (tj. kod nieprawidłowo wprowadza zmianę major w wydaniu patch)?\nPostępuj zgodnie z rozsądkiem. Jeśli oprogramowanie używane jest przez wielu
użytkowników, dla których zmiana publicznego API do poprzednio zamierzonego
stanu może być dużym uderzeniem, lepiej jest wypuścić nową wersję major, nawet
jeśli problem mógłby być rozwiązany wydaniem wersji patch. Należy pamiętać, że
w semantycznym wersjonowaniu chodzi przede wszystkim o przekazanie znaczenia
zmiany poprzez zmianę numeru wersji. Jeśli zmiany są ważne dla użytkowników,
poinformuj ich o tym poprzez numer wersji.\nJak powinienem radzić sobie z dezaprobowaniem funkcjonalności?\nDezaprobowanie istniejącej funkcjonalności jest normalną częścią programowania
i często jest konieczne, by móc rozwijać oprogramowanie. Gdy wycofujesz część
swojego publicznego API, powinieneś zrobić dwie rzeczy: (1) zaktualizować
dokumentację, by użytkownicy wiedzieli o tej zmianie, (2) wypuścić nowe wydanie
minor z informacją o zdezaprobowaniu. Zanim całkowicie usuniesz funkcjonalność
w nowym wydaniu major, powinno być co najmniej jedno wydanie minor zawierające
informację o zdezaprobowaniu, aby użytkownicy mogli płynnie przejść na nowe API.\nCzy SemVer ma limit długości na oznaczenie wersji?\nNie, ale miej zdrowy rozsądek. Na przykład numer wersji długi na 255 znaków to
prawdopodobnie przesada. Ponadto konkretne systemy mogą narzucać swoje własne
ograniczenia na rozmiar tego ciągu znaków.\nCzy ciąg „v1.2.3” spełnia zasady?\nNie, „v1.2.3” nie jest zgodne z wersjonowaniem semantycznym. Jednak przedrostek „v” jest
zazwyczaj używany w języku angielskim do oznaczenia, że mamy do czynienia z numerem wersji.
Skrót „v” od angielskiego słowa „version” jest często spotykany w systemach kontroli wersji.
Przykładowo, w przypadku git tag v1.2.3 -m "Release version 1.2.3", „v1.2.3” jest nazwą taga,
a semantyczna wersja to „1.2.3”.\nCzy istnieje sugerowane wyrażenie regularne (RegEx) do weryfikacji porawności SemVer?\nIstnieją dwa. Pierwsze wykorzystuje grupy nazwane i jest przeznaczone dla systemów, które wspierają tę funkcjonalność (
PCRE [Perl Compatible Regular Expressions, np. Perl, PHP i R], Python czy Go).\nPatrz: https://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nDruga wykorzystuje numerowane grupy przechwytujące (wzór gp1 = major, gp2 = minor, gp3 = patch, gp4 = przedpremierowa i gp5 =
meta-dane buildu) i jest kompatybilna z ECMA Script (JavaScript), PCRE [Perl Compatible Regular Expressions, np. Perl, PHP i R],
Python czy Go.\nPatrz: https://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nAutorem specyfikacji wersjonowania semantycznego jest
Tom Preston-Werner, wynalazca Gravatara
i współzałożyciel GitHuba.\nJeśli chcesz podzielić się opinią, prosimy
o otworzenie zgłoszenia na GitHubie.\notworzenie zgłoszenia na GitHubie\nCreative Commons – CC BY 3.0.\nCreative Commons – CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nVersionamento Semântico 2.0.0

Sumário

Dado um número de versão MAJOR.MINOR.PATCH, incremente a:


  versão Maior (MAJOR): quando fizer mudanças incompatíveis na API,
  versão Menor (MINOR): quando adicionar funcionalidades mantendo
compatibilidade, e
  versão de Correção (PATCH): quando corrigir falhas mantendo compatibilidade.


Rótulos adicionais para pré-lançamento (pre-release) e metadados de
construção (build) estão disponíveis como extensão ao formato MAJOR.MINOR.PATCH.

Introdução

No mundo de gerenciamento de software existe algo terrível conhecido como
inferno das dependências (“dependency hell”). Quanto mais o sistema cresce, e
mais pacotes são adicionados a ele, maior será a possibilidade de, um dia, você
encontrar-se neste poço de desespero.

Em sistemas com muitas dependências, lançar novos pacotes de versões pode se
tornar rapidamente um pesadelo. Se as especificações das dependências são muito
amarradas você corre o risco de um bloqueio de versão (a falta de capacidade de
atualizar um pacote sem ter de liberar novas versões de cada pacote dependente).
Se as dependências são vagamente especificadas, você irá inevitavelmente ser
mordido pela ‘promiscuidade da versão’ (assumindo compatibilidade com futuras
versões mais do que é razoável). O inferno das dependências é onde você está
quando um bloqueio de versão e/ou promiscuidade de versão te impede de seguir
em frente com seu projeto de maneira fácil e segura.

Como uma solução para este problema proponho um conjunto simples de regras e
requisitos que ditam como os números das versões são atribuídos e incrementados.

Essas regras são baseadas em, mas não necessariamente limitadas às bem
difundidas práticas comumente em uso tanto em software fechados como
open-source.
Para que este sistema funcione, primeiro você precisa declarar uma API pública.
Isto pode consistir de documentação ou ser determinada pelo próprio código. De
qualquer maneira, é importante que esta API seja clara e precisa. Depois de
identificada a API pública, você comunica as mudanças com incrementos
específicos para o seu número de versão. Considere o formato de versão X.Y.Z
(Maior.Menor.Correção). Correção de falhas (bug fixes) que não afetam a API,
incrementa a versão de Correção, adições/alterações compatíveis com as versões
anteriores da API incrementa a versão Menor, e alterações incompatíveis com as
versões anteriores da API incrementa a versão Maior.

Eu chamo esse sistema de “Versionamento Semântico”. Sob este esquema, os números
de versão e a forma como eles mudam, transmite o significado do código
subjacente e o que foi modificado de uma versão para a próxima.

Especificação de Versionamento Semântico (SemVer)

As palavras-chaves “DEVE”, “NÃO DEVE”, “OBRIGATÓRIO”, “DEVERÁ”, “NÃO DEVERÁ”,
“PODEM”, “NÃO PODEM”, “RECOMENDADO”, “PODE” e “OPCIONAL” no presente
documento devem ser interpretados como descrito na [RFC 2119]
(http://tools.ietf.org/html/rfc2119).


  
    Software usando Versionamento Semântico DEVE declarar uma API pública. Esta
API poderá ser declarada no próprio código ou existir estritamente na
documentação, desde que seja precisa e compreensiva.
  
  
    Um número de versão normal DEVE ter o formato de X.Y.Z, onde X, Y, e Z são
inteiros não negativos, e NÃO DEVE conter zeros à esquerda. X é a versão Maior,
Y é a versão Menor, e Z é a versão de Correção. Cada elemento DEVE aumentar
numericamente. Por exemplo: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Uma vez que um pacote versionado foi lançado (released), o conteúdo desta
versão NÃO DEVE ser modificado. Qualquer modificação DEVE ser lançado como uma
nova versão.
  
  
    No início do desenvolvimento, a versão Maior DEVE ser zero (0.y.z). Qualquer
coisa pode mudar a qualquer momento. A API pública não deve ser considerada
estável.
  
  
    Versão 1.0.0 define a API como pública. A maneira como o número de versão é
incrementado após este lançamento é dependente da API pública e como ela muda.
  
  
    Versão de Correção Z (x.y.Z | x > 0) DEVE ser incrementado apenas se mantiver
compatibilidade e introduzir correção de bugs. Uma correção de bug é definida
como uma mudança interna que corrige um comportamento incorreto.
  
  
    Versão Menor Y (x.Y.z | x > 0) DEVE  ser incrementada se uma funcionalidade
nova e compatível for introduzida na API pública. DEVE ser incrementada se
qualquer funcionalidade da API pública for definida como descontinuada. PODE ser
incrementada se uma nova funcionalidade ou melhoria substancial for introduzida
dentro do código privado. PODE incluir mudanças a nível de correção. A versão de
Correção deve ser redefinida para 0 (zero) quando a versão Menor for
incrementada.
  
  
    Versão Maior X (X.y.z | X > 0) DEVE ser incrementada se forem introduzidas
mudanças incompatíveis na API pública. PODE incluir alterações a nível de versão
Menor e de versão de Correção. Versão de Correção e Versão Menor devem ser
redefinidas para 0 (zero) quando a versão Maior for incrementada.
  
  
    Uma versão de Pré-Lançamento (pre-release) PODE ser identificada adicionando
um hífen (dash) e uma série de identificadores separados por ponto (dot)
imediatamente após a versão de Correção. Identificador DEVE incluir apenas
caracteres alfanuméricos e hífen [0-9A-Za-z-]. Identificador NÃO DEVE ser
vazio. Indicador numérico NÃO DEVE incluir zeros à esquerda. Versão de
Pré-Lançamento tem precedência inferior à versão normal a que está associada.
Uma versão de Pré-Lançamento (pre-release) indica que a versão é instável e pode
não satisfazer os requisitos de compatibilidade pretendidos, como indicado por
sua versão normal associada. Exemplos: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.
  
  
    Metadados de construção (Build) PODEM ser identificadas por adicionar um
sinal de adição (+) e uma série de identificadores separados por ponto
imediatamente após a Correção ou Pré-Lançamento. Identificador DEVE
ser composto apenas por caracteres alfanuméricos e hífen [0-9A-Za-z-].
Identificador NÃO DEVE ser vazio.  Metadados de construção PODEM ser ignorados
quando se determina a versão de precedência. Assim, duas versões que diferem
apenas nos metadados de construção, têm a mesma precedência. Exemplos:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    A precedência refere como as versões são comparadas com cada outra quando
solicitado.  A precedência DEVE ser calculada separando identificadores de
versão em Maior, Menor, Correção e Pré-lançamento, nesta ordem (Metadados de
construção não figuram na precedência). A precedência é determinada pela
primeira diferença quando se compara cada identificador da esquerda para
direita, como se segue: Versões Maior, Menor e Correção são sempre comparadas
numericamente. Exemplo: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Quando Maior, Menor e
Correção são iguais, a versão de Pré-Lançamento tem precedência menor que a
versão normal. Exemplo: 1.0.0-alpha < 1.0.0. A precedência entre duas versões
de Pré-lançamento com mesma versão Maior, Menor e Correção DEVE ser
determinada comparando cada identificador separado por ponto da esquerda para
direita até que seja encontrada diferença da seguinte forma: identificadores
consistindo apenas dígitos são comparados numericamente e identificadores com
letras ou hífen são comparados lexicalmente na ordem de classificação ASCII.
Identificadores numéricos sempre têm menor precedência do que os não numéricos.
Um conjunto maior de campos de pré-lançamento tem uma precedência maior do que
um conjunto menor, se todos os identificadores anteriores são iguais.
Exemplo: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Por que usar Versionamento Semântico?
Esta não é uma ideia nova ou revolucionária. De fato, você provavelmente já faz
algo próximo a isso. O problema é que “próximo” não é bom o bastante. Sem a
aderência a algum tipo de especificação formal, os números de versão são
essencialmente inúteis para gerenciamento de dependências. Dando um nome e
definições claras às ideias acima, fica fácil comunicar suas intenções aos
usuários de seu software. Uma vez que estas intenções estão claras,
especificações de dependências flexíveis (mas não tão flexíveis) finalmente
podem ser feitas.

Um exemplo simples vai demonstrar como o Versionamento Semântico pode fazer do
inferno de dependência uma coisa do passado. Considere uma biblioteca chamada
“CaminhaoBombeiros”. Ela requer um pacote versionado dinamicamente chamado
“Escada”. Quando CaminhaoBombeiros foi criado, Escada estava na versão 3.1.0.
Como CaminhaoBombeiros utiliza algumas funcionalidades que foram inicialmente
introduzidas na versão 3.1.0, você pode especificar, com segurança, a
dependência da Escada como maior ou igual a 3.1.0 porém menor que 4.0.0. Agora,
quando Escada versão 3.1.1 e 3.2.0 estiverem disponíveis, você poderá lançá-los
ao seu sistema de gerenciamento de pacote e saberá que eles serão compatíveis
com os softwares dependentes existentes.

Como um desenvolvedor responsável você irá, é claro, querer certificar-se que
qualquer atualização no pacote funcionará como anunciado. O mundo real é um
lugar bagunçado; não há nada que possamos fazer quanto a isso senão sermos
vigilantes. O que você pode fazer é deixar o Versionamento Semântico lhe
fornecer uma maneira sensata de lançar e atualizar pacotes sem precisar
atualizar para novas versões de pacotes dependentes, salvando-lhe tempo e
aborrecimento.

Se tudo isto soa desejável, tudo que você precisar fazer para começar a usar
Versionamento Semântico é declarar que você o esta usando e então, seguir as
regras. Adicione um link para este website no seu README para que outros saibam
as regras e possam beneficiar-se delas.

FAQ

Como devo lidar com revisões na fase 0.y.z de desenvolvimento inicial?

A coisa mais simples a se fazer é começar sua versão de desenvolvimento inicial
em 0.1.0 e, então, incrementar a uma versão ‘menor’ em cada lançamento
subsequente.

Como eu sei quando lançar a versão 1.0.0?

Se seu software está sendo usado em produção, ele já deve ser provavelmente
1.0.0. Se você possui uma API estável a qual usuários passaram a depender, deve
ser 1.0.0. Se você está se preocupando bastante com compatibilidade com versões
anteriores, já deve ser 1.0.0.

Isto não desencoraja o desenvolvimento ágil e iteração rápida?

A versão Maior zero tem o foco exatamente no desenvolvimento rápido. Se você
está mudando a API todo dia, provavelmente você está na versão 0.y.z ou num
branch separado de desenvolvimento, trabalhando numa próxima versão Maior.

Se mesmo a menor mudança incompatível com a API pública requer aumento da versão maior, não vou acabar na versão 42.0.0 muito rapidamente?

Esta é uma questão de desenvolvimento responsável e conhecimento antecipado.
Mudanças incompatíveis não devem ser levemente introduzidas para o software que
tem um monte de código dependente. O custo que deve ser incorrido para atualizar
pode ser significante. Tendo que aumentar a versão maior para lançar mudanças
incompatíveis, significa que você pensará no impacto das suas mudanças, e
avaliará a relação de custo/benefício envolvida.

Documentar toda a API pública dá muito trabalho!

É sua responsabilidade como desenvolvedor profissional documentar corretamente o
software que será usado por outros. Gerenciar a complexidade de software é uma
parte muito importante para manter o projeto eficiente, e isto é difícil de
fazer se ninguém sabe como usá-lo ou que métodos são seguros de chamar. A longo
prazo, Versionamento Semântico e a insistência em uma API pública bem definida
podem deixar tudo e todos funcionando suavemente.

O que eu faço se, acidentalmente, liberar uma mudança incompatível com versões anteriores como uma versão menor (minor version)?

Assim que você perceber que quebrou a especificação de versionamento semântico,
conserte o problema e lance uma nova versão menor, que corrige o problema e
restaura a compatibilidade. Mesmo sob esta circunstância, é inaceitável
modificar versões lançadas. Se for apropriado, documente a versão ofensiva e
informe seus usuários do problema de forma que eles fiquem cientes da versão em
questão.

O que devo fazer se eu atualizar minhas próprias dependências sem modificar a API pública?

Isso seria considerado compatível, uma vez que não afeta a API pública. Software
que depende explicitamente das mesmas dependências que seu pacote, deve ter sua
própria especificação de dependência e o autor notificará quaisquer conflitos.
Para determinar se a mudança é a nível de correção ou modificação de nível menor
dependente se você atualizou suas dependências a fim de corrigir um bug ou
introduzir nova funcionalidade. Eu normalmente esperaria código adicional para
última instância, caso em que é obviamente um incremento no nível menor.

E se eu alterei inadvertidamente a API pública de forma incompatível com a mudança no número de versão (ex.: o código incorretamente introduz uma grande mudança incompatível em  liberação de um patch)

Use o bom senso. Se você tem um público enorme que será drasticamente impactado
pela mudança de comportamento de volta para o que a API pública pretendida,
então pode ser melhor realizar um lançamento de uma versão maior, mesmo que a
correção pudesse ser considerada estritamente uma versão de correção.Lembre-se,
Versionamento Semântico trata de transmitir o conhecimento das mudanças
ocorridas na versão. Se estas mudanças são importantes para seus usuários,
utilize o número da versão para informá-los.

Como devo lidar com descontinuação de funcionalidades?

Descontinuar funcionalidades é um processo comum no desenvolvimento de software
e muitas vezes é necessário para haver progresso. Quando você descontinua partes
de sua API pública, você deve fazer duas coisas: (1) atualizar sua documentação,
para que os usuários saibam das mudanças, (2) lançar uma versão Menor anunciando
a descontinuação. Antes de remover completamente a funcionalidade em uma versão
Maior deve haver ao menos uma versão Menor que possui a descontinução anunciada,
fazendo com que os usuários realizem uma transição tranquila para a nova API.

O SemVer tem um limite de tamanho para string de versão?

Não, mas use o bom senso. Uma string de versão com 255 caracteres por exemplo,
provavelmente é um exagero. Porém, sistemas específicos podem definir seus
próprios limites para o tamanho da string.

Sobre

A Especificação da Semântica de Versionamento é autoria de Tom
Preston-Werner, criador do Gravatars e
co-fundador do GitHub.

Caso queira deixar sua opinião, por favor abra uma issue no GitHub.

Licença

Creative Commons ― CC BY 3.0\nVersionamento Semântico 2.0.0\nDado um número de versão MAJOR.MINOR.PATCH, incremente a:\nversão Maior (MAJOR): quando fizer mudanças incompatíveis na API,\nversão Menor (MINOR): quando adicionar funcionalidades mantendo
compatibilidade, e\nversão de Correção (PATCH): quando corrigir falhas mantendo compatibilidade.\nRótulos adicionais para pré-lançamento (pre-release) e metadados de
construção (build) estão disponíveis como extensão ao formato MAJOR.MINOR.PATCH.\nNo mundo de gerenciamento de software existe algo terrível conhecido como
inferno das dependências (“dependency hell”). Quanto mais o sistema cresce, e
mais pacotes são adicionados a ele, maior será a possibilidade de, um dia, você
encontrar-se neste poço de desespero.\nEm sistemas com muitas dependências, lançar novos pacotes de versões pode se
tornar rapidamente um pesadelo. Se as especificações das dependências são muito
amarradas você corre o risco de um bloqueio de versão (a falta de capacidade de
atualizar um pacote sem ter de liberar novas versões de cada pacote dependente).
Se as dependências são vagamente especificadas, você irá inevitavelmente ser
mordido pela ‘promiscuidade da versão’ (assumindo compatibilidade com futuras
versões mais do que é razoável). O inferno das dependências é onde você está
quando um bloqueio de versão e/ou promiscuidade de versão te impede de seguir
em frente com seu projeto de maneira fácil e segura.\nComo uma solução para este problema proponho um conjunto simples de regras e
requisitos que ditam como os números das versões são atribuídos e incrementados.\nEssas regras são baseadas em, mas não necessariamente limitadas às bem
difundidas práticas comumente em uso tanto em software fechados como
open-source.
Para que este sistema funcione, primeiro você precisa declarar uma API pública.
Isto pode consistir de documentação ou ser determinada pelo próprio código. De
qualquer maneira, é importante que esta API seja clara e precisa. Depois de
identificada a API pública, você comunica as mudanças com incrementos
específicos para o seu número de versão. Considere o formato de versão X.Y.Z
(Maior.Menor.Correção). Correção de falhas (bug fixes) que não afetam a API,
incrementa a versão de Correção, adições/alterações compatíveis com as versões
anteriores da API incrementa a versão Menor, e alterações incompatíveis com as
versões anteriores da API incrementa a versão Maior.\nEu chamo esse sistema de “Versionamento Semântico”. Sob este esquema, os números
de versão e a forma como eles mudam, transmite o significado do código
subjacente e o que foi modificado de uma versão para a próxima.\nEspecificação de Versionamento Semântico (SemVer)\nAs palavras-chaves “DEVE”, “NÃO DEVE”, “OBRIGATÓRIO”, “DEVERÁ”, “NÃO DEVERÁ”,
“PODEM”, “NÃO PODEM”, “RECOMENDADO”, “PODE” e “OPCIONAL” no presente
documento devem ser interpretados como descrito na [RFC 2119]
(http://tools.ietf.org/html/rfc2119).\nSoftware usando Versionamento Semântico DEVE declarar uma API pública. Esta
API poderá ser declarada no próprio código ou existir estritamente na
documentação, desde que seja precisa e compreensiva.\nSoftware usando Versionamento Semântico DEVE declarar uma API pública. Esta
API poderá ser declarada no próprio código ou existir estritamente na
documentação, desde que seja precisa e compreensiva.\nUm número de versão normal DEVE ter o formato de X.Y.Z, onde X, Y, e Z são
inteiros não negativos, e NÃO DEVE conter zeros à esquerda. X é a versão Maior,
Y é a versão Menor, e Z é a versão de Correção. Cada elemento DEVE aumentar
numericamente. Por exemplo: 1.9.0 -> 1.10.0 -> 1.11.0.\nUm número de versão normal DEVE ter o formato de X.Y.Z, onde X, Y, e Z são
inteiros não negativos, e NÃO DEVE conter zeros à esquerda. X é a versão Maior,
Y é a versão Menor, e Z é a versão de Correção. Cada elemento DEVE aumentar
numericamente. Por exemplo: 1.9.0 -> 1.10.0 -> 1.11.0.\nUma vez que um pacote versionado foi lançado (released), o conteúdo desta
versão NÃO DEVE ser modificado. Qualquer modificação DEVE ser lançado como uma
nova versão.\nUma vez que um pacote versionado foi lançado (released), o conteúdo desta
versão NÃO DEVE ser modificado. Qualquer modificação DEVE ser lançado como uma
nova versão.\nNo início do desenvolvimento, a versão Maior DEVE ser zero (0.y.z). Qualquer
coisa pode mudar a qualquer momento. A API pública não deve ser considerada
estável.\nNo início do desenvolvimento, a versão Maior DEVE ser zero (0.y.z). Qualquer
coisa pode mudar a qualquer momento. A API pública não deve ser considerada
estável.\nVersão 1.0.0 define a API como pública. A maneira como o número de versão é
incrementado após este lançamento é dependente da API pública e como ela muda.\nVersão 1.0.0 define a API como pública. A maneira como o número de versão é
incrementado após este lançamento é dependente da API pública e como ela muda.\nVersão de Correção Z (x.y.Z | x > 0) DEVE ser incrementado apenas se mantiver
compatibilidade e introduzir correção de bugs. Uma correção de bug é definida
como uma mudança interna que corrige um comportamento incorreto.\nVersão de Correção Z (x.y.Z | x > 0) DEVE ser incrementado apenas se mantiver
compatibilidade e introduzir correção de bugs. Uma correção de bug é definida
como uma mudança interna que corrige um comportamento incorreto.\nVersão Menor Y (x.Y.z | x > 0) DEVE  ser incrementada se uma funcionalidade
nova e compatível for introduzida na API pública. DEVE ser incrementada se
qualquer funcionalidade da API pública for definida como descontinuada. PODE ser
incrementada se uma nova funcionalidade ou melhoria substancial for introduzida
dentro do código privado. PODE incluir mudanças a nível de correção. A versão de
Correção deve ser redefinida para 0 (zero) quando a versão Menor for
incrementada.\nVersão Menor Y (x.Y.z | x > 0) DEVE  ser incrementada se uma funcionalidade
nova e compatível for introduzida na API pública. DEVE ser incrementada se
qualquer funcionalidade da API pública for definida como descontinuada. PODE ser
incrementada se uma nova funcionalidade ou melhoria substancial for introduzida
dentro do código privado. PODE incluir mudanças a nível de correção. A versão de
Correção deve ser redefinida para 0 (zero) quando a versão Menor for
incrementada.\nVersão Maior X (X.y.z | X > 0) DEVE ser incrementada se forem introduzidas
mudanças incompatíveis na API pública. PODE incluir alterações a nível de versão
Menor e de versão de Correção. Versão de Correção e Versão Menor devem ser
redefinidas para 0 (zero) quando a versão Maior for incrementada.\nVersão Maior X (X.y.z | X > 0) DEVE ser incrementada se forem introduzidas
mudanças incompatíveis na API pública. PODE incluir alterações a nível de versão
Menor e de versão de Correção. Versão de Correção e Versão Menor devem ser
redefinidas para 0 (zero) quando a versão Maior for incrementada.\nUma versão de Pré-Lançamento (pre-release) PODE ser identificada adicionando
um hífen (dash) e uma série de identificadores separados por ponto (dot)
imediatamente após a versão de Correção. Identificador DEVE incluir apenas
caracteres alfanuméricos e hífen [0-9A-Za-z-]. Identificador NÃO DEVE ser
vazio. Indicador numérico NÃO DEVE incluir zeros à esquerda. Versão de
Pré-Lançamento tem precedência inferior à versão normal a que está associada.
Uma versão de Pré-Lançamento (pre-release) indica que a versão é instável e pode
não satisfazer os requisitos de compatibilidade pretendidos, como indicado por
sua versão normal associada. Exemplos: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.\nUma versão de Pré-Lançamento (pre-release) PODE ser identificada adicionando
um hífen (dash) e uma série de identificadores separados por ponto (dot)
imediatamente após a versão de Correção. Identificador DEVE incluir apenas
caracteres alfanuméricos e hífen [0-9A-Za-z-]. Identificador NÃO DEVE ser
vazio. Indicador numérico NÃO DEVE incluir zeros à esquerda. Versão de
Pré-Lançamento tem precedência inferior à versão normal a que está associada.
Uma versão de Pré-Lançamento (pre-release) indica que a versão é instável e pode
não satisfazer os requisitos de compatibilidade pretendidos, como indicado por
sua versão normal associada. Exemplos: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.\nMetadados de construção (Build) PODEM ser identificadas por adicionar um
sinal de adição (+) e uma série de identificadores separados por ponto
imediatamente após a Correção ou Pré-Lançamento. Identificador DEVE
ser composto apenas por caracteres alfanuméricos e hífen [0-9A-Za-z-].
Identificador NÃO DEVE ser vazio.  Metadados de construção PODEM ser ignorados
quando se determina a versão de precedência. Assim, duas versões que diferem
apenas nos metadados de construção, têm a mesma precedência. Exemplos:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nMetadados de construção (Build) PODEM ser identificadas por adicionar um
sinal de adição (+) e uma série de identificadores separados por ponto
imediatamente após a Correção ou Pré-Lançamento. Identificador DEVE
ser composto apenas por caracteres alfanuméricos e hífen [0-9A-Za-z-].
Identificador NÃO DEVE ser vazio.  Metadados de construção PODEM ser ignorados
quando se determina a versão de precedência. Assim, duas versões que diferem
apenas nos metadados de construção, têm a mesma precedência. Exemplos:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nA precedência refere como as versões são comparadas com cada outra quando
solicitado.  A precedência DEVE ser calculada separando identificadores de
versão em Maior, Menor, Correção e Pré-lançamento, nesta ordem (Metadados de
construção não figuram na precedência). A precedência é determinada pela
primeira diferença quando se compara cada identificador da esquerda para
direita, como se segue: Versões Maior, Menor e Correção são sempre comparadas
numericamente. Exemplo: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Quando Maior, Menor e
Correção são iguais, a versão de Pré-Lançamento tem precedência menor que a
versão normal. Exemplo: 1.0.0-alpha < 1.0.0. A precedência entre duas versões
de Pré-lançamento com mesma versão Maior, Menor e Correção DEVE ser
determinada comparando cada identificador separado por ponto da esquerda para
direita até que seja encontrada diferença da seguinte forma: identificadores
consistindo apenas dígitos são comparados numericamente e identificadores com
letras ou hífen são comparados lexicalmente na ordem de classificação ASCII.
Identificadores numéricos sempre têm menor precedência do que os não numéricos.
Um conjunto maior de campos de pré-lançamento tem uma precedência maior do que
um conjunto menor, se todos os identificadores anteriores são iguais.
Exemplo: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nA precedência refere como as versões são comparadas com cada outra quando
solicitado.  A precedência DEVE ser calculada separando identificadores de
versão em Maior, Menor, Correção e Pré-lançamento, nesta ordem (Metadados de
construção não figuram na precedência). A precedência é determinada pela
primeira diferença quando se compara cada identificador da esquerda para
direita, como se segue: Versões Maior, Menor e Correção são sempre comparadas
numericamente. Exemplo: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Quando Maior, Menor e
Correção são iguais, a versão de Pré-Lançamento tem precedência menor que a
versão normal. Exemplo: 1.0.0-alpha < 1.0.0. A precedência entre duas versões
de Pré-lançamento com mesma versão Maior, Menor e Correção DEVE ser
determinada comparando cada identificador separado por ponto da esquerda para
direita até que seja encontrada diferença da seguinte forma: identificadores
consistindo apenas dígitos são comparados numericamente e identificadores com
letras ou hífen são comparados lexicalmente na ordem de classificação ASCII.
Identificadores numéricos sempre têm menor precedência do que os não numéricos.
Um conjunto maior de campos de pré-lançamento tem uma precedência maior do que
um conjunto menor, se todos os identificadores anteriores são iguais.
Exemplo: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPor que usar Versionamento Semântico?\nEsta não é uma ideia nova ou revolucionária. De fato, você provavelmente já faz
algo próximo a isso. O problema é que “próximo” não é bom o bastante. Sem a
aderência a algum tipo de especificação formal, os números de versão são
essencialmente inúteis para gerenciamento de dependências. Dando um nome e
definições claras às ideias acima, fica fácil comunicar suas intenções aos
usuários de seu software. Uma vez que estas intenções estão claras,
especificações de dependências flexíveis (mas não tão flexíveis) finalmente
podem ser feitas.\nUm exemplo simples vai demonstrar como o Versionamento Semântico pode fazer do
inferno de dependência uma coisa do passado. Considere uma biblioteca chamada
“CaminhaoBombeiros”. Ela requer um pacote versionado dinamicamente chamado
“Escada”. Quando CaminhaoBombeiros foi criado, Escada estava na versão 3.1.0.
Como CaminhaoBombeiros utiliza algumas funcionalidades que foram inicialmente
introduzidas na versão 3.1.0, você pode especificar, com segurança, a
dependência da Escada como maior ou igual a 3.1.0 porém menor que 4.0.0. Agora,
quando Escada versão 3.1.1 e 3.2.0 estiverem disponíveis, você poderá lançá-los
ao seu sistema de gerenciamento de pacote e saberá que eles serão compatíveis
com os softwares dependentes existentes.\nComo um desenvolvedor responsável você irá, é claro, querer certificar-se que
qualquer atualização no pacote funcionará como anunciado. O mundo real é um
lugar bagunçado; não há nada que possamos fazer quanto a isso senão sermos
vigilantes. O que você pode fazer é deixar o Versionamento Semântico lhe
fornecer uma maneira sensata de lançar e atualizar pacotes sem precisar
atualizar para novas versões de pacotes dependentes, salvando-lhe tempo e
aborrecimento.\nSe tudo isto soa desejável, tudo que você precisar fazer para começar a usar
Versionamento Semântico é declarar que você o esta usando e então, seguir as
regras. Adicione um link para este website no seu README para que outros saibam
as regras e possam beneficiar-se delas.\nComo devo lidar com revisões na fase 0.y.z de desenvolvimento inicial?\nA coisa mais simples a se fazer é começar sua versão de desenvolvimento inicial
em 0.1.0 e, então, incrementar a uma versão ‘menor’ em cada lançamento
subsequente.\nComo eu sei quando lançar a versão 1.0.0?\nSe seu software está sendo usado em produção, ele já deve ser provavelmente
1.0.0. Se você possui uma API estável a qual usuários passaram a depender, deve
ser 1.0.0. Se você está se preocupando bastante com compatibilidade com versões
anteriores, já deve ser 1.0.0.\nIsto não desencoraja o desenvolvimento ágil e iteração rápida?\nA versão Maior zero tem o foco exatamente no desenvolvimento rápido. Se você
está mudando a API todo dia, provavelmente você está na versão 0.y.z ou num
branch separado de desenvolvimento, trabalhando numa próxima versão Maior.\nSe mesmo a menor mudança incompatível com a API pública requer aumento da versão maior, não vou acabar na versão 42.0.0 muito rapidamente?\nEsta é uma questão de desenvolvimento responsável e conhecimento antecipado.
Mudanças incompatíveis não devem ser levemente introduzidas para o software que
tem um monte de código dependente. O custo que deve ser incorrido para atualizar
pode ser significante. Tendo que aumentar a versão maior para lançar mudanças
incompatíveis, significa que você pensará no impacto das suas mudanças, e
avaliará a relação de custo/benefício envolvida.\nDocumentar toda a API pública dá muito trabalho!\nÉ sua responsabilidade como desenvolvedor profissional documentar corretamente o
software que será usado por outros. Gerenciar a complexidade de software é uma
parte muito importante para manter o projeto eficiente, e isto é difícil de
fazer se ninguém sabe como usá-lo ou que métodos são seguros de chamar. A longo
prazo, Versionamento Semântico e a insistência em uma API pública bem definida
podem deixar tudo e todos funcionando suavemente.\nO que eu faço se, acidentalmente, liberar uma mudança incompatível com versões anteriores como uma versão menor (minor version)?\nAssim que você perceber que quebrou a especificação de versionamento semântico,
conserte o problema e lance uma nova versão menor, que corrige o problema e
restaura a compatibilidade. Mesmo sob esta circunstância, é inaceitável
modificar versões lançadas. Se for apropriado, documente a versão ofensiva e
informe seus usuários do problema de forma que eles fiquem cientes da versão em
questão.\nO que devo fazer se eu atualizar minhas próprias dependências sem modificar a API pública?\nIsso seria considerado compatível, uma vez que não afeta a API pública. Software
que depende explicitamente das mesmas dependências que seu pacote, deve ter sua
própria especificação de dependência e o autor notificará quaisquer conflitos.
Para determinar se a mudança é a nível de correção ou modificação de nível menor
dependente se você atualizou suas dependências a fim de corrigir um bug ou
introduzir nova funcionalidade. Eu normalmente esperaria código adicional para
última instância, caso em que é obviamente um incremento no nível menor.\nE se eu alterei inadvertidamente a API pública de forma incompatível com a mudança no número de versão (ex.: o código incorretamente introduz uma grande mudança incompatível em  liberação de um patch)\nUse o bom senso. Se você tem um público enorme que será drasticamente impactado
pela mudança de comportamento de volta para o que a API pública pretendida,
então pode ser melhor realizar um lançamento de uma versão maior, mesmo que a
correção pudesse ser considerada estritamente uma versão de correção.Lembre-se,
Versionamento Semântico trata de transmitir o conhecimento das mudanças
ocorridas na versão. Se estas mudanças são importantes para seus usuários,
utilize o número da versão para informá-los.\nComo devo lidar com descontinuação de funcionalidades?\nDescontinuar funcionalidades é um processo comum no desenvolvimento de software
e muitas vezes é necessário para haver progresso. Quando você descontinua partes
de sua API pública, você deve fazer duas coisas: (1) atualizar sua documentação,
para que os usuários saibam das mudanças, (2) lançar uma versão Menor anunciando
a descontinuação. Antes de remover completamente a funcionalidade em uma versão
Maior deve haver ao menos uma versão Menor que possui a descontinução anunciada,
fazendo com que os usuários realizem uma transição tranquila para a nova API.\nO SemVer tem um limite de tamanho para string de versão?\nNão, mas use o bom senso. Uma string de versão com 255 caracteres por exemplo,
provavelmente é um exagero. Porém, sistemas específicos podem definir seus
próprios limites para o tamanho da string.\nA Especificação da Semântica de Versionamento é autoria de Tom
Preston-Werner, criador do Gravatars e
co-fundador do GitHub.\nCaso queira deixar sua opinião, por favor abra uma issue no GitHub.\nabra uma issue no GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nVersionamento Semântico 2.0.0-rc.1

No mundo de gerenciamento de software existe algo terrível conhecido como
inferno das dependências (“dependency hell”). Quanto mais o sistema cresce, e
mais pacotes são adicionados a ele, maior será a possibilidade de, um dia, você
encontrar-se neste poço de desespero.

Em sistemas com muitas dependências, lançar novos pacotes de versões pode se
tornar rapidamente um pesadelo. Se as especificações das dependências são muito
amarradas você corre o risco de um bloqueio de versão (A falta de capacidade de
atualizar um pacote sem ter de liberar novas versões de cada pacote dependente).
Se as dependências são vagamente especificadas, você irá inevitavelmente ser
mordido pela ‘promiscuidade da versão’ (assumindo compatibilidade com futuras
versões mais do que é razoável). O inferno das dependências é onde você está
quando um bloqueio de versão e/ou promiscuidade de versão te impede de seguir
em frente com seu projeto de maneira fácil e segura.

Como uma solução para este problema proponho um conjunto simples de regras e
requisitos que ditam como os números das versões são atribuídos e incrementados.

Para que este sistema funcione, primeiro você precisa declarar uma API pública.
Isto pode consistir de documentação ou ser determinada pelo próprio código. De
qualquer maneira, é importante que esta API seja clara e precisa. Depois de
identificada a API pública, você comunica as mudanças com incrementos
específicos para o seu número de versão. Considere o formato de versão X.Y.Z
(Maior.Menor.Correção). Correção de falhas (bug fixes) que não afetam a API,
incrementa a versão de Correção, adições/alterações compatíveis com as versões
anteriores da API incrementa a versão Menor, e alterações incompatíveis com as
versões anteriores da API incrementa a versão Maior.

Eu chamo esse sistema de “Versionamento Semântico”. Sob este esquema, os números
de versão e a forma como eles mudam, transmite o significado do código
subjacente e o que foi modificado de uma versão para a próxima.

Especificação de Versionamento Semântico (SemVer)

As palavras-chaves “DEVE”, “NÃO DEVE”, “OBRIGATÓRIO”, “DEVERÁ”, “NÃO DEVERÁ”,
“DEVERIA”, “NÃO DEVERIA”, “RECOMENDADO”, “PODE” e “OPCIONAL” no presente
documento devem ser interpretados como descrito na [RFC 2119]
(http://tools.ietf.org/html/rfc2119).


  
    Software usando Versionamento Semântico DEVE declarar uma API pública. Esta
API poderá ser declarada no próprio código ou existir estritamente na
documentação, desde que seja precisa e compreensiva.
  
  
    Um número de versão normal DEVE ter o formato de X.Y.Z, onde X, Y, e Z são
inteiros não negativos. X é a versão Maior, Y é a versão Menor, e Z é a versão
de Correção. Cada elemento DEVE aumentar numericamente por incrementos de um.
Por exemplo: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Uma vez que um pacote versionado foi lançado (released), o conteúdo desta
versão NÃO DEVE ser modificado. Qualquer modificação DEVE ser lançado como uma
nova versão.
  
  
    No início do desenvolvimento, a versão Maior DEVE ser zero (0.y.z). Qualquer
coisa pode mudar a qualquer momento. A API pública não deve ser considerada
estável.
  
  
    Versão 1.0.0 define a API como pública. A maneira como o número de versão é
incrementado após este lançamento é dependente da API pública e como ela muda.
  
  
    Versão de Correção Z (x.y.Z | x > 0) DEVE ser incrementado apenas se mantiver
compatibilidade e introduzir correção de bugs. Uma correção de bug é definida
como uma mudança interna que corrige um comportamento incorreto.
  
  
    Versão Menor Y (x.Y.z | x > 0) DEVE  ser incrementada se uma funcionalidade
nova e compatível for introduzida na API pública. DEVE ser incrementada se
qualquer funcionalidade da API pública for definida como descontinuada. PODE ser
incrementada se uma nova funcionalidade ou melhoria substancial for introduzida
dentro do código privado. PODE incluir mudanças a nível de correção. A versão de
Correção deve ser redefinida para 0(zero) quando a versão Menor for
incrementada.
  
  
    Versão Maior X (X.y.z | X > 0) DEVE ser incrementada se forem introduzidas
mudanças incompatíveis na API pública. PODE incluir alterações a nível de versão
Menor e de versão de Correção. Versão de Correção e Versão Menor devem ser
redefinidas para 0(zero) quando a versão Maior for incrementada.
  
  
    Uma versão de Pré-Lançamento (pre-release) PODE ser identificada adicionando
um hífen e uma série de identificadores separados por ponto (dot)
imediatamente após a versão de Correção. o identificador DEVE compreender
apenas caracteres alfanumérios e hífen [0-9A-Za-z-]. Versão de
Pré-Lançamento tem precedência inferior à versão normal a que está associada.
Exemplos: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Metadados de Construção (build) PODE ser identificada por adicionar um
sinal de adição (+) e uma série de identificadores separados por ponto
imediatamente após a versão de Correção ou Pré-Lançamento. Identificador DEVE
compreende apenas caracteres alfanumérios e hífen [0-9A-Za-z-]. Metadados de
Construção DEVEM ser ignorados quando for determinada uma versão precendente. 
Por isso, dois pacotes com a mesma versão, mas diferentes metadados de construção
são considerados sendo da mesma versão. Exemplos:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    A precendência DEVE ser calculada separando identificadores de versão em
Maior, Menor, Correção e Pré-lançamento, nesta ordem (metadados de construção
não possuem precendência). Versões Maior, Menor e Correção são sempre
comparadas numericamente. A precedência de versões de Pré-lançamento DEVE ser
determinada comparando cada identificador separado por ponto da seguinte forma: identificadores consistindo apenas dígitos são comparados numericamente e
identificadores com letras ou hífen são comparados lexicalmente na ordem de
classificação ASCII.
Identificadores numéricos sempre têm menor precedência do que os não numéricos.
Exemplo: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1
< 1.0.0.
  


Por que usar Versionamento Semântico?

Esta não é uma ideia nova ou revolucionária. De fato, você provavelmente já faz
algo próximo a isso. O problema é que “próximo” não é bom o bastante. Sem a
aderência a algum tipo de especificação formal, os números de versão são
essencialmente inúteis para gerenciamento de dependências. Dando um nome e
definições claras às ideias acima, fica fácil comunicar suas intenções aos
usuários de seu software. Uma vez que estas intenções estão claras,
especificações de dependências flexíveis (mas não tão flexíveis) finalmente
podem ser feitas.

Um exemplo simples vai demonstrar como o Versionamento Semântico pode fazer do
inferno de dependência uma coisa do passado. Considere uma biblioteca chamada
“CaminhaoBombeiros”. Ela requer um pacote versionado dinamicamente chamado
“Escada”. Quando CaminhaoBombeiros foi criado, Escada estava na versão 3.1.0.
Como CaminhaoBombeiros utiliza algumas funcionalidades que foram inicialmente
introduzidas na versão 3.1.0, você pode especificar, com segurança, a
dependência da Escada como maior ou igual a 3.1.0 porém menor que 4.0.0. Agora,
quando Escada versão 3.1.1 e 3.2.0 estiverem disponíveis, você poderá lançá-los
ao seu sistema de gerenciamento de pacote e saberá que eles serão compatíveis
com os softwares dependentes existentes.

Como um desenvolvedor responsável você irá, é claro, querer certificar-se que
qualquer atualização no pacote funcionará como anunciado. O mundo real é um
lugar bagunçado; não há nada que possamos fazer quanto a isso senão sermos
vigilantes. O que você pode fazer é deixar o Versionamento Semântico lhe
fornecer uma maneira sensata de lançar e atualizar pacotes sem precisar
atualizar para novas versões de pacotes dependentes, salvando-lhe tempo e
aborrecimento.

Se tudo isto soa desejável, tudo que você precisar fazer para começar a usar
Versionamento Semântico é declarar que você o esta usando e então, seguir as
regras. Adicione um link para este website no seu README para que outros saibam
as regras e possam beneficiar-se delas.

FAQ

Como devo lidar com revisões na fase 0.y.z de desenvolvimento inicial?

A coisa mais simples a se fazer é começar sua versão de desenvolvimento inicial
em 0.1.0 e, então, incrementar a uma versão ‘menor’ em cada lançamento
subsequente.

Como eu sei quando lançar a versão 1.0.0?

Se seu software está sendo usado em produção, ele já deve ser provavelmente
1.0.0. Se você possui uma API estável a qual usuários passaram a depender, deve
ser 1.0.0. Se você está se preocupando bastante com compatibilidade com versões
anteriores, já deve ser 1.0.0.

Isto não desencoraja o desenvolvimento ágil e iteração rápida?

A versão Maior zero tem o foco exatamente no desenvolvimento rápido. Se você
está mudando a API todo dia, provavelmente você está na versão 0.y.z ou num
branch separado de desenvolvimento, trabalhando numa próxima versão Maior.

Se mesmo a menor mudança incompatível com a API pública requer aumento da versão maior, não vou acabar na versão 42.0.0 muito rapidamente?

Esta é uma questão de desenvolvimento responsável e conhecimento antecipado.
Mudanças incompatíveis não devem ser levemente introduzidas para o software que
tem um monte de código dependente. O custo que deve ser incorrido para atualizar
pode ser significante. Tendo que aumentar a versão maior para lançar mudanças
incompatíveis, significa que você pensará no impacto das suas mudanças, e
avaliará a relação de custo/benefício envolvida.

Documentar toda a API pública dá muito trabalho!

É sua responsabilidade como desenvolvedor profissional documentar corretamente o
software que será usado por outros. Gerenciar a complexidade de software é uma
parte muito importante para manter o projeto eficiente, e isto é difícil de
fazer se ninguém sabe como usá-lo ou que métodos são seguros de chamar. A longo
prazo, Versionamento Semântico e a insistência em uma API pública bem definida
podem deixar tudo e todos funcionamente suavemente.

O que eu faço se, acidentalmente, liberar uma mudança incompatível com versões anteriores como uma versão menor (minor version)?

Assim que você perceber que quebrou a especificação de versionamento semântico,
conserte o problema e lance uma nova versão menor, que corrige o problema e
restaura a retrocompatibilidade. Mesmo sob esta circunstância, é inaceitável
modificar versões lançadas. Se for apropriado, documente a versão ofensiva e
informe seus usuários do problema de forma que eles fiquem cientes da versão em
questão.

O que devo fazer se eu atualizar minhas próprias dependências sem modificar a API pública?

Isso seria considerado compatível, uma vez que não afeta a API pública. Software
que depende explicitamente das mesmas dependências que seu pacote, deve ter sua
própria especificação de dependência e o autor notificará quaisquer conflitos.
Para determinar se a mudança é a nível de correção ou modificação de nível menor
dependente se você atualizou suas dependências a fim de corrigir um bug ou
introduzir nova funcionalidade. Eu normalmente esperaria código adicional para
última instância, caso em que é obviamente um incremento no nível menor.

O que devo fazer se o erro que está sendo corrigido retorna o código para estar em conformidade com a API pública (ou seja, o código estava incorretamente fora de sincronia com a documentação da API pública)?

Use o bom senso. Se você tem um público enorme que será drasticamente impactado
pela mudança de comportamento de volta para o que a API pública pretendida,
então pode ser melhor realizar um lançamento de uma versão maior, mesmo que a
correção pudesse ser considerada estritamente uma versão de correção.Lembre-se,
Versionamento Semântico trata de transmitir o conhecimento das mudanças
ocorridas na versão. Se estas mudanças são importantes para seus usuários,
utilize o número da versão para informá-los.

Como devo lidar com descontinuação de funcionalidades?

Descontinuar funcionalidades é um processo comum no desenvolvimento de software
e muitas vezes é necessário para haver progresso. Quando você descontinua parte
de sua API pública, você deve fazer duas coisas: (1) atualizar sua documentação,
para que os usuários saibam das mudanças, (2) lançar uma versão Menor anunciando
a descontinuação. Antes de remover completamente a funcionalidade em uma versão
Maior deve haver ao menos uma versão Menor que possui a descontinução anunciada,
fazendo com que os usuários realizem uma transição tranquila para a nova API.

Sobre

A Especificação da Semântica de Versionamento é autoria de Tom
Preston-Werner, criador do Gravatars e
co-fundador do GitHub.

Caso queira deixar sua opinião, por favor abra uma issue no
GitHub.

Licença

Creative Commons ― CC BY 3.0\nVersionamento Semântico 2.0.0-rc.1\nNo mundo de gerenciamento de software existe algo terrível conhecido como
inferno das dependências (“dependency hell”). Quanto mais o sistema cresce, e
mais pacotes são adicionados a ele, maior será a possibilidade de, um dia, você
encontrar-se neste poço de desespero.\nEm sistemas com muitas dependências, lançar novos pacotes de versões pode se
tornar rapidamente um pesadelo. Se as especificações das dependências são muito
amarradas você corre o risco de um bloqueio de versão (A falta de capacidade de
atualizar um pacote sem ter de liberar novas versões de cada pacote dependente).
Se as dependências são vagamente especificadas, você irá inevitavelmente ser
mordido pela ‘promiscuidade da versão’ (assumindo compatibilidade com futuras
versões mais do que é razoável). O inferno das dependências é onde você está
quando um bloqueio de versão e/ou promiscuidade de versão te impede de seguir
em frente com seu projeto de maneira fácil e segura.\nComo uma solução para este problema proponho um conjunto simples de regras e
requisitos que ditam como os números das versões são atribuídos e incrementados.\nPara que este sistema funcione, primeiro você precisa declarar uma API pública.
Isto pode consistir de documentação ou ser determinada pelo próprio código. De
qualquer maneira, é importante que esta API seja clara e precisa. Depois de
identificada a API pública, você comunica as mudanças com incrementos
específicos para o seu número de versão. Considere o formato de versão X.Y.Z
(Maior.Menor.Correção). Correção de falhas (bug fixes) que não afetam a API,
incrementa a versão de Correção, adições/alterações compatíveis com as versões
anteriores da API incrementa a versão Menor, e alterações incompatíveis com as
versões anteriores da API incrementa a versão Maior.\nEu chamo esse sistema de “Versionamento Semântico”. Sob este esquema, os números
de versão e a forma como eles mudam, transmite o significado do código
subjacente e o que foi modificado de uma versão para a próxima.\nEspecificação de Versionamento Semântico (SemVer)\nAs palavras-chaves “DEVE”, “NÃO DEVE”, “OBRIGATÓRIO”, “DEVERÁ”, “NÃO DEVERÁ”,
“DEVERIA”, “NÃO DEVERIA”, “RECOMENDADO”, “PODE” e “OPCIONAL” no presente
documento devem ser interpretados como descrito na [RFC 2119]
(http://tools.ietf.org/html/rfc2119).\nSoftware usando Versionamento Semântico DEVE declarar uma API pública. Esta
API poderá ser declarada no próprio código ou existir estritamente na
documentação, desde que seja precisa e compreensiva.\nSoftware usando Versionamento Semântico DEVE declarar uma API pública. Esta
API poderá ser declarada no próprio código ou existir estritamente na
documentação, desde que seja precisa e compreensiva.\nUm número de versão normal DEVE ter o formato de X.Y.Z, onde X, Y, e Z são
inteiros não negativos. X é a versão Maior, Y é a versão Menor, e Z é a versão
de Correção. Cada elemento DEVE aumentar numericamente por incrementos de um.
Por exemplo: 1.9.0 -> 1.10.0 -> 1.11.0.\nUm número de versão normal DEVE ter o formato de X.Y.Z, onde X, Y, e Z são
inteiros não negativos. X é a versão Maior, Y é a versão Menor, e Z é a versão
de Correção. Cada elemento DEVE aumentar numericamente por incrementos de um.
Por exemplo: 1.9.0 -> 1.10.0 -> 1.11.0.\nUma vez que um pacote versionado foi lançado (released), o conteúdo desta
versão NÃO DEVE ser modificado. Qualquer modificação DEVE ser lançado como uma
nova versão.\nUma vez que um pacote versionado foi lançado (released), o conteúdo desta
versão NÃO DEVE ser modificado. Qualquer modificação DEVE ser lançado como uma
nova versão.\nNo início do desenvolvimento, a versão Maior DEVE ser zero (0.y.z). Qualquer
coisa pode mudar a qualquer momento. A API pública não deve ser considerada
estável.\nNo início do desenvolvimento, a versão Maior DEVE ser zero (0.y.z). Qualquer
coisa pode mudar a qualquer momento. A API pública não deve ser considerada
estável.\nVersão 1.0.0 define a API como pública. A maneira como o número de versão é
incrementado após este lançamento é dependente da API pública e como ela muda.\nVersão 1.0.0 define a API como pública. A maneira como o número de versão é
incrementado após este lançamento é dependente da API pública e como ela muda.\nVersão de Correção Z (x.y.Z | x > 0) DEVE ser incrementado apenas se mantiver
compatibilidade e introduzir correção de bugs. Uma correção de bug é definida
como uma mudança interna que corrige um comportamento incorreto.\nVersão de Correção Z (x.y.Z | x > 0) DEVE ser incrementado apenas se mantiver
compatibilidade e introduzir correção de bugs. Uma correção de bug é definida
como uma mudança interna que corrige um comportamento incorreto.\nVersão Menor Y (x.Y.z | x > 0) DEVE  ser incrementada se uma funcionalidade
nova e compatível for introduzida na API pública. DEVE ser incrementada se
qualquer funcionalidade da API pública for definida como descontinuada. PODE ser
incrementada se uma nova funcionalidade ou melhoria substancial for introduzida
dentro do código privado. PODE incluir mudanças a nível de correção. A versão de
Correção deve ser redefinida para 0(zero) quando a versão Menor for
incrementada.\nVersão Menor Y (x.Y.z | x > 0) DEVE  ser incrementada se uma funcionalidade
nova e compatível for introduzida na API pública. DEVE ser incrementada se
qualquer funcionalidade da API pública for definida como descontinuada. PODE ser
incrementada se uma nova funcionalidade ou melhoria substancial for introduzida
dentro do código privado. PODE incluir mudanças a nível de correção. A versão de
Correção deve ser redefinida para 0(zero) quando a versão Menor for
incrementada.\nVersão Maior X (X.y.z | X > 0) DEVE ser incrementada se forem introduzidas
mudanças incompatíveis na API pública. PODE incluir alterações a nível de versão
Menor e de versão de Correção. Versão de Correção e Versão Menor devem ser
redefinidas para 0(zero) quando a versão Maior for incrementada.\nVersão Maior X (X.y.z | X > 0) DEVE ser incrementada se forem introduzidas
mudanças incompatíveis na API pública. PODE incluir alterações a nível de versão
Menor e de versão de Correção. Versão de Correção e Versão Menor devem ser
redefinidas para 0(zero) quando a versão Maior for incrementada.\nUma versão de Pré-Lançamento (pre-release) PODE ser identificada adicionando
um hífen e uma série de identificadores separados por ponto (dot)
imediatamente após a versão de Correção. o identificador DEVE compreender
apenas caracteres alfanumérios e hífen [0-9A-Za-z-]. Versão de
Pré-Lançamento tem precedência inferior à versão normal a que está associada.
Exemplos: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nUma versão de Pré-Lançamento (pre-release) PODE ser identificada adicionando
um hífen e uma série de identificadores separados por ponto (dot)
imediatamente após a versão de Correção. o identificador DEVE compreender
apenas caracteres alfanumérios e hífen [0-9A-Za-z-]. Versão de
Pré-Lançamento tem precedência inferior à versão normal a que está associada.
Exemplos: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nMetadados de Construção (build) PODE ser identificada por adicionar um
sinal de adição (+) e uma série de identificadores separados por ponto
imediatamente após a versão de Correção ou Pré-Lançamento. Identificador DEVE
compreende apenas caracteres alfanumérios e hífen [0-9A-Za-z-]. Metadados de
Construção DEVEM ser ignorados quando for determinada uma versão precendente. 
Por isso, dois pacotes com a mesma versão, mas diferentes metadados de construção
são considerados sendo da mesma versão. Exemplos:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nMetadados de Construção (build) PODE ser identificada por adicionar um
sinal de adição (+) e uma série de identificadores separados por ponto
imediatamente após a versão de Correção ou Pré-Lançamento. Identificador DEVE
compreende apenas caracteres alfanumérios e hífen [0-9A-Za-z-]. Metadados de
Construção DEVEM ser ignorados quando for determinada uma versão precendente. 
Por isso, dois pacotes com a mesma versão, mas diferentes metadados de construção
são considerados sendo da mesma versão. Exemplos:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nA precendência DEVE ser calculada separando identificadores de versão em
Maior, Menor, Correção e Pré-lançamento, nesta ordem (metadados de construção
não possuem precendência). Versões Maior, Menor e Correção são sempre
comparadas numericamente. A precedência de versões de Pré-lançamento DEVE ser
determinada comparando cada identificador separado por ponto da seguinte forma: identificadores consistindo apenas dígitos são comparados numericamente e
identificadores com letras ou hífen são comparados lexicalmente na ordem de
classificação ASCII.
Identificadores numéricos sempre têm menor precedência do que os não numéricos.
Exemplo: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1
< 1.0.0.\nA precendência DEVE ser calculada separando identificadores de versão em
Maior, Menor, Correção e Pré-lançamento, nesta ordem (metadados de construção
não possuem precendência). Versões Maior, Menor e Correção são sempre
comparadas numericamente. A precedência de versões de Pré-lançamento DEVE ser
determinada comparando cada identificador separado por ponto da seguinte forma: identificadores consistindo apenas dígitos são comparados numericamente e
identificadores com letras ou hífen são comparados lexicalmente na ordem de
classificação ASCII.
Identificadores numéricos sempre têm menor precedência do que os não numéricos.
Exemplo: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1
< 1.0.0.\nPor que usar Versionamento Semântico?\nEsta não é uma ideia nova ou revolucionária. De fato, você provavelmente já faz
algo próximo a isso. O problema é que “próximo” não é bom o bastante. Sem a
aderência a algum tipo de especificação formal, os números de versão são
essencialmente inúteis para gerenciamento de dependências. Dando um nome e
definições claras às ideias acima, fica fácil comunicar suas intenções aos
usuários de seu software. Uma vez que estas intenções estão claras,
especificações de dependências flexíveis (mas não tão flexíveis) finalmente
podem ser feitas.\nUm exemplo simples vai demonstrar como o Versionamento Semântico pode fazer do
inferno de dependência uma coisa do passado. Considere uma biblioteca chamada
“CaminhaoBombeiros”. Ela requer um pacote versionado dinamicamente chamado
“Escada”. Quando CaminhaoBombeiros foi criado, Escada estava na versão 3.1.0.
Como CaminhaoBombeiros utiliza algumas funcionalidades que foram inicialmente
introduzidas na versão 3.1.0, você pode especificar, com segurança, a
dependência da Escada como maior ou igual a 3.1.0 porém menor que 4.0.0. Agora,
quando Escada versão 3.1.1 e 3.2.0 estiverem disponíveis, você poderá lançá-los
ao seu sistema de gerenciamento de pacote e saberá que eles serão compatíveis
com os softwares dependentes existentes.\nComo um desenvolvedor responsável você irá, é claro, querer certificar-se que
qualquer atualização no pacote funcionará como anunciado. O mundo real é um
lugar bagunçado; não há nada que possamos fazer quanto a isso senão sermos
vigilantes. O que você pode fazer é deixar o Versionamento Semântico lhe
fornecer uma maneira sensata de lançar e atualizar pacotes sem precisar
atualizar para novas versões de pacotes dependentes, salvando-lhe tempo e
aborrecimento.\nSe tudo isto soa desejável, tudo que você precisar fazer para começar a usar
Versionamento Semântico é declarar que você o esta usando e então, seguir as
regras. Adicione um link para este website no seu README para que outros saibam
as regras e possam beneficiar-se delas.\nComo devo lidar com revisões na fase 0.y.z de desenvolvimento inicial?\nA coisa mais simples a se fazer é começar sua versão de desenvolvimento inicial
em 0.1.0 e, então, incrementar a uma versão ‘menor’ em cada lançamento
subsequente.\nComo eu sei quando lançar a versão 1.0.0?\nSe seu software está sendo usado em produção, ele já deve ser provavelmente
1.0.0. Se você possui uma API estável a qual usuários passaram a depender, deve
ser 1.0.0. Se você está se preocupando bastante com compatibilidade com versões
anteriores, já deve ser 1.0.0.\nIsto não desencoraja o desenvolvimento ágil e iteração rápida?\nA versão Maior zero tem o foco exatamente no desenvolvimento rápido. Se você
está mudando a API todo dia, provavelmente você está na versão 0.y.z ou num
branch separado de desenvolvimento, trabalhando numa próxima versão Maior.\nSe mesmo a menor mudança incompatível com a API pública requer aumento da versão maior, não vou acabar na versão 42.0.0 muito rapidamente?\nEsta é uma questão de desenvolvimento responsável e conhecimento antecipado.
Mudanças incompatíveis não devem ser levemente introduzidas para o software que
tem um monte de código dependente. O custo que deve ser incorrido para atualizar
pode ser significante. Tendo que aumentar a versão maior para lançar mudanças
incompatíveis, significa que você pensará no impacto das suas mudanças, e
avaliará a relação de custo/benefício envolvida.\nDocumentar toda a API pública dá muito trabalho!\nÉ sua responsabilidade como desenvolvedor profissional documentar corretamente o
software que será usado por outros. Gerenciar a complexidade de software é uma
parte muito importante para manter o projeto eficiente, e isto é difícil de
fazer se ninguém sabe como usá-lo ou que métodos são seguros de chamar. A longo
prazo, Versionamento Semântico e a insistência em uma API pública bem definida
podem deixar tudo e todos funcionamente suavemente.\nO que eu faço se, acidentalmente, liberar uma mudança incompatível com versões anteriores como uma versão menor (minor version)?\nAssim que você perceber que quebrou a especificação de versionamento semântico,
conserte o problema e lance uma nova versão menor, que corrige o problema e
restaura a retrocompatibilidade. Mesmo sob esta circunstância, é inaceitável
modificar versões lançadas. Se for apropriado, documente a versão ofensiva e
informe seus usuários do problema de forma que eles fiquem cientes da versão em
questão.\nO que devo fazer se eu atualizar minhas próprias dependências sem modificar a API pública?\nIsso seria considerado compatível, uma vez que não afeta a API pública. Software
que depende explicitamente das mesmas dependências que seu pacote, deve ter sua
própria especificação de dependência e o autor notificará quaisquer conflitos.
Para determinar se a mudança é a nível de correção ou modificação de nível menor
dependente se você atualizou suas dependências a fim de corrigir um bug ou
introduzir nova funcionalidade. Eu normalmente esperaria código adicional para
última instância, caso em que é obviamente um incremento no nível menor.\nO que devo fazer se o erro que está sendo corrigido retorna o código para estar em conformidade com a API pública (ou seja, o código estava incorretamente fora de sincronia com a documentação da API pública)?\nUse o bom senso. Se você tem um público enorme que será drasticamente impactado
pela mudança de comportamento de volta para o que a API pública pretendida,
então pode ser melhor realizar um lançamento de uma versão maior, mesmo que a
correção pudesse ser considerada estritamente uma versão de correção.Lembre-se,
Versionamento Semântico trata de transmitir o conhecimento das mudanças
ocorridas na versão. Se estas mudanças são importantes para seus usuários,
utilize o número da versão para informá-los.\nComo devo lidar com descontinuação de funcionalidades?\nDescontinuar funcionalidades é um processo comum no desenvolvimento de software
e muitas vezes é necessário para haver progresso. Quando você descontinua parte
de sua API pública, você deve fazer duas coisas: (1) atualizar sua documentação,
para que os usuários saibam das mudanças, (2) lançar uma versão Menor anunciando
a descontinuação. Antes de remover completamente a funcionalidade em uma versão
Maior deve haver ao menos uma versão Menor que possui a descontinução anunciada,
fazendo com que os usuários realizem uma transição tranquila para a nova API.\nA Especificação da Semântica de Versionamento é autoria de Tom
Preston-Werner, criador do Gravatars e
co-fundador do GitHub.\nCaso queira deixar sua opinião, por favor abra uma issue no
GitHub.\nabra uma issue no
GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nVersionamento Semântico 2.0.0-rc.1

No mundo de gerenciamento de software existe algo terrível conhecido como
inferno das dependências (“dependency hell”). Quanto mais o sistema cresce, e
mais pacotes são adicionados a ele, maior será a possibilidade de, um dia, você
encontrar-se neste poço de desespero.

Em sistemas com muitas dependências, lançar novos pacotes de versões pode se
tornar rapidamente um pesadelo. Se as especificações das dependências são muito
amarradas você corre o risco de um bloqueio de versão (A falta de capacidade de
atualizar um pacote sem ter de liberar novas versões de cada pacote dependente).
Se as dependências são vagamente especificadas, você irá inevitavelmente ser
mordido pela ‘promiscuidade da versão’ (assumindo compatibilidade com futuras
versões mais do que é razoável). O inferno das dependências é onde você está
quando um bloqueio de versão e/ou promiscuidade de versão te impede de seguir
em frente com seu projeto de maneira fácil e segura.

Como uma solução para este problema proponho um conjunto simples de regras e
requisitos que ditam como os números das versões são atribuídos e incrementados.

Para que este sistema funcione, primeiro você precisa declarar uma API pública.
Isto pode consistir de documentação ou ser determinada pelo próprio código. De
qualquer maneira, é importante que esta API seja clara e precisa. Depois de
identificada a API pública, você comunica as mudanças com incrementos
específicos para o seu número de versão. Considere o formato de versão X.Y.Z
(Maior.Menor.Correção). Correção de falhas (bug fixes) que não afetam a API,
incrementa a versão de Correção, adições/alterações compatíveis com as versões
anteriores da API incrementa a versão Menor, e alterações incompatíveis com as
versões anteriores da API incrementa a versão Maior.

Eu chamo esse sistema de “Versionamento Semântico”. Sob este esquema, os números
de versão e a forma como eles mudam, transmite o significado do código
subjacente e o que foi modificado de uma versão para a próxima.

Especificação de Versionamento Semântico (SemVer)

As palavras-chaves “DEVE”, “NÃO DEVE”, “OBRIGATÓRIO”, “DEVERÁ”, “NÃO DEVERÁ”,
“DEVERIA”, “NÃO DEVERIA”, “RECOMENDADO”, “PODE” e “OPCIONAL” no presente
documento devem ser interpretados como descrito na RFC 2119.


  
    Software usando Versionamento Semântico DEVE declarar uma API pública. Esta
API poderá ser declarada no próprio código ou existir estritamente na
documentação, desde que seja precisa e compreensiva.
  
  
    Um número de versão normal DEVE ter o formato de X.Y.Z, onde X, Y, e Z são
inteiros não negativos. X é a versão Maior, Y é a versão Menor, e Z é a versão
de Correção. Cada elemento DEVE aumentar numericamente por incrementos de um.
Por exemplo: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Quando o número de uma versão maior for incrementado, a versão menor e a
versão de correção DEVEM ser reinicializadas para 0 (zero). Quando o número de
uma versão menor foi incrementado, a versão de correção DEVE ser reinicializada
como 0 (zero). Por exemplo: 1.1.3 -> 2.0.0 e 2.1.7 -> 2.2.0.
  
  
    Uma vez que um pacote versionado foi lançado (released), o conteúdo desta
versão NÃO DEVE ser modificado. Qualquer modificação deve ser lançado como uma
nova versão.
  
  
    No início do desenvolvimento, a versão Maior DEVE ser zero (0.y.z). Qualquer
coisa pode mudar a qualquer momento. A API pública não deve ser considerada
estável.
  
  
    Versão 1.0.0 define a API como pública. A maneira como o número de versão é
incrementado após este lançamento é dependente da API pública e como ela muda.
  
  
    Versão de Correção Z (x.y.Z | x > 0) DEVE ser incrementado apenas se mantiver
compatibilidade e introduzir correção de bugs. Uma correção de bug é definida
como uma mudança interna que corrige um comportamento incorreto.
  
  
    Versão Menor Y (x.Y.z | x > 0) DEVE  ser incrementada se uma funcionalidade
nova e compatível for introduzida na API pública. DEVE ser incrementada se
qualquer funcionalidade da API pública for definida como descontinuada. PODE ser
incrementada se uma nova funcionalidade ou melhoria substancial for introduzida
dentro do código privado. PODE incluir mudanças a nível de correção. A versão de
Correção deve ser redefinida para 0(zero) quando a versão Menor for
incrementada.
  
  
    Versão Maior X (X.y.z | X > 0) DEVE ser incrementada se forem introduzidas
mudanças incompatíveis na API pública. PODE incluir alterações a nível de versão
Menor e de versão de Correção. Versão de Correção e Versão Menor devem ser
redefinidas para 0(zero) quando a versão Maior for incrementada.
  
  
    Uma versão de Pré-Lançamento (pre-release) PODE ser identificada adicionando
um hífen (dash) e uma série de identificadores separados por ponto (dot)
imediatamente após a versão de Correção. o identificador DEVE ser composto
apenas por caracteres alfanumérios e hífen [0-9A-Za-z-]. Versão de
Pré-Lançamento tem  precedência inferior à versão normal a que está associada.
Exemplos: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Uma versão de Construção (build) PODE ser identificada por adicionar um
sinal de adição (+) e uma série de identificadores separados por ponto
imediatamente após a versão de Correção ou Pré-Lançamento. Identificador DEVE
ser composto apenas por caracteres alfanumérios e hífen [0-9A-Za-z-]. Versões de
Construção têm precedência maior à versão normal a que está associada. Exemplos:
1.0.0+build.1, 1.3.7+build.11.e0f985a.
  
  
    A precendência DEVE ser calculada separando identificadores de versão em
Maior, Menor, Correção, Pré-lançamento e Construção, nesta ordem. Versões Maior,
Menor e Correção são sempre comparadas numericamente. A precedência de versões
de Pré-lançamento e Construção DEVE ser determinada comparando cada
identificador separado por ponto da seguinte forma: identificadores consistindo
apenas dígitos são comparados numericamente e identificadores com letras ou
hífen são comparados lexicalmente na ordem de classificação ASCII.
Identificadores numéricos sempre têm menor precedência do que os não numéricos.
Exemplo: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1
< 1.0.0-rc.1+build.1 < 1.0.0 < 1.0.0+0.3.7 < 1.3.7+build < 1.3.7+build.2.b8f12d7
< 1.3.7+build.11.e0f985a.
  


Por que usar Versionamento Semântico?

Esta não é uma ideia nova ou revolucionária. De fato, você provavelmente já faz
algo próximo a isso. O problema é que “próximo” não é bom o bastante. Sem a
aderência a algum tipo de especificação formal, os números de versão são
essencialmente inúteis para gerenciamento de dependências. Dando um nome e
definições claras às ideias acima, fica fácil comunicar suas intenções aos
usuários de seu software. Uma vez que estas intenções estão claras,
especificações de dependências flexíveis (mas não tão flexíveis) finalmente
podem ser feitas.

Um exemplo simples vai demonstrar como o Versionamento Semântico pode fazer do
inferno de dependência uma coisa do passado. Considere uma biblioteca chamada
“CaminhaoBombeiros”. Ela requer um pacote versionado dinamicamente chamado
“Escada”. Quando CaminhaoBombeiros foi criado, Escada estava na versão 3.1.0.
Como CaminhaoBombeiros utiliza algumas funcionalidades que foram inicialmente
introduzidas na versão 3.1.0, você pode especificar, com segurança, a
dependência da Escada como maior ou igual a 3.1.0 porém menor que 4.0.0. Agora,
quando Escada versão 3.1.1 e 3.2.0 estiverem disponíveis, você poderá lançá-los
ao seu sistema de gerenciamento de pacote e saberá que eles serão compatíveis
com os softwares dependentes existentes.

Como um desenvolvedor responsável você irá, é claro, querer certificar-se que
qualquer atualização no pacote funcionará como anunciado. O mundo real é um
lugar bagunçado; não há nada que possamos fazer quanto a isso senão sermos
vigilantes. O que você pode fazer é deixar o Versionamento Semântico lhe
fornecer uma maneira sensata de lançar e atualizar pacotes sem precisar
atualizar para novas versões de pacotes dependentes, salvando-lhe tempo e
aborrecimento.

Se tudo isto soa desejável, tudo que você precisar fazer para começar a usar
Versionamento Semântico é declarar que você o esta usando e então, seguir as
regras. Adicione um link para este website no seu README para que outros saibam
as regras e possam beneficiar-se delas.

FAQ

Como devo lidar com revisões na fase 0.y.z de desenvolvimento inicial?

A coisa mais simples a se fazer é começar sua versão de desenvolvimento inicial
em 0.1.0 e, então, incrementar a uma versão ‘menor’ em cada lançamento
subsequente.

Como eu sei quando lançar a versão 1.0.0?

Se seu software está sendo usado em produção, ele já deve ser provavelmente
1.0.0. Se você possui uma API estável a qual usuários passaram a depender, deve
ser 1.0.0. Se você está se preocupando bastante com compatibilidade com versões
anteriores, já deve ser 1.0.0.

Isto não desencoraja o desenvolvimento ágil e iteração rápida?

A versão Maior zero tem o foco exatamente no desenvolvimento rápido. Se você
está mudando a API todo dia, provavelmente você está na versão 0.x.x ou num
branch separado de desenvolvimento, trabalhando numa próxima versão Maior.

Se mesmo a menor mudança incompatível com a API pública requer aumento da versão maior, não vou acabar na versão 42.0.0 muito rapidamente?

Esta é uma questão de desenvolvimento responsável e conhecimento antecipado.
Mudanças incompatíveis não devem ser levemente introduzidas para o software que
tem um monte de código dependente. O custo que deve ser incorrido para atualizar
pode ser significante. Tendo que aumentar a versão maior para lançar mudanças
incompatíveis, significa que você pensará no impacto das suas mudanças, e
avaliará a relação de custo/benefício envolvida.

Documentar toda a API pública dá muito trabalho!

É sua responsabilidade como desenvolvedor profissional documentar corretamente o
software que será usado por outros. Gerenciar a complexidade de software é uma
parte muito importante para manter o projeto eficiente, e isto é difícil de
fazer se ninguém sabe como usá-lo ou que métodos são seguros de chamar. A longo
prazo, Versionamento Semântico e a insistência em uma API pública bem definida
podem deixar tudo e todos funcionamente suavemente.

O que eu faço se, acidentalmente, liberar uma mudança incompatível com versões anteriores como uma versão menor (minor version)?

Assim que você perceber que quebrou a especificação de versionamento semântico,
conserte o problema e lance uma nova versão menor, que corrige o problema e
restaura a compatibilidade. Lembre-se que é inaceitável modificar versões
lançadas, mesmo sob essas circustâncias. Se for apropriado, documente a versão
ofensiva e informe seus usuários do problema de forma que eles fiquem cientes da
versão em questão.

O que devo fazer se eu atualizar minhas próprias dependências sem modificar a API pública?

Isso seria considerado compatível, uma vez que não afeta a API pública. Software
que depende explicitamente da mesmas dependências que seu pacote, deve ter sua
própria especificação de dependência e o autor notificará quaisquer conflitos.
Para determinar se a mudança é a nível de correção ou modificação de nível menor
dependente se você atualizou suas dependências a fim de corrigir um bug ou
introduzir nova funcionalidade. Eu normalmente esperaria código adicional para
última instância, caso em que é obviamente um incremento no nível menor.

O que devo fazer se o erro que está sendo corrigido retorna o código para estar em conformidade com a API pública (ou seja, o código estava incorretamente fora de sincronia com a documentação da API pública)?

Use o bom senso. Se você tem um público enorme que será drasticamente impactado
pela mudança de comportamento de volta para o que a API pública pretendida,
então pode ser melhor realizar um lançamento de uma versão maior, mesmo que a
correção pudesse ser considerada estritamente uma versão de correção.Lembre-se,
Versionamento Semântico trata de transmitir o conhecimento das mudanças
ocorridas na versão. Se estas mudanças são importantes para seus usuários,
utilize o número da versão para informá-los.

Como devo lidar com descontinuação de funcionalidades?

Descontinuar funcionalidades é um processo comum no desenvolvimento de software e
muitas vezes é necessário para haver progresso. Quando você descontinua partes de
sua API pública, você deve fazer duas coisas: (1) atualizar sua documentação,
para que os usuários saibam das mudanças, (2) lançar uma versão Menor anunciando
a descontinuação. Antes de remover completamente a funcionalidade em uma versão
Maior deve haver ao menos uma versão Menor que possui a descontinução anunciada,
fazendo com que os usuários realizem uma transição tranquila para a nova API.

Sobre

A Especificação da Semântica de Versionamento é autoria de Tom
Preston-Werner, criador do Gravatars e
co-fundador do GitHub.

Caso queira deixar sua opinião, por favor abra uma issue no GitHub.

Licença

Creative Commons ― CC BY 3.0\nVersionamento Semântico 2.0.0-rc.1\nNo mundo de gerenciamento de software existe algo terrível conhecido como
inferno das dependências (“dependency hell”). Quanto mais o sistema cresce, e
mais pacotes são adicionados a ele, maior será a possibilidade de, um dia, você
encontrar-se neste poço de desespero.\nEm sistemas com muitas dependências, lançar novos pacotes de versões pode se
tornar rapidamente um pesadelo. Se as especificações das dependências são muito
amarradas você corre o risco de um bloqueio de versão (A falta de capacidade de
atualizar um pacote sem ter de liberar novas versões de cada pacote dependente).
Se as dependências são vagamente especificadas, você irá inevitavelmente ser
mordido pela ‘promiscuidade da versão’ (assumindo compatibilidade com futuras
versões mais do que é razoável). O inferno das dependências é onde você está
quando um bloqueio de versão e/ou promiscuidade de versão te impede de seguir
em frente com seu projeto de maneira fácil e segura.\nComo uma solução para este problema proponho um conjunto simples de regras e
requisitos que ditam como os números das versões são atribuídos e incrementados.\nPara que este sistema funcione, primeiro você precisa declarar uma API pública.
Isto pode consistir de documentação ou ser determinada pelo próprio código. De
qualquer maneira, é importante que esta API seja clara e precisa. Depois de
identificada a API pública, você comunica as mudanças com incrementos
específicos para o seu número de versão. Considere o formato de versão X.Y.Z
(Maior.Menor.Correção). Correção de falhas (bug fixes) que não afetam a API,
incrementa a versão de Correção, adições/alterações compatíveis com as versões
anteriores da API incrementa a versão Menor, e alterações incompatíveis com as
versões anteriores da API incrementa a versão Maior.\nEu chamo esse sistema de “Versionamento Semântico”. Sob este esquema, os números
de versão e a forma como eles mudam, transmite o significado do código
subjacente e o que foi modificado de uma versão para a próxima.\nEspecificação de Versionamento Semântico (SemVer)\nAs palavras-chaves “DEVE”, “NÃO DEVE”, “OBRIGATÓRIO”, “DEVERÁ”, “NÃO DEVERÁ”,
“DEVERIA”, “NÃO DEVERIA”, “RECOMENDADO”, “PODE” e “OPCIONAL” no presente
documento devem ser interpretados como descrito na RFC 2119.\nSoftware usando Versionamento Semântico DEVE declarar uma API pública. Esta
API poderá ser declarada no próprio código ou existir estritamente na
documentação, desde que seja precisa e compreensiva.\nSoftware usando Versionamento Semântico DEVE declarar uma API pública. Esta
API poderá ser declarada no próprio código ou existir estritamente na
documentação, desde que seja precisa e compreensiva.\nUm número de versão normal DEVE ter o formato de X.Y.Z, onde X, Y, e Z são
inteiros não negativos. X é a versão Maior, Y é a versão Menor, e Z é a versão
de Correção. Cada elemento DEVE aumentar numericamente por incrementos de um.
Por exemplo: 1.9.0 -> 1.10.0 -> 1.11.0.\nUm número de versão normal DEVE ter o formato de X.Y.Z, onde X, Y, e Z são
inteiros não negativos. X é a versão Maior, Y é a versão Menor, e Z é a versão
de Correção. Cada elemento DEVE aumentar numericamente por incrementos de um.
Por exemplo: 1.9.0 -> 1.10.0 -> 1.11.0.\nQuando o número de uma versão maior for incrementado, a versão menor e a
versão de correção DEVEM ser reinicializadas para 0 (zero). Quando o número de
uma versão menor foi incrementado, a versão de correção DEVE ser reinicializada
como 0 (zero). Por exemplo: 1.1.3 -> 2.0.0 e 2.1.7 -> 2.2.0.\nQuando o número de uma versão maior for incrementado, a versão menor e a
versão de correção DEVEM ser reinicializadas para 0 (zero). Quando o número de
uma versão menor foi incrementado, a versão de correção DEVE ser reinicializada
como 0 (zero). Por exemplo: 1.1.3 -> 2.0.0 e 2.1.7 -> 2.2.0.\nUma vez que um pacote versionado foi lançado (released), o conteúdo desta
versão NÃO DEVE ser modificado. Qualquer modificação deve ser lançado como uma
nova versão.\nUma vez que um pacote versionado foi lançado (released), o conteúdo desta
versão NÃO DEVE ser modificado. Qualquer modificação deve ser lançado como uma
nova versão.\nNo início do desenvolvimento, a versão Maior DEVE ser zero (0.y.z). Qualquer
coisa pode mudar a qualquer momento. A API pública não deve ser considerada
estável.\nNo início do desenvolvimento, a versão Maior DEVE ser zero (0.y.z). Qualquer
coisa pode mudar a qualquer momento. A API pública não deve ser considerada
estável.\nVersão 1.0.0 define a API como pública. A maneira como o número de versão é
incrementado após este lançamento é dependente da API pública e como ela muda.\nVersão 1.0.0 define a API como pública. A maneira como o número de versão é
incrementado após este lançamento é dependente da API pública e como ela muda.\nVersão de Correção Z (x.y.Z | x > 0) DEVE ser incrementado apenas se mantiver
compatibilidade e introduzir correção de bugs. Uma correção de bug é definida
como uma mudança interna que corrige um comportamento incorreto.\nVersão de Correção Z (x.y.Z | x > 0) DEVE ser incrementado apenas se mantiver
compatibilidade e introduzir correção de bugs. Uma correção de bug é definida
como uma mudança interna que corrige um comportamento incorreto.\nVersão Menor Y (x.Y.z | x > 0) DEVE  ser incrementada se uma funcionalidade
nova e compatível for introduzida na API pública. DEVE ser incrementada se
qualquer funcionalidade da API pública for definida como descontinuada. PODE ser
incrementada se uma nova funcionalidade ou melhoria substancial for introduzida
dentro do código privado. PODE incluir mudanças a nível de correção. A versão de
Correção deve ser redefinida para 0(zero) quando a versão Menor for
incrementada.\nVersão Menor Y (x.Y.z | x > 0) DEVE  ser incrementada se uma funcionalidade
nova e compatível for introduzida na API pública. DEVE ser incrementada se
qualquer funcionalidade da API pública for definida como descontinuada. PODE ser
incrementada se uma nova funcionalidade ou melhoria substancial for introduzida
dentro do código privado. PODE incluir mudanças a nível de correção. A versão de
Correção deve ser redefinida para 0(zero) quando a versão Menor for
incrementada.\nVersão Maior X (X.y.z | X > 0) DEVE ser incrementada se forem introduzidas
mudanças incompatíveis na API pública. PODE incluir alterações a nível de versão
Menor e de versão de Correção. Versão de Correção e Versão Menor devem ser
redefinidas para 0(zero) quando a versão Maior for incrementada.\nVersão Maior X (X.y.z | X > 0) DEVE ser incrementada se forem introduzidas
mudanças incompatíveis na API pública. PODE incluir alterações a nível de versão
Menor e de versão de Correção. Versão de Correção e Versão Menor devem ser
redefinidas para 0(zero) quando a versão Maior for incrementada.\nUma versão de Pré-Lançamento (pre-release) PODE ser identificada adicionando
um hífen (dash) e uma série de identificadores separados por ponto (dot)
imediatamente após a versão de Correção. o identificador DEVE ser composto
apenas por caracteres alfanumérios e hífen [0-9A-Za-z-]. Versão de
Pré-Lançamento tem  precedência inferior à versão normal a que está associada.
Exemplos: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nUma versão de Pré-Lançamento (pre-release) PODE ser identificada adicionando
um hífen (dash) e uma série de identificadores separados por ponto (dot)
imediatamente após a versão de Correção. o identificador DEVE ser composto
apenas por caracteres alfanumérios e hífen [0-9A-Za-z-]. Versão de
Pré-Lançamento tem  precedência inferior à versão normal a que está associada.
Exemplos: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nUma versão de Construção (build) PODE ser identificada por adicionar um
sinal de adição (+) e uma série de identificadores separados por ponto
imediatamente após a versão de Correção ou Pré-Lançamento. Identificador DEVE
ser composto apenas por caracteres alfanumérios e hífen [0-9A-Za-z-]. Versões de
Construção têm precedência maior à versão normal a que está associada. Exemplos:
1.0.0+build.1, 1.3.7+build.11.e0f985a.\nUma versão de Construção (build) PODE ser identificada por adicionar um
sinal de adição (+) e uma série de identificadores separados por ponto
imediatamente após a versão de Correção ou Pré-Lançamento. Identificador DEVE
ser composto apenas por caracteres alfanumérios e hífen [0-9A-Za-z-]. Versões de
Construção têm precedência maior à versão normal a que está associada. Exemplos:
1.0.0+build.1, 1.3.7+build.11.e0f985a.\nA precendência DEVE ser calculada separando identificadores de versão em
Maior, Menor, Correção, Pré-lançamento e Construção, nesta ordem. Versões Maior,
Menor e Correção são sempre comparadas numericamente. A precedência de versões
de Pré-lançamento e Construção DEVE ser determinada comparando cada
identificador separado por ponto da seguinte forma: identificadores consistindo
apenas dígitos são comparados numericamente e identificadores com letras ou
hífen são comparados lexicalmente na ordem de classificação ASCII.
Identificadores numéricos sempre têm menor precedência do que os não numéricos.
Exemplo: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1
< 1.0.0-rc.1+build.1 < 1.0.0 < 1.0.0+0.3.7 < 1.3.7+build < 1.3.7+build.2.b8f12d7
< 1.3.7+build.11.e0f985a.\nA precendência DEVE ser calculada separando identificadores de versão em
Maior, Menor, Correção, Pré-lançamento e Construção, nesta ordem. Versões Maior,
Menor e Correção são sempre comparadas numericamente. A precedência de versões
de Pré-lançamento e Construção DEVE ser determinada comparando cada
identificador separado por ponto da seguinte forma: identificadores consistindo
apenas dígitos são comparados numericamente e identificadores com letras ou
hífen são comparados lexicalmente na ordem de classificação ASCII.
Identificadores numéricos sempre têm menor precedência do que os não numéricos.
Exemplo: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1
< 1.0.0-rc.1+build.1 < 1.0.0 < 1.0.0+0.3.7 < 1.3.7+build < 1.3.7+build.2.b8f12d7
< 1.3.7+build.11.e0f985a.\nPor que usar Versionamento Semântico?\nEsta não é uma ideia nova ou revolucionária. De fato, você provavelmente já faz
algo próximo a isso. O problema é que “próximo” não é bom o bastante. Sem a
aderência a algum tipo de especificação formal, os números de versão são
essencialmente inúteis para gerenciamento de dependências. Dando um nome e
definições claras às ideias acima, fica fácil comunicar suas intenções aos
usuários de seu software. Uma vez que estas intenções estão claras,
especificações de dependências flexíveis (mas não tão flexíveis) finalmente
podem ser feitas.\nUm exemplo simples vai demonstrar como o Versionamento Semântico pode fazer do
inferno de dependência uma coisa do passado. Considere uma biblioteca chamada
“CaminhaoBombeiros”. Ela requer um pacote versionado dinamicamente chamado
“Escada”. Quando CaminhaoBombeiros foi criado, Escada estava na versão 3.1.0.
Como CaminhaoBombeiros utiliza algumas funcionalidades que foram inicialmente
introduzidas na versão 3.1.0, você pode especificar, com segurança, a
dependência da Escada como maior ou igual a 3.1.0 porém menor que 4.0.0. Agora,
quando Escada versão 3.1.1 e 3.2.0 estiverem disponíveis, você poderá lançá-los
ao seu sistema de gerenciamento de pacote e saberá que eles serão compatíveis
com os softwares dependentes existentes.\nComo um desenvolvedor responsável você irá, é claro, querer certificar-se que
qualquer atualização no pacote funcionará como anunciado. O mundo real é um
lugar bagunçado; não há nada que possamos fazer quanto a isso senão sermos
vigilantes. O que você pode fazer é deixar o Versionamento Semântico lhe
fornecer uma maneira sensata de lançar e atualizar pacotes sem precisar
atualizar para novas versões de pacotes dependentes, salvando-lhe tempo e
aborrecimento.\nSe tudo isto soa desejável, tudo que você precisar fazer para começar a usar
Versionamento Semântico é declarar que você o esta usando e então, seguir as
regras. Adicione um link para este website no seu README para que outros saibam
as regras e possam beneficiar-se delas.\nComo devo lidar com revisões na fase 0.y.z de desenvolvimento inicial?\nA coisa mais simples a se fazer é começar sua versão de desenvolvimento inicial
em 0.1.0 e, então, incrementar a uma versão ‘menor’ em cada lançamento
subsequente.\nComo eu sei quando lançar a versão 1.0.0?\nSe seu software está sendo usado em produção, ele já deve ser provavelmente
1.0.0. Se você possui uma API estável a qual usuários passaram a depender, deve
ser 1.0.0. Se você está se preocupando bastante com compatibilidade com versões
anteriores, já deve ser 1.0.0.\nIsto não desencoraja o desenvolvimento ágil e iteração rápida?\nA versão Maior zero tem o foco exatamente no desenvolvimento rápido. Se você
está mudando a API todo dia, provavelmente você está na versão 0.x.x ou num
branch separado de desenvolvimento, trabalhando numa próxima versão Maior.\nSe mesmo a menor mudança incompatível com a API pública requer aumento da versão maior, não vou acabar na versão 42.0.0 muito rapidamente?\nEsta é uma questão de desenvolvimento responsável e conhecimento antecipado.
Mudanças incompatíveis não devem ser levemente introduzidas para o software que
tem um monte de código dependente. O custo que deve ser incorrido para atualizar
pode ser significante. Tendo que aumentar a versão maior para lançar mudanças
incompatíveis, significa que você pensará no impacto das suas mudanças, e
avaliará a relação de custo/benefício envolvida.\nDocumentar toda a API pública dá muito trabalho!\nÉ sua responsabilidade como desenvolvedor profissional documentar corretamente o
software que será usado por outros. Gerenciar a complexidade de software é uma
parte muito importante para manter o projeto eficiente, e isto é difícil de
fazer se ninguém sabe como usá-lo ou que métodos são seguros de chamar. A longo
prazo, Versionamento Semântico e a insistência em uma API pública bem definida
podem deixar tudo e todos funcionamente suavemente.\nO que eu faço se, acidentalmente, liberar uma mudança incompatível com versões anteriores como uma versão menor (minor version)?\nAssim que você perceber que quebrou a especificação de versionamento semântico,
conserte o problema e lance uma nova versão menor, que corrige o problema e
restaura a compatibilidade. Lembre-se que é inaceitável modificar versões
lançadas, mesmo sob essas circustâncias. Se for apropriado, documente a versão
ofensiva e informe seus usuários do problema de forma que eles fiquem cientes da
versão em questão.\nO que devo fazer se eu atualizar minhas próprias dependências sem modificar a API pública?\nIsso seria considerado compatível, uma vez que não afeta a API pública. Software
que depende explicitamente da mesmas dependências que seu pacote, deve ter sua
própria especificação de dependência e o autor notificará quaisquer conflitos.
Para determinar se a mudança é a nível de correção ou modificação de nível menor
dependente se você atualizou suas dependências a fim de corrigir um bug ou
introduzir nova funcionalidade. Eu normalmente esperaria código adicional para
última instância, caso em que é obviamente um incremento no nível menor.\nO que devo fazer se o erro que está sendo corrigido retorna o código para estar em conformidade com a API pública (ou seja, o código estava incorretamente fora de sincronia com a documentação da API pública)?\nUse o bom senso. Se você tem um público enorme que será drasticamente impactado
pela mudança de comportamento de volta para o que a API pública pretendida,
então pode ser melhor realizar um lançamento de uma versão maior, mesmo que a
correção pudesse ser considerada estritamente uma versão de correção.Lembre-se,
Versionamento Semântico trata de transmitir o conhecimento das mudanças
ocorridas na versão. Se estas mudanças são importantes para seus usuários,
utilize o número da versão para informá-los.\nComo devo lidar com descontinuação de funcionalidades?\nDescontinuar funcionalidades é um processo comum no desenvolvimento de software e
muitas vezes é necessário para haver progresso. Quando você descontinua partes de
sua API pública, você deve fazer duas coisas: (1) atualizar sua documentação,
para que os usuários saibam das mudanças, (2) lançar uma versão Menor anunciando
a descontinuação. Antes de remover completamente a funcionalidade em uma versão
Maior deve haver ao menos uma versão Menor que possui a descontinução anunciada,
fazendo com que os usuários realizem uma transição tranquila para a nova API.\nA Especificação da Semântica de Versionamento é autoria de Tom
Preston-Werner, criador do Gravatars e
co-fundador do GitHub.\nCaso queira deixar sua opinião, por favor abra uma issue no GitHub.\nabra uma issue no GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nVersionamento Semântico 1.0.0

No mundo de gerenciamento de software existe algo terrível conhecido como
inferno das dependências (“dependency hell”). Quanto mais o sistema cresce, e
mais pacotes são adicionados a ele, maior será a possibilidade de, um dia, você
encontrar-se neste poço de desespero.

Em sistemas com muitas dependências, lançar novos pacotes de versões pode se
tornar rapidamente um pesadelo. Se as especificações das dependências são muito
amarradas você corre o risco de um bloqueio de versão (A falta de capacidade de
atualizar um pacote sem ter de liberar novas versões de cada pacote dependente).
Se as dependências são vagamente especificadas, você irá inevitavelmente ser
mordido pela ‘promiscuidade da versão’ (assumindo compatibilidade com futuras
versões mais do que é razoável). O inferno das dependências é onde você está
quando um bloqueio de versão e/ou promiscuidade de versão te impede de seguir
em frente com seu projeto de maneira fácil e segura.

Como uma solução para este problema proponho um conjunto simples de regras e
requisitos que ditam como os números das versões são atribuídos e incrementados.

Para que este sistema funcione, primeiro você precisa declarar uma API pública.
Isto pode consistir de documentação ou ser determinada pelo próprio código. De
qualquer maneira, é importante que esta API seja clara e precisa. Depois de
identificada a API pública, você comunica as mudanças com incrementos
específicos para o seu número de versão. Considere o formato de versão X.Y.Z
(Maior.Menor.Correção). Correção de falhas (bug fixes) que não afetam a API,
incrementa a versão de Correção, adições/alterações compatíveis com as versões
anteriores da API incrementa a versão Menor, e alterações incompatíveis com as
versões anteriores da API incrementa a versão Maior.

Eu chamo esse sistema de “Versionamento Semântico”. Sob este esquema, os números
de versão e a forma como eles mudam, transmite o significado do código
subjacente e o que foi modificado de uma versão para a próxima.

Especificação de Versionamento Semântico (SemVer)

As palavras-chaves “DEVE”, “NÃO DEVE”, “OBRIGATÓRIO”, “DEVERÁ”, “NÃO DEVERÁ”,
“DEVERIA”, “NÃO DEVERIA”, “RECOMENDADO”, “PODE” e “OPCIONAL” no presente
documento devem ser interpretados como descrito na RFC 2119.


  
    Software usando Versionamento Semântico DEVE declarar uma API pública. Esta
API poderá ser declarada no próprio código ou existir estritamente na
documentação, desde que seja precisa e compreensiva.
  
  
    Um número de versão normal DEVE ter o formato de X.Y.Z, onde X, Y, e Z são
inteiros. X é a versão Maior, Y é a versão Menor, e Z é a versão de Correção.
Cada elemento DEVE aumentar numericamente por incrementos de um.
Por exemplo: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Quando o número de uma versão maior for incrementado, a versão menor e a
versão de correção DEVEM ser reinicializadas para 0 (zero). Quando o número de
uma versão menor foi incrementado, a versão de correção DEVE ser reinicializada
como 0 (zero). Por exemplo: 1.1.3 -> 2.0.0 e 2.1.7 -> 2.2.0.
  
  
    Uma versão de Pré-Lançamento (pre-release) PODE ser identificada adicionando
um texto arbitrário imediatamente após a versão de correção e um ponto (decimal
point). Esse texto  DEVE ser composto por apenas caracteres alfanuméricos e
hífen (dash) [0-9A-Za-z-] e DEVE começar com um caractere alfabético [A-Za-z].
Versão de Pré-Lançamento tem precedência inferior à versão normal a que está
associada. A precedência DEVE ser determinada lexicalmente na ordem de
classificação ASCII. Por exemplo: 1.0.0.alpha1 < 1.0.0.beta1 < 1.0.0.beta2
< 1.0.0.rc1 < 1.0.0.
  
  
    Uma vez que um pacote versionado foi lançado (released), o conteúdo desta
versão NÃO DEVE ser modificado. Qualquer modificação deve ser lançado como uma
nova versão.
  
  
    No início do desenvolvimento, a versão Maior DEVE ser zero (0.y.z). Qualquer
coisa pode mudar a qualquer momento. A API pública não deve ser considerada
estável.
  
  
    Versão 1.0.0 define a API como pública. A maneira como o número de versão é
incrementado após este lançamento é dependente da API pública e como ela muda.
  
  
    Versão de Correção Z (x.y.Z | x > 0) DEVE ser incrementado apenas se mantiver
compatibilidade e introduzir correção de bugs. Uma correção de bug é definida
como uma mudança interna que corrige um comportamento incorreto.
  
  
    Versão Menor Y (x.Y.z | x > 0) DEVE  ser incrementada se uma funcionalidade
nova e compatível for introduzida na API pública. PODE ser incrementada se
uma nova funcionalidade ou melhoria substancial for introduzida
dentro do código privado. PODE incluir mudanças a nível de correção.
  
  
    Versão Maior X (X.y.z | X > 0) DEVE ser incrementada se forem introduzidas
mudanças incompatíveis na API pública. PODE incluir alterações a nível de versão
Menor e de versão de Correção.
  


Especificação de Rotulação (SemVerTag)

Esta sub-especificação DEVE ser utilizada se você utilizar um sistema de
controle de versão (Git, Mercurial, SVN, etc) para armazenar seus códigos. A
utilização de um sistema desses permite às ferramentas de automação a
inspecionar o seu pacote e determinar a conformidade com o Versionamento
Semântico e das versões lançadas.


  
    Quando for rotular lançamentos em sistemas de controle de versão, o rótulo
para uma versão DEVE ser “vX.Y.Z” e.g. “v3.1.0”.
  
  
    A primeira revisão a introduzir conformidade com o Versionamento Semântico
DEVE ser rotulada com “semver”. Isso permite que projetos pré-existentes a
assumirem a conformidade em algum ponto arbitrário e para ferramentas de
automação a descobrirem isso.
  


Por que usar Versionamento Semântico?

Esta não é uma ideia nova ou revolucionária. De fato, você provavelmente já faz
algo próximo a isso. O problema é que “próximo” não é bom o bastante. Sem a
aderência a algum tipo de especificação formal, os números de versão são
essencialmente inúteis para gerenciamento de dependências. Dando um nome e
definições claras às ideias acima, fica fácil comunicar suas intenções aos
usuários de seu software. Uma vez que estas intenções estão claras,
especificações de dependências flexíveis (mas não tão flexíveis) finalmente
podem ser feitas.

Um exemplo simples vai demonstrar como o Versionamento Semântico pode fazer do
inferno de dependência uma coisa do passado. Considere uma biblioteca chamada
“CaminhaoBombeiros”. Ela requer um pacote versionado dinamicamente chamado
“Escada”. Quando CaminhaoBombeiros foi criado, Escada estava na versão 3.1.0.
Como CaminhaoBombeiros utiliza algumas funcionalidades que foram inicialmente
introduzidas na versão 3.1.0, você pode especificar, com segurança, a
dependência da Escada como maior ou igual a 3.1.0 porém menor que 4.0.0. Agora,
quando Escada versão 3.1.1 e 3.2.0 estiverem disponíveis, você poderá lançá-los
ao seu sistema de gerenciamento de pacote e saberá que eles serão compatíveis
com os softwares dependentes existentes.

Como um desenvolvedor responsável você irá, é claro, querer certificar-se que
qualquer atualização no pacote funcionará como anunciado. O mundo real é um
lugar bagunçado; não há nada que possamos fazer quanto a isso senão sermos
vigilantes. O que você pode fazer é deixar o Versionamento Semântico lhe
fornecer uma maneira sensata de lançar e atualizar pacotes sem precisar
atualizar para novas versões de pacotes dependentes, salvando-lhe tempo e
aborrecimento.

Se tudo isto soa desejável, tudo que você precisar fazer para começar a usar
Versionamento Semântico é declarar que você o esta usando e então, seguir as
regras. Adicione um link para este website no seu README para que outros saibam
as regras e possam beneficiar-se delas.

FAQ

Como eu sei quando lançar a versão 1.0.0?

Se seu software está sendo usado em produção, ele já deve ser provavelmente
1.0.0. Se você possui uma API estável a qual usuários passaram a depender, deve
ser 1.0.0. Se você está se preocupando bastante com compatibilidade com versões
anteriores, já deve ser 1.0.0.

Isto não desencoraja o desenvolvimento ágil e iteração rápida?

A versão Maior zero tem o foco exatamente no desenvolvimento rápido. Se você
está mudando a API todo dia, provavelmente você está na versão 0.x.x ou num
branch separado de desenvolvimento, trabalhando numa próxima versão Maior.

Se mesmo a menor mudança incompatível com a API pública requer aumento da versão maior, não vou acabar na versão 42.0.0 muito rapidamente?

Esta é uma questão de desenvolvimento responsável e conhecimento antecipado.
Mudanças incompatíveis não devem ser levemente introduzidas para o software que
tem um monte de código dependente. O custo que deve ser incorrido para atualizar
pode ser significante. Tendo que aumentar a versão maior para lançar mudanças
incompatíveis, significa que você pensará no impacto das suas mudanças, e
avaliará a relação de custo/benefício envolvida.

Documentar toda a API pública dá muito trabalho!

É sua responsabilidade como desenvolvedor profissional documentar corretamente o
software que será usado por outros. Gerenciar a complexidade de software é uma
parte muito importante para manter o projeto eficiente, e isto é difícil de
fazer se ninguém sabe como usá-lo ou que métodos são seguros de chamar. A longo
prazo, Versionamento Semântico e a insistência em uma API pública bem definida
podem deixar tudo e todos funcionamente suavemente.

O que eu faço se, acidentalmente, liberar uma mudança incompatível com versões anteriores como uma versão menor (minor version)?

Assim que você perceber que quebrou a especificação de versionamento semântico,
conserte o problema e lance uma nova versão menor, que corrige o problema e
restaura a compatibilidade. Lembre-se que é inaceitável modificar versões
lançadas, mesmo sob essas circustâncias. Se for apropriado, documente a versão
ofensiva e informe seus usuários do problema de forma que eles fiquem cientes da
versão em questão.

O que devo fazer se eu atualizar minhas próprias dependências sem modificar a API pública?

Isso seria considerado compatível, uma vez que não afeta a API pública. Software
que depende explicitamente da mesmas dependências que seu pacote, deve ter sua
própria especificação de dependência e o autor notificará quaisquer conflitos.
Para determinar se a mudança é a nível de correção ou modificação de nível menor
dependente se você atualizou suas dependências a fim de corrigir um bug ou
introduzir nova funcionalidade. Eu normalmente esperaria código adicional para
última instância, caso em que é obviamente um incremento no nível menor.

Sobre

A Especificação da Semântica de Versionamento é autoria de Tom
Preston-Werner, criador do Gravatars e
co-fundador do GitHub.

Caso queira deixar sua opinião, por favor abra uma issue no GitHub.

Licença

Creative Commons ― CC BY 3.0\nVersionamento Semântico 1.0.0\nNo mundo de gerenciamento de software existe algo terrível conhecido como
inferno das dependências (“dependency hell”). Quanto mais o sistema cresce, e
mais pacotes são adicionados a ele, maior será a possibilidade de, um dia, você
encontrar-se neste poço de desespero.\nEm sistemas com muitas dependências, lançar novos pacotes de versões pode se
tornar rapidamente um pesadelo. Se as especificações das dependências são muito
amarradas você corre o risco de um bloqueio de versão (A falta de capacidade de
atualizar um pacote sem ter de liberar novas versões de cada pacote dependente).
Se as dependências são vagamente especificadas, você irá inevitavelmente ser
mordido pela ‘promiscuidade da versão’ (assumindo compatibilidade com futuras
versões mais do que é razoável). O inferno das dependências é onde você está
quando um bloqueio de versão e/ou promiscuidade de versão te impede de seguir
em frente com seu projeto de maneira fácil e segura.\nComo uma solução para este problema proponho um conjunto simples de regras e
requisitos que ditam como os números das versões são atribuídos e incrementados.\nPara que este sistema funcione, primeiro você precisa declarar uma API pública.
Isto pode consistir de documentação ou ser determinada pelo próprio código. De
qualquer maneira, é importante que esta API seja clara e precisa. Depois de
identificada a API pública, você comunica as mudanças com incrementos
específicos para o seu número de versão. Considere o formato de versão X.Y.Z
(Maior.Menor.Correção). Correção de falhas (bug fixes) que não afetam a API,
incrementa a versão de Correção, adições/alterações compatíveis com as versões
anteriores da API incrementa a versão Menor, e alterações incompatíveis com as
versões anteriores da API incrementa a versão Maior.\nEu chamo esse sistema de “Versionamento Semântico”. Sob este esquema, os números
de versão e a forma como eles mudam, transmite o significado do código
subjacente e o que foi modificado de uma versão para a próxima.\nEspecificação de Versionamento Semântico (SemVer)\nAs palavras-chaves “DEVE”, “NÃO DEVE”, “OBRIGATÓRIO”, “DEVERÁ”, “NÃO DEVERÁ”,
“DEVERIA”, “NÃO DEVERIA”, “RECOMENDADO”, “PODE” e “OPCIONAL” no presente
documento devem ser interpretados como descrito na RFC 2119.\nSoftware usando Versionamento Semântico DEVE declarar uma API pública. Esta
API poderá ser declarada no próprio código ou existir estritamente na
documentação, desde que seja precisa e compreensiva.\nSoftware usando Versionamento Semântico DEVE declarar uma API pública. Esta
API poderá ser declarada no próprio código ou existir estritamente na
documentação, desde que seja precisa e compreensiva.\nUm número de versão normal DEVE ter o formato de X.Y.Z, onde X, Y, e Z são
inteiros. X é a versão Maior, Y é a versão Menor, e Z é a versão de Correção.
Cada elemento DEVE aumentar numericamente por incrementos de um.
Por exemplo: 1.9.0 -> 1.10.0 -> 1.11.0.\nUm número de versão normal DEVE ter o formato de X.Y.Z, onde X, Y, e Z são
inteiros. X é a versão Maior, Y é a versão Menor, e Z é a versão de Correção.
Cada elemento DEVE aumentar numericamente por incrementos de um.
Por exemplo: 1.9.0 -> 1.10.0 -> 1.11.0.\nQuando o número de uma versão maior for incrementado, a versão menor e a
versão de correção DEVEM ser reinicializadas para 0 (zero). Quando o número de
uma versão menor foi incrementado, a versão de correção DEVE ser reinicializada
como 0 (zero). Por exemplo: 1.1.3 -> 2.0.0 e 2.1.7 -> 2.2.0.\nQuando o número de uma versão maior for incrementado, a versão menor e a
versão de correção DEVEM ser reinicializadas para 0 (zero). Quando o número de
uma versão menor foi incrementado, a versão de correção DEVE ser reinicializada
como 0 (zero). Por exemplo: 1.1.3 -> 2.0.0 e 2.1.7 -> 2.2.0.\nUma versão de Pré-Lançamento (pre-release) PODE ser identificada adicionando
um texto arbitrário imediatamente após a versão de correção e um ponto (decimal
point). Esse texto  DEVE ser composto por apenas caracteres alfanuméricos e
hífen (dash) [0-9A-Za-z-] e DEVE começar com um caractere alfabético [A-Za-z].
Versão de Pré-Lançamento tem precedência inferior à versão normal a que está
associada. A precedência DEVE ser determinada lexicalmente na ordem de
classificação ASCII. Por exemplo: 1.0.0.alpha1 < 1.0.0.beta1 < 1.0.0.beta2
< 1.0.0.rc1 < 1.0.0.\nUma versão de Pré-Lançamento (pre-release) PODE ser identificada adicionando
um texto arbitrário imediatamente após a versão de correção e um ponto (decimal
point). Esse texto  DEVE ser composto por apenas caracteres alfanuméricos e
hífen (dash) [0-9A-Za-z-] e DEVE começar com um caractere alfabético [A-Za-z].
Versão de Pré-Lançamento tem precedência inferior à versão normal a que está
associada. A precedência DEVE ser determinada lexicalmente na ordem de
classificação ASCII. Por exemplo: 1.0.0.alpha1 < 1.0.0.beta1 < 1.0.0.beta2
< 1.0.0.rc1 < 1.0.0.\nUma vez que um pacote versionado foi lançado (released), o conteúdo desta
versão NÃO DEVE ser modificado. Qualquer modificação deve ser lançado como uma
nova versão.\nUma vez que um pacote versionado foi lançado (released), o conteúdo desta
versão NÃO DEVE ser modificado. Qualquer modificação deve ser lançado como uma
nova versão.\nNo início do desenvolvimento, a versão Maior DEVE ser zero (0.y.z). Qualquer
coisa pode mudar a qualquer momento. A API pública não deve ser considerada
estável.\nNo início do desenvolvimento, a versão Maior DEVE ser zero (0.y.z). Qualquer
coisa pode mudar a qualquer momento. A API pública não deve ser considerada
estável.\nVersão 1.0.0 define a API como pública. A maneira como o número de versão é
incrementado após este lançamento é dependente da API pública e como ela muda.\nVersão 1.0.0 define a API como pública. A maneira como o número de versão é
incrementado após este lançamento é dependente da API pública e como ela muda.\nVersão de Correção Z (x.y.Z | x > 0) DEVE ser incrementado apenas se mantiver
compatibilidade e introduzir correção de bugs. Uma correção de bug é definida
como uma mudança interna que corrige um comportamento incorreto.\nVersão de Correção Z (x.y.Z | x > 0) DEVE ser incrementado apenas se mantiver
compatibilidade e introduzir correção de bugs. Uma correção de bug é definida
como uma mudança interna que corrige um comportamento incorreto.\nVersão Menor Y (x.Y.z | x > 0) DEVE  ser incrementada se uma funcionalidade
nova e compatível for introduzida na API pública. PODE ser incrementada se
uma nova funcionalidade ou melhoria substancial for introduzida
dentro do código privado. PODE incluir mudanças a nível de correção.\nVersão Menor Y (x.Y.z | x > 0) DEVE  ser incrementada se uma funcionalidade
nova e compatível for introduzida na API pública. PODE ser incrementada se
uma nova funcionalidade ou melhoria substancial for introduzida
dentro do código privado. PODE incluir mudanças a nível de correção.\nVersão Maior X (X.y.z | X > 0) DEVE ser incrementada se forem introduzidas
mudanças incompatíveis na API pública. PODE incluir alterações a nível de versão
Menor e de versão de Correção.\nVersão Maior X (X.y.z | X > 0) DEVE ser incrementada se forem introduzidas
mudanças incompatíveis na API pública. PODE incluir alterações a nível de versão
Menor e de versão de Correção.\nEspecificação de Rotulação (SemVerTag)\nEsta sub-especificação DEVE ser utilizada se você utilizar um sistema de
controle de versão (Git, Mercurial, SVN, etc) para armazenar seus códigos. A
utilização de um sistema desses permite às ferramentas de automação a
inspecionar o seu pacote e determinar a conformidade com o Versionamento
Semântico e das versões lançadas.\nQuando for rotular lançamentos em sistemas de controle de versão, o rótulo
para uma versão DEVE ser “vX.Y.Z” e.g. “v3.1.0”.\nQuando for rotular lançamentos em sistemas de controle de versão, o rótulo
para uma versão DEVE ser “vX.Y.Z” e.g. “v3.1.0”.\nA primeira revisão a introduzir conformidade com o Versionamento Semântico
DEVE ser rotulada com “semver”. Isso permite que projetos pré-existentes a
assumirem a conformidade em algum ponto arbitrário e para ferramentas de
automação a descobrirem isso.\nA primeira revisão a introduzir conformidade com o Versionamento Semântico
DEVE ser rotulada com “semver”. Isso permite que projetos pré-existentes a
assumirem a conformidade em algum ponto arbitrário e para ferramentas de
automação a descobrirem isso.\nPor que usar Versionamento Semântico?\nEsta não é uma ideia nova ou revolucionária. De fato, você provavelmente já faz
algo próximo a isso. O problema é que “próximo” não é bom o bastante. Sem a
aderência a algum tipo de especificação formal, os números de versão são
essencialmente inúteis para gerenciamento de dependências. Dando um nome e
definições claras às ideias acima, fica fácil comunicar suas intenções aos
usuários de seu software. Uma vez que estas intenções estão claras,
especificações de dependências flexíveis (mas não tão flexíveis) finalmente
podem ser feitas.\nUm exemplo simples vai demonstrar como o Versionamento Semântico pode fazer do
inferno de dependência uma coisa do passado. Considere uma biblioteca chamada
“CaminhaoBombeiros”. Ela requer um pacote versionado dinamicamente chamado
“Escada”. Quando CaminhaoBombeiros foi criado, Escada estava na versão 3.1.0.
Como CaminhaoBombeiros utiliza algumas funcionalidades que foram inicialmente
introduzidas na versão 3.1.0, você pode especificar, com segurança, a
dependência da Escada como maior ou igual a 3.1.0 porém menor que 4.0.0. Agora,
quando Escada versão 3.1.1 e 3.2.0 estiverem disponíveis, você poderá lançá-los
ao seu sistema de gerenciamento de pacote e saberá que eles serão compatíveis
com os softwares dependentes existentes.\nComo um desenvolvedor responsável você irá, é claro, querer certificar-se que
qualquer atualização no pacote funcionará como anunciado. O mundo real é um
lugar bagunçado; não há nada que possamos fazer quanto a isso senão sermos
vigilantes. O que você pode fazer é deixar o Versionamento Semântico lhe
fornecer uma maneira sensata de lançar e atualizar pacotes sem precisar
atualizar para novas versões de pacotes dependentes, salvando-lhe tempo e
aborrecimento.\nSe tudo isto soa desejável, tudo que você precisar fazer para começar a usar
Versionamento Semântico é declarar que você o esta usando e então, seguir as
regras. Adicione um link para este website no seu README para que outros saibam
as regras e possam beneficiar-se delas.\nComo eu sei quando lançar a versão 1.0.0?\nSe seu software está sendo usado em produção, ele já deve ser provavelmente
1.0.0. Se você possui uma API estável a qual usuários passaram a depender, deve
ser 1.0.0. Se você está se preocupando bastante com compatibilidade com versões
anteriores, já deve ser 1.0.0.\nIsto não desencoraja o desenvolvimento ágil e iteração rápida?\nA versão Maior zero tem o foco exatamente no desenvolvimento rápido. Se você
está mudando a API todo dia, provavelmente você está na versão 0.x.x ou num
branch separado de desenvolvimento, trabalhando numa próxima versão Maior.\nSe mesmo a menor mudança incompatível com a API pública requer aumento da versão maior, não vou acabar na versão 42.0.0 muito rapidamente?\nEsta é uma questão de desenvolvimento responsável e conhecimento antecipado.
Mudanças incompatíveis não devem ser levemente introduzidas para o software que
tem um monte de código dependente. O custo que deve ser incorrido para atualizar
pode ser significante. Tendo que aumentar a versão maior para lançar mudanças
incompatíveis, significa que você pensará no impacto das suas mudanças, e
avaliará a relação de custo/benefício envolvida.\nDocumentar toda a API pública dá muito trabalho!\nÉ sua responsabilidade como desenvolvedor profissional documentar corretamente o
software que será usado por outros. Gerenciar a complexidade de software é uma
parte muito importante para manter o projeto eficiente, e isto é difícil de
fazer se ninguém sabe como usá-lo ou que métodos são seguros de chamar. A longo
prazo, Versionamento Semântico e a insistência em uma API pública bem definida
podem deixar tudo e todos funcionamente suavemente.\nO que eu faço se, acidentalmente, liberar uma mudança incompatível com versões anteriores como uma versão menor (minor version)?\nAssim que você perceber que quebrou a especificação de versionamento semântico,
conserte o problema e lance uma nova versão menor, que corrige o problema e
restaura a compatibilidade. Lembre-se que é inaceitável modificar versões
lançadas, mesmo sob essas circustâncias. Se for apropriado, documente a versão
ofensiva e informe seus usuários do problema de forma que eles fiquem cientes da
versão em questão.\nO que devo fazer se eu atualizar minhas próprias dependências sem modificar a API pública?\nIsso seria considerado compatível, uma vez que não afeta a API pública. Software
que depende explicitamente da mesmas dependências que seu pacote, deve ter sua
própria especificação de dependência e o autor notificará quaisquer conflitos.
Para determinar se a mudança é a nível de correção ou modificação de nível menor
dependente se você atualizou suas dependências a fim de corrigir um bug ou
introduzir nova funcionalidade. Eu normalmente esperaria código adicional para
última instância, caso em que é obviamente um incremento no nível menor.\nA Especificação da Semântica de Versionamento é autoria de Tom
Preston-Werner, criador do Gravatars e
co-fundador do GitHub.\nCaso queira deixar sua opinião, por favor abra uma issue no GitHub.\nabra uma issue no GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nVersionamento Semântico 1.0.0-beta

No mundo de gerenciamento de software existe algo terrível conhecido como
inferno das dependências (“dependency hell”). Quanto mais o sistema cresce, e
mais pacotes são adicionados a ele, maior será a possibilidade de, um dia, você
encontrar-se neste poço de desespero.

Em sistemas com muitas dependências, lançar novos pacotes de versões pode se
tornar rapidamente um pesadelo. Se as especificações das dependências são muito
amarradas você corre o risco de um bloqueio de versão (A falta de capacidade de
atualizar um pacote sem ter de liberar novas versões de cada pacote dependente).
Se as dependências são vagamente especificadas, você irá inevitavelmente ser
mordido pela ‘promiscuidade da versão’ (assumindo compatibilidade com futuras
versões mais do que é razoável). O inferno das dependências é onde você está
quando um bloqueio de versão e/ou promiscuidade de versão te impede de seguir
em frente com seu projeto de maneira fácil e segura.

Como uma solução para este problema proponho um conjunto simples de regras e
requisitos que ditam como os números das versões são atribuídos e incrementados.

Para que este sistema funcione, primeiro você precisa declarar uma API pública.
Isto pode consistir de documentação ou ser determinada pelo próprio código. De
qualquer maneira, é importante que esta API seja clara e precisa. Depois de
identificada a API pública, você comunica as mudanças com incrementos
específicos para o seu número de versão. Considere o formato de versão X.Y.Z
(Maior.Menor.Correção). Correção de falhas (bug fixes) que não afetam a API,
incrementa a versão de Correção, adições/alterações compatíveis com as versões
anteriores da API incrementa a versão Menor, e alterações incompatíveis com as
versões anteriores da API incrementa a versão Maior.

Eu chamo esse sistema de “Versionamento Semântico”. Sob este esquema, os números
de versão e a forma como eles mudam, transmite o significado do código
subjacente e o que foi modificado de uma versão para a próxima.

Especificação de Versionamento Semântico (SemVer)

As palavras-chaves “DEVE”, “NÃO DEVE”, “OBRIGATÓRIO”, “DEVERÁ”, “NÃO DEVERÁ”,
“DEVERIA”, “NÃO DEVERIA”, “RECOMENDADO”, “PODE” e “OPCIONAL” no presente
documento devem ser interpretados como descrito na RFC 2119.


  
    Software usando Versionamento Semântico DEVE declarar uma API pública. Esta
API poderá ser declarada no próprio código ou existir estritamente na
documentação, desde que seja precisa e compreensiva.
  
  
    Um número de versão normal DEVE ter o formato de X.Y.Z, onde X, Y, e Z são
inteiros. X é a versão Maior, Y é a versão Menor, e Z é a versão de Correção.
Cada elemento DEVE aumentar numericamente por incrementos de um.
Por exemplo: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Quando o número de uma versão maior for incrementado, a versão menor e a
versão de correção DEVEM ser reinicializadas para 0 (zero). Quando o número de
uma versão menor foi incrementado, a versão de correção DEVE ser reinicializada
como 0 (zero). Por exemplo: 1.1.3 -> 2.0.0 e 2.1.7 -> 2.2.0.
  
  
    Uma versão de Pré-Lançamento (pre-release) PODE ser identificada adicionando
um texto arbitrário imediatamente após a versão de correção e um ponto (decimal
point). Esse texto  DEVE ser composto por apenas caracteres alfanuméricos e
hífen (dash) [0-9A-Za-z-] e DEVE começar com um caractere alfabético [A-Za-z].
versões de Pré-Lançamento satisfazem, mas tem inferior à versão normal a que está
associada. A precedência DEVE ser determinada lexicalmente na ordem de
classificação ASCII. Por exemplo: 1.0.0.alpha1 < 1.0.0.beta1 < 1.0.0.beta2
< 1.0.0.rc1 < 1.0.0.
  
  
    Uma vez que um pacote versionado foi lançado (released), o conteúdo desta
versão NÃO DEVE ser modificado. Qualquer modificação deve ser lançado como uma
nova versão.
  
  
    versão Maior DEVE ser zero (0.y.z) é para o início do desenvolvimento.
Qualquer coisa pode mudar a qualquer momento. A API pública não deve ser considerada
estável.
  
  
    Versão 1.0.0 define a API como pública. A maneira como o número de versão é
incrementado após este lançamento é dependente da API pública e como ela muda.
  
  
    Versão de Correção Z (x.y.Z | x > 0) DEVE ser incrementado apenas se mantiver
compatibilidade e introduzir correção de bugs. Uma correção de bug é definida
como uma mudança interna que corrige um comportamento incorreto.
  
  
    Versão Menor Y (x.Y.z | x > 0) DEVE  ser incrementada se uma funcionalidade
nova e compatível for introduzida na API pública. PODE ser incrementada se
uma nova funcionalidade ou melhoria substancial for introduzida
dentro do código privado. PODE incluir mudanças a nível de correção.
  
  
    Versão Maior X (X.y.z | X > 0) DEVE ser incrementada se forem introduzidas
mudanças incompatíveis na API pública. PODE incluir alterações a nível de versão
Menor e de versão de Correção.
  


Especificação de Rotulação (SemVerTag)

Esta sub-especificação DEVE ser utilizada se você utilizar um sistema de
controle de versão (Git, Mercurial, SVN, etc) para armazenar seus códigos. A
utilização de um sistema desses permite às ferramentas de automação a
inspecionar o seu pacote e determinar a conformidade com o Versionamento
Semântico e das versões lançadas.


  
    Quando for rotular lançamentos em sistemas de controle de versão, o rótulo
para uma versão DEVE ser “vX.Y.Z” e.g. “v3.1.0”.
  
  
    A primeira revisão a introduzir conformidade com o Versionamento Semântico
DEVE ser rotulada com “semver”. Isso permite que projetos pré-existentes a
assumirem a conformidade em algum ponto arbitrário e para ferramentas de
automação a descobrirem isso.
  


Por que usar Versionamento Semântico?

Esta não é uma ideia nova ou revolucionária. De fato, você provavelmente já faz
algo próximo a isso. O problema é que “próximo” não é bom o bastante. Sem a
aderência a algum tipo de especificação formal, os números de versão são
essencialmente inúteis para gerenciamento de dependências. Dando um nome e
definições claras às ideias acima, fica fácil comunicar suas intenções aos
usuários de seu software. Uma vez que estas intenções estão claras,
especificações de dependências flexíveis  (mas não tão flexíveis) finalmente
podem ser feitas.

Um exemplo simples vai demonstrar como o Versionamento Semântico pode fazer do
inferno de dependência uma coisa do passado. Considere uma biblioteca chamada
“CaminhaoBombeiros.” Ela requer um pacote versionado semânticamente chamado
“Escada.” Quando CaminhaoBombeiros foi criado, Escada estava na versão 3.1.0.
Como CaminhaoBombeiros utiliza algumas funcionalidades que foram inicialmente
introduzidas na versão 3.1.0, você pode especificar, com segurança, a
dependência da Escada como maior ou igual a 3.1.0 porém menor que 4.0.0. Agora,
quando Escada versão 3.1.1 e 3.2.0 estiverem disponíveis, você poderá lançá-los
ao seu sistema de gerenciamento de pacote e saberá que eles serão compatíveis
com os softwares dependentes existentes.

Como um desenvolvedor responsável você irá, é claro, querer certificar-se que
qualquer atualização no pacote funcionará como anunciado. O mundo real é um
lugar bagunçado; não há nada que possamos fazer quanto a isso senão sermos
vigilantes. O que você pode fazer é deixar o Versionamento Semântico lhe
fornecer uma maneira sensata de lançar e atualizar pacotes sem precisar
atualizar para novas versões de pacotes dependentes, salvando-lhe tempo e
aborrecimento.

Se tudo isto soa desejável, tudo que você precisar fazer para começar a usar
Versionamento Semântico é declarar que você o esta usando e então, seguir as
regras. Adicione um link para este website no seu README para que outros saibam
as regras e possam beneficiar-se delas.

FAQ

Como eu sei quando lançar a versão 1.0.0?

Se seu software está sendo usado em produção, ele já deve ser provavelmente
1.0.0. Se você possui uma API estável a qual usuários passaram a depender, deve
ser 1.0.0. Se você está se preocupando bastante com compatibilidade com versões
anteriores, já deve ser 1.0.0.

Isto não desencoraja o desenvolvimento ágil e iteração rápida?

A versão Maior zero tem o foco exatamente no desenvolvimento rápido. Se você
está mudando a API todo dia, provavelmente você está na versão 0.x.x ou num
branch separado de desenvolvimento, trabalhando numa próxima versão Maior.

Se mesmo a menor mudança incompatível com a API pública requer aumento da versão maior, não vou acabar na versão 42.0.0 muito rapidamente?

Esta é uma questão de desenvolvimento responsável e conhecimento antecipado.
Mudanças incompatíveis não devem ser levemente introduzidas para o software que
tem um monte de código dependente. O custo que deve ser incorrido para atualizar
pode ser significante. Tendo que aumentar a versão maior para lançar mudanças
incompatíveis, significa que você pensará no impacto das suas mudanças, e
avaliará a relação de custo/benefício envolvida.

Documentar toda a API pública dá muito trabalho!

É sua responsabilidade como desenvolvedor profissional documentar corretamente o
software que será usado por outros. Gerenciar a complexidade de software é uma
parte muito importante para manter o projeto eficiente, e isto é difícil de
fazer se ninguém sabe como usá-lo ou que métodos são seguros de chamar. A longo
prazo, Versionamento Semântico e a insistência em uma API pública bem definida
podem deixar tudo e todos funcionando suavemente.

O que eu faço se, acidentalmente, liberar uma mudança incompatível com versões anteriores como uma versão menor (minor version)?

Assim que você perceber que quebrou a especificação de versionamento semântico,
conserte o problema e lance uma nova versão menor, que corrige o problema e
restaura a compatibilidade. Lembre-se que é inaceitável modificar versões
lançadas, mesmo sob essas circustâncias. Se for apropriado, documente a versão
ofensiva e informe seus usuários do problema de forma que eles fiquem cientes da
versão em questão.

O que devo fazer se eu atualizar minhas próprias dependências sem modificar a API pública?

Isso seria considerado compatível, uma vez que não afeta a API pública. Software
que depende explicitamente da mesmas dependências que seu pacote, deve ter sua
própria especificação de dependência e o autor notificará quaisquer conflitos.
Para determinar se a mudança é a nível de correção ou modificação de nível menor
dependente se você atualizou suas dependências a fim de corrigir um bug ou
introduzir nova funcionalidade. Eu normalmente esperaria código adicional para
última instância, caso em que é obviamente um incremento no nível menor.

Sobre

A Especificação da Semântica de Versionamento é autoria de Tom
Preston-Werner, criador do Gravatars e
co-fundador do GitHub.

Caso queira deixar sua opinião, por favor abra uma issue no GitHub.

Licença

Creative Commons ― CC BY 3.0
http://creativecommons.org/licenses/by/3.0/\nVersionamento Semântico 1.0.0-beta\nNo mundo de gerenciamento de software existe algo terrível conhecido como
inferno das dependências (“dependency hell”). Quanto mais o sistema cresce, e
mais pacotes são adicionados a ele, maior será a possibilidade de, um dia, você
encontrar-se neste poço de desespero.\nEm sistemas com muitas dependências, lançar novos pacotes de versões pode se
tornar rapidamente um pesadelo. Se as especificações das dependências são muito
amarradas você corre o risco de um bloqueio de versão (A falta de capacidade de
atualizar um pacote sem ter de liberar novas versões de cada pacote dependente).
Se as dependências são vagamente especificadas, você irá inevitavelmente ser
mordido pela ‘promiscuidade da versão’ (assumindo compatibilidade com futuras
versões mais do que é razoável). O inferno das dependências é onde você está
quando um bloqueio de versão e/ou promiscuidade de versão te impede de seguir
em frente com seu projeto de maneira fácil e segura.\nComo uma solução para este problema proponho um conjunto simples de regras e
requisitos que ditam como os números das versões são atribuídos e incrementados.\nPara que este sistema funcione, primeiro você precisa declarar uma API pública.
Isto pode consistir de documentação ou ser determinada pelo próprio código. De
qualquer maneira, é importante que esta API seja clara e precisa. Depois de
identificada a API pública, você comunica as mudanças com incrementos
específicos para o seu número de versão. Considere o formato de versão X.Y.Z
(Maior.Menor.Correção). Correção de falhas (bug fixes) que não afetam a API,
incrementa a versão de Correção, adições/alterações compatíveis com as versões
anteriores da API incrementa a versão Menor, e alterações incompatíveis com as
versões anteriores da API incrementa a versão Maior.\nEu chamo esse sistema de “Versionamento Semântico”. Sob este esquema, os números
de versão e a forma como eles mudam, transmite o significado do código
subjacente e o que foi modificado de uma versão para a próxima.\nEspecificação de Versionamento Semântico (SemVer)\nAs palavras-chaves “DEVE”, “NÃO DEVE”, “OBRIGATÓRIO”, “DEVERÁ”, “NÃO DEVERÁ”,
“DEVERIA”, “NÃO DEVERIA”, “RECOMENDADO”, “PODE” e “OPCIONAL” no presente
documento devem ser interpretados como descrito na RFC 2119.\nSoftware usando Versionamento Semântico DEVE declarar uma API pública. Esta
API poderá ser declarada no próprio código ou existir estritamente na
documentação, desde que seja precisa e compreensiva.\nSoftware usando Versionamento Semântico DEVE declarar uma API pública. Esta
API poderá ser declarada no próprio código ou existir estritamente na
documentação, desde que seja precisa e compreensiva.\nUm número de versão normal DEVE ter o formato de X.Y.Z, onde X, Y, e Z são
inteiros. X é a versão Maior, Y é a versão Menor, e Z é a versão de Correção.
Cada elemento DEVE aumentar numericamente por incrementos de um.
Por exemplo: 1.9.0 -> 1.10.0 -> 1.11.0.\nUm número de versão normal DEVE ter o formato de X.Y.Z, onde X, Y, e Z são
inteiros. X é a versão Maior, Y é a versão Menor, e Z é a versão de Correção.
Cada elemento DEVE aumentar numericamente por incrementos de um.
Por exemplo: 1.9.0 -> 1.10.0 -> 1.11.0.\nQuando o número de uma versão maior for incrementado, a versão menor e a
versão de correção DEVEM ser reinicializadas para 0 (zero). Quando o número de
uma versão menor foi incrementado, a versão de correção DEVE ser reinicializada
como 0 (zero). Por exemplo: 1.1.3 -> 2.0.0 e 2.1.7 -> 2.2.0.\nQuando o número de uma versão maior for incrementado, a versão menor e a
versão de correção DEVEM ser reinicializadas para 0 (zero). Quando o número de
uma versão menor foi incrementado, a versão de correção DEVE ser reinicializada
como 0 (zero). Por exemplo: 1.1.3 -> 2.0.0 e 2.1.7 -> 2.2.0.\nUma versão de Pré-Lançamento (pre-release) PODE ser identificada adicionando
um texto arbitrário imediatamente após a versão de correção e um ponto (decimal
point). Esse texto  DEVE ser composto por apenas caracteres alfanuméricos e
hífen (dash) [0-9A-Za-z-] e DEVE começar com um caractere alfabético [A-Za-z].
versões de Pré-Lançamento satisfazem, mas tem inferior à versão normal a que está
associada. A precedência DEVE ser determinada lexicalmente na ordem de
classificação ASCII. Por exemplo: 1.0.0.alpha1 < 1.0.0.beta1 < 1.0.0.beta2
< 1.0.0.rc1 < 1.0.0.\nUma versão de Pré-Lançamento (pre-release) PODE ser identificada adicionando
um texto arbitrário imediatamente após a versão de correção e um ponto (decimal
point). Esse texto  DEVE ser composto por apenas caracteres alfanuméricos e
hífen (dash) [0-9A-Za-z-] e DEVE começar com um caractere alfabético [A-Za-z].
versões de Pré-Lançamento satisfazem, mas tem inferior à versão normal a que está
associada. A precedência DEVE ser determinada lexicalmente na ordem de
classificação ASCII. Por exemplo: 1.0.0.alpha1 < 1.0.0.beta1 < 1.0.0.beta2
< 1.0.0.rc1 < 1.0.0.\nUma vez que um pacote versionado foi lançado (released), o conteúdo desta
versão NÃO DEVE ser modificado. Qualquer modificação deve ser lançado como uma
nova versão.\nUma vez que um pacote versionado foi lançado (released), o conteúdo desta
versão NÃO DEVE ser modificado. Qualquer modificação deve ser lançado como uma
nova versão.\nversão Maior DEVE ser zero (0.y.z) é para o início do desenvolvimento.
Qualquer coisa pode mudar a qualquer momento. A API pública não deve ser considerada
estável.\nversão Maior DEVE ser zero (0.y.z) é para o início do desenvolvimento.
Qualquer coisa pode mudar a qualquer momento. A API pública não deve ser considerada
estável.\nVersão 1.0.0 define a API como pública. A maneira como o número de versão é
incrementado após este lançamento é dependente da API pública e como ela muda.\nVersão 1.0.0 define a API como pública. A maneira como o número de versão é
incrementado após este lançamento é dependente da API pública e como ela muda.\nVersão de Correção Z (x.y.Z | x > 0) DEVE ser incrementado apenas se mantiver
compatibilidade e introduzir correção de bugs. Uma correção de bug é definida
como uma mudança interna que corrige um comportamento incorreto.\nVersão de Correção Z (x.y.Z | x > 0) DEVE ser incrementado apenas se mantiver
compatibilidade e introduzir correção de bugs. Uma correção de bug é definida
como uma mudança interna que corrige um comportamento incorreto.\nVersão Menor Y (x.Y.z | x > 0) DEVE  ser incrementada se uma funcionalidade
nova e compatível for introduzida na API pública. PODE ser incrementada se
uma nova funcionalidade ou melhoria substancial for introduzida
dentro do código privado. PODE incluir mudanças a nível de correção.\nVersão Menor Y (x.Y.z | x > 0) DEVE  ser incrementada se uma funcionalidade
nova e compatível for introduzida na API pública. PODE ser incrementada se
uma nova funcionalidade ou melhoria substancial for introduzida
dentro do código privado. PODE incluir mudanças a nível de correção.\nVersão Maior X (X.y.z | X > 0) DEVE ser incrementada se forem introduzidas
mudanças incompatíveis na API pública. PODE incluir alterações a nível de versão
Menor e de versão de Correção.\nVersão Maior X (X.y.z | X > 0) DEVE ser incrementada se forem introduzidas
mudanças incompatíveis na API pública. PODE incluir alterações a nível de versão
Menor e de versão de Correção.\nEspecificação de Rotulação (SemVerTag)\nEsta sub-especificação DEVE ser utilizada se você utilizar um sistema de
controle de versão (Git, Mercurial, SVN, etc) para armazenar seus códigos. A
utilização de um sistema desses permite às ferramentas de automação a
inspecionar o seu pacote e determinar a conformidade com o Versionamento
Semântico e das versões lançadas.\nQuando for rotular lançamentos em sistemas de controle de versão, o rótulo
para uma versão DEVE ser “vX.Y.Z” e.g. “v3.1.0”.\nQuando for rotular lançamentos em sistemas de controle de versão, o rótulo
para uma versão DEVE ser “vX.Y.Z” e.g. “v3.1.0”.\nA primeira revisão a introduzir conformidade com o Versionamento Semântico
DEVE ser rotulada com “semver”. Isso permite que projetos pré-existentes a
assumirem a conformidade em algum ponto arbitrário e para ferramentas de
automação a descobrirem isso.\nA primeira revisão a introduzir conformidade com o Versionamento Semântico
DEVE ser rotulada com “semver”. Isso permite que projetos pré-existentes a
assumirem a conformidade em algum ponto arbitrário e para ferramentas de
automação a descobrirem isso.\nPor que usar Versionamento Semântico?\nEsta não é uma ideia nova ou revolucionária. De fato, você provavelmente já faz
algo próximo a isso. O problema é que “próximo” não é bom o bastante. Sem a
aderência a algum tipo de especificação formal, os números de versão são
essencialmente inúteis para gerenciamento de dependências. Dando um nome e
definições claras às ideias acima, fica fácil comunicar suas intenções aos
usuários de seu software. Uma vez que estas intenções estão claras,
especificações de dependências flexíveis  (mas não tão flexíveis) finalmente
podem ser feitas.\nUm exemplo simples vai demonstrar como o Versionamento Semântico pode fazer do
inferno de dependência uma coisa do passado. Considere uma biblioteca chamada
“CaminhaoBombeiros.” Ela requer um pacote versionado semânticamente chamado
“Escada.” Quando CaminhaoBombeiros foi criado, Escada estava na versão 3.1.0.
Como CaminhaoBombeiros utiliza algumas funcionalidades que foram inicialmente
introduzidas na versão 3.1.0, você pode especificar, com segurança, a
dependência da Escada como maior ou igual a 3.1.0 porém menor que 4.0.0. Agora,
quando Escada versão 3.1.1 e 3.2.0 estiverem disponíveis, você poderá lançá-los
ao seu sistema de gerenciamento de pacote e saberá que eles serão compatíveis
com os softwares dependentes existentes.\nComo um desenvolvedor responsável você irá, é claro, querer certificar-se que
qualquer atualização no pacote funcionará como anunciado. O mundo real é um
lugar bagunçado; não há nada que possamos fazer quanto a isso senão sermos
vigilantes. O que você pode fazer é deixar o Versionamento Semântico lhe
fornecer uma maneira sensata de lançar e atualizar pacotes sem precisar
atualizar para novas versões de pacotes dependentes, salvando-lhe tempo e
aborrecimento.\nSe tudo isto soa desejável, tudo que você precisar fazer para começar a usar
Versionamento Semântico é declarar que você o esta usando e então, seguir as
regras. Adicione um link para este website no seu README para que outros saibam
as regras e possam beneficiar-se delas.\nComo eu sei quando lançar a versão 1.0.0?\nSe seu software está sendo usado em produção, ele já deve ser provavelmente
1.0.0. Se você possui uma API estável a qual usuários passaram a depender, deve
ser 1.0.0. Se você está se preocupando bastante com compatibilidade com versões
anteriores, já deve ser 1.0.0.\nIsto não desencoraja o desenvolvimento ágil e iteração rápida?\nA versão Maior zero tem o foco exatamente no desenvolvimento rápido. Se você
está mudando a API todo dia, provavelmente você está na versão 0.x.x ou num
branch separado de desenvolvimento, trabalhando numa próxima versão Maior.\nSe mesmo a menor mudança incompatível com a API pública requer aumento da versão maior, não vou acabar na versão 42.0.0 muito rapidamente?\nEsta é uma questão de desenvolvimento responsável e conhecimento antecipado.
Mudanças incompatíveis não devem ser levemente introduzidas para o software que
tem um monte de código dependente. O custo que deve ser incorrido para atualizar
pode ser significante. Tendo que aumentar a versão maior para lançar mudanças
incompatíveis, significa que você pensará no impacto das suas mudanças, e
avaliará a relação de custo/benefício envolvida.\nDocumentar toda a API pública dá muito trabalho!\nÉ sua responsabilidade como desenvolvedor profissional documentar corretamente o
software que será usado por outros. Gerenciar a complexidade de software é uma
parte muito importante para manter o projeto eficiente, e isto é difícil de
fazer se ninguém sabe como usá-lo ou que métodos são seguros de chamar. A longo
prazo, Versionamento Semântico e a insistência em uma API pública bem definida
podem deixar tudo e todos funcionando suavemente.\nO que eu faço se, acidentalmente, liberar uma mudança incompatível com versões anteriores como uma versão menor (minor version)?\nAssim que você perceber que quebrou a especificação de versionamento semântico,
conserte o problema e lance uma nova versão menor, que corrige o problema e
restaura a compatibilidade. Lembre-se que é inaceitável modificar versões
lançadas, mesmo sob essas circustâncias. Se for apropriado, documente a versão
ofensiva e informe seus usuários do problema de forma que eles fiquem cientes da
versão em questão.\nO que devo fazer se eu atualizar minhas próprias dependências sem modificar a API pública?\nIsso seria considerado compatível, uma vez que não afeta a API pública. Software
que depende explicitamente da mesmas dependências que seu pacote, deve ter sua
própria especificação de dependência e o autor notificará quaisquer conflitos.
Para determinar se a mudança é a nível de correção ou modificação de nível menor
dependente se você atualizou suas dependências a fim de corrigir um bug ou
introduzir nova funcionalidade. Eu normalmente esperaria código adicional para
última instância, caso em que é obviamente um incremento no nível menor.\nA Especificação da Semântica de Versionamento é autoria de Tom
Preston-Werner, criador do Gravatars e
co-fundador do GitHub.\nCaso queira deixar sua opinião, por favor abra uma issue no GitHub.\nabra uma issue no GitHub\nCreative Commons ― CC BY 3.0
http://creativecommons.org/licenses/by/3.0/\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nNumerotarea Semantica a Versiunii Software 2.0.0

Sumar
Fiind dat un număr de versiune MAJOR.MINOR.PATCH, se incrementează:

  Numărul MAJOR atunci când se fac modificări ale API-ului ce nu sunt 
compatibile cu versiunea precedenta,
  Numărul MINOR atunci când se adaugă funcționalitate care nu afectează 
compatibilitatea, și
  Numărul PATCH atunci când se adaugă corectări de bug-uri care nu afectează 
compatibilitatea.


Etichete adiționale pentru pre-release și build sunt disponibile ca extensii ale 
formatului MAJOR.MINOR.PATCH.

Introducere

În lumea dezvoltării de software exista ceea ce se numește “iadul
dependențelor”. Cu cât sistemul crește și cu cât integrezi mai multe pachete în
soft-ul tău, cu atât crește posibilitatea să ajungi, într-o zi, în acest iad.

În sistemele cu multe dependențe, lansarea de versiuni noi ale pachetelor poate
sa devină ușor un coșmar. Daca specificațiile dependențelor sunt prea stricte,
există riscul de înghețare a versiunii (inabilitatea de a îmbunătății un pachet 
fara a lansa versiuni noi pentru fiecare din pachetele dependente). Dacă
specificațiile sunt prea flexibile, exista riscul de promiscuitate a versiunii 
(compatibilitate cu prea multe versiuni viitoare). Iadul dependențelor este
acela când înghețarea versiunii sau promiscuitatea versiunii te împiedică să
avansezi proiectul ușor și sigur.

Ca o soluție la această problemă, propun un set de reguli și cerințe simple care
să stabilească modul în care să se stabilească și să se incrementeze numerele
de versiune. Aceste reguli sunt bazate pe, dar nu neapărat limitate la, 
practici răspândite folosite în dezvoltarea de software open-source și 
closed-source. Pentru ca acest sistem de numerotare a versiunii sa funcționeze,
întâi trebuie stabilit și declarat un API public. Acesta poate consta în 
documentație sau să reiasă automat din codul sursă. Indiferent de metoda aleasă,
este important ca acest API sa fie clar și foarte specific. Odată ce ai stabilit
API-ul public, vei comunica schimbări efectuate asupra sa prin incrementări ale
numărului de versiune. Sa luam în considerare formatul X.Y.Z 
(Major.Minor.Patch). Corectările de bug-uri care nu afectează API-ul vor 
incrementa versiunea patch, adăugările și modificările care de asemenea păstrează 
compatibilitatea vor incrementa versiunea minoră, iar adăugările și modificările
care sunt incompatibile vor incrementa versiunea majoră.

Am numit acest sistem “numerotarea semantică a versiunii software”. Sub aceasta
schema de numerotare, numerele de versiune și modul în care ele se schimbă,
oferă o semnificație anume despre codul sursă și ce a fost modificat de la o
versiune la alta.

Specificații pentru numerotarea semantica a versiunii software (SemVer)
Cuvintele cheie “TREBUIE”, “NU TREBUIE”, “NECESAR”, “TREBUIE”, “NU TREBUIE”, 
“AR TREBUI SĂ”, “NU AR TREBUI SĂ”, “RECOMANDAT”, “POATE” și “OPTIONAL” în acest 
document trebuiesc interpretate in maniera descrisă in 
RFC 2119.


  
    Software-ul care folosește Numerotarea Semantică a Versiunii TREBUIE să 
declare un API public. Acest API poate fi declarat în codul sursă să existe 
numai în documentație. Indiferent cum este declarat AR TREBUI să fie exact și 
complet.
  
  
    Un număr de versiune normal TREBUIE să ia forma X.Y.Z unde, Z, Y și Z sunt 
numere naturale și NU TREBUIE să conțină cifre zero în față. X este versiunea 
majoră, Y este versiunea minoră și Z este versiunea de corecție (patch). Fiecare 
element TREBUIE să crească numeric. Spre exemplu: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Odată ce un pachet versionat a fost lansat, conținutul acelei versiuni 
NU TREBUIE să fie modificat. Orice modificare TREBUIE să fie lansată ca o nouă 
versiune.
  
  
    Versiunea majoră zero (0.y.z) este pentru faza inițială de dezvoltare. Orice 
POATE să fie modificat la orice moment în această versiune majoră. API-ul public 
NU AR TREBUI SA fie considerat stabil.
  
  
    Versiunea 1.0.0 definește API-ul public. Modul în care numărul versiunii este 
incrementat după această lansare (en. release) depinde de acest API public și 
felul în care acesta se schimbă.
  
  
    Versiunea de corecție (patch-ul) Z (x.y.Z | x > 0) TREBUIE să fie incrementat 
doar dacă există corecții (en. bug fixes) compatibile cu versiunile anterioare au 
fost introduse. O corecție este definită ca o modificare internă care corectează 
un comportament incorect.
  
  
    Versiunea minoră Y (x.Y.z | x > 0) TREBUIE sa fie incrementată dacă 
funcționalitate nouă, compatibilă cu versiunea anterioară, este introdusă in 
API-ul public. TREBUIE să fie incrementată dacă orice funcționalitate din API-ul 
public este marcată ca învechită (en. deprecated). POATE fi incrementată dacă 
funcționalitate sau îmbunătățiri substanțiale sunt introduse in codul privat. 
POATE include modificări de tip corecție. Numărul versiunii de corecție TREBUIE 
resetat la 0 când numărul versiunii minore este incrementat.
  
  
    Numărul versiunii majore X (X.y.z | X > 0) TREBUIE incrementat daca modificări 
care nu sunt compatibile cu versiunile anterioare au fost introduse in API-ul 
public. POATE de asemenea include modificări ale numărului versiunii minore și 
ale numărului de versiune de corecție. Numerele de versiune minor și de corecție 
TREBUIE să fie resetate la 0 când versiunea majoră este incrementată.
  
  
    O versiune de tipul pre-lansare (en. pre-release) POATE fi notată adaugând o 
liniuță separatoare și o serie de identificatori separați prin punct imediat 
după numărul versiunii de corecție. Identificatorii TREBUIE să conțină numai 
caractere ASCII alfanumerice și caracterul liniuță [0-9A-Za-z-]. Identificatorii 
NU TREBUIE să fie goi. Identificatorii numerici NU TREBUIE să conțină zerouri în 
față. Versiunile pre-lansare au o precedență față de versiunea normală asociată. 
O versiune pre-lansare indică faptul că versiunea este instabilă și ar putea să 
nu satisfacă nevoile de compatibilitate pe care le implică numărul versiunii 
normale. Exemple: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.–.
  
  
    Metadatele de build POT fi notate adăugând un plus și o serie de identificatori 
separați cu punct imediat după versiunea de corecție sau de pre-lansare. 
Identificatorii TREBUIE să fie compuși doar din caractere ASCII alfanumerice și 
liniuțe [0-9A-Za-z-]. Identificatorii nu trebuie să fie goi. Metadatele de build 
trebuie ignorate când se determină precedența versiunii. Astfel două versiuni 
care diferă doar prin metadatele de build au aceeași precedență. Exemple: 
1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3—-117B344092BD.
  
  
    Precedența se referă la cum versiunile sunt comparate una cu alta atunci când 
se sortează.
  
  
    Precedența trebuie calculată separând versiunea in identificatori major, 
minor, corecți și pre-lansare în această ordine (metadata de build nu este 
luată în considerare la calculul precedenței).
  
  
    Precedența este determinată de prima diferență când se compară fiecare 
dintre acești identificatori de la stânga la dreapta după cum urmează: major, 
minor și corecție sunt întotdeauna comparate numeric.

    Exemplu: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
  
  
    Când numerele versiunii majore, minore și de corecție sunt egale, o versiune 
de pre-lansare are precedență mai mică decât o versiune normală.

    Exemplu: 1.0.0-alpha < 1.0.0.
  
  
    Precedența a două versiuni pre-lansare cu aceeași versiune majoră, minoră și 
de corecție TREBUIE determinată comparând fiecare identificator separat cu 
punct, de la stânga la dreapta până când o diferență este găsită, după cum 
urmează:

    
      
        Identificatorii care consistă in cifre sunt comparați numeric.
      
      
        Identificatorii cu litere sau liniuță sunt comparați lexical in ordinea 
   de sortare ASCII.
      
      
        Identificatorii numerici au întotdeauna precedență mai mică decât cei 
non-numerici.
      
      
        Un set mai mare de câmpuri pre-lansare are o precedență mai mare decât 
un set mai mic, daca toți identificatorii precedenți sunt egali.

        Exemplu: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
      
    
  


Forma gramaticală Backus–Naur pentru versiuni SemVer valide
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


De ce să folosim numerotarea semantică a versiunii?

Aceasta nu este o idee nouă sau revoluționară. De fapt, deja poate faci ceva de 
genul acesta deja. Problema este că “ceva de genul” nu este suficient de bine. 
Fără a adera la o specificație formală, numerele de versiune sunt în esență 
inutile pentru managementul dependințelor. Oferind un nume și o definiție clară 
ideilor de mai sus, devine facil să comunici intențiile tale utilizatorilor 
software-ului dezvoltat de tine. Odată ce aceste intenții sunt clare, specificații 
de dependințe flexibile (dar nu mult prea flexibile) pot fi făcute.

Un exemplu simplu va demonstra cum Versionarea Semantică poate face iadul 
dependințelor (en. dependency hell) o realitate de domeniul trecutului. Să 
considerăm o bibliotecă numită “Firetruck”. Necesită un package cu Versionare 
Semantică numit “Ladder”. La momentul când Firetruck este creat, Ladder este 
la versiunea 3.1.0. Din moment ce Firetruck folosește niște funcționalitate care 
a fost introdusă pentru prima dată în
3.1.0 poți specifica în siguranță ca dependința pentru Ladder este mai mare sau 
egală cu 3.1.0 dar mai mică decât 4.0.0. Când versiunile pentru Ladder 3.1.1 și 
3.2.0 vor fi disponibile, le poți lansa în sistemul tău de management al 
pachetelor știind că vor fi compatibile cu software-ul dependent, existent.

Fiind un dezvoltator responsabil, desigur vei dori să verifici ca orice 
upgrade-uri de pachete funcționează așa cum trebuie. Realitatea este un loc 
dezordonat și cu probleme; nu putem face nimic în privința asta decât să fim 
vigilenți. Ce poți face este să lași Versionarea Semantică să îți ofere o cale 
sănătoasă prin care să lansezi și upgradezi pachete fără a fi nevoie să dezvolți 
noi versiuni de pachete dependente, fără a pierde vremea și cu deranj minim.

Dacă toate acestea sună ca ceva ce îți dorești să ai, tot ce trebuie să faci ca 
să începi să folosești Versionarea Semantică este să declari asta și să urmezi 
regulile. Include un link către acest site web đin fișierul README pentru ca 
alții să știe regulile și să beneficieze de pe urma lor.

Întrebări frecvente

Care este modul de lucru cu revizuiri (en. revisions) 0.y.z in faza inițială de dezvoltare?

Cel mai simplu lucru care poate fi făcut este să începi lansarea de dezvoltare 
inițială la 0.1.0 și apoi să incrementezi versiunea minoră la fiecare lansare 
ulterioară.

Când știu că este momentul să lansez 1.0.0?

Daca software-ul tău este folosit în producție, ar trebui să fie deja 1.0.0. Dacă 
ai un API stabil de care utilizatorii au ajuns să depindă, at trebui să fie 1.0.0. 
Dacă îti faci griji despre compatibilitate cu versiunile anterioare, ar trebui 
deja să fie 1.0.0.

Nu descurajează asta dezvoltarea și iterațiile rapide?

Versiunea majoră zero este pentru și despre dezvoltare rapidă. Dacă schimbi 
API-ul în fiecare zi ar trebui să fi încă in versiunea 0.y.z sau pe o ramură de 
dezvoltare separată, lucrând la următoarea versiune majoră.

Dacă până și cele mai mici modificări ale API-ului public care nu mențin compatibilitatea cu versiunile anterioare necesită o incrementare a versiunii majore, nu voi ajunge foarte repede la versiunea 42.0.0?

Aceasta este o chestiune de dezvoltare responsabilă și prevedere. Modificările 
incompatibile nu ar trebui introduse cu ușurință în software care are foarte 
mult cod dependent. Costul care poate apărea pentru a upgrada poate să fie 
semnificativ. Să crești versiunea majoră pentru a lansa modificări care nu 
mențin compatibilitatea înseamna să te gândești dinainte la impactul pe care 
îl vor avea modificările și să evaluezi rația costuri/beneficii.

Să documentez întregul API public necesită prea multă muncă!

Este responsabilitatea ta ca dezvoltator profesionist să documentezi software 
care este intenționat spre a fi folosit de alții. Managementul complexității 
software este un aspect deosebit de important în a menține un proiect la un 
nivel înalt de eficiență și asta este ceva dificil de realizat dacă nimeni nu 
știe cum sa folosească software-ul dezvoltat de tine sau ce metode poate să 
apeleze în siguranță. Pe termen lung, Versionarea Semantică, și insistarea pe 
a avea un API public foarte bine definit poate să mențină totul într-o stare bună.

Ce fac dacă în mod accidental lansez o versiune minoră care este incompatibilă cu versiunile anterioare?

Imediat ce realizezi că ai încălcat specificațiile Versionării Semantice, 
rezolvă problema și lansează o nouă versiune minoră care rezolvă problema 
incompatibilității și reface compatibilitatea cu versiunile anterioare. 
Chiar și în acest caz, nu este acceptabil să modifici versiuni deja lansate. 
Dacă este cazul, documentează versiunea care introducea această problemă și 
informează utilizatorii de această problemă pentru ca și ei să cunoască 
problema introdusă de versiunea în cauză.

Ce să fac dacă înnoiesc propriile mele dependințe fără a modifica API-ul public?

Acest lucru este considerat compatibil deoarece nu afectează API-ul public. 
Software care in mod explicit depinde de aceleași dependințe de care depinde 
pachetul tău, ar trebui să aibă propriile sale specificații de dependințe și 
autorul sau va realiza orice conflicte. Determinarea dacă modificarea este una 
de tip corecție sau de nivel minor, depinde dacă ai înnoit dependințele pentru 
a rezolva un bug sau pentru a introduce funcționalități noi. In mod normal ca 
dezvoltator mă aștept la cod adițional pentru al doilea caz și natural ar fi o 
incrementare de nivel minor.

Dacă din neatenție alterez API-ul public într-o manieră care nu aderă la principiile schimbării de versiune (ex. codul în mod incorect introduce o modificare care afectează funcționalitatea într-o lansare de tip corecție)

Folosește-ți judecata. Dacă ai o audiență uriașă care va fi afectată în mod 
drastic schimbând comportamentul pachetului înapoi la ce se intenționa din 
API-ul public, atunci ar putea fi cel mai bine să lansezi o versiune majoră, d
eși corecția în mod strict ar putea fi considerată o versiune de corecție. 
Reamintește-ți ca Versionarea Semantică este despre a oferi o semnificație 
în funcție de cum se schimbă numărul de versiune. Dacă aceste schimbări sunt 
importante pentru utilizatorii tăi, folosește-te de numărul de versiune 
pentru a-i informa.

Cum abordez funcționalitatea care este pe cale să devină învechită?

Funcționalitatea existentă care este pe cale să devină învechită 
(en. deprecating) este un aspect normal al dezvoltării software și este de 
multe ori necesară pentru a obține progresul. Când parte din API-ul public 
devine învechită, ar trebi să faci două lucruri: (1) înnoiește documentația 
pentru ca utilizatorii să știe de modificare, (2) lansează o nouă versiune 
minoră în care păstrezi codul învechit. Înainte de a elimina complet codul 
învechit într-o lansare majoră, ar trebuie să fie cel puțin o lansare minoră 
care conține codul învechit care va fi eliminat, pentru ca utilizatorii să 
poată trece elegant la noul API.

Are SemVer o dimensiune limită a șirului de caractere care definește versiunea?

Nu, dar folosește o judecată sănătoasă. Un șir de 255 de caractere este probabil 
exagerat spre exemplu. De asemenea, sisteme specifice ar putea impune propriile 
lor limite în ceea ce privește dimensiunea șirului de caractere.

Este “v1.2.3” o versiune semantică?

Nu, “v1.2.3” nu este o versiune semantică. Totuși, prefixarea unei versiuni 
semantice cu un “v” este o modalitate comună (în engleză și română) pentru a 
indica faptul că este un număr de versiune. Abrevierea cuvântului “versiune” 
prin “v” este un comportament văzut des în sistemele de control al versiunii. 
Examplu: git tag v1.2.3 -m "Lansare versiune 1.2.3", în acest caz “v1.2.3” 
este o etichetă (en. tag) și versiunea semantică este “1.2.3”.

Există o expresie regulată (RegEx) pentru a verifica un șir de caractere SemVer?

Există două. Una cu grupuri cu denumire pentru acele sisteme care le suportă 
(PCRE “Perl Compatible Regular Expressions”, i.e. Perl, PHP and R], Python and Go).

Vezi: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Și una cu grupuri de captură numerotate (așadar cg1 = major, cg2 = minor,
cg3 = corecție, cg4 = pre-lansare și cg5 = metainformație de build) care sunt compatibile cu ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
i.e. Perl, PHP and R), Python și Go.

Vezi: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Despre

Specificațiile nmerotării semantice a versiunii a fost original creată de Tom
Preston-Werner, inventatorul Gravatar și co-fondator al GitHub.

Dacă dorești să oferi feedback, te rugăm înaintează o sesizare pe GitHub.

Traducerea în română a fost realizată de catre echipele de dezvoltatori software ai 
Epigrade, 
Locatorix, 
Moneeva și 
Lux Rehabs.

Licență

Creative Commons ― CC BY 3.0\nNumerotarea Semantica a Versiunii Software 2.0.0\nFiind dat un număr de versiune MAJOR.MINOR.PATCH, se incrementează:\nNumărul MAJOR atunci când se fac modificări ale API-ului ce nu sunt 
compatibile cu versiunea precedenta,\nNumărul MINOR atunci când se adaugă funcționalitate care nu afectează 
compatibilitatea, și\nNumărul PATCH atunci când se adaugă corectări de bug-uri care nu afectează 
compatibilitatea.\nEtichete adiționale pentru pre-release și build sunt disponibile ca extensii ale 
formatului MAJOR.MINOR.PATCH.\nÎn lumea dezvoltării de software exista ceea ce se numește “iadul
dependențelor”. Cu cât sistemul crește și cu cât integrezi mai multe pachete în
soft-ul tău, cu atât crește posibilitatea să ajungi, într-o zi, în acest iad.\nÎn sistemele cu multe dependențe, lansarea de versiuni noi ale pachetelor poate
sa devină ușor un coșmar. Daca specificațiile dependențelor sunt prea stricte,
există riscul de înghețare a versiunii (inabilitatea de a îmbunătății un pachet 
fara a lansa versiuni noi pentru fiecare din pachetele dependente). Dacă
specificațiile sunt prea flexibile, exista riscul de promiscuitate a versiunii 
(compatibilitate cu prea multe versiuni viitoare). Iadul dependențelor este
acela când înghețarea versiunii sau promiscuitatea versiunii te împiedică să
avansezi proiectul ușor și sigur.\nCa o soluție la această problemă, propun un set de reguli și cerințe simple care
să stabilească modul în care să se stabilească și să se incrementeze numerele
de versiune. Aceste reguli sunt bazate pe, dar nu neapărat limitate la, 
practici răspândite folosite în dezvoltarea de software open-source și 
closed-source. Pentru ca acest sistem de numerotare a versiunii sa funcționeze,
întâi trebuie stabilit și declarat un API public. Acesta poate consta în 
documentație sau să reiasă automat din codul sursă. Indiferent de metoda aleasă,
este important ca acest API sa fie clar și foarte specific. Odată ce ai stabilit
API-ul public, vei comunica schimbări efectuate asupra sa prin incrementări ale
numărului de versiune. Sa luam în considerare formatul X.Y.Z 
(Major.Minor.Patch). Corectările de bug-uri care nu afectează API-ul vor 
incrementa versiunea patch, adăugările și modificările care de asemenea păstrează 
compatibilitatea vor incrementa versiunea minoră, iar adăugările și modificările
care sunt incompatibile vor incrementa versiunea majoră.\nAm numit acest sistem “numerotarea semantică a versiunii software”. Sub aceasta
schema de numerotare, numerele de versiune și modul în care ele se schimbă,
oferă o semnificație anume despre codul sursă și ce a fost modificat de la o
versiune la alta.\nSpecificații pentru numerotarea semantica a versiunii software (SemVer)\nCuvintele cheie “TREBUIE”, “NU TREBUIE”, “NECESAR”, “TREBUIE”, “NU TREBUIE”, 
“AR TREBUI SĂ”, “NU AR TREBUI SĂ”, “RECOMANDAT”, “POATE” și “OPTIONAL” în acest 
document trebuiesc interpretate in maniera descrisă in 
RFC 2119.\nSoftware-ul care folosește Numerotarea Semantică a Versiunii TREBUIE să 
declare un API public. Acest API poate fi declarat în codul sursă să existe 
numai în documentație. Indiferent cum este declarat AR TREBUI să fie exact și 
complet.\nSoftware-ul care folosește Numerotarea Semantică a Versiunii TREBUIE să 
declare un API public. Acest API poate fi declarat în codul sursă să existe 
numai în documentație. Indiferent cum este declarat AR TREBUI să fie exact și 
complet.\nUn număr de versiune normal TREBUIE să ia forma X.Y.Z unde, Z, Y și Z sunt 
numere naturale și NU TREBUIE să conțină cifre zero în față. X este versiunea 
majoră, Y este versiunea minoră și Z este versiunea de corecție (patch). Fiecare 
element TREBUIE să crească numeric. Spre exemplu: 1.9.0 -> 1.10.0 -> 1.11.0.\nUn număr de versiune normal TREBUIE să ia forma X.Y.Z unde, Z, Y și Z sunt 
numere naturale și NU TREBUIE să conțină cifre zero în față. X este versiunea 
majoră, Y este versiunea minoră și Z este versiunea de corecție (patch). Fiecare 
element TREBUIE să crească numeric. Spre exemplu: 1.9.0 -> 1.10.0 -> 1.11.0.\nOdată ce un pachet versionat a fost lansat, conținutul acelei versiuni 
NU TREBUIE să fie modificat. Orice modificare TREBUIE să fie lansată ca o nouă 
versiune.\nOdată ce un pachet versionat a fost lansat, conținutul acelei versiuni 
NU TREBUIE să fie modificat. Orice modificare TREBUIE să fie lansată ca o nouă 
versiune.\nVersiunea majoră zero (0.y.z) este pentru faza inițială de dezvoltare. Orice 
POATE să fie modificat la orice moment în această versiune majoră. API-ul public 
NU AR TREBUI SA fie considerat stabil.\nVersiunea majoră zero (0.y.z) este pentru faza inițială de dezvoltare. Orice 
POATE să fie modificat la orice moment în această versiune majoră. API-ul public 
NU AR TREBUI SA fie considerat stabil.\nVersiunea 1.0.0 definește API-ul public. Modul în care numărul versiunii este 
incrementat după această lansare (en. release) depinde de acest API public și 
felul în care acesta se schimbă.\nVersiunea 1.0.0 definește API-ul public. Modul în care numărul versiunii este 
incrementat după această lansare (en. release) depinde de acest API public și 
felul în care acesta se schimbă.\nVersiunea de corecție (patch-ul) Z (x.y.Z | x > 0) TREBUIE să fie incrementat 
doar dacă există corecții (en. bug fixes) compatibile cu versiunile anterioare au 
fost introduse. O corecție este definită ca o modificare internă care corectează 
un comportament incorect.\nVersiunea de corecție (patch-ul) Z (x.y.Z | x > 0) TREBUIE să fie incrementat 
doar dacă există corecții (en. bug fixes) compatibile cu versiunile anterioare au 
fost introduse. O corecție este definită ca o modificare internă care corectează 
un comportament incorect.\nVersiunea minoră Y (x.Y.z | x > 0) TREBUIE sa fie incrementată dacă 
funcționalitate nouă, compatibilă cu versiunea anterioară, este introdusă in 
API-ul public. TREBUIE să fie incrementată dacă orice funcționalitate din API-ul 
public este marcată ca învechită (en. deprecated). POATE fi incrementată dacă 
funcționalitate sau îmbunătățiri substanțiale sunt introduse in codul privat. 
POATE include modificări de tip corecție. Numărul versiunii de corecție TREBUIE 
resetat la 0 când numărul versiunii minore este incrementat.\nVersiunea minoră Y (x.Y.z | x > 0) TREBUIE sa fie incrementată dacă 
funcționalitate nouă, compatibilă cu versiunea anterioară, este introdusă in 
API-ul public. TREBUIE să fie incrementată dacă orice funcționalitate din API-ul 
public este marcată ca învechită (en. deprecated). POATE fi incrementată dacă 
funcționalitate sau îmbunătățiri substanțiale sunt introduse in codul privat. 
POATE include modificări de tip corecție. Numărul versiunii de corecție TREBUIE 
resetat la 0 când numărul versiunii minore este incrementat.\nNumărul versiunii majore X (X.y.z | X > 0) TREBUIE incrementat daca modificări 
care nu sunt compatibile cu versiunile anterioare au fost introduse in API-ul 
public. POATE de asemenea include modificări ale numărului versiunii minore și 
ale numărului de versiune de corecție. Numerele de versiune minor și de corecție 
TREBUIE să fie resetate la 0 când versiunea majoră este incrementată.\nNumărul versiunii majore X (X.y.z | X > 0) TREBUIE incrementat daca modificări 
care nu sunt compatibile cu versiunile anterioare au fost introduse in API-ul 
public. POATE de asemenea include modificări ale numărului versiunii minore și 
ale numărului de versiune de corecție. Numerele de versiune minor și de corecție 
TREBUIE să fie resetate la 0 când versiunea majoră este incrementată.\nO versiune de tipul pre-lansare (en. pre-release) POATE fi notată adaugând o 
liniuță separatoare și o serie de identificatori separați prin punct imediat 
după numărul versiunii de corecție. Identificatorii TREBUIE să conțină numai 
caractere ASCII alfanumerice și caracterul liniuță [0-9A-Za-z-]. Identificatorii 
NU TREBUIE să fie goi. Identificatorii numerici NU TREBUIE să conțină zerouri în 
față. Versiunile pre-lansare au o precedență față de versiunea normală asociată. 
O versiune pre-lansare indică faptul că versiunea este instabilă și ar putea să 
nu satisfacă nevoile de compatibilitate pe care le implică numărul versiunii 
normale. Exemple: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.–.\nO versiune de tipul pre-lansare (en. pre-release) POATE fi notată adaugând o 
liniuță separatoare și o serie de identificatori separați prin punct imediat 
după numărul versiunii de corecție. Identificatorii TREBUIE să conțină numai 
caractere ASCII alfanumerice și caracterul liniuță [0-9A-Za-z-]. Identificatorii 
NU TREBUIE să fie goi. Identificatorii numerici NU TREBUIE să conțină zerouri în 
față. Versiunile pre-lansare au o precedență față de versiunea normală asociată. 
O versiune pre-lansare indică faptul că versiunea este instabilă și ar putea să 
nu satisfacă nevoile de compatibilitate pe care le implică numărul versiunii 
normale. Exemple: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.–.\nMetadatele de build POT fi notate adăugând un plus și o serie de identificatori 
separați cu punct imediat după versiunea de corecție sau de pre-lansare. 
Identificatorii TREBUIE să fie compuși doar din caractere ASCII alfanumerice și 
liniuțe [0-9A-Za-z-]. Identificatorii nu trebuie să fie goi. Metadatele de build 
trebuie ignorate când se determină precedența versiunii. Astfel două versiuni 
care diferă doar prin metadatele de build au aceeași precedență. Exemple: 
1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3—-117B344092BD.\nMetadatele de build POT fi notate adăugând un plus și o serie de identificatori 
separați cu punct imediat după versiunea de corecție sau de pre-lansare. 
Identificatorii TREBUIE să fie compuși doar din caractere ASCII alfanumerice și 
liniuțe [0-9A-Za-z-]. Identificatorii nu trebuie să fie goi. Metadatele de build 
trebuie ignorate când se determină precedența versiunii. Astfel două versiuni 
care diferă doar prin metadatele de build au aceeași precedență. Exemple: 
1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3—-117B344092BD.\nPrecedența se referă la cum versiunile sunt comparate una cu alta atunci când 
se sortează.\nPrecedența se referă la cum versiunile sunt comparate una cu alta atunci când 
se sortează.\nPrecedența trebuie calculată separând versiunea in identificatori major, 
minor, corecți și pre-lansare în această ordine (metadata de build nu este 
luată în considerare la calculul precedenței).\nPrecedența trebuie calculată separând versiunea in identificatori major, 
minor, corecți și pre-lansare în această ordine (metadata de build nu este 
luată în considerare la calculul precedenței).\nPrecedența este determinată de prima diferență când se compară fiecare 
dintre acești identificatori de la stânga la dreapta după cum urmează: major, 
minor și corecție sunt întotdeauna comparate numeric.

    Exemplu: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nPrecedența este determinată de prima diferență când se compară fiecare 
dintre acești identificatori de la stânga la dreapta după cum urmează: major, 
minor și corecție sunt întotdeauna comparate numeric.\nExemplu: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nCând numerele versiunii majore, minore și de corecție sunt egale, o versiune 
de pre-lansare are precedență mai mică decât o versiune normală.

    Exemplu: 1.0.0-alpha < 1.0.0.\nCând numerele versiunii majore, minore și de corecție sunt egale, o versiune 
de pre-lansare are precedență mai mică decât o versiune normală.\nExemplu: 1.0.0-alpha < 1.0.0.\nPrecedența a două versiuni pre-lansare cu aceeași versiune majoră, minoră și 
de corecție TREBUIE determinată comparând fiecare identificator separat cu 
punct, de la stânga la dreapta până când o diferență este găsită, după cum 
urmează:

    
      
        Identificatorii care consistă in cifre sunt comparați numeric.
      
      
        Identificatorii cu litere sau liniuță sunt comparați lexical in ordinea 
   de sortare ASCII.
      
      
        Identificatorii numerici au întotdeauna precedență mai mică decât cei 
non-numerici.
      
      
        Un set mai mare de câmpuri pre-lansare are o precedență mai mare decât 
un set mai mic, daca toți identificatorii precedenți sunt egali.

        Exemplu: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPrecedența a două versiuni pre-lansare cu aceeași versiune majoră, minoră și 
de corecție TREBUIE determinată comparând fiecare identificator separat cu 
punct, de la stânga la dreapta până când o diferență este găsită, după cum 
urmează:\nIdentificatorii care consistă in cifre sunt comparați numeric.\nIdentificatorii care consistă in cifre sunt comparați numeric.\nIdentificatorii cu litere sau liniuță sunt comparați lexical in ordinea 
   de sortare ASCII.\nIdentificatorii cu litere sau liniuță sunt comparați lexical in ordinea 
   de sortare ASCII.\nIdentificatorii numerici au întotdeauna precedență mai mică decât cei 
non-numerici.\nIdentificatorii numerici au întotdeauna precedență mai mică decât cei 
non-numerici.\nUn set mai mare de câmpuri pre-lansare are o precedență mai mare decât 
un set mai mic, daca toți identificatorii precedenți sunt egali.

        Exemplu: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nUn set mai mare de câmpuri pre-lansare are o precedență mai mare decât 
un set mai mic, daca toți identificatorii precedenți sunt egali.\nExemplu: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nForma gramaticală Backus–Naur pentru versiuni SemVer valide\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nDe ce să folosim numerotarea semantică a versiunii?\nAceasta nu este o idee nouă sau revoluționară. De fapt, deja poate faci ceva de 
genul acesta deja. Problema este că “ceva de genul” nu este suficient de bine. 
Fără a adera la o specificație formală, numerele de versiune sunt în esență 
inutile pentru managementul dependințelor. Oferind un nume și o definiție clară 
ideilor de mai sus, devine facil să comunici intențiile tale utilizatorilor 
software-ului dezvoltat de tine. Odată ce aceste intenții sunt clare, specificații 
de dependințe flexibile (dar nu mult prea flexibile) pot fi făcute.\nUn exemplu simplu va demonstra cum Versionarea Semantică poate face iadul 
dependințelor (en. dependency hell) o realitate de domeniul trecutului. Să 
considerăm o bibliotecă numită “Firetruck”. Necesită un package cu Versionare 
Semantică numit “Ladder”. La momentul când Firetruck este creat, Ladder este 
la versiunea 3.1.0. Din moment ce Firetruck folosește niște funcționalitate care 
a fost introdusă pentru prima dată în
3.1.0 poți specifica în siguranță ca dependința pentru Ladder este mai mare sau 
egală cu 3.1.0 dar mai mică decât 4.0.0. Când versiunile pentru Ladder 3.1.1 și 
3.2.0 vor fi disponibile, le poți lansa în sistemul tău de management al 
pachetelor știind că vor fi compatibile cu software-ul dependent, existent.\nFiind un dezvoltator responsabil, desigur vei dori să verifici ca orice 
upgrade-uri de pachete funcționează așa cum trebuie. Realitatea este un loc 
dezordonat și cu probleme; nu putem face nimic în privința asta decât să fim 
vigilenți. Ce poți face este să lași Versionarea Semantică să îți ofere o cale 
sănătoasă prin care să lansezi și upgradezi pachete fără a fi nevoie să dezvolți 
noi versiuni de pachete dependente, fără a pierde vremea și cu deranj minim.\nDacă toate acestea sună ca ceva ce îți dorești să ai, tot ce trebuie să faci ca 
să începi să folosești Versionarea Semantică este să declari asta și să urmezi 
regulile. Include un link către acest site web đin fișierul README pentru ca 
alții să știe regulile și să beneficieze de pe urma lor.\nCare este modul de lucru cu revizuiri (en. revisions) 0.y.z in faza inițială de dezvoltare?\nCel mai simplu lucru care poate fi făcut este să începi lansarea de dezvoltare 
inițială la 0.1.0 și apoi să incrementezi versiunea minoră la fiecare lansare 
ulterioară.\nCând știu că este momentul să lansez 1.0.0?\nDaca software-ul tău este folosit în producție, ar trebui să fie deja 1.0.0. Dacă 
ai un API stabil de care utilizatorii au ajuns să depindă, at trebui să fie 1.0.0. 
Dacă îti faci griji despre compatibilitate cu versiunile anterioare, ar trebui 
deja să fie 1.0.0.\nNu descurajează asta dezvoltarea și iterațiile rapide?\nVersiunea majoră zero este pentru și despre dezvoltare rapidă. Dacă schimbi 
API-ul în fiecare zi ar trebui să fi încă in versiunea 0.y.z sau pe o ramură de 
dezvoltare separată, lucrând la următoarea versiune majoră.\nDacă până și cele mai mici modificări ale API-ului public care nu mențin compatibilitatea cu versiunile anterioare necesită o incrementare a versiunii majore, nu voi ajunge foarte repede la versiunea 42.0.0?\nAceasta este o chestiune de dezvoltare responsabilă și prevedere. Modificările 
incompatibile nu ar trebui introduse cu ușurință în software care are foarte 
mult cod dependent. Costul care poate apărea pentru a upgrada poate să fie 
semnificativ. Să crești versiunea majoră pentru a lansa modificări care nu 
mențin compatibilitatea înseamna să te gândești dinainte la impactul pe care 
îl vor avea modificările și să evaluezi rația costuri/beneficii.\nSă documentez întregul API public necesită prea multă muncă!\nEste responsabilitatea ta ca dezvoltator profesionist să documentezi software 
care este intenționat spre a fi folosit de alții. Managementul complexității 
software este un aspect deosebit de important în a menține un proiect la un 
nivel înalt de eficiență și asta este ceva dificil de realizat dacă nimeni nu 
știe cum sa folosească software-ul dezvoltat de tine sau ce metode poate să 
apeleze în siguranță. Pe termen lung, Versionarea Semantică, și insistarea pe 
a avea un API public foarte bine definit poate să mențină totul într-o stare bună.\nCe fac dacă în mod accidental lansez o versiune minoră care este incompatibilă cu versiunile anterioare?\nImediat ce realizezi că ai încălcat specificațiile Versionării Semantice, 
rezolvă problema și lansează o nouă versiune minoră care rezolvă problema 
incompatibilității și reface compatibilitatea cu versiunile anterioare. 
Chiar și în acest caz, nu este acceptabil să modifici versiuni deja lansate. 
Dacă este cazul, documentează versiunea care introducea această problemă și 
informează utilizatorii de această problemă pentru ca și ei să cunoască 
problema introdusă de versiunea în cauză.\nCe să fac dacă înnoiesc propriile mele dependințe fără a modifica API-ul public?\nAcest lucru este considerat compatibil deoarece nu afectează API-ul public. 
Software care in mod explicit depinde de aceleași dependințe de care depinde 
pachetul tău, ar trebui să aibă propriile sale specificații de dependințe și 
autorul sau va realiza orice conflicte. Determinarea dacă modificarea este una 
de tip corecție sau de nivel minor, depinde dacă ai înnoit dependințele pentru 
a rezolva un bug sau pentru a introduce funcționalități noi. In mod normal ca 
dezvoltator mă aștept la cod adițional pentru al doilea caz și natural ar fi o 
incrementare de nivel minor.\nDacă din neatenție alterez API-ul public într-o manieră care nu aderă la principiile schimbării de versiune (ex. codul în mod incorect introduce o modificare care afectează funcționalitatea într-o lansare de tip corecție)\nFolosește-ți judecata. Dacă ai o audiență uriașă care va fi afectată în mod 
drastic schimbând comportamentul pachetului înapoi la ce se intenționa din 
API-ul public, atunci ar putea fi cel mai bine să lansezi o versiune majoră, d
eși corecția în mod strict ar putea fi considerată o versiune de corecție. 
Reamintește-ți ca Versionarea Semantică este despre a oferi o semnificație 
în funcție de cum se schimbă numărul de versiune. Dacă aceste schimbări sunt 
importante pentru utilizatorii tăi, folosește-te de numărul de versiune 
pentru a-i informa.\nCum abordez funcționalitatea care este pe cale să devină învechită?\nFuncționalitatea existentă care este pe cale să devină învechită 
(en. deprecating) este un aspect normal al dezvoltării software și este de 
multe ori necesară pentru a obține progresul. Când parte din API-ul public 
devine învechită, ar trebi să faci două lucruri: (1) înnoiește documentația 
pentru ca utilizatorii să știe de modificare, (2) lansează o nouă versiune 
minoră în care păstrezi codul învechit. Înainte de a elimina complet codul 
învechit într-o lansare majoră, ar trebuie să fie cel puțin o lansare minoră 
care conține codul învechit care va fi eliminat, pentru ca utilizatorii să 
poată trece elegant la noul API.\nAre SemVer o dimensiune limită a șirului de caractere care definește versiunea?\nNu, dar folosește o judecată sănătoasă. Un șir de 255 de caractere este probabil 
exagerat spre exemplu. De asemenea, sisteme specifice ar putea impune propriile 
lor limite în ceea ce privește dimensiunea șirului de caractere.\nEste “v1.2.3” o versiune semantică?\nNu, “v1.2.3” nu este o versiune semantică. Totuși, prefixarea unei versiuni 
semantice cu un “v” este o modalitate comună (în engleză și română) pentru a 
indica faptul că este un număr de versiune. Abrevierea cuvântului “versiune” 
prin “v” este un comportament văzut des în sistemele de control al versiunii. 
Examplu: git tag v1.2.3 -m "Lansare versiune 1.2.3", în acest caz “v1.2.3” 
este o etichetă (en. tag) și versiunea semantică este “1.2.3”.\nExistă o expresie regulată (RegEx) pentru a verifica un șir de caractere SemVer?\nExistă două. Una cu grupuri cu denumire pentru acele sisteme care le suportă 
(PCRE “Perl Compatible Regular Expressions”, i.e. Perl, PHP and R], Python and Go).\nVezi: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nȘi una cu grupuri de captură numerotate (așadar cg1 = major, cg2 = minor,
cg3 = corecție, cg4 = pre-lansare și cg5 = metainformație de build) care sunt compatibile cu ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
i.e. Perl, PHP and R), Python și Go.\nVezi: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nSpecificațiile nmerotării semantice a versiunii a fost original creată de Tom
Preston-Werner, inventatorul Gravatar și co-fondator al GitHub.\nDacă dorești să oferi feedback, te rugăm înaintează o sesizare pe GitHub.\nînaintează o sesizare pe GitHub\nTraducerea în română a fost realizată de catre echipele de dezvoltatori software ai 
Epigrade, 
Locatorix, 
Moneeva și 
Lux Rehabs.\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nСемантическое Версионирование 2.0.0

Кратко

Учитывая номер версии МАЖОРНАЯ.МИНОРНАЯ.ПАТЧ, следует увеличивать:


  МАЖОРНУЮ версию, когда сделаны обратно несовместимые изменения API.
  МИНОРНУЮ версию, когда вы добавляете новую функциональность, не нарушая обратной
совместимости.
  ПАТЧ-версию, когда вы делаете обратно совместимые исправления.


Дополнительные обозначения для предрелизных и билд-метаданных возможны как
дополнения к МАЖОРНАЯ.МИНОРНАЯ.ПАТЧ формату.

Вступление

В мире управления процессом разработки есть понятие «ад зависимостей»
(dependency hell). Чем больше растёт ваша система и чем больше библиотек вы
интегрируете в ваш проект, тем больше вероятность оказаться в этой ситуации.

В системе с множественными зависимостями выпуск новой версии может быстро
превратиться в кошмар. Если спецификации зависимости слишком жесткие, вы
находитесь в опасности блокирования выпуска новой версии (невозможность
обновить пакет без необходимости выпуска новой версии каждой зависимой
библиотеки). Если спецификация зависимостей слишком свободна, вас неизбежно
настигнет версионное несоответствие (необоснованное предположение совместимости
с будущими версиями).

В качестве решения данной проблемы я предлагаю простой набор правил и
требований, которые определяют, как назначаются и увеличиваются номера версий.
Для того чтобы эта система работала, вам необходимо определить публичный API.
Он может быть описан в документации или определяться самим кодом. Главное,
чтобы этот API был ясным и точным. Однажды определив публичный API, вы
сообщаете об изменениях в нём особым увеличением номера версий. Рассмотрим
формат версий X.Y.Z (мажорная, минорная, патч). Баг-фиксы, не влияющие на
API, увеличивают патч-версию, обратно совместимые добавления/изменения API
увеличивают минорную версию и обратно несовместимые изменения API увеличивают
мажорную версию.

Я называю эту систему «Семантическое Версионирование» (Semantic Versioning). По
этой схеме номера версий и то, как они изменяются, передают смысл содержания
исходного кода и что было модифицировано от одной версии к другой.

Спецификация Семантического Версионирования (SemVer)

Слова «ДОЛЖЕН» (MUST), «НЕ ДОЛЖЕН» (MUST NOT), «ОБЯЗАТЕЛЬНО» (REQUIRED),
«СЛЕДУЕТ» (SHOULD), «НЕ СЛЕДУЕТ» (SHOULD NOT), «РЕКОМЕНДОВАННЫЙ» (RECOMMENDED),
«МОЖЕТ» (MAY) и «НЕОБЯЗАТЕЛЬНЫЙ» (OPTIONAL) в этом документе должны быть
интерпретированы в соответствии с RFC 2119.


  
    ПО, использующее Семантическое Версионирование, должно объявить публичный
API. Этот API может быть объявлен самим кодом или существовать строго в
документации.  Как бы ни было это сделано, он должен быть точным и
исчерпывающим.
  
  
    Обычный номер версии ДОЛЖЕН иметь формат X.Y.Z, где X, Y и Z — неотрицательные
целые числа и НЕ ДОЛЖНЫ начинаться с нуля. X — мажорная версия, Y — минорная
версия и Z — патч-версия. Каждый элемент ДОЛЖЕН увеличиваться численно.
Например: 1.9.0 ->1.10.0 -> 1.11.0.
  
  
    После релиза новой версии пакета содержание этой версии НЕ ДОЛЖНО быть
модифицировано. Любые изменения ДОЛЖНЫ быть выпущены как новая версия.
  
  
    Мажорная версия ноль (0.y.z) предназначена для начальной разработки. Всё
может измениться в любой момент. Публичный API не должен рассматриваться как
стабильный.
  
  
    Версия 1.0.0 определяет публичный API. После этого релиза номера версий
увеличиваются в зависимости от того, как изменяется публичный API.
  
  
    Патч-версия  Z (x.y.Z | x > 0) ДОЛЖНА быть увеличена только если содержит
обратно совместимые баг-фиксы. Определение баг-фикс означает внутренние
изменения, которые исправляют некорректное поведение.
  
  
    Минорная версия (x.Y.z | x > 0) ДОЛЖНА быть увеличена, если в публичном API
представлеа новая обратно совместимая функциональность. Она ДОЛЖНА быть увеличена,
если какая-либо функциональность публичного API помечена как устаревший (deprecated).
Версия МОЖЕТ быть увеличена в случае реализации новой функциональности или
существенного усовершенствования в приватном коде. Версия МОЖЕТ включать в себя
изменения, характерные для патчей. Патч-версия ДОЛЖНА быть обнулена, когда
увеличивается минорная версия.
  
  
    Мажорная версия X (X.y.z | X > 0) ДОЛЖНА быть увеличена, если в публичном API
представлены какие-либо обратно несовместимые изменения. Она МОЖЕТ включать в
себя изменения, характерные для уровня минорных версий и патчей. Когда
увеличивается мажорная версия, минорная и патч-версия ДОЛЖНЫ быть обнулены.
  
  
    Предрелизная версия МОЖЕТ быть обозначена добавлением дефиса и серией
разделённых точкой идентификаторов, следующих сразу за патч-версией.
Идентификаторы ДОЛЖНЫ содержать только ASCII буквенно-цифровые символы и дефис
[0-9A-Za-z-]. Идентификаторы НЕ ДОЛЖНЫ быть пустыми. Числовые идентификаторы
НЕ ДОЛЖНЫ начинаться с нуля. Предрелизные версии имеют более низкий приоритет,
чем соответствующая релизная версия. Предрелизная версия указывает на то, что
эта версия не стабильна и может не удовлетворять требованиям совместимости,
обозначенными соответствующей нормальной версией. Примеры: 1.0.0-alpha,
1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Сборочные метаданные МОГУТ быть обозначены добавлением знака плюс и ряда
разделённых точкой идентификаторов, следующих сразу за патчем или предрелизной
версией. Идентификаторы ДОЛЖНЫ содержать только ASCII буквенно-цифровые символы
и дефис [0-9A-Za-z-]. Идентификаторы НЕ ДОЛЖНЫ быть пустыми. Сборочные
метаданные СЛЕДУЕТ игнорировать, когда определяется старшинство версий. Поэтому
два пакета с одинаковой версией, но разными сборочными метаданными,
рассматриваются как одна и та же версия. Примеры: 1.0.0-alpha+001,
1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    Приоритет определяет, как версии соотносятся друг с другом, когда
упорядочиваются. Приоритет версий ДОЛЖЕН рассчитываться путём разделения номеров
версий на мажорную, минорную, патч и предрелизные идентификаторы. Именно в
такой последовательности (сборочные метаданные не фигурируют в расчёте).
Приоритет определяется по первому отличию при сравнении каждого из этих
идентификаторов слева направо: Мажорная, минорная и патч-версия всегда
сравниваются численно. Пример: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Когда мажорная,
минорная и патч-версия равны, предрелизная версия имеет более низкий приоритет,
чем нормальная версия. Пример: 1.0.0-alpha < 1.0.0. Приоритет двух предрелизных
версий с одинаковыми мажорной, минорной и патч-версией ДОЛЖНЫ быть определены
сравнением каждого разделённого точкой идентификатора слева направо до тех пор,
пока различие не будет найдено следующим образом: идентификаторы, состоящие
только из цифр, сравниваются численно; буквенные идентификаторы или дефисы
сравниваются лексически в ASCII-порядке. Численные идентификаторы всегда имеют
низший приоритет, чем символьные. Больший набор предрелизных символов имеет
больший приоритет, чем меньший набор, если сравниваемые идентификаторы равны.
Пример: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Зачем использовать семантическое версионирование?

Это не новая или революционная идея. Вероятно, вы уже используете что-то
подобное. Проблема в том, что «подобное» — не достаточно хорошо. Без
соответствия формальной спецификации, номера версий практически бесполезны для
управления зависимостями. Ясно определив и сформулировав идею версионирования,
становится легче сообщать о намерениях пользователям вашего ПО. Когда эти
намерения ясны, гибки (но не слишком), спецификации зависимостей наконец могут
быть созданы.

Простой пример демонстрирует, как Семантическое Версионирование может сделать
«ад зависимостей» вещью из прошлого. Представим библиотеку, названную
«Firetruck». Она требует Семантически Версионированный пакет под названием
«Ladder». Когда Firetruck был создан, Ladder был 3.1.0 версии. Так как Firetruck
использует функциональности версии 3.1.0,  вы спокойно можете объявить зависимость от
Ladder версии 3.1.0, но менее чем 4.0.0. Теперь, когда доступен Ladder 3.1.1 и
3.2.0 версии, вы можете интегрировать его в вашу систему и знать, что он будет
совместим с текущей функциональностью.

Как ответственный разработчик, вы, конечно, хотите быть уверены, что все
обновления функционируют как заявлено. В реальном мире полный бардак и ничего
нельзя с этим поделать. Что вы можете сделать — это дать Семантическому
Версионированию предоставить способ выпуска релизов без выпуска новых версий
зависимых пакетов и сохранить вам время и нервы.

Если это звучит соблазнительно, всё что вам нужно — это начать использовать
Семантическое Версионирование, объявить, что вы его используете, и следовать
правилам. Добавьте ссылку на этот сайт в вашем README, тогда пользователи будут
знать правила и извлекать из этого пользу.

FAQ

Что я должен делать с ревизиями в 0.y.z на начальной стадии разработки?

Самое простое — начать разработку с 0.1.0 и затем увеличивать минорную версию
для каждого последующего релиза.

Как я узнаю, когда пора делать релиз 1.0.0?

Если ваше ПО используется на продакшене, оно, вероятно, уже должно быть версии
1.0.0. Если у вас стабильный API, от которого зависят пользователи, версия
должна быть 1.0.0. Если вы беспокоитесь за обратную совместимость, вероятно,
версия вашего ПО уже 1.0.0.

Не препятствует ли это быстрой разработке и коротким итерациям?

Мажорная версия 0 как раз и означает быструю разработку. Если вы изменяете API
каждый день, вы должны быть на версии 0.y.z или на отдельной ветке разработки
работать над следующей главной версией.

Даже если малейшие обратно несовместимые изменения в публичном API требуют выпуска новой главной версии, не закончится ли это тем, что очень скоро версия станет 42.0.0?

Это вопрос ответственной разработки и предвидения. Несовместимые изменения не
должны быть представлены как незначительные в ПО, имеющем много зависимого кода.
Стоимость обновления может быть велика. Практика увеличения главных версий
релизов с обратно несовместимыми изменениями означает, что вам придётся думать о
последствиях ваших изменений и учитывать соотношение цена/качество.

Документирование всего API — слишком много работы!

Это ваша ответственность, как профессионального разработчика, правильно
документировать ПО, предназначенное для широкого использования. Управление
сложностью ПО очень важная часть поддержки высокой эффективности проекта. Это
тяжело сделать, если никто не знает, как использовать ваше ПО или какой метод
можно вызывать безопасно. В долгосрочной перспективе Семантическое
Версионирование и настойчивость в качественном документировании публичного API
поможет всем и всему работать слаженно.

Что мне делать, если я случайно зарелизил обратно несовместимые изменения как минорную версию?

Как только вы поняли, что нарушили спецификации Семантического Версионирования,
исправьте проблему и выпустите новую минорную версию, которая исправляет
проблему и восстанавливает обратную совместимость. Даже в таких обстоятельствах
неприемлемо модифицировать уже выпущенные релизы. Если это необходимо, укажите в
документации о нарушении обратной совместимости, версионирования и
проинформируйте ваших пользователей, чтобы они знали о нарушении порядка версий.

Что я должен делать, если я обновляю свои собственные зависимости без изменения публичного API?

Это можно рассматривать как совместимые изменения, так как они не влияют на
публичный API. ПО, которое явно зависит от тех же зависимостей что и ваш пакет,
должно иметь собственные спецификации зависимостей и автор будет уведомлен о
возможных конфликтах. Являются ли данные изменения уровня патча или
минорного уровня, зависит от того, обновили ли вы свои зависимости чтобы
исправить баг или реализовать новую функциональность. В последнем случае, как правило,
добавляется некоторое количество дополнительного кода и как следствие,
увеличивается минорная версия.

Что если я нечаянно изменил публичный API в несоответствии с изменением номера версии (т.е. код содержит обратно несовместимые изменения в патч-релизе)?

На ваше усмотрение. Если у вас огромная аудитория, которая будет поставлена
перед фактом возвращения прежнего поведения API, то лучше выпустить новый релиз
с увеличением главной версии, даже несмотря на то, что фикс содержит исправления
уровня патча. Запомните, в Семантическом Версионировании номера версий
изменяются строго следуя спецификации. Если эти изменения важны для ваших
пользователей, используйте номер версии, чтобы информировать их.

Что делать с устаревшей функциональностью?

Объявление функциональности устаревшей — это обычное дело в ходе разработки и часто
необходимо для продвижения вперёд. Когда вы объявляете устаревшим часть
публичного API, вы должны сделать две вещи: (1) обновить вашу документацию,
чтобы дать пользователям узнать об этом изменении; (2) выпустить новый релиз с
увеличением минорной версии. Прежде чем вы полностью удалите устаревшую
функциональность в релизе с увеличением главной версии, должен быть как минимум один
минорный релиз, содержащий объявление функциональности устаревшим, чтобы
пользователи могли плавно перейти на новый API.

Есть ли в SemVer лимиты на длину строки версии?

Нет, но руководствуйтесь здравым смыслом. 255 символов в строке версии, пожалуй,
перебор. Кроме того, определенные системы могут предъявлять свои
собственные ограничения на размер строки.

Об авторе

Авторство спецификаций Семантического Версионирования принадлежит
Тому Престон-Вернеру, основателю Gravatars и
соучредителю GitHub.

Если вы хотите оставить отзыв, пожалуйста, создайте запрос на
GitHub.

Лицензия

Creative Commons — CC BY 3.0\nСемантическое Версионирование 2.0.0\nУчитывая номер версии МАЖОРНАЯ.МИНОРНАЯ.ПАТЧ, следует увеличивать:\nМАЖОРНУЮ версию, когда сделаны обратно несовместимые изменения API.\nМИНОРНУЮ версию, когда вы добавляете новую функциональность, не нарушая обратной
совместимости.\nПАТЧ-версию, когда вы делаете обратно совместимые исправления.\nДополнительные обозначения для предрелизных и билд-метаданных возможны как
дополнения к МАЖОРНАЯ.МИНОРНАЯ.ПАТЧ формату.\nВ мире управления процессом разработки есть понятие «ад зависимостей»
(dependency hell). Чем больше растёт ваша система и чем больше библиотек вы
интегрируете в ваш проект, тем больше вероятность оказаться в этой ситуации.\nВ системе с множественными зависимостями выпуск новой версии может быстро
превратиться в кошмар. Если спецификации зависимости слишком жесткие, вы
находитесь в опасности блокирования выпуска новой версии (невозможность
обновить пакет без необходимости выпуска новой версии каждой зависимой
библиотеки). Если спецификация зависимостей слишком свободна, вас неизбежно
настигнет версионное несоответствие (необоснованное предположение совместимости
с будущими версиями).\nВ качестве решения данной проблемы я предлагаю простой набор правил и
требований, которые определяют, как назначаются и увеличиваются номера версий.
Для того чтобы эта система работала, вам необходимо определить публичный API.
Он может быть описан в документации или определяться самим кодом. Главное,
чтобы этот API был ясным и точным. Однажды определив публичный API, вы
сообщаете об изменениях в нём особым увеличением номера версий. Рассмотрим
формат версий X.Y.Z (мажорная, минорная, патч). Баг-фиксы, не влияющие на
API, увеличивают патч-версию, обратно совместимые добавления/изменения API
увеличивают минорную версию и обратно несовместимые изменения API увеличивают
мажорную версию.\nЯ называю эту систему «Семантическое Версионирование» (Semantic Versioning). По
этой схеме номера версий и то, как они изменяются, передают смысл содержания
исходного кода и что было модифицировано от одной версии к другой.\nСпецификация Семантического Версионирования (SemVer)\nСлова «ДОЛЖЕН» (MUST), «НЕ ДОЛЖЕН» (MUST NOT), «ОБЯЗАТЕЛЬНО» (REQUIRED),
«СЛЕДУЕТ» (SHOULD), «НЕ СЛЕДУЕТ» (SHOULD NOT), «РЕКОМЕНДОВАННЫЙ» (RECOMMENDED),
«МОЖЕТ» (MAY) и «НЕОБЯЗАТЕЛЬНЫЙ» (OPTIONAL) в этом документе должны быть
интерпретированы в соответствии с RFC 2119.\nПО, использующее Семантическое Версионирование, должно объявить публичный
API. Этот API может быть объявлен самим кодом или существовать строго в
документации.  Как бы ни было это сделано, он должен быть точным и
исчерпывающим.\nПО, использующее Семантическое Версионирование, должно объявить публичный
API. Этот API может быть объявлен самим кодом или существовать строго в
документации.  Как бы ни было это сделано, он должен быть точным и
исчерпывающим.\nОбычный номер версии ДОЛЖЕН иметь формат X.Y.Z, где X, Y и Z — неотрицательные
целые числа и НЕ ДОЛЖНЫ начинаться с нуля. X — мажорная версия, Y — минорная
версия и Z — патч-версия. Каждый элемент ДОЛЖЕН увеличиваться численно.
Например: 1.9.0 ->1.10.0 -> 1.11.0.\nОбычный номер версии ДОЛЖЕН иметь формат X.Y.Z, где X, Y и Z — неотрицательные
целые числа и НЕ ДОЛЖНЫ начинаться с нуля. X — мажорная версия, Y — минорная
версия и Z — патч-версия. Каждый элемент ДОЛЖЕН увеличиваться численно.
Например: 1.9.0 ->1.10.0 -> 1.11.0.\nПосле релиза новой версии пакета содержание этой версии НЕ ДОЛЖНО быть
модифицировано. Любые изменения ДОЛЖНЫ быть выпущены как новая версия.\nПосле релиза новой версии пакета содержание этой версии НЕ ДОЛЖНО быть
модифицировано. Любые изменения ДОЛЖНЫ быть выпущены как новая версия.\nМажорная версия ноль (0.y.z) предназначена для начальной разработки. Всё
может измениться в любой момент. Публичный API не должен рассматриваться как
стабильный.\nМажорная версия ноль (0.y.z) предназначена для начальной разработки. Всё
может измениться в любой момент. Публичный API не должен рассматриваться как
стабильный.\nВерсия 1.0.0 определяет публичный API. После этого релиза номера версий
увеличиваются в зависимости от того, как изменяется публичный API.\nВерсия 1.0.0 определяет публичный API. После этого релиза номера версий
увеличиваются в зависимости от того, как изменяется публичный API.\nПатч-версия  Z (x.y.Z | x > 0) ДОЛЖНА быть увеличена только если содержит
обратно совместимые баг-фиксы. Определение баг-фикс означает внутренние
изменения, которые исправляют некорректное поведение.\nПатч-версия  Z (x.y.Z | x > 0) ДОЛЖНА быть увеличена только если содержит
обратно совместимые баг-фиксы. Определение баг-фикс означает внутренние
изменения, которые исправляют некорректное поведение.\nМинорная версия (x.Y.z | x > 0) ДОЛЖНА быть увеличена, если в публичном API
представлеа новая обратно совместимая функциональность. Она ДОЛЖНА быть увеличена,
если какая-либо функциональность публичного API помечена как устаревший (deprecated).
Версия МОЖЕТ быть увеличена в случае реализации новой функциональности или
существенного усовершенствования в приватном коде. Версия МОЖЕТ включать в себя
изменения, характерные для патчей. Патч-версия ДОЛЖНА быть обнулена, когда
увеличивается минорная версия.\nМинорная версия (x.Y.z | x > 0) ДОЛЖНА быть увеличена, если в публичном API
представлеа новая обратно совместимая функциональность. Она ДОЛЖНА быть увеличена,
если какая-либо функциональность публичного API помечена как устаревший (deprecated).
Версия МОЖЕТ быть увеличена в случае реализации новой функциональности или
существенного усовершенствования в приватном коде. Версия МОЖЕТ включать в себя
изменения, характерные для патчей. Патч-версия ДОЛЖНА быть обнулена, когда
увеличивается минорная версия.\nМажорная версия X (X.y.z | X > 0) ДОЛЖНА быть увеличена, если в публичном API
представлены какие-либо обратно несовместимые изменения. Она МОЖЕТ включать в
себя изменения, характерные для уровня минорных версий и патчей. Когда
увеличивается мажорная версия, минорная и патч-версия ДОЛЖНЫ быть обнулены.\nМажорная версия X (X.y.z | X > 0) ДОЛЖНА быть увеличена, если в публичном API
представлены какие-либо обратно несовместимые изменения. Она МОЖЕТ включать в
себя изменения, характерные для уровня минорных версий и патчей. Когда
увеличивается мажорная версия, минорная и патч-версия ДОЛЖНЫ быть обнулены.\nПредрелизная версия МОЖЕТ быть обозначена добавлением дефиса и серией
разделённых точкой идентификаторов, следующих сразу за патч-версией.
Идентификаторы ДОЛЖНЫ содержать только ASCII буквенно-цифровые символы и дефис
[0-9A-Za-z-]. Идентификаторы НЕ ДОЛЖНЫ быть пустыми. Числовые идентификаторы
НЕ ДОЛЖНЫ начинаться с нуля. Предрелизные версии имеют более низкий приоритет,
чем соответствующая релизная версия. Предрелизная версия указывает на то, что
эта версия не стабильна и может не удовлетворять требованиям совместимости,
обозначенными соответствующей нормальной версией. Примеры: 1.0.0-alpha,
1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nПредрелизная версия МОЖЕТ быть обозначена добавлением дефиса и серией
разделённых точкой идентификаторов, следующих сразу за патч-версией.
Идентификаторы ДОЛЖНЫ содержать только ASCII буквенно-цифровые символы и дефис
[0-9A-Za-z-]. Идентификаторы НЕ ДОЛЖНЫ быть пустыми. Числовые идентификаторы
НЕ ДОЛЖНЫ начинаться с нуля. Предрелизные версии имеют более низкий приоритет,
чем соответствующая релизная версия. Предрелизная версия указывает на то, что
эта версия не стабильна и может не удовлетворять требованиям совместимости,
обозначенными соответствующей нормальной версией. Примеры: 1.0.0-alpha,
1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nСборочные метаданные МОГУТ быть обозначены добавлением знака плюс и ряда
разделённых точкой идентификаторов, следующих сразу за патчем или предрелизной
версией. Идентификаторы ДОЛЖНЫ содержать только ASCII буквенно-цифровые символы
и дефис [0-9A-Za-z-]. Идентификаторы НЕ ДОЛЖНЫ быть пустыми. Сборочные
метаданные СЛЕДУЕТ игнорировать, когда определяется старшинство версий. Поэтому
два пакета с одинаковой версией, но разными сборочными метаданными,
рассматриваются как одна и та же версия. Примеры: 1.0.0-alpha+001,
1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nСборочные метаданные МОГУТ быть обозначены добавлением знака плюс и ряда
разделённых точкой идентификаторов, следующих сразу за патчем или предрелизной
версией. Идентификаторы ДОЛЖНЫ содержать только ASCII буквенно-цифровые символы
и дефис [0-9A-Za-z-]. Идентификаторы НЕ ДОЛЖНЫ быть пустыми. Сборочные
метаданные СЛЕДУЕТ игнорировать, когда определяется старшинство версий. Поэтому
два пакета с одинаковой версией, но разными сборочными метаданными,
рассматриваются как одна и та же версия. Примеры: 1.0.0-alpha+001,
1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nПриоритет определяет, как версии соотносятся друг с другом, когда
упорядочиваются. Приоритет версий ДОЛЖЕН рассчитываться путём разделения номеров
версий на мажорную, минорную, патч и предрелизные идентификаторы. Именно в
такой последовательности (сборочные метаданные не фигурируют в расчёте).
Приоритет определяется по первому отличию при сравнении каждого из этих
идентификаторов слева направо: Мажорная, минорная и патч-версия всегда
сравниваются численно. Пример: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Когда мажорная,
минорная и патч-версия равны, предрелизная версия имеет более низкий приоритет,
чем нормальная версия. Пример: 1.0.0-alpha < 1.0.0. Приоритет двух предрелизных
версий с одинаковыми мажорной, минорной и патч-версией ДОЛЖНЫ быть определены
сравнением каждого разделённого точкой идентификатора слева направо до тех пор,
пока различие не будет найдено следующим образом: идентификаторы, состоящие
только из цифр, сравниваются численно; буквенные идентификаторы или дефисы
сравниваются лексически в ASCII-порядке. Численные идентификаторы всегда имеют
низший приоритет, чем символьные. Больший набор предрелизных символов имеет
больший приоритет, чем меньший набор, если сравниваемые идентификаторы равны.
Пример: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nПриоритет определяет, как версии соотносятся друг с другом, когда
упорядочиваются. Приоритет версий ДОЛЖЕН рассчитываться путём разделения номеров
версий на мажорную, минорную, патч и предрелизные идентификаторы. Именно в
такой последовательности (сборочные метаданные не фигурируют в расчёте).
Приоритет определяется по первому отличию при сравнении каждого из этих
идентификаторов слева направо: Мажорная, минорная и патч-версия всегда
сравниваются численно. Пример: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Когда мажорная,
минорная и патч-версия равны, предрелизная версия имеет более низкий приоритет,
чем нормальная версия. Пример: 1.0.0-alpha < 1.0.0. Приоритет двух предрелизных
версий с одинаковыми мажорной, минорной и патч-версией ДОЛЖНЫ быть определены
сравнением каждого разделённого точкой идентификатора слева направо до тех пор,
пока различие не будет найдено следующим образом: идентификаторы, состоящие
только из цифр, сравниваются численно; буквенные идентификаторы или дефисы
сравниваются лексически в ASCII-порядке. Численные идентификаторы всегда имеют
низший приоритет, чем символьные. Больший набор предрелизных символов имеет
больший приоритет, чем меньший набор, если сравниваемые идентификаторы равны.
Пример: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nЗачем использовать семантическое версионирование?\nЭто не новая или революционная идея. Вероятно, вы уже используете что-то
подобное. Проблема в том, что «подобное» — не достаточно хорошо. Без
соответствия формальной спецификации, номера версий практически бесполезны для
управления зависимостями. Ясно определив и сформулировав идею версионирования,
становится легче сообщать о намерениях пользователям вашего ПО. Когда эти
намерения ясны, гибки (но не слишком), спецификации зависимостей наконец могут
быть созданы.\nПростой пример демонстрирует, как Семантическое Версионирование может сделать
«ад зависимостей» вещью из прошлого. Представим библиотеку, названную
«Firetruck». Она требует Семантически Версионированный пакет под названием
«Ladder». Когда Firetruck был создан, Ladder был 3.1.0 версии. Так как Firetruck
использует функциональности версии 3.1.0,  вы спокойно можете объявить зависимость от
Ladder версии 3.1.0, но менее чем 4.0.0. Теперь, когда доступен Ladder 3.1.1 и
3.2.0 версии, вы можете интегрировать его в вашу систему и знать, что он будет
совместим с текущей функциональностью.\nКак ответственный разработчик, вы, конечно, хотите быть уверены, что все
обновления функционируют как заявлено. В реальном мире полный бардак и ничего
нельзя с этим поделать. Что вы можете сделать — это дать Семантическому
Версионированию предоставить способ выпуска релизов без выпуска новых версий
зависимых пакетов и сохранить вам время и нервы.\nЕсли это звучит соблазнительно, всё что вам нужно — это начать использовать
Семантическое Версионирование, объявить, что вы его используете, и следовать
правилам. Добавьте ссылку на этот сайт в вашем README, тогда пользователи будут
знать правила и извлекать из этого пользу.\nЧто я должен делать с ревизиями в 0.y.z на начальной стадии разработки?\nСамое простое — начать разработку с 0.1.0 и затем увеличивать минорную версию
для каждого последующего релиза.\nКак я узнаю, когда пора делать релиз 1.0.0?\nЕсли ваше ПО используется на продакшене, оно, вероятно, уже должно быть версии
1.0.0. Если у вас стабильный API, от которого зависят пользователи, версия
должна быть 1.0.0. Если вы беспокоитесь за обратную совместимость, вероятно,
версия вашего ПО уже 1.0.0.\nНе препятствует ли это быстрой разработке и коротким итерациям?\nМажорная версия 0 как раз и означает быструю разработку. Если вы изменяете API
каждый день, вы должны быть на версии 0.y.z или на отдельной ветке разработки
работать над следующей главной версией.\nДаже если малейшие обратно несовместимые изменения в публичном API требуют выпуска новой главной версии, не закончится ли это тем, что очень скоро версия станет 42.0.0?\nЭто вопрос ответственной разработки и предвидения. Несовместимые изменения не
должны быть представлены как незначительные в ПО, имеющем много зависимого кода.
Стоимость обновления может быть велика. Практика увеличения главных версий
релизов с обратно несовместимыми изменениями означает, что вам придётся думать о
последствиях ваших изменений и учитывать соотношение цена/качество.\nДокументирование всего API — слишком много работы!\nЭто ваша ответственность, как профессионального разработчика, правильно
документировать ПО, предназначенное для широкого использования. Управление
сложностью ПО очень важная часть поддержки высокой эффективности проекта. Это
тяжело сделать, если никто не знает, как использовать ваше ПО или какой метод
можно вызывать безопасно. В долгосрочной перспективе Семантическое
Версионирование и настойчивость в качественном документировании публичного API
поможет всем и всему работать слаженно.\nЧто мне делать, если я случайно зарелизил обратно несовместимые изменения как минорную версию?\nКак только вы поняли, что нарушили спецификации Семантического Версионирования,
исправьте проблему и выпустите новую минорную версию, которая исправляет
проблему и восстанавливает обратную совместимость. Даже в таких обстоятельствах
неприемлемо модифицировать уже выпущенные релизы. Если это необходимо, укажите в
документации о нарушении обратной совместимости, версионирования и
проинформируйте ваших пользователей, чтобы они знали о нарушении порядка версий.\nЧто я должен делать, если я обновляю свои собственные зависимости без изменения публичного API?\nЭто можно рассматривать как совместимые изменения, так как они не влияют на
публичный API. ПО, которое явно зависит от тех же зависимостей что и ваш пакет,
должно иметь собственные спецификации зависимостей и автор будет уведомлен о
возможных конфликтах. Являются ли данные изменения уровня патча или
минорного уровня, зависит от того, обновили ли вы свои зависимости чтобы
исправить баг или реализовать новую функциональность. В последнем случае, как правило,
добавляется некоторое количество дополнительного кода и как следствие,
увеличивается минорная версия.\nЧто если я нечаянно изменил публичный API в несоответствии с изменением номера версии (т.е. код содержит обратно несовместимые изменения в патч-релизе)?\nНа ваше усмотрение. Если у вас огромная аудитория, которая будет поставлена
перед фактом возвращения прежнего поведения API, то лучше выпустить новый релиз
с увеличением главной версии, даже несмотря на то, что фикс содержит исправления
уровня патча. Запомните, в Семантическом Версионировании номера версий
изменяются строго следуя спецификации. Если эти изменения важны для ваших
пользователей, используйте номер версии, чтобы информировать их.\nЧто делать с устаревшей функциональностью?\nОбъявление функциональности устаревшей — это обычное дело в ходе разработки и часто
необходимо для продвижения вперёд. Когда вы объявляете устаревшим часть
публичного API, вы должны сделать две вещи: (1) обновить вашу документацию,
чтобы дать пользователям узнать об этом изменении; (2) выпустить новый релиз с
увеличением минорной версии. Прежде чем вы полностью удалите устаревшую
функциональность в релизе с увеличением главной версии, должен быть как минимум один
минорный релиз, содержащий объявление функциональности устаревшим, чтобы
пользователи могли плавно перейти на новый API.\nЕсть ли в SemVer лимиты на длину строки версии?\nНет, но руководствуйтесь здравым смыслом. 255 символов в строке версии, пожалуй,
перебор. Кроме того, определенные системы могут предъявлять свои
собственные ограничения на размер строки.\nАвторство спецификаций Семантического Версионирования принадлежит
Тому Престон-Вернеру, основателю Gravatars и
соучредителю GitHub.\nЕсли вы хотите оставить отзыв, пожалуйста, создайте запрос на
GitHub.\nсоздайте запрос на
GitHub\nCreative Commons — CC BY 3.0\nCreative Commons — CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nСемантическое Версионирование 2.0.0-rc.2

В мире управления процессом разработки есть понятие «ад зависимостей»
(dependency hell). Чем больше растёт ваша система и чем больше библиотек вы
интегрируете в ваш проект, тем больше вероятность оказаться в этой ситуации.

В системе с множественными зависимостями выпуск новой версии может быстро
превратиться в кошмар. Если спецификации зависимости слишком жесткие, вы
находитесь в опасности блокирования выпуска новой версии (невозможность
обновить пакет без необходимости выпуска новой версии каждой зависимой
библиотеки). Если спецификация зависимостей слишком свободна, вас неизбежно
настигнет версионное несоответствие (необоснованное предположение совместимости
с будущими версиями).

В качестве решения данной проблемы я предлагаю простой набор правил и
требований, которые определяют, как назначаются и увеличиваются номера версий.
Для того чтобы эта система работала, вам необходимо определить публичный API.
Он может быть описан в документации или определяться самим кодом. Главное,
чтобы это API было ясным и точным. Однажды определив публичное API, вы
сообщаете об изменениях в нём особым увеличением номера версий. Рассмотрим
формат версий X.Y.Z (главная, второстепенная, патч). Баг-фиксы, не влияющие на
API, увеличивают патч версию, обратно совместимые добавления/изменения API
увеличивают второстепенную версию и обратно несовместимые изменения API
увеличивают главную версию.

Я называю эту систему «Семантическое Версионирование» (Semantic Versioning). По
этой схеме номера версий и то, как они изменяются, передают смысл содержания
исходного кода и что было модифицировано от одной версии к другой.

Спецификация Семантического Версионирования (SemVer)

Слова «ДОЛЖЕН» (MUST), «НЕ ДОЛЖЕН» (MUST NOT), «ОБЯЗАТЕЛЬНО» (REQUIRED),
«СЛЕДУЕТ» (SHOULD), «НЕ СЛЕДУЕТ» (SHOULD NOT), «РЕКОМЕНДОВАННЫЙ» (RECOMMENDED),
«МОЖЕТ» (MAY) и «НЕОБЯЗАТЕЛЬНЫЙ» (OPTIONAL) в этом документе должны быть
интерпретированы в соответствии с RFC 2119.


  
    ПО, использующее Семантическое Версионирование, должно объявить публичное
API. Это API может быть объявлено самим кодом или существовать строго в
документации.  Как бы ни было это сделано, оно должно быть точным и
исчерпывающим.
  
  
    Обычный номер версии ДОЛЖЕН иметь формат X.Y.Z, где X, Y и Z — положительные
целые числа. X — главная версия, Y — второстепенная версия и Z — патч-версия.
Каждый элемент ДОЛЖЕН численно увеличиваться на единицу. Например: 1.9.0 ->
1.10.0 -> 1.11.0.
  
  
    После релиза новой версии пакета содержание этой версии НЕ ДОЛЖНО быть
модифицировано. Любые изменения ДОЛЖНЫ быть выпущены как новая версия.
  
  
    Главная версия ноль (0.y.z) предназначена для начальной разработки. Всё может
измениться в любой момент. Публичное API не должно рассматриваться как
стабильное.
  
  
    Версия 1.0.0 определяет публичное API. После этого релиза номера версий
увеличиваются в зависимости от того, как изменяется публичное API.
  
  
    Патч-версия  Z (x.y.Z | x > 0) ДОЛЖНА быть увеличена только если содержит
обратно совместимые баг-фиксы. Определение баг-фикс означает внутренние
изменения, которые исправляют некорректное поведение.
  
  
    Второстепенная версия (x.Y.z | x > 0) ДОЛЖНА быть увеличена, если новая
обратно совместимая функциональность представлена в публичном API.  Версия ДОЛЖНА быть
увеличена, если какая-либо функциональность публичного API помечена как устаревшая
(deprecated). Версия МОЖЕТ быть увеличена в случае реализации новой функциональности
или существенного усовершенствования в приватном коде. Версия МОЖЕТ включать в себя
изменения, характерные для патчей. Патч-версия ДОЛЖНА быть обнулена, когда
увеличивается второстепенная версия.
  
  
    Главная версия X (X.y.z | X > 0) ДОЛЖНА быть увеличена, если в публичном API
представлены какие-либо обратно несовместимые изменения. Она МОЖЕТ включать в
себя изменения, характерные для уровня второстепенных версий и патчей. Когда
увеличивается главная версия, второстепенная и патч-версия ДОЛЖНЫ быть обнулены.
  
  
    Предрелизная версия МОЖЕТ быть обозначена добавлением дефиса и серией
разделённых точкой идентификаторов, следующих сразу за патч-версией.
Идентификаторы ДОЛЖНЫ содержать только латинские буквы, цифры и дефис
[0-9A-Za-z-]. Предрелизные версии имеют более низкий приоритет, чем
соответствующая релизная версия. Примеры: 1.0.0-alpha, 1.0.0-alpha.1,
1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Сборочные мета-данные МОГУТ быть обозначены добавлением знака плюс и ряда
разделённых точкой идентификаторов, следующих сразу за патчем или предрелизной
версией. Идентификаторы ДОЛЖНЫ содержать только латинские буквы, номера и дефис
[0-9A-Za-z-]. Сборочные мета-данные СЛЕДУЕТ игнорировать, когда определяется
старшинство версий. Поэтому два пакета с одинаковой версией, но разными
сборочными мета-данными, рассматриваются как одна и та же версия. Примеры:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    Старшинство ДОЛЖНО рассчитываться путём разделения версии на главную,
второстепенную, патч и предрелизные идентификаторы. Именно в перечисленном
порядке (Сборочные мета-данные не фигурируют в расчёте старшинства). Главная,
второстепенная и патч-версии всегда сравниваются численно. Старшинство
предрелизных версий ДОЛЖНО быть определено сравнением наборов идентификаторов,
разделённых точкой следующим образом: идентификаторы, состоящие только из цифр,
сравниваются численно, буквенные идентификаторы или дефисы сравниваются
лексически в ASCII-порядке. Численные идентификаторы всегда имеют низший
приоритет, чем символьные. Примеры: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta.2
< 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Зачем использовать семантическое версионирование?

Это не новая или революционная идея. Вероятно, вы уже используете что-то
подобное. Проблема в том, что «подобное» — не достаточно хорошо. Без
соответствия формальной спецификации, номера версий практически бесполезны для
управления зависимостями. Ясно определив и сформулировав идею версионирования,
становится легче сообщать о намерениях пользователям вашего ПО. Когда эти
намерения ясны, гибки (но не слишком), спецификации зависимостей наконец могут
быть созданы.

Простой пример демонстрирует, как Семантическое Версионирование может сделать
«ад зависимостей» вещью из прошлого. Представим библиотеку, названную
«Firetruck». Она требует Семантически Версионированный пакет под названием
«Ladder». Когда Firetruck был создан, Ladder был 3.1.0 версии. Так как Firetruck
использует функциональность версии 3.1.0,  вы спокойно можете объявить зависимость от
Ladder версии 3.1.0, но менее чем 4.0.0. Теперь, когда доступен Ladder 3.1.1 и
3.2.0 версии, вы можете интегрировать его в вашу систему и знать, что он будет
совместим с текущей функциональностью.

Как ответственный разработчик, вы, конечно, хотите быть уверены, что все
обновления функционируют как заявлено. В реальном мире полный бардак и ничего
нельзя с этим поделать. Что вы можете сделать — это дать Семантическому
Версионированию предоставить способ выпуска релизов без выпуска новых версий
зависимых пакетов и сохранить вам время и нервы.

Если это звучит соблазнительно, всё что вам нужно — это начать использовать
Семантическое Версионирование, объявить, что вы его используете, и следовать
правилам. Добавьте ссылку на этот сайт в вашем README, тогда пользователи будут
знать правила и извлекать из этого пользу.

FAQ

Что я должен делать с ревизиями в 0.y.z на начальной стадии разработки?

Самое простое — начать разработку с 0.1.0 и затем увеличивать второстепенную
версию для каждого последующего релиза.

Как я узнаю, когда пора делать релиз 1.0.0?

Если ваше ПО используется на продакшене, оно, вероятно, уже должно быть версии
1.0.0. Если у вас стабильное API, от которого зависят пользователи, версия
должна быть 1.0.0. Если вы беспокоитесь за обратную совместимость, вероятно,
версия вашего ПО уже 1.0.0.

Не препятствует ли это быстрой разработке и коротким итерациям?

Главная версия 0 как раз и означает быструю разработку. Если вы изменяете API
каждый день, вы должны быть на версии 0.y.z или на отдельной ветке разработки
работать над следующей главной версией.

Даже если малейшие обратно несовместимые изменения в публичном API требуют
выпуска новой главной версии, не закончится ли это тем, что очень скоро версия
станет 42.0.0?

Это вопрос ответственной разработки и предвидения. Несовместимые изменения не
должны быть представлены как незначительные в ПО, имеющем много зависимого кода.
Стоимость обновления может быть велика. Практика увеличения главных версий
релизов с обратно несовместимыми изменениями означает, что вам придётся думать о
последствиях ваших изменений и учитывать соотношение цена/качество.

Документирование всего API — слишком много работы!

Это ваша ответственность, как профессионального разработчика, правильно
документировать ПО, предназначенное для широкого использования. Управление
сложностью ПО очень важная часть поддержки высокой эффективности проекта. Это
тяжело сделать, если никто не знает, как использовать ваше ПО или какой метод
можно вызывать безопасно. В долгосрочной перспективе Семантическое
Версионирование и настойчивость в качественном документировании публичного API
поможет всем и всему работать слаженно.

Что мне делать, если я случайно зарелизил обратно несовместимые изменения как второстепенную версию?

Как только вы поняли, что нарушили спецификации Семантического Версионирования,
исправьте проблему и выпустите новую второстепенную версию, которая исправляет
проблему и восстанавливает обратную совместимость. Даже в таких обстоятельствах
неприемлемо модифицировать уже выпущенные релизы. Если это необходимо, укажите в
документации о нарушении обратной совместимости, версионирования и
проинформируйте ваших пользователей, чтобы они знали о нарушении порядка версий.

Что я должен делать, если я обновляю свои собственные зависимости без изменения публичного API?

Это можно рассматривать как совместимые изменения, так как они не влияют на
публичное API. ПО, которое явно зависит от тех же зависимостей что и ваш пакет,
должно иметь собственные спецификации зависимостей и автор будет уведомлен о
возможных конфликтах. Являются ли данные изменения уровня патча или
второстепенного уровня, зависит от того, обновили ли вы свои зависимости чтобы
исправить баг или реализовать новую функциональность. В последнем случае, как правило,
добавляется некоторое количество дополнительного кода и как следствие,
увеличивается второстепенная версия.

Что я должен делать, если исправление бага вернуло код в состояние совместимости с публичным API (т.е. появилось расхождение в документации публичного API и кодом)?

На ваше усмотрение. Если у вас огромная аудитория, которая будет поставлена
перед фактом возвращения прежнего поведения API, то лучше выпустить новый релиз
с увеличением главной версии, даже несмотря на то, что фикс содержит исправления
уровня патча. Запомните, в Семантическом Версионировании номера версий
изменяются строго следуя спецификации. Если эти изменения важны для ваших
пользователей, используйте номер версии, чтобы информировать их.

Что делать с устаревшей функциональностью?

Объявление функциональности устаревшей — это обычное дело в ходе разработки и часто
необходимо для продвижения вперёд. Когда вы объявляете устаревшим часть
публичного API, вы должны сделать две вещи: (1) обновить вашу документацию,
чтобы дать пользователям узнать об этом изменении; (2) выпустить новый релиз с
увеличением второстепенной версии. Прежде чем вы полностью удалите устаревшую
функциональность в релизе с увеличением главной версии, должен быть как минимум один
второстепенный релиз, содержащий объявление функциональности устаревшей, чтобы
пользователи могли плавно перейти на новый API.

Об авторе

Авторство спецификаций Семантического Версионирования принадлежит
Тому Престон-Вернеру, основателю Gravatars и
соучредителю GitHub.

Если вы хотите оставить отзыв, пожалуйста, создайте запрос на
GitHub.

Лицензия

Creative Commons — CC BY 3.0
http://creativecommons.org/licenses/by/3.0/\nСемантическое Версионирование 2.0.0-rc.2\nВ мире управления процессом разработки есть понятие «ад зависимостей»
(dependency hell). Чем больше растёт ваша система и чем больше библиотек вы
интегрируете в ваш проект, тем больше вероятность оказаться в этой ситуации.\nВ системе с множественными зависимостями выпуск новой версии может быстро
превратиться в кошмар. Если спецификации зависимости слишком жесткие, вы
находитесь в опасности блокирования выпуска новой версии (невозможность
обновить пакет без необходимости выпуска новой версии каждой зависимой
библиотеки). Если спецификация зависимостей слишком свободна, вас неизбежно
настигнет версионное несоответствие (необоснованное предположение совместимости
с будущими версиями).\nВ качестве решения данной проблемы я предлагаю простой набор правил и
требований, которые определяют, как назначаются и увеличиваются номера версий.
Для того чтобы эта система работала, вам необходимо определить публичный API.
Он может быть описан в документации или определяться самим кодом. Главное,
чтобы это API было ясным и точным. Однажды определив публичное API, вы
сообщаете об изменениях в нём особым увеличением номера версий. Рассмотрим
формат версий X.Y.Z (главная, второстепенная, патч). Баг-фиксы, не влияющие на
API, увеличивают патч версию, обратно совместимые добавления/изменения API
увеличивают второстепенную версию и обратно несовместимые изменения API
увеличивают главную версию.\nЯ называю эту систему «Семантическое Версионирование» (Semantic Versioning). По
этой схеме номера версий и то, как они изменяются, передают смысл содержания
исходного кода и что было модифицировано от одной версии к другой.\nСпецификация Семантического Версионирования (SemVer)\nСлова «ДОЛЖЕН» (MUST), «НЕ ДОЛЖЕН» (MUST NOT), «ОБЯЗАТЕЛЬНО» (REQUIRED),
«СЛЕДУЕТ» (SHOULD), «НЕ СЛЕДУЕТ» (SHOULD NOT), «РЕКОМЕНДОВАННЫЙ» (RECOMMENDED),
«МОЖЕТ» (MAY) и «НЕОБЯЗАТЕЛЬНЫЙ» (OPTIONAL) в этом документе должны быть
интерпретированы в соответствии с RFC 2119.\nПО, использующее Семантическое Версионирование, должно объявить публичное
API. Это API может быть объявлено самим кодом или существовать строго в
документации.  Как бы ни было это сделано, оно должно быть точным и
исчерпывающим.\nПО, использующее Семантическое Версионирование, должно объявить публичное
API. Это API может быть объявлено самим кодом или существовать строго в
документации.  Как бы ни было это сделано, оно должно быть точным и
исчерпывающим.\nОбычный номер версии ДОЛЖЕН иметь формат X.Y.Z, где X, Y и Z — положительные
целые числа. X — главная версия, Y — второстепенная версия и Z — патч-версия.
Каждый элемент ДОЛЖЕН численно увеличиваться на единицу. Например: 1.9.0 ->
1.10.0 -> 1.11.0.\nОбычный номер версии ДОЛЖЕН иметь формат X.Y.Z, где X, Y и Z — положительные
целые числа. X — главная версия, Y — второстепенная версия и Z — патч-версия.
Каждый элемент ДОЛЖЕН численно увеличиваться на единицу. Например: 1.9.0 ->
1.10.0 -> 1.11.0.\nПосле релиза новой версии пакета содержание этой версии НЕ ДОЛЖНО быть
модифицировано. Любые изменения ДОЛЖНЫ быть выпущены как новая версия.\nПосле релиза новой версии пакета содержание этой версии НЕ ДОЛЖНО быть
модифицировано. Любые изменения ДОЛЖНЫ быть выпущены как новая версия.\nГлавная версия ноль (0.y.z) предназначена для начальной разработки. Всё может
измениться в любой момент. Публичное API не должно рассматриваться как
стабильное.\nГлавная версия ноль (0.y.z) предназначена для начальной разработки. Всё может
измениться в любой момент. Публичное API не должно рассматриваться как
стабильное.\nВерсия 1.0.0 определяет публичное API. После этого релиза номера версий
увеличиваются в зависимости от того, как изменяется публичное API.\nВерсия 1.0.0 определяет публичное API. После этого релиза номера версий
увеличиваются в зависимости от того, как изменяется публичное API.\nПатч-версия  Z (x.y.Z | x > 0) ДОЛЖНА быть увеличена только если содержит
обратно совместимые баг-фиксы. Определение баг-фикс означает внутренние
изменения, которые исправляют некорректное поведение.\nПатч-версия  Z (x.y.Z | x > 0) ДОЛЖНА быть увеличена только если содержит
обратно совместимые баг-фиксы. Определение баг-фикс означает внутренние
изменения, которые исправляют некорректное поведение.\nВторостепенная версия (x.Y.z | x > 0) ДОЛЖНА быть увеличена, если новая
обратно совместимая функциональность представлена в публичном API.  Версия ДОЛЖНА быть
увеличена, если какая-либо функциональность публичного API помечена как устаревшая
(deprecated). Версия МОЖЕТ быть увеличена в случае реализации новой функциональности
или существенного усовершенствования в приватном коде. Версия МОЖЕТ включать в себя
изменения, характерные для патчей. Патч-версия ДОЛЖНА быть обнулена, когда
увеличивается второстепенная версия.\nВторостепенная версия (x.Y.z | x > 0) ДОЛЖНА быть увеличена, если новая
обратно совместимая функциональность представлена в публичном API.  Версия ДОЛЖНА быть
увеличена, если какая-либо функциональность публичного API помечена как устаревшая
(deprecated). Версия МОЖЕТ быть увеличена в случае реализации новой функциональности
или существенного усовершенствования в приватном коде. Версия МОЖЕТ включать в себя
изменения, характерные для патчей. Патч-версия ДОЛЖНА быть обнулена, когда
увеличивается второстепенная версия.\nГлавная версия X (X.y.z | X > 0) ДОЛЖНА быть увеличена, если в публичном API
представлены какие-либо обратно несовместимые изменения. Она МОЖЕТ включать в
себя изменения, характерные для уровня второстепенных версий и патчей. Когда
увеличивается главная версия, второстепенная и патч-версия ДОЛЖНЫ быть обнулены.\nГлавная версия X (X.y.z | X > 0) ДОЛЖНА быть увеличена, если в публичном API
представлены какие-либо обратно несовместимые изменения. Она МОЖЕТ включать в
себя изменения, характерные для уровня второстепенных версий и патчей. Когда
увеличивается главная версия, второстепенная и патч-версия ДОЛЖНЫ быть обнулены.\nПредрелизная версия МОЖЕТ быть обозначена добавлением дефиса и серией
разделённых точкой идентификаторов, следующих сразу за патч-версией.
Идентификаторы ДОЛЖНЫ содержать только латинские буквы, цифры и дефис
[0-9A-Za-z-]. Предрелизные версии имеют более низкий приоритет, чем
соответствующая релизная версия. Примеры: 1.0.0-alpha, 1.0.0-alpha.1,
1.0.0-0.3.7, 1.0.0-x.7.z.92.\nПредрелизная версия МОЖЕТ быть обозначена добавлением дефиса и серией
разделённых точкой идентификаторов, следующих сразу за патч-версией.
Идентификаторы ДОЛЖНЫ содержать только латинские буквы, цифры и дефис
[0-9A-Za-z-]. Предрелизные версии имеют более низкий приоритет, чем
соответствующая релизная версия. Примеры: 1.0.0-alpha, 1.0.0-alpha.1,
1.0.0-0.3.7, 1.0.0-x.7.z.92.\nСборочные мета-данные МОГУТ быть обозначены добавлением знака плюс и ряда
разделённых точкой идентификаторов, следующих сразу за патчем или предрелизной
версией. Идентификаторы ДОЛЖНЫ содержать только латинские буквы, номера и дефис
[0-9A-Za-z-]. Сборочные мета-данные СЛЕДУЕТ игнорировать, когда определяется
старшинство версий. Поэтому два пакета с одинаковой версией, но разными
сборочными мета-данными, рассматриваются как одна и та же версия. Примеры:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nСборочные мета-данные МОГУТ быть обозначены добавлением знака плюс и ряда
разделённых точкой идентификаторов, следующих сразу за патчем или предрелизной
версией. Идентификаторы ДОЛЖНЫ содержать только латинские буквы, номера и дефис
[0-9A-Za-z-]. Сборочные мета-данные СЛЕДУЕТ игнорировать, когда определяется
старшинство версий. Поэтому два пакета с одинаковой версией, но разными
сборочными мета-данными, рассматриваются как одна и та же версия. Примеры:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nСтаршинство ДОЛЖНО рассчитываться путём разделения версии на главную,
второстепенную, патч и предрелизные идентификаторы. Именно в перечисленном
порядке (Сборочные мета-данные не фигурируют в расчёте старшинства). Главная,
второстепенная и патч-версии всегда сравниваются численно. Старшинство
предрелизных версий ДОЛЖНО быть определено сравнением наборов идентификаторов,
разделённых точкой следующим образом: идентификаторы, состоящие только из цифр,
сравниваются численно, буквенные идентификаторы или дефисы сравниваются
лексически в ASCII-порядке. Численные идентификаторы всегда имеют низший
приоритет, чем символьные. Примеры: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta.2
< 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nСтаршинство ДОЛЖНО рассчитываться путём разделения версии на главную,
второстепенную, патч и предрелизные идентификаторы. Именно в перечисленном
порядке (Сборочные мета-данные не фигурируют в расчёте старшинства). Главная,
второстепенная и патч-версии всегда сравниваются численно. Старшинство
предрелизных версий ДОЛЖНО быть определено сравнением наборов идентификаторов,
разделённых точкой следующим образом: идентификаторы, состоящие только из цифр,
сравниваются численно, буквенные идентификаторы или дефисы сравниваются
лексически в ASCII-порядке. Численные идентификаторы всегда имеют низший
приоритет, чем символьные. Примеры: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-beta.2
< 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nЗачем использовать семантическое версионирование?\nЭто не новая или революционная идея. Вероятно, вы уже используете что-то
подобное. Проблема в том, что «подобное» — не достаточно хорошо. Без
соответствия формальной спецификации, номера версий практически бесполезны для
управления зависимостями. Ясно определив и сформулировав идею версионирования,
становится легче сообщать о намерениях пользователям вашего ПО. Когда эти
намерения ясны, гибки (но не слишком), спецификации зависимостей наконец могут
быть созданы.\nПростой пример демонстрирует, как Семантическое Версионирование может сделать
«ад зависимостей» вещью из прошлого. Представим библиотеку, названную
«Firetruck». Она требует Семантически Версионированный пакет под названием
«Ladder». Когда Firetruck был создан, Ladder был 3.1.0 версии. Так как Firetruck
использует функциональность версии 3.1.0,  вы спокойно можете объявить зависимость от
Ladder версии 3.1.0, но менее чем 4.0.0. Теперь, когда доступен Ladder 3.1.1 и
3.2.0 версии, вы можете интегрировать его в вашу систему и знать, что он будет
совместим с текущей функциональностью.\nКак ответственный разработчик, вы, конечно, хотите быть уверены, что все
обновления функционируют как заявлено. В реальном мире полный бардак и ничего
нельзя с этим поделать. Что вы можете сделать — это дать Семантическому
Версионированию предоставить способ выпуска релизов без выпуска новых версий
зависимых пакетов и сохранить вам время и нервы.\nЕсли это звучит соблазнительно, всё что вам нужно — это начать использовать
Семантическое Версионирование, объявить, что вы его используете, и следовать
правилам. Добавьте ссылку на этот сайт в вашем README, тогда пользователи будут
знать правила и извлекать из этого пользу.\nЧто я должен делать с ревизиями в 0.y.z на начальной стадии разработки?\nСамое простое — начать разработку с 0.1.0 и затем увеличивать второстепенную
версию для каждого последующего релиза.\nКак я узнаю, когда пора делать релиз 1.0.0?\nЕсли ваше ПО используется на продакшене, оно, вероятно, уже должно быть версии
1.0.0. Если у вас стабильное API, от которого зависят пользователи, версия
должна быть 1.0.0. Если вы беспокоитесь за обратную совместимость, вероятно,
версия вашего ПО уже 1.0.0.\nНе препятствует ли это быстрой разработке и коротким итерациям?\nГлавная версия 0 как раз и означает быструю разработку. Если вы изменяете API
каждый день, вы должны быть на версии 0.y.z или на отдельной ветке разработки
работать над следующей главной версией.\nДаже если малейшие обратно несовместимые изменения в публичном API требуют\nвыпуска новой главной версии, не закончится ли это тем, что очень скоро версия
станет 42.0.0?\nЭто вопрос ответственной разработки и предвидения. Несовместимые изменения не
должны быть представлены как незначительные в ПО, имеющем много зависимого кода.
Стоимость обновления может быть велика. Практика увеличения главных версий
релизов с обратно несовместимыми изменениями означает, что вам придётся думать о
последствиях ваших изменений и учитывать соотношение цена/качество.\nДокументирование всего API — слишком много работы!\nЭто ваша ответственность, как профессионального разработчика, правильно
документировать ПО, предназначенное для широкого использования. Управление
сложностью ПО очень важная часть поддержки высокой эффективности проекта. Это
тяжело сделать, если никто не знает, как использовать ваше ПО или какой метод
можно вызывать безопасно. В долгосрочной перспективе Семантическое
Версионирование и настойчивость в качественном документировании публичного API
поможет всем и всему работать слаженно.\nЧто мне делать, если я случайно зарелизил обратно несовместимые изменения как второстепенную версию?\nКак только вы поняли, что нарушили спецификации Семантического Версионирования,
исправьте проблему и выпустите новую второстепенную версию, которая исправляет
проблему и восстанавливает обратную совместимость. Даже в таких обстоятельствах
неприемлемо модифицировать уже выпущенные релизы. Если это необходимо, укажите в
документации о нарушении обратной совместимости, версионирования и
проинформируйте ваших пользователей, чтобы они знали о нарушении порядка версий.\nЧто я должен делать, если я обновляю свои собственные зависимости без изменения публичного API?\nЭто можно рассматривать как совместимые изменения, так как они не влияют на
публичное API. ПО, которое явно зависит от тех же зависимостей что и ваш пакет,
должно иметь собственные спецификации зависимостей и автор будет уведомлен о
возможных конфликтах. Являются ли данные изменения уровня патча или
второстепенного уровня, зависит от того, обновили ли вы свои зависимости чтобы
исправить баг или реализовать новую функциональность. В последнем случае, как правило,
добавляется некоторое количество дополнительного кода и как следствие,
увеличивается второстепенная версия.\nЧто я должен делать, если исправление бага вернуло код в состояние совместимости с публичным API (т.е. появилось расхождение в документации публичного API и кодом)?\nНа ваше усмотрение. Если у вас огромная аудитория, которая будет поставлена
перед фактом возвращения прежнего поведения API, то лучше выпустить новый релиз
с увеличением главной версии, даже несмотря на то, что фикс содержит исправления
уровня патча. Запомните, в Семантическом Версионировании номера версий
изменяются строго следуя спецификации. Если эти изменения важны для ваших
пользователей, используйте номер версии, чтобы информировать их.\nЧто делать с устаревшей функциональностью?\nОбъявление функциональности устаревшей — это обычное дело в ходе разработки и часто
необходимо для продвижения вперёд. Когда вы объявляете устаревшим часть
публичного API, вы должны сделать две вещи: (1) обновить вашу документацию,
чтобы дать пользователям узнать об этом изменении; (2) выпустить новый релиз с
увеличением второстепенной версии. Прежде чем вы полностью удалите устаревшую
функциональность в релизе с увеличением главной версии, должен быть как минимум один
второстепенный релиз, содержащий объявление функциональности устаревшей, чтобы
пользователи могли плавно перейти на новый API.\nАвторство спецификаций Семантического Версионирования принадлежит
Тому Престон-Вернеру, основателю Gravatars и
соучредителю GitHub.\nЕсли вы хотите оставить отзыв, пожалуйста, создайте запрос на
GitHub.\nсоздайте запрос на
GitHub\nCreative Commons — CC BY 3.0
http://creativecommons.org/licenses/by/3.0/\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSémantické verzovanie 2.0.0

Zhrnutie

V čísle verzie vo formáte MAJOR.MINOR.PATCH zväčšujeme číslo:


  MAJOR verzie, keď sme spravili zmeny, ktoré nie sú spätne kompatibilné,
  MINOR verzie, keď sme pridali funkcionalitu so zachovaním spätnej
kompatibility,
  PATCH verzie, keď sme opravili chyby a ostala zachovaná spätná kompatibilita.


Značenie predbežných verzií a pridávanie metadát verzií je možné rozšírením
spomínaného formátu MAJOR.MINOR.PATCH o potrebné informácie.

Úvod

Vo svete softvéru, jeho vývoja a správy existuje hrozné miesto nazývané peklo
závislostí (angl. dependency hell). Znamená to, že čím viac váš systém rastie
a máte v ňom integrovaných čoraz viac knižníc, tým je väčšia pravdepodobnosť,
že sa, kompletne zúfalí, v tomto pekle sami ocitnete.

Ak majú systémy veľa závislostí, raz-dva sa vám stane, že vydávanie novej verzie sa
stane nočnou morou. Ak je špecifikácia závislostí príliš striktná, hrozí vám, že
ostanete na jednej verzii (angl. version lock) a nebudete mať možnosť prejsť
na ďalšiu verziu bez toho, aby ste vydali ďalšie verzie všetkých balíčkov, na
ktorých závisí. Naopak, ak je špecifikácia závislostí príliš voľná, prídete na
to, že váš systém je kompatibilný s viac verziami, ako je potrebné. V pekle
závislostí sa nachádzate, ak ste zviazaný určitou verziou, prípadne nie je presne
špecifikované, ktorú máte použiť. Jednoducho, bráni vám to v tom, aby ste sa so
svojim projektom pohli bezpečne vpred.

Riešením tohto problému je jednoduchý súbor pravidiel, ktorý
určuje, ako budú čísla verzií priraďované a zväčšované. Tieto pravidlá sú
založené (no nie nevyhnutne obmedzené) na už existujúcich bežne zaužívaných
praktikách vo vývoji otvoreného, či uzavretého softvéru. Pre fungovanie
tohto systému si musíte najskôr zadefinovať rozhranie popisujúce spôsob,
akým sa bude komunikovať s vaším systémom (ďalej len API). Môže byť zadefinované
formou dokumentácie, prípadne vynútené samotným kódom. Bez ohľadu na formu akou
to bude, je
dôležité aby toto API bolo presné a jasné. Akonáhle budete mať zadefinované vaše
API, jeho zmeny budete oznamovať špecifickým zväčšením čísla verzie vášho
systému. Uvažujme, že číslo verzie bude vo formáte MAJOR.MINOR.PATCH. Opravy
chýb, ktoré nemenia vaše API, zväčšujú číslo PATCH verzie. Spätne kompatibilné
zmeny API zväčšujú číslo MINOR verzie a spätne nekompatibilné zmeny API zväčšujú
číslo MAJOR verzie.

Tento systém je nazývaný Sémantické verzovanie. Čísla verzií v tomto systéme a
spôsob, akým sa menia nesú so sebou informáciu o použitom kóde a zmenách medzi
jednotlivými verziami.

Špecifikácia sémantického verzovania (SemVer)

Kľúčové slová “MUSÍ” (angl. MUST, REQUIRED, SHALL), “NESMIE” (angl. MUST NOT,
SHALL NOT), “MALO BY” (angl. SHOULD, RECOMMENDED), “NEMALO BY” (angl. SHOULD
NOT) a “MÔŽE” (angl. MAY, OPTIONAL) sú interpretovené ako je popísané
v dokumente RFC 2119.


  
    Softvér používajúci Sémentické verzovanie MUSÍ mať zadefinované API. Toto API
môže byť definované priamo v kóde, prípadne môže existovať v dokumentácii. Nech
už to je tak alebo onak, malo by byť presné a komplexné.
  
  
    Normálne číslo verzie MUSÍ byť vo formáte X.Y.Z, kde X, Y a Z sú nezáporné
celé čísla a NESMÚ obsahovať úvodné nuly. X je číslo MAJOR verzie, Y je číslo
MINOR verzie a Z je číslo PATCH verzie. Každé z týchto čísel sa musí zväčšovať
štandardne. Napr.: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Akonáhle je takto očíslovaná verzia vydaná, softvér pod číslom tejto verzie
už NESMIE byť modifikovaný a každá zmena MUSÍ byť vydaná ako nová verzia.
  
  
    MAJOR verzia s číslom 0 (0.y.z) je pre začiatočný vývoj. Čokoľvek sa môže
zmeniť a API takto očíslovanej verzie by nemalo byť považované za stabilné.
  
  
    Verzia 1.0.0 už presne definuje API. Spôsob, akým sa po vydaní takejto verzie
mení číslo verzie je závislý na tomto API a jeho zmenách.
  
  
    Číslo PATCH verzie Z (x.y.Z | x > 0) MUSÍ byť zväčšené len vtedy, ak
boli implementované spätne kompatibilné opravy chýb. Oprava chyby je definovaná
ako interná zmena opravujúca nežiadúce chovanie.
  
  
    Číslo MINOR verzie Y (x.Y.z | x > 0) MUSÍ byť zväčšené, ak bola do API
pridaná nová, spätne kompatibilná funkcionalita a tiež MUSÍ byť zväčšené, ak
bola nejaká funcionalita označená ako zastaralá. MÔŽE tiež byť zväčšené, ak bola
pridaná alebo vylepšená podstatná funkcionalita v rámci kódu, ktorý
neovplyvňuje API. MÔŽE zahrnúť aj zmenu v rámci PATCH verzie. Číslo PATCH verzie
MUSÍ byť nastavené na 0 vždy, keď sa zmení číslo MINOR verzie.
  
  
    Číslo MAJOR verzie X (X.y.z | X > 0) MUSÍ byť zväčšené, ak boli pridané
zmeny, ktoré spôsobili, že API nie je spätne kompatibilné. MÔŽE zahrnúť aj zmenu
v rámci MINOR a PATCH verzie. Číslo MINOR aj PATCH verzie MUSÍ byť nastavené na 0
vždy, keď sa zmení číslo MAJOR verzie.
  
  
    Predbežná verzia (angl. pre-release) MÔŽE byť označená pridaním pomlčky
a sériou identifikátorov oddelených bodkou, hneď za číslo PATCH verzie.
Identifikátory MUSIA obsahovať len ASCII alfanumerické znaky a pomlčku
[0-9A-Za-z-], NESMÚ byť prázdne a číselné identifikátory NESMÚ obsahovať úvodné
nuly. Predbežné verzie majú nižšiu prioritu ako súvisiace normálne verzie.
Predbežná verzia je nestabilná a nemusí spĺňať požiadavky a závislosti ako
súvisiaca normálna verzia. Napr.: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.
  
  
    Metadáta MÔŽU byť označené vo verzii pridaním znaku plus (+) a sériou
identifikátorov oddelených bodkou, hneď za číslo PATCH alebo predbežnej verzie.
Identifikátory MUSIA obsahovať len ASCII alfanumerické znaky a pomlčku
[0-9A-Za-z-], NESMÚ byť prázdne a číselné identifikátory NESMÚ obsahovať úvodné
nuly. Metadáta by MALI BYŤ ignorované pri rozhodovaní o priorite verzie, a teda
dve verzie, ktoré sa líšia len v metadátach majú rovnakú prioritu.
Napr.: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    Priorita sa vzťahuje k tomu, ako sú verzie navzájom porovnávané. Priorita
MUSÍ byť určovaná rozdelením verzie na MAJOR, MINOR, PATCH a identifikátory
predbežných verzií ― presne v takomto poradí (s metadátami sa nepočíta).
Priorita je daná prvým rozdielom pri porovnávaní zľava doprava pričom čísla
MAJOR, MINOR a PATCH sú porovnávané vždy ako čísla. Napr.: 1.0.0 < 2.0.0 <
2.1.0 < 2.1.1. Keď sú čísla MAJOR, MINOR a PATCH rovnaké, predbežná verzia má
menšiu prioritu ako normálna. Napr.: 1.0.0-alpha < 1.0.0. Priorita pre dve
predbežné verzie, ktoré sa zhodujú v číslach MAJOR, MINOR a PATCH MUSÍ byť
počítaná z bodkou oddelených identifikátorov zľava doprava a to dovtedy,
pokým sa nenájde rozdiel nasledovným spôsobom: (1) Identifikátory obsahujúce
iba číslice sú porovnávané číselne a identifikátory s písmenami alebo pomlčkami
sú porovnávané lexikálne, zoradené podľa ASCII. (2) Číselné identifikátory majú
vždy nižšiu prioritu ako nečíselné. (3) Ak sú všetky predchádzajúce
identifikátory v predbežnej verzii rovnaké, tak väčšie množstvo identifikátorov
značí vyššiu prioritu ako menšie množstvo. Napr.: 1.0.0-alpha < 1.0.0-alpha.1 <
1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Prečo používať Sémantické verzovanie?

Sémantické verzovanie nie je revolučná myšlienka a ak vydávate softvér,
pravdepodobne robíte niečo podobné. Problémom je, že “niečo podobné” nestačí.
Bez dodržiavania akejsi formálnej špecifikácie sú čísla pre manažment závislostí
v podstate nanič. Tým, že hore uvedeným myšlienkam dávame presnú a jasnú
definíciu, je ľahšie komunikovať zámery vášho softvéru jeho používateľom.
Akonáhle sú zámery jasné a flexibilné (ale nie príliš), špecifikácia závislostí
môže začať.

Jednoduchým príkladom demonštrujeme, že peklo závislostí môže byť pre vás ľahko
minulosťou. Predstavte si, že máte knižnicu Hasičské auto. Táto knižnica
vyžaduje sémanticky verzovanú knižnicu Rebrík. V čase, kedy je Hasičské auto
vytvorené, verzia Rebríka je 3.1.0. Keďže Hasičské auto používa funkcie,
ktoré boli pridané vo verzii 3.1.0, môžete bezpečne špecifikovať, že potrebujete
verziu Rebríka väčšiu alebo rovnú 3.1.0, no menšiu ako 4.0.0. A potom, keď vyjde
nová verzia Rebríka 3.1.1 alebo 3.2.0, môžete ju použiť vo vašom Hasičskom aute
a budete vedieť, že je s ním kompatibilná.

Ako zodpovední developeri si určite budete chcieť skontrolovať, či všetko
funguje podľa predpokladov. V skutočnosti je však všade neporiadok; tam nám
pomôže iba dávať si pozor. Čo však môžete spraviť je nechať Sémantické
verzovanie aby vám umožnilo rozumný spôsob ako vydávať a aktualizovať
knižnice tak, aby ste nemuseli riešiť nové verzie závislostí, ušetrili čas
a vyhli sa zmätkom.

Ak to znie rozumne, všetko čo potrebujete spraviť pre začatie používania
Sémantického verzovania je povedať, že to robíte a následne dodržiavať pravidlá.
Odkážte z README vášho softvéru na tieto stránky, nech aj ostatní vedia, aké
pravidlá používate a majú z nich prospech.

Často kladené otázky (FAQ)

Ako si poradiť s verziami 0.y.z na začiatku vývoja?

Najjednoduchším spôsobom je začať vývoj na verzii 0.1.0 a potom zväčšovať MINOR
verziu pri každom ďalšom vydaní softvéru.

Ako vedieť, kedy vydať verziu 1.0.0?

Ak sa váš softvér už používa v produkcii, už by pravdepodobne mal mať verziu
1.0.0. Ak máte stabilné API, ktoré už používatelia majú medzi svojimi
závislosťami, mali by ste mať verziu 1.0.0. Taktiež, ak sa obávate o spätnú
kompatibilitu, už by ste mali mať 1.0.0.

Neodrádza to od rýchleho vývoja a iterácií?

MAJOR verzia nula je o rýchlom vývoji. Ak každý deň meníte API, stále by ste
mali byť niekde vo fáze 0.x.y alebo na separátnej vývojovej vetve, kde sa
pripravuje nasledujúca MAJOR verzia.

Ak aj tie najmenšie spätne nekompatibilné zmeny v API znamenajú zväčšenie MAJOR verzie, neskončíme pomerne rýchlo niekde pri verzii 42.0.0?

To je otázka zodpovedného vývoja a prognóz. Nekompatibilné zmeny by nemali byť
do softvéru, ktorý má veľa závislostí zavádzané len tak. Náklady vynaložené na
aktualizáciu môžu byť dosť veľké. To, že musíte vydať novú MAJOR verziu znamená,
že ste si dobre premysleli dopad vašich zmien a zrátali aké to bude mať výhody
a následky.

Zdokumentovať celé API je strašne veľa práce!

Je vašou zodpovednosťou, ako profesionálnych developerov, správne dokumentovať
softvér, ktorý je určený na používanie aj pre ostatných. Spravovanie zložitosti
softvéru je veľmi dôležitá časť, ak chcete projekt udržať efektívny. A to nebude
možné, ak nikto nebude vedieť ako váš softvér používať alebo ktoré metódy je
bezpečné volať. Z dlhodobého hľadiska sa Sémantické verzovanie a dôraz na dobre
definované API ukázali ako správna voľba umožňujúca bežať veciam hladko.

Čo spraviť, keď vydám spätne nekompatibilnú verziu ako MINOR?

Akonáhle zistíte, že ste porušili pravidlá Sémantického verzovania, opravte
problém a vydajte ďalšiu MINOR verziu, ktorá opäť vráti spätnú kompatibilitu.
Napriek takejto situácii, je neprípustné aby ste menili už vydanú verziu. A ak
je to možné a vhodné, informujte používateľov o zlej verzii, aby vedeli, že sa
jedná o chybu a danej verzii sa vyhli.

Čo robiť, keď som aktualizoval vlastné závislosti bez toho, aby sa zmenilo API?

Môžeme to považovať za kompatibilné, keďže to nijako neovplyvnilo API. Softvér,
ktorý presne závisí na balíčkoch ako váš, by mal mať vlastnú definíciu
závislostí a autor si všimne akékoľvek konflikty. Rozhodnutie, či sa jedná o
MINOR alebo PATCH závisí od toho, či ste upravili vaše závislosti kvôli nejakej
chybe alebo preto, že ste pridali novú funkcionalitu. Ak sa jedná o druhý
prípad, zvyčajne tam bude aj nejaký kód, a tak sa jedná o zväčšenie MINOR
verzie.

Čo keď som nechtiac zmenil API, spôsobom, ktorý nie v súlade so zmenou čísla verzie (napríklad som zaviedol MAJOR zmenu v PATCH verzii)?

Usúďte, čo je najlepšie. Ak máte veľkú skupinu používateľov, ktorá by bola
ovplyvnená zmenou späť, tak asi bude najlepšie vydať MAJOR verziu, napriek tomu,
že oprava späť by mala byť súčasťou PATCH verzie. Pamätajte, že Sémantické
verzovanie je o tom, ako sa verzie menia. Ak sú zmeny pre vašich používateľov
dôležité, použite také číslo verzie, aby ste ich informovali.

Ako sa vysporiadať so zastarávaním funkcionality?

Označenie funcionality ako zastaralej je štandardná časť softvérového vývoja
a väčšinou je žiadané ísť vpred, takže k tomu jednoducho dôjde. Keď zastarávate
časť svojho API, mali by ste spraviť dve veci: (1) upraviť dokumentáciu aby
používatelia vedeli o zmene, (2) vydať ďalšiu MINOR verziu, ktorá funcionalitu
zastaráva. A teda, predtým ako funkcionalitu kompletne odstránite v ďalšej
MAJOR verzii, mali by ste spraviť aspoň jednu MINOR verziu, ktorá obsahuje
zastaranie a používatelia mohli ľahko prejsť na nové API.

Má Sémantické verzovanie nejaký limit na dĺžku označenia verzie?

Nie, no použite zdravý rozum. Číslo verzie, ktoré má 255 znakov je už asi moc,
no špecifické systémy môžu mať vlastné limity na dĺžku čísla verzie.

O špecifikácii

Autorom špecifikácie sémantického verzovania je
Tom Preston-Werner, autor projektu Gravatar a
spoluzakladateľ projektu Github.

Ak chcete zanechať spätnú väzbu, prosím
cez GitHub.

Preklad

Vladimír Kriška (autor),
Tibor Soviš (korektor),
Peter Dulačka (korektor),
Jaroslav Brtiš (korektor)

Licencia

Creative Commons ― CC BY 3.0\nSémantické verzovanie 2.0.0\nV čísle verzie vo formáte MAJOR.MINOR.PATCH zväčšujeme číslo:\nMAJOR verzie, keď sme spravili zmeny, ktoré nie sú spätne kompatibilné,\nMINOR verzie, keď sme pridali funkcionalitu so zachovaním spätnej
kompatibility,\nPATCH verzie, keď sme opravili chyby a ostala zachovaná spätná kompatibilita.\nZnačenie predbežných verzií a pridávanie metadát verzií je možné rozšírením
spomínaného formátu MAJOR.MINOR.PATCH o potrebné informácie.\nVo svete softvéru, jeho vývoja a správy existuje hrozné miesto nazývané peklo
závislostí (angl. dependency hell). Znamená to, že čím viac váš systém rastie
a máte v ňom integrovaných čoraz viac knižníc, tým je väčšia pravdepodobnosť,
že sa, kompletne zúfalí, v tomto pekle sami ocitnete.\nAk majú systémy veľa závislostí, raz-dva sa vám stane, že vydávanie novej verzie sa
stane nočnou morou. Ak je špecifikácia závislostí príliš striktná, hrozí vám, že
ostanete na jednej verzii (angl. version lock) a nebudete mať možnosť prejsť
na ďalšiu verziu bez toho, aby ste vydali ďalšie verzie všetkých balíčkov, na
ktorých závisí. Naopak, ak je špecifikácia závislostí príliš voľná, prídete na
to, že váš systém je kompatibilný s viac verziami, ako je potrebné. V pekle
závislostí sa nachádzate, ak ste zviazaný určitou verziou, prípadne nie je presne
špecifikované, ktorú máte použiť. Jednoducho, bráni vám to v tom, aby ste sa so
svojim projektom pohli bezpečne vpred.\nRiešením tohto problému je jednoduchý súbor pravidiel, ktorý
určuje, ako budú čísla verzií priraďované a zväčšované. Tieto pravidlá sú
založené (no nie nevyhnutne obmedzené) na už existujúcich bežne zaužívaných
praktikách vo vývoji otvoreného, či uzavretého softvéru. Pre fungovanie
tohto systému si musíte najskôr zadefinovať rozhranie popisujúce spôsob,
akým sa bude komunikovať s vaším systémom (ďalej len API). Môže byť zadefinované
formou dokumentácie, prípadne vynútené samotným kódom. Bez ohľadu na formu akou
to bude, je
dôležité aby toto API bolo presné a jasné. Akonáhle budete mať zadefinované vaše
API, jeho zmeny budete oznamovať špecifickým zväčšením čísla verzie vášho
systému. Uvažujme, že číslo verzie bude vo formáte MAJOR.MINOR.PATCH. Opravy
chýb, ktoré nemenia vaše API, zväčšujú číslo PATCH verzie. Spätne kompatibilné
zmeny API zväčšujú číslo MINOR verzie a spätne nekompatibilné zmeny API zväčšujú
číslo MAJOR verzie.\nTento systém je nazývaný Sémantické verzovanie. Čísla verzií v tomto systéme a
spôsob, akým sa menia nesú so sebou informáciu o použitom kóde a zmenách medzi
jednotlivými verziami.\nŠpecifikácia sémantického verzovania (SemVer)\nKľúčové slová “MUSÍ” (angl. MUST, REQUIRED, SHALL), “NESMIE” (angl. MUST NOT,
SHALL NOT), “MALO BY” (angl. SHOULD, RECOMMENDED), “NEMALO BY” (angl. SHOULD
NOT) a “MÔŽE” (angl. MAY, OPTIONAL) sú interpretovené ako je popísané
v dokumente RFC 2119.\nSoftvér používajúci Sémentické verzovanie MUSÍ mať zadefinované API. Toto API
môže byť definované priamo v kóde, prípadne môže existovať v dokumentácii. Nech
už to je tak alebo onak, malo by byť presné a komplexné.\nSoftvér používajúci Sémentické verzovanie MUSÍ mať zadefinované API. Toto API
môže byť definované priamo v kóde, prípadne môže existovať v dokumentácii. Nech
už to je tak alebo onak, malo by byť presné a komplexné.\nNormálne číslo verzie MUSÍ byť vo formáte X.Y.Z, kde X, Y a Z sú nezáporné
celé čísla a NESMÚ obsahovať úvodné nuly. X je číslo MAJOR verzie, Y je číslo
MINOR verzie a Z je číslo PATCH verzie. Každé z týchto čísel sa musí zväčšovať
štandardne. Napr.: 1.9.0 -> 1.10.0 -> 1.11.0.\nNormálne číslo verzie MUSÍ byť vo formáte X.Y.Z, kde X, Y a Z sú nezáporné
celé čísla a NESMÚ obsahovať úvodné nuly. X je číslo MAJOR verzie, Y je číslo
MINOR verzie a Z je číslo PATCH verzie. Každé z týchto čísel sa musí zväčšovať
štandardne. Napr.: 1.9.0 -> 1.10.0 -> 1.11.0.\nAkonáhle je takto očíslovaná verzia vydaná, softvér pod číslom tejto verzie
už NESMIE byť modifikovaný a každá zmena MUSÍ byť vydaná ako nová verzia.\nAkonáhle je takto očíslovaná verzia vydaná, softvér pod číslom tejto verzie
už NESMIE byť modifikovaný a každá zmena MUSÍ byť vydaná ako nová verzia.\nMAJOR verzia s číslom 0 (0.y.z) je pre začiatočný vývoj. Čokoľvek sa môže
zmeniť a API takto očíslovanej verzie by nemalo byť považované za stabilné.\nMAJOR verzia s číslom 0 (0.y.z) je pre začiatočný vývoj. Čokoľvek sa môže
zmeniť a API takto očíslovanej verzie by nemalo byť považované za stabilné.\nVerzia 1.0.0 už presne definuje API. Spôsob, akým sa po vydaní takejto verzie
mení číslo verzie je závislý na tomto API a jeho zmenách.\nVerzia 1.0.0 už presne definuje API. Spôsob, akým sa po vydaní takejto verzie
mení číslo verzie je závislý na tomto API a jeho zmenách.\nČíslo PATCH verzie Z (x.y.Z | x > 0) MUSÍ byť zväčšené len vtedy, ak
boli implementované spätne kompatibilné opravy chýb. Oprava chyby je definovaná
ako interná zmena opravujúca nežiadúce chovanie.\nČíslo PATCH verzie Z (x.y.Z | x > 0) MUSÍ byť zväčšené len vtedy, ak
boli implementované spätne kompatibilné opravy chýb. Oprava chyby je definovaná
ako interná zmena opravujúca nežiadúce chovanie.\nČíslo MINOR verzie Y (x.Y.z | x > 0) MUSÍ byť zväčšené, ak bola do API
pridaná nová, spätne kompatibilná funkcionalita a tiež MUSÍ byť zväčšené, ak
bola nejaká funcionalita označená ako zastaralá. MÔŽE tiež byť zväčšené, ak bola
pridaná alebo vylepšená podstatná funkcionalita v rámci kódu, ktorý
neovplyvňuje API. MÔŽE zahrnúť aj zmenu v rámci PATCH verzie. Číslo PATCH verzie
MUSÍ byť nastavené na 0 vždy, keď sa zmení číslo MINOR verzie.\nČíslo MINOR verzie Y (x.Y.z | x > 0) MUSÍ byť zväčšené, ak bola do API
pridaná nová, spätne kompatibilná funkcionalita a tiež MUSÍ byť zväčšené, ak
bola nejaká funcionalita označená ako zastaralá. MÔŽE tiež byť zväčšené, ak bola
pridaná alebo vylepšená podstatná funkcionalita v rámci kódu, ktorý
neovplyvňuje API. MÔŽE zahrnúť aj zmenu v rámci PATCH verzie. Číslo PATCH verzie
MUSÍ byť nastavené na 0 vždy, keď sa zmení číslo MINOR verzie.\nČíslo MAJOR verzie X (X.y.z | X > 0) MUSÍ byť zväčšené, ak boli pridané
zmeny, ktoré spôsobili, že API nie je spätne kompatibilné. MÔŽE zahrnúť aj zmenu
v rámci MINOR a PATCH verzie. Číslo MINOR aj PATCH verzie MUSÍ byť nastavené na 0
vždy, keď sa zmení číslo MAJOR verzie.\nČíslo MAJOR verzie X (X.y.z | X > 0) MUSÍ byť zväčšené, ak boli pridané
zmeny, ktoré spôsobili, že API nie je spätne kompatibilné. MÔŽE zahrnúť aj zmenu
v rámci MINOR a PATCH verzie. Číslo MINOR aj PATCH verzie MUSÍ byť nastavené na 0
vždy, keď sa zmení číslo MAJOR verzie.\nPredbežná verzia (angl. pre-release) MÔŽE byť označená pridaním pomlčky
a sériou identifikátorov oddelených bodkou, hneď za číslo PATCH verzie.
Identifikátory MUSIA obsahovať len ASCII alfanumerické znaky a pomlčku
[0-9A-Za-z-], NESMÚ byť prázdne a číselné identifikátory NESMÚ obsahovať úvodné
nuly. Predbežné verzie majú nižšiu prioritu ako súvisiace normálne verzie.
Predbežná verzia je nestabilná a nemusí spĺňať požiadavky a závislosti ako
súvisiaca normálna verzia. Napr.: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.\nPredbežná verzia (angl. pre-release) MÔŽE byť označená pridaním pomlčky
a sériou identifikátorov oddelených bodkou, hneď za číslo PATCH verzie.
Identifikátory MUSIA obsahovať len ASCII alfanumerické znaky a pomlčku
[0-9A-Za-z-], NESMÚ byť prázdne a číselné identifikátory NESMÚ obsahovať úvodné
nuly. Predbežné verzie majú nižšiu prioritu ako súvisiace normálne verzie.
Predbežná verzia je nestabilná a nemusí spĺňať požiadavky a závislosti ako
súvisiaca normálna verzia. Napr.: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.\nMetadáta MÔŽU byť označené vo verzii pridaním znaku plus (+) a sériou
identifikátorov oddelených bodkou, hneď za číslo PATCH alebo predbežnej verzie.
Identifikátory MUSIA obsahovať len ASCII alfanumerické znaky a pomlčku
[0-9A-Za-z-], NESMÚ byť prázdne a číselné identifikátory NESMÚ obsahovať úvodné
nuly. Metadáta by MALI BYŤ ignorované pri rozhodovaní o priorite verzie, a teda
dve verzie, ktoré sa líšia len v metadátach majú rovnakú prioritu.
Napr.: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nMetadáta MÔŽU byť označené vo verzii pridaním znaku plus (+) a sériou
identifikátorov oddelených bodkou, hneď za číslo PATCH alebo predbežnej verzie.
Identifikátory MUSIA obsahovať len ASCII alfanumerické znaky a pomlčku
[0-9A-Za-z-], NESMÚ byť prázdne a číselné identifikátory NESMÚ obsahovať úvodné
nuly. Metadáta by MALI BYŤ ignorované pri rozhodovaní o priorite verzie, a teda
dve verzie, ktoré sa líšia len v metadátach majú rovnakú prioritu.
Napr.: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nPriorita sa vzťahuje k tomu, ako sú verzie navzájom porovnávané. Priorita
MUSÍ byť určovaná rozdelením verzie na MAJOR, MINOR, PATCH a identifikátory
predbežných verzií ― presne v takomto poradí (s metadátami sa nepočíta).
Priorita je daná prvým rozdielom pri porovnávaní zľava doprava pričom čísla
MAJOR, MINOR a PATCH sú porovnávané vždy ako čísla. Napr.: 1.0.0 < 2.0.0 <
2.1.0 < 2.1.1. Keď sú čísla MAJOR, MINOR a PATCH rovnaké, predbežná verzia má
menšiu prioritu ako normálna. Napr.: 1.0.0-alpha < 1.0.0. Priorita pre dve
predbežné verzie, ktoré sa zhodujú v číslach MAJOR, MINOR a PATCH MUSÍ byť
počítaná z bodkou oddelených identifikátorov zľava doprava a to dovtedy,
pokým sa nenájde rozdiel nasledovným spôsobom: (1) Identifikátory obsahujúce
iba číslice sú porovnávané číselne a identifikátory s písmenami alebo pomlčkami
sú porovnávané lexikálne, zoradené podľa ASCII. (2) Číselné identifikátory majú
vždy nižšiu prioritu ako nečíselné. (3) Ak sú všetky predchádzajúce
identifikátory v predbežnej verzii rovnaké, tak väčšie množstvo identifikátorov
značí vyššiu prioritu ako menšie množstvo. Napr.: 1.0.0-alpha < 1.0.0-alpha.1 <
1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPriorita sa vzťahuje k tomu, ako sú verzie navzájom porovnávané. Priorita
MUSÍ byť určovaná rozdelením verzie na MAJOR, MINOR, PATCH a identifikátory
predbežných verzií ― presne v takomto poradí (s metadátami sa nepočíta).
Priorita je daná prvým rozdielom pri porovnávaní zľava doprava pričom čísla
MAJOR, MINOR a PATCH sú porovnávané vždy ako čísla. Napr.: 1.0.0 < 2.0.0 <
2.1.0 < 2.1.1. Keď sú čísla MAJOR, MINOR a PATCH rovnaké, predbežná verzia má
menšiu prioritu ako normálna. Napr.: 1.0.0-alpha < 1.0.0. Priorita pre dve
predbežné verzie, ktoré sa zhodujú v číslach MAJOR, MINOR a PATCH MUSÍ byť
počítaná z bodkou oddelených identifikátorov zľava doprava a to dovtedy,
pokým sa nenájde rozdiel nasledovným spôsobom: (1) Identifikátory obsahujúce
iba číslice sú porovnávané číselne a identifikátory s písmenami alebo pomlčkami
sú porovnávané lexikálne, zoradené podľa ASCII. (2) Číselné identifikátory majú
vždy nižšiu prioritu ako nečíselné. (3) Ak sú všetky predchádzajúce
identifikátory v predbežnej verzii rovnaké, tak väčšie množstvo identifikátorov
značí vyššiu prioritu ako menšie množstvo. Napr.: 1.0.0-alpha < 1.0.0-alpha.1 <
1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPrečo používať Sémantické verzovanie?\nSémantické verzovanie nie je revolučná myšlienka a ak vydávate softvér,
pravdepodobne robíte niečo podobné. Problémom je, že “niečo podobné” nestačí.
Bez dodržiavania akejsi formálnej špecifikácie sú čísla pre manažment závislostí
v podstate nanič. Tým, že hore uvedeným myšlienkam dávame presnú a jasnú
definíciu, je ľahšie komunikovať zámery vášho softvéru jeho používateľom.
Akonáhle sú zámery jasné a flexibilné (ale nie príliš), špecifikácia závislostí
môže začať.\nJednoduchým príkladom demonštrujeme, že peklo závislostí môže byť pre vás ľahko
minulosťou. Predstavte si, že máte knižnicu Hasičské auto. Táto knižnica
vyžaduje sémanticky verzovanú knižnicu Rebrík. V čase, kedy je Hasičské auto
vytvorené, verzia Rebríka je 3.1.0. Keďže Hasičské auto používa funkcie,
ktoré boli pridané vo verzii 3.1.0, môžete bezpečne špecifikovať, že potrebujete
verziu Rebríka väčšiu alebo rovnú 3.1.0, no menšiu ako 4.0.0. A potom, keď vyjde
nová verzia Rebríka 3.1.1 alebo 3.2.0, môžete ju použiť vo vašom Hasičskom aute
a budete vedieť, že je s ním kompatibilná.\nAko zodpovední developeri si určite budete chcieť skontrolovať, či všetko
funguje podľa predpokladov. V skutočnosti je však všade neporiadok; tam nám
pomôže iba dávať si pozor. Čo však môžete spraviť je nechať Sémantické
verzovanie aby vám umožnilo rozumný spôsob ako vydávať a aktualizovať
knižnice tak, aby ste nemuseli riešiť nové verzie závislostí, ušetrili čas
a vyhli sa zmätkom.\nAk to znie rozumne, všetko čo potrebujete spraviť pre začatie používania
Sémantického verzovania je povedať, že to robíte a následne dodržiavať pravidlá.
Odkážte z README vášho softvéru na tieto stránky, nech aj ostatní vedia, aké
pravidlá používate a majú z nich prospech.\nČasto kladené otázky (FAQ)\nAko si poradiť s verziami 0.y.z na začiatku vývoja?\nNajjednoduchším spôsobom je začať vývoj na verzii 0.1.0 a potom zväčšovať MINOR
verziu pri každom ďalšom vydaní softvéru.\nAko vedieť, kedy vydať verziu 1.0.0?\nAk sa váš softvér už používa v produkcii, už by pravdepodobne mal mať verziu
1.0.0. Ak máte stabilné API, ktoré už používatelia majú medzi svojimi
závislosťami, mali by ste mať verziu 1.0.0. Taktiež, ak sa obávate o spätnú
kompatibilitu, už by ste mali mať 1.0.0.\nNeodrádza to od rýchleho vývoja a iterácií?\nMAJOR verzia nula je o rýchlom vývoji. Ak každý deň meníte API, stále by ste
mali byť niekde vo fáze 0.x.y alebo na separátnej vývojovej vetve, kde sa
pripravuje nasledujúca MAJOR verzia.\nAk aj tie najmenšie spätne nekompatibilné zmeny v API znamenajú zväčšenie MAJOR verzie, neskončíme pomerne rýchlo niekde pri verzii 42.0.0?\nTo je otázka zodpovedného vývoja a prognóz. Nekompatibilné zmeny by nemali byť
do softvéru, ktorý má veľa závislostí zavádzané len tak. Náklady vynaložené na
aktualizáciu môžu byť dosť veľké. To, že musíte vydať novú MAJOR verziu znamená,
že ste si dobre premysleli dopad vašich zmien a zrátali aké to bude mať výhody
a následky.\nZdokumentovať celé API je strašne veľa práce!\nJe vašou zodpovednosťou, ako profesionálnych developerov, správne dokumentovať
softvér, ktorý je určený na používanie aj pre ostatných. Spravovanie zložitosti
softvéru je veľmi dôležitá časť, ak chcete projekt udržať efektívny. A to nebude
možné, ak nikto nebude vedieť ako váš softvér používať alebo ktoré metódy je
bezpečné volať. Z dlhodobého hľadiska sa Sémantické verzovanie a dôraz na dobre
definované API ukázali ako správna voľba umožňujúca bežať veciam hladko.\nČo spraviť, keď vydám spätne nekompatibilnú verziu ako MINOR?\nAkonáhle zistíte, že ste porušili pravidlá Sémantického verzovania, opravte
problém a vydajte ďalšiu MINOR verziu, ktorá opäť vráti spätnú kompatibilitu.
Napriek takejto situácii, je neprípustné aby ste menili už vydanú verziu. A ak
je to možné a vhodné, informujte používateľov o zlej verzii, aby vedeli, že sa
jedná o chybu a danej verzii sa vyhli.\nČo robiť, keď som aktualizoval vlastné závislosti bez toho, aby sa zmenilo API?\nMôžeme to považovať za kompatibilné, keďže to nijako neovplyvnilo API. Softvér,
ktorý presne závisí na balíčkoch ako váš, by mal mať vlastnú definíciu
závislostí a autor si všimne akékoľvek konflikty. Rozhodnutie, či sa jedná o
MINOR alebo PATCH závisí od toho, či ste upravili vaše závislosti kvôli nejakej
chybe alebo preto, že ste pridali novú funkcionalitu. Ak sa jedná o druhý
prípad, zvyčajne tam bude aj nejaký kód, a tak sa jedná o zväčšenie MINOR
verzie.\nČo keď som nechtiac zmenil API, spôsobom, ktorý nie v súlade so zmenou čísla verzie (napríklad som zaviedol MAJOR zmenu v PATCH verzii)?\nUsúďte, čo je najlepšie. Ak máte veľkú skupinu používateľov, ktorá by bola
ovplyvnená zmenou späť, tak asi bude najlepšie vydať MAJOR verziu, napriek tomu,
že oprava späť by mala byť súčasťou PATCH verzie. Pamätajte, že Sémantické
verzovanie je o tom, ako sa verzie menia. Ak sú zmeny pre vašich používateľov
dôležité, použite také číslo verzie, aby ste ich informovali.\nAko sa vysporiadať so zastarávaním funkcionality?\nOznačenie funcionality ako zastaralej je štandardná časť softvérového vývoja
a väčšinou je žiadané ísť vpred, takže k tomu jednoducho dôjde. Keď zastarávate
časť svojho API, mali by ste spraviť dve veci: (1) upraviť dokumentáciu aby
používatelia vedeli o zmene, (2) vydať ďalšiu MINOR verziu, ktorá funcionalitu
zastaráva. A teda, predtým ako funkcionalitu kompletne odstránite v ďalšej
MAJOR verzii, mali by ste spraviť aspoň jednu MINOR verziu, ktorá obsahuje
zastaranie a používatelia mohli ľahko prejsť na nové API.\nMá Sémantické verzovanie nejaký limit na dĺžku označenia verzie?\nNie, no použite zdravý rozum. Číslo verzie, ktoré má 255 znakov je už asi moc,
no špecifické systémy môžu mať vlastné limity na dĺžku čísla verzie.\nAutorom špecifikácie sémantického verzovania je
Tom Preston-Werner, autor projektu Gravatar a
spoluzakladateľ projektu Github.\nAk chcete zanechať spätnú väzbu, prosím
cez GitHub.\nVladimír Kriška (autor),
Tibor Soviš (korektor),
Peter Dulačka (korektor),
Jaroslav Brtiš (korektor)\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSemantične verzije 2.0.0

Povzetek

Dane številke verzij GLAVNA.MANJŠA.POPRAVEK povečajte:


  GLAVNO verzijo, ko naredite nazaj nezdružljive spremembe API-ja,
  MANJŠO verzijo, ko dodate funkcionalnost na način združljivosti za
nazaj in
  POPRAVEK verzije, ko naredite popravke hroščev z združljivostjo za nazaj.


Dodatne oznake za pred-izdaje in metapodatki gradnje so na voljo kot razširitve v obliki GLAVNA.MANJŠA.POPRAVEK.

Uvod

V svetu programske opreme obstaja grozen prostor imenovan
“pekel odvisnosti”. Večji kot sistem zraste in več je paketov,
ki jih integrirate v vašo programsko opremo, bolj možno se boste našli nekega
dne v tem obupu.

V sistemih z veliko odvisnostmi lahko izdaja nove verzije paketa hitro
postane nočna mora. Če so specifikacije odvisnosti preveč ozke, ste v
nevarnosti zaklenjenih verzij (nezmožnost nadgradnje paketa brez, da
izdajate nove verzije za vsak odvisni paket). Če so odvisnosti
določene preveč ohlapno, boste neizogibno ugriznjeni s strani promiskuitete verzije
(ob predpostavki, da je združljivost z večimi prihodnjimi verzijami razumna).
Pekel odvisnosti je, kjer ste vi, ko je verzija zaklenjena in/ali vam promiskuiteta verzije
preprečuje, da enostavno in varno prestavite vaš projekt naprej.

Kot rešitev tega problema, predlagam enostaven skupek pravil in
zahtev, ki diktirajo, kako naj bodo številke verzij določene in povečane.
Ta pravila so osnovana na in ne nujno omejena na pred obstoječe
široko skupne prakse v uporabi tako v programski opremi zaprte kode kot odprte kode.
Da ta sistem deluje, morate najprej določiti javni API. To lahko sestoji
iz dokumentacije ali je izvršeno s strani same kode. Ne glede na to,
pomembno je, da je ta API jasen in točen. Ko enkrat identificirate vaš javni
API, lahko komunicirate spremembe na njem z določenimi povečanji na vaši številki
verzije. Smatrajte obliko verzije X.Y.Z (Glavna.Manjša.Popravek). Popravki hroščev ne
vplivajo na API a povečujejo številko popravka, nazaj združljivi API
dodatki/spremembe povečujejo manjšo verzijo in nazaj nezdružljive API
spremembe povečujejo glavno verzijo.

Ta sistem se imenuje “Semantične verzije.” Pod to shemo, številke verzij
in način, kako spreminjajo poslani pomen o podležeči kodi in kaj je bilo
spremenjeno iz ene verzije v naslednji.

Specifikacija semantičnih verzij (SemVer)

Ključne besede “MORA”, “NE SME”, “ZAHTEVANO”, “BO”, “NE BO”, “BI MORALO”,
“NE BI SMELO”, “PRIPOROČLJIVO”, “LAHKO” in “OPCIJSKO” se v tem dokumentu
interpretira, kot so opisane v RFC 2119.


  
    Programska oprema, ki uporablja semantične verzije MORA določiti javni API. Ta API
je lahko določen v sami kodi ali obstaja striktno v dokumentaciji.
Kakorkoli je končan, bi moral biti točen in celovit.
  
  
    Običajna številka verzije MORA biti oblike X.Y.Z, kjer so X, Y, in Z
pozitivna cena števila in NE SMEJO vsebovati vodilnih ničel. X je
glavna verzija, Y je manjša verzija in Z je verzija popravka.
Vsak element se MORA povečati numerično. Na primer: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Ko je enkrat paket verzije izdan, se vsebina te verzija
NE SME spremeniti. Kakršnekoli spremembe MORAJO biti izdane kot nova verzija.
  
  
    Glavna verzija nič (0.y.z) je za začetni razvoj. Karkoli se lahko spremeni
kadarkoli. Javni API ne bi smel biti smatran za stabilnega.
  
  
    Verzija 1.0.0 definira javni API. Način, kako je številka verzija
povečana za to izdajo je odvisno od tega javnega API-ja in kako se
spremeni.
  
  
    Verzija popravka Z (x.y.Z | x > 0) MORA biti povečana, če so predstavljeni samo nazaj
združljivi popravki hroščev. Popravek hrošča je definiran kot notranja
sprememba, ki popravi nepravilno obnašanje.
  
  
    Manjša verzija Y (x.Y.z | x > 0) MORA biti povečana, če so nove nazaj
združljive funkcionalnosti predstavljene javnemu API-ju. MORA biti
povečana, če je katerakoli funkcionalnost javnega API-ja označena za opuščeno. LAHKO
je povečana, če so znatna nova funkcionalnost ali izboljšave predstavljene
znotraj privatne kode. LAHKO vključuje spremembe nivoja popravka. Verzija popravka
MORA biti ponastavljena na nič, ko je manjša verzija povečana.
  
  
    Glavna verzija X (X.y.z | X > 0) MORA biti povečevana, če je kakršnakoli nazaj
nezdružljiva sprememba predstavljena javnemu API-ju. LAHKO vključuje spremembe
manjše verzije in verzije popravka. Manjša verzija in popravek MORATA biti ponastavljena na 0, ko je
glavna verzija povečana.
  
  
    Verzija pred-izdaje je LAHKO označena z dodajanjem vezaja in
serije s pikami ločenih identifikatorjev, ki jim takoj sledi verzija
popravka. Identifikatorji MORAJO biti sestavljeni iz samo alfanumeričnih ASCII-jev in vezaja
[0-9A-Za-z-]. Identifikatorji NE SMEJO biti prazni. Numerični identifikatorji NE
SMEJO vključevati vodilnih ničel. Verzije pred-izdaj imajo manjši
vrstni red, ko povezana običajna verzija. Verzija pred-izdaje
označuje, da je verzija nestabilna in lahko ne zadosti
namenjenim zahtevam združljivosti, kot je označeno z njihovimi povezanimi
normalnimi verzijami. Na primer: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.
  
  
    Metapodatki gradnje so LAHKO označeni z dodajanjem znaka plus in serije pik
ločenih identifikatorjev, ki jim takoj sledi popravek ali verzija pred-izdaje.
Identifikatorji MORAJO biti sestavljeni iz samo alfanumeričnih ASCII-jev in vezajev [0-9A-Za-z-].
Identifikatorji NE SMEJO biti prazni. Podatki metagradnje BI MORALI biti ignorirani, ko se določa
vrstni red verzij. Zato dve verziji, ki se razlikujeta samo v metapodatkih gradnje,
imata enak vrstni red. Na primer: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85.
  
  
    Vrstni red se sklicuje na to, kako so verzije primerjane druga z drugo, ko so urejene.
Vrstni red MORA biti izračunan z ločitvijo verzije v glavno, manjšo, popravek
in identifikator pred-izdaje v tem vrstnem redu (metapodatki gradnje ne pašejo
v vrstni red). Vrstni red je določen s prvo razliko, ko
primerjate vsako od teh identifikatorjev iz leve proti desni kot sledi: Verzije glavna, manjša
in popravek so vedno primerjane s številkami. Na primer: 1.0.0 < 2.0.0 <
2.1.0 < 2.1.1. Ko so glavna, manjša in popravek enake, ima verzija pred-izdaje
manjši vrstni red kot običajne izdaje. Na primer 1.0.0-alpha < 1.0.0. Vrstni red
za dve verziji pred-izdaje z enako verzijo glavne, manjše in popravka MORATA
biti določeli s primerjanjem vsake pike ločenega identifikatorja iz leve proti desni
dokler ni razlika najdena kot sledi: identifikatorji sestavljeni iz samo številk
so primerjani numerično in identifikatorji s črkami ali vezaji so primerjani
besedno v ASCII vrstnem redu. Numerični identifikatorji imajo vedno manjši vrstni red
kot ne-numerični identifikatorji. Večji skupek polj pred-izdaje imajo večji
vrstni red kot manjši skupek, če vsi prejšnji identifikatorji so enaki.
Na primer: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Zakaj uporabljati semantične verzije?

To ni nova ali revolucionarna ideja. V bistvu delate nekaj podobnega
temu že sedaj. Problem je, da “nekaj podobnega” ni dovolj dobro. Brez
skladnosti z nekakšno uradno specifikacijo, so številke verzij
v bistvu neuporabne za upravljanje odvisnosti. Z dodajanjem imena in jasne
definicije zgornjim idejam, postane enostavno za komunicirati vaše namere
uporabnikom vaše programske opreme. Ko enkrat postanejo te namere jasne, fleksibilne (vendar
ne preveč fleksibilne), se lahko končno naredi specifikacija odvisnosti.

Enostaven primer bo demonstriral, kako semantične verzije lahko naredijo pekel
odvisnosti stvar preteklosti. Premislite o knjižnici imenovani “Firetruck”. Zahteva
paket s semantično verzijo in se imenuje “Ladder”. Ko je Firetruck
narejen, je Ladder pri verziji 3.1.0, lahko varno določite verzijo odvisnosti Ladder
kot večjo ali enako 3.1.0, vendar manjšo kot 4.0.0. Sedaj ko postane
Ladder verzija 3.1.1 in 3.2.0 postane na voljo, jih lahko izdate v vašem
sistemu paketnega upravljanja in veste, da bodo postale kompatibilne z obstoječo
odvisno programsko opremo.

Kot odgovoren razvijalec boste seveda želeli preveriti, da katerikoli
paket nadgradnje funkcionira, kot je oglaševano. Realni svet je grdo mesto;
ničesar ni, kar bi lahko naredili o tem, razen da smo pazljivi. Kar lahko naredite je
omogočiti semantičnim verzijam, da vam ponudijo pameten način izdaje in nadgradnje
paketov brez, da morate kotaliti nove verzije odvisnih paketov, kar vam prihrani
čas in težave.

Če to vse zveni zaželjeno, je vse kar morate storiti, da začnete uporabljati semantične
verzije, razglasitev, da to tako delate in nato slediti pravilom. Povežite
na to spletno stran iz vaše datoteke README, da ostali vedo pravila in jih lahko
koristijo.

Pogosta vprašanja

Kako ravnam z revizijami v 0.y.z začetni fazi razvoja?

Najenostavnejše narediti je začeti vašo začetno razvojno izdajo pri 0.1.0
in nato povečevati manjše verzije za vsako naknadno izdajo.

Kako vem, kdaj izdati 1.0.0?

Če je vaša programska oprema uporabljena v produkciji, bi morala verjeno že biti
1.0.0. Če imate stabilni API od katerega so postali uporabniki odvisni, bi morali
imeti 1.0.0. Če vas skrbi veliko o združljivosti za nazaj, bi morali verjetno
že biti na 1.0.0.

Ali to ne odvrača hitrega razvoja in hitrih interacij?

Glavna verzija nič je vse o hitrem razvoju. Če spreminjate API
vsak dan, bi morali ali biti še vedno na verziji 0.y.z ali na ločeni
razvojni veji delati na naslednji glavni verziji.

Če tudi najmanjša nazaj nezdružljiva sprememba javnega API-ja zahteva povečanje glavne verzije, ali ne bom potem končal pri verziji 42.0.0 zelo hitro?

To je vprašanje odgovornega razvoja in vpogleda vnaprej. Nezdružljive
spremembe ne bi smele biti predstavljene ohlapno v programsko opremo, ki ima
veliko odvisne kode. Cena, ki mora nastati za nadgradnjo, je lahko pomembna.
Povečanje glavnih verzij za izdajo nekompatibilnih sprememb pomeni, da boste
premislili skozi vpliv vaših sprememb in ocenili vpleteno razmerje
cena/korist.

Dokumentiranje celotnega javnega API-ja je preveč dela!

Vaša odgovornost kot profesionalnega razvijalca je, da ustrezno dokumentirate
programsko opremo, ki je nameravana za uporabo s strani drugih. Upravljanje kompleksnosti programske opreme je
zelo pomemben del, da obdržite projekt učinkovit in to narediti je težko, če
nihče ne ve, kako uporabiti vašo programsko opremo ali katere metode so varne za klicanje. Na
dolgi rok semantične verzije in vztrajanje na dobro definiranem javnem
API-ju lahko obdrži poganjanje vsakogar in vsega gladko.

Kaj narediti, če ponesreči izdam nazaj nezdružljivo spremembo kot manjšo verzijo?

Kakor hitro se zaveste, da ste prelomili specifikacijo semantičnih verzij, popravite
problem in izdajte novo manjšo verzijo, ki popravi problem in
povrne združljivost za nazaj. Tudi pod temi okoliščinami, ni
sprejemljivo spreminjati verzij izdaj. Če je primerno,
dokumentirajte kršeno izdajo in obvestite vaše uporabnike o problemu, da so
seznanjeni o kršeni izdaji.

Kaj naj naredim, če posodobim svoje lastne odvisnosti brez spremembe javnega API-ja?

To bi moralo biti smatrano kompatibilno, ker ne vpliva na javni API.
Programska oprema, ki je eksplicitno odvisna od istih odvistnosti, bi vaš paket
moral imeti svoje lastne specifikacije odvisnosti in avtor bo opazil kakršnekoli
konflikte. Določanje ali je sprememba modifikacije nivoja popravka ali manjšega nivoja
zavisi na tem ali posodabljate vaše odvisnosti z namenom popraviti hrošč ali dodati novo
funkcionalnost. Običajno bi pričakoval dodatno kodo
za slednjo instanco, v katerem primeru je očitno povečanje manjšega nivoja.

Kaj če nehote spremenim javni API na način, ki ni skladen s spremembo številke verzije (t.j. koda nepravilno predstavi glavno zlomljivo spremembo v izdaji popravka)?

Uporabite vašo najboljšo presojo. Če imate veliko občinstvo, ki bo močno
vplivano s spreminjanjem obnašanja nazaj k čemur je bil javni API namenjen, potem
je lahko najboljše opraviti glavno verzijo izdaje, četudi bi popravek
striktno bil smatran za izdajo popravka. Spomnimo se, semantične verzije so samo
transportiranje, kar pomeni za koliko se številka verzije spremeni. Če so te
verzije pomembne za vaše uporabnike, uporabite številko verzije, da jih obvestite.

Kako ravnam z opuščenimi funkcionalnostmi?

Opuščanje obstoječe funkcionalnosti je običajen del razvoja programske opreme in
je pogosto zahtevano za narediti, da se naredi nadaljnji razvoj. Ko opuščate del vašega
javnega API-ja, bi morali narediti dve stvari: (1) posodobiti vašo dokumentacijo, da
obvestite uporabnike o spremembi, (2) izdati novo manjšo verzijo z opuščenostjo
na mestu. Preden v celoti odstranite funkcionalnost v novi glavni izdaji
bi morala biti vsaj ena manjša izdaja, ki vsebuje opuščenost, da
lahko uporabniki gladko preidejo na nov API.

Ali ima semver omejitev velikosti na nizu verzije?

Ne, vendar uporabite dobro presojo. Na primer verzija z 255 dolgim nizom je verjetno pretiravanje.
Tudi določeni sistemi lahko nalagajo njihove lastne omejitve na velikosti
niza.

O projektu

Specifikacija sementičnih verzij je avtorizirana s strani Toma
Preston-Werner-ja, izumitelja Gravatarjev in
soustanovitelja GitHub-a.

Slovenski prevod so prispevali:


  Peter Kokot
  Aleš Šarkanj


Če želite pustiti povratne informacije, prosimo, da odprete vprašanje na
GitHub-u.

Licenca

Creative Commons ― CC BY 3.0\nSemantične verzije 2.0.0\nDane številke verzij GLAVNA.MANJŠA.POPRAVEK povečajte:\nGLAVNO verzijo, ko naredite nazaj nezdružljive spremembe API-ja,\nMANJŠO verzijo, ko dodate funkcionalnost na način združljivosti za
nazaj in\nPOPRAVEK verzije, ko naredite popravke hroščev z združljivostjo za nazaj.\nDodatne oznake za pred-izdaje in metapodatki gradnje so na voljo kot razširitve v obliki GLAVNA.MANJŠA.POPRAVEK.\nV svetu programske opreme obstaja grozen prostor imenovan
“pekel odvisnosti”. Večji kot sistem zraste in več je paketov,
ki jih integrirate v vašo programsko opremo, bolj možno se boste našli nekega
dne v tem obupu.\nV sistemih z veliko odvisnostmi lahko izdaja nove verzije paketa hitro
postane nočna mora. Če so specifikacije odvisnosti preveč ozke, ste v
nevarnosti zaklenjenih verzij (nezmožnost nadgradnje paketa brez, da
izdajate nove verzije za vsak odvisni paket). Če so odvisnosti
določene preveč ohlapno, boste neizogibno ugriznjeni s strani promiskuitete verzije
(ob predpostavki, da je združljivost z večimi prihodnjimi verzijami razumna).
Pekel odvisnosti je, kjer ste vi, ko je verzija zaklenjena in/ali vam promiskuiteta verzije
preprečuje, da enostavno in varno prestavite vaš projekt naprej.\nKot rešitev tega problema, predlagam enostaven skupek pravil in
zahtev, ki diktirajo, kako naj bodo številke verzij določene in povečane.
Ta pravila so osnovana na in ne nujno omejena na pred obstoječe
široko skupne prakse v uporabi tako v programski opremi zaprte kode kot odprte kode.
Da ta sistem deluje, morate najprej določiti javni API. To lahko sestoji
iz dokumentacije ali je izvršeno s strani same kode. Ne glede na to,
pomembno je, da je ta API jasen in točen. Ko enkrat identificirate vaš javni
API, lahko komunicirate spremembe na njem z določenimi povečanji na vaši številki
verzije. Smatrajte obliko verzije X.Y.Z (Glavna.Manjša.Popravek). Popravki hroščev ne
vplivajo na API a povečujejo številko popravka, nazaj združljivi API
dodatki/spremembe povečujejo manjšo verzijo in nazaj nezdružljive API
spremembe povečujejo glavno verzijo.\nTa sistem se imenuje “Semantične verzije.” Pod to shemo, številke verzij
in način, kako spreminjajo poslani pomen o podležeči kodi in kaj je bilo
spremenjeno iz ene verzije v naslednji.\nSpecifikacija semantičnih verzij (SemVer)\nKljučne besede “MORA”, “NE SME”, “ZAHTEVANO”, “BO”, “NE BO”, “BI MORALO”,
“NE BI SMELO”, “PRIPOROČLJIVO”, “LAHKO” in “OPCIJSKO” se v tem dokumentu
interpretira, kot so opisane v RFC 2119.\nProgramska oprema, ki uporablja semantične verzije MORA določiti javni API. Ta API
je lahko določen v sami kodi ali obstaja striktno v dokumentaciji.
Kakorkoli je končan, bi moral biti točen in celovit.\nProgramska oprema, ki uporablja semantične verzije MORA določiti javni API. Ta API
je lahko določen v sami kodi ali obstaja striktno v dokumentaciji.
Kakorkoli je končan, bi moral biti točen in celovit.\nObičajna številka verzije MORA biti oblike X.Y.Z, kjer so X, Y, in Z
pozitivna cena števila in NE SMEJO vsebovati vodilnih ničel. X je
glavna verzija, Y je manjša verzija in Z je verzija popravka.
Vsak element se MORA povečati numerično. Na primer: 1.9.0 -> 1.10.0 -> 1.11.0.\nObičajna številka verzije MORA biti oblike X.Y.Z, kjer so X, Y, in Z
pozitivna cena števila in NE SMEJO vsebovati vodilnih ničel. X je
glavna verzija, Y je manjša verzija in Z je verzija popravka.
Vsak element se MORA povečati numerično. Na primer: 1.9.0 -> 1.10.0 -> 1.11.0.\nKo je enkrat paket verzije izdan, se vsebina te verzija
NE SME spremeniti. Kakršnekoli spremembe MORAJO biti izdane kot nova verzija.\nKo je enkrat paket verzije izdan, se vsebina te verzija
NE SME spremeniti. Kakršnekoli spremembe MORAJO biti izdane kot nova verzija.\nGlavna verzija nič (0.y.z) je za začetni razvoj. Karkoli se lahko spremeni
kadarkoli. Javni API ne bi smel biti smatran za stabilnega.\nGlavna verzija nič (0.y.z) je za začetni razvoj. Karkoli se lahko spremeni
kadarkoli. Javni API ne bi smel biti smatran za stabilnega.\nVerzija 1.0.0 definira javni API. Način, kako je številka verzija
povečana za to izdajo je odvisno od tega javnega API-ja in kako se
spremeni.\nVerzija 1.0.0 definira javni API. Način, kako je številka verzija
povečana za to izdajo je odvisno od tega javnega API-ja in kako se
spremeni.\nVerzija popravka Z (x.y.Z | x > 0) MORA biti povečana, če so predstavljeni samo nazaj
združljivi popravki hroščev. Popravek hrošča je definiran kot notranja
sprememba, ki popravi nepravilno obnašanje.\nVerzija popravka Z (x.y.Z | x > 0) MORA biti povečana, če so predstavljeni samo nazaj
združljivi popravki hroščev. Popravek hrošča je definiran kot notranja
sprememba, ki popravi nepravilno obnašanje.\nManjša verzija Y (x.Y.z | x > 0) MORA biti povečana, če so nove nazaj
združljive funkcionalnosti predstavljene javnemu API-ju. MORA biti
povečana, če je katerakoli funkcionalnost javnega API-ja označena za opuščeno. LAHKO
je povečana, če so znatna nova funkcionalnost ali izboljšave predstavljene
znotraj privatne kode. LAHKO vključuje spremembe nivoja popravka. Verzija popravka
MORA biti ponastavljena na nič, ko je manjša verzija povečana.\nManjša verzija Y (x.Y.z | x > 0) MORA biti povečana, če so nove nazaj
združljive funkcionalnosti predstavljene javnemu API-ju. MORA biti
povečana, če je katerakoli funkcionalnost javnega API-ja označena za opuščeno. LAHKO
je povečana, če so znatna nova funkcionalnost ali izboljšave predstavljene
znotraj privatne kode. LAHKO vključuje spremembe nivoja popravka. Verzija popravka
MORA biti ponastavljena na nič, ko je manjša verzija povečana.\nGlavna verzija X (X.y.z | X > 0) MORA biti povečevana, če je kakršnakoli nazaj
nezdružljiva sprememba predstavljena javnemu API-ju. LAHKO vključuje spremembe
manjše verzije in verzije popravka. Manjša verzija in popravek MORATA biti ponastavljena na 0, ko je
glavna verzija povečana.\nGlavna verzija X (X.y.z | X > 0) MORA biti povečevana, če je kakršnakoli nazaj
nezdružljiva sprememba predstavljena javnemu API-ju. LAHKO vključuje spremembe
manjše verzije in verzije popravka. Manjša verzija in popravek MORATA biti ponastavljena na 0, ko je
glavna verzija povečana.\nVerzija pred-izdaje je LAHKO označena z dodajanjem vezaja in
serije s pikami ločenih identifikatorjev, ki jim takoj sledi verzija
popravka. Identifikatorji MORAJO biti sestavljeni iz samo alfanumeričnih ASCII-jev in vezaja
[0-9A-Za-z-]. Identifikatorji NE SMEJO biti prazni. Numerični identifikatorji NE
SMEJO vključevati vodilnih ničel. Verzije pred-izdaj imajo manjši
vrstni red, ko povezana običajna verzija. Verzija pred-izdaje
označuje, da je verzija nestabilna in lahko ne zadosti
namenjenim zahtevam združljivosti, kot je označeno z njihovimi povezanimi
normalnimi verzijami. Na primer: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.\nVerzija pred-izdaje je LAHKO označena z dodajanjem vezaja in
serije s pikami ločenih identifikatorjev, ki jim takoj sledi verzija
popravka. Identifikatorji MORAJO biti sestavljeni iz samo alfanumeričnih ASCII-jev in vezaja
[0-9A-Za-z-]. Identifikatorji NE SMEJO biti prazni. Numerični identifikatorji NE
SMEJO vključevati vodilnih ničel. Verzije pred-izdaj imajo manjši
vrstni red, ko povezana običajna verzija. Verzija pred-izdaje
označuje, da je verzija nestabilna in lahko ne zadosti
namenjenim zahtevam združljivosti, kot je označeno z njihovimi povezanimi
normalnimi verzijami. Na primer: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92.\nMetapodatki gradnje so LAHKO označeni z dodajanjem znaka plus in serije pik
ločenih identifikatorjev, ki jim takoj sledi popravek ali verzija pred-izdaje.
Identifikatorji MORAJO biti sestavljeni iz samo alfanumeričnih ASCII-jev in vezajev [0-9A-Za-z-].
Identifikatorji NE SMEJO biti prazni. Podatki metagradnje BI MORALI biti ignorirani, ko se določa
vrstni red verzij. Zato dve verziji, ki se razlikujeta samo v metapodatkih gradnje,
imata enak vrstni red. Na primer: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85.\nMetapodatki gradnje so LAHKO označeni z dodajanjem znaka plus in serije pik
ločenih identifikatorjev, ki jim takoj sledi popravek ali verzija pred-izdaje.
Identifikatorji MORAJO biti sestavljeni iz samo alfanumeričnih ASCII-jev in vezajev [0-9A-Za-z-].
Identifikatorji NE SMEJO biti prazni. Podatki metagradnje BI MORALI biti ignorirani, ko se določa
vrstni red verzij. Zato dve verziji, ki se razlikujeta samo v metapodatkih gradnje,
imata enak vrstni red. Na primer: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85.\nVrstni red se sklicuje na to, kako so verzije primerjane druga z drugo, ko so urejene.
Vrstni red MORA biti izračunan z ločitvijo verzije v glavno, manjšo, popravek
in identifikator pred-izdaje v tem vrstnem redu (metapodatki gradnje ne pašejo
v vrstni red). Vrstni red je določen s prvo razliko, ko
primerjate vsako od teh identifikatorjev iz leve proti desni kot sledi: Verzije glavna, manjša
in popravek so vedno primerjane s številkami. Na primer: 1.0.0 < 2.0.0 <
2.1.0 < 2.1.1. Ko so glavna, manjša in popravek enake, ima verzija pred-izdaje
manjši vrstni red kot običajne izdaje. Na primer 1.0.0-alpha < 1.0.0. Vrstni red
za dve verziji pred-izdaje z enako verzijo glavne, manjše in popravka MORATA
biti določeli s primerjanjem vsake pike ločenega identifikatorja iz leve proti desni
dokler ni razlika najdena kot sledi: identifikatorji sestavljeni iz samo številk
so primerjani numerično in identifikatorji s črkami ali vezaji so primerjani
besedno v ASCII vrstnem redu. Numerični identifikatorji imajo vedno manjši vrstni red
kot ne-numerični identifikatorji. Večji skupek polj pred-izdaje imajo večji
vrstni red kot manjši skupek, če vsi prejšnji identifikatorji so enaki.
Na primer: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nVrstni red se sklicuje na to, kako so verzije primerjane druga z drugo, ko so urejene.
Vrstni red MORA biti izračunan z ločitvijo verzije v glavno, manjšo, popravek
in identifikator pred-izdaje v tem vrstnem redu (metapodatki gradnje ne pašejo
v vrstni red). Vrstni red je določen s prvo razliko, ko
primerjate vsako od teh identifikatorjev iz leve proti desni kot sledi: Verzije glavna, manjša
in popravek so vedno primerjane s številkami. Na primer: 1.0.0 < 2.0.0 <
2.1.0 < 2.1.1. Ko so glavna, manjša in popravek enake, ima verzija pred-izdaje
manjši vrstni red kot običajne izdaje. Na primer 1.0.0-alpha < 1.0.0. Vrstni red
za dve verziji pred-izdaje z enako verzijo glavne, manjše in popravka MORATA
biti določeli s primerjanjem vsake pike ločenega identifikatorja iz leve proti desni
dokler ni razlika najdena kot sledi: identifikatorji sestavljeni iz samo številk
so primerjani numerično in identifikatorji s črkami ali vezaji so primerjani
besedno v ASCII vrstnem redu. Numerični identifikatorji imajo vedno manjši vrstni red
kot ne-numerični identifikatorji. Večji skupek polj pred-izdaje imajo večji
vrstni red kot manjši skupek, če vsi prejšnji identifikatorji so enaki.
Na primer: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nZakaj uporabljati semantične verzije?\nTo ni nova ali revolucionarna ideja. V bistvu delate nekaj podobnega
temu že sedaj. Problem je, da “nekaj podobnega” ni dovolj dobro. Brez
skladnosti z nekakšno uradno specifikacijo, so številke verzij
v bistvu neuporabne za upravljanje odvisnosti. Z dodajanjem imena in jasne
definicije zgornjim idejam, postane enostavno za komunicirati vaše namere
uporabnikom vaše programske opreme. Ko enkrat postanejo te namere jasne, fleksibilne (vendar
ne preveč fleksibilne), se lahko končno naredi specifikacija odvisnosti.\nEnostaven primer bo demonstriral, kako semantične verzije lahko naredijo pekel
odvisnosti stvar preteklosti. Premislite o knjižnici imenovani “Firetruck”. Zahteva
paket s semantično verzijo in se imenuje “Ladder”. Ko je Firetruck
narejen, je Ladder pri verziji 3.1.0, lahko varno določite verzijo odvisnosti Ladder
kot večjo ali enako 3.1.0, vendar manjšo kot 4.0.0. Sedaj ko postane
Ladder verzija 3.1.1 in 3.2.0 postane na voljo, jih lahko izdate v vašem
sistemu paketnega upravljanja in veste, da bodo postale kompatibilne z obstoječo
odvisno programsko opremo.\nKot odgovoren razvijalec boste seveda želeli preveriti, da katerikoli
paket nadgradnje funkcionira, kot je oglaševano. Realni svet je grdo mesto;
ničesar ni, kar bi lahko naredili o tem, razen da smo pazljivi. Kar lahko naredite je
omogočiti semantičnim verzijam, da vam ponudijo pameten način izdaje in nadgradnje
paketov brez, da morate kotaliti nove verzije odvisnih paketov, kar vam prihrani
čas in težave.\nČe to vse zveni zaželjeno, je vse kar morate storiti, da začnete uporabljati semantične
verzije, razglasitev, da to tako delate in nato slediti pravilom. Povežite
na to spletno stran iz vaše datoteke README, da ostali vedo pravila in jih lahko
koristijo.\nKako ravnam z revizijami v 0.y.z začetni fazi razvoja?\nNajenostavnejše narediti je začeti vašo začetno razvojno izdajo pri 0.1.0
in nato povečevati manjše verzije za vsako naknadno izdajo.\nKako vem, kdaj izdati 1.0.0?\nČe je vaša programska oprema uporabljena v produkciji, bi morala verjeno že biti
1.0.0. Če imate stabilni API od katerega so postali uporabniki odvisni, bi morali
imeti 1.0.0. Če vas skrbi veliko o združljivosti za nazaj, bi morali verjetno
že biti na 1.0.0.\nAli to ne odvrača hitrega razvoja in hitrih interacij?\nGlavna verzija nič je vse o hitrem razvoju. Če spreminjate API
vsak dan, bi morali ali biti še vedno na verziji 0.y.z ali na ločeni
razvojni veji delati na naslednji glavni verziji.\nČe tudi najmanjša nazaj nezdružljiva sprememba javnega API-ja zahteva povečanje glavne verzije, ali ne bom potem končal pri verziji 42.0.0 zelo hitro?\nTo je vprašanje odgovornega razvoja in vpogleda vnaprej. Nezdružljive
spremembe ne bi smele biti predstavljene ohlapno v programsko opremo, ki ima
veliko odvisne kode. Cena, ki mora nastati za nadgradnjo, je lahko pomembna.
Povečanje glavnih verzij za izdajo nekompatibilnih sprememb pomeni, da boste
premislili skozi vpliv vaših sprememb in ocenili vpleteno razmerje
cena/korist.\nDokumentiranje celotnega javnega API-ja je preveč dela!\nVaša odgovornost kot profesionalnega razvijalca je, da ustrezno dokumentirate
programsko opremo, ki je nameravana za uporabo s strani drugih. Upravljanje kompleksnosti programske opreme je
zelo pomemben del, da obdržite projekt učinkovit in to narediti je težko, če
nihče ne ve, kako uporabiti vašo programsko opremo ali katere metode so varne za klicanje. Na
dolgi rok semantične verzije in vztrajanje na dobro definiranem javnem
API-ju lahko obdrži poganjanje vsakogar in vsega gladko.\nKaj narediti, če ponesreči izdam nazaj nezdružljivo spremembo kot manjšo verzijo?\nKakor hitro se zaveste, da ste prelomili specifikacijo semantičnih verzij, popravite
problem in izdajte novo manjšo verzijo, ki popravi problem in
povrne združljivost za nazaj. Tudi pod temi okoliščinami, ni
sprejemljivo spreminjati verzij izdaj. Če je primerno,
dokumentirajte kršeno izdajo in obvestite vaše uporabnike o problemu, da so
seznanjeni o kršeni izdaji.\nKaj naj naredim, če posodobim svoje lastne odvisnosti brez spremembe javnega API-ja?\nTo bi moralo biti smatrano kompatibilno, ker ne vpliva na javni API.
Programska oprema, ki je eksplicitno odvisna od istih odvistnosti, bi vaš paket
moral imeti svoje lastne specifikacije odvisnosti in avtor bo opazil kakršnekoli
konflikte. Določanje ali je sprememba modifikacije nivoja popravka ali manjšega nivoja
zavisi na tem ali posodabljate vaše odvisnosti z namenom popraviti hrošč ali dodati novo
funkcionalnost. Običajno bi pričakoval dodatno kodo
za slednjo instanco, v katerem primeru je očitno povečanje manjšega nivoja.\nKaj če nehote spremenim javni API na način, ki ni skladen s spremembo številke verzije (t.j. koda nepravilno predstavi glavno zlomljivo spremembo v izdaji popravka)?\nUporabite vašo najboljšo presojo. Če imate veliko občinstvo, ki bo močno
vplivano s spreminjanjem obnašanja nazaj k čemur je bil javni API namenjen, potem
je lahko najboljše opraviti glavno verzijo izdaje, četudi bi popravek
striktno bil smatran za izdajo popravka. Spomnimo se, semantične verzije so samo
transportiranje, kar pomeni za koliko se številka verzije spremeni. Če so te
verzije pomembne za vaše uporabnike, uporabite številko verzije, da jih obvestite.\nKako ravnam z opuščenimi funkcionalnostmi?\nOpuščanje obstoječe funkcionalnosti je običajen del razvoja programske opreme in
je pogosto zahtevano za narediti, da se naredi nadaljnji razvoj. Ko opuščate del vašega
javnega API-ja, bi morali narediti dve stvari: (1) posodobiti vašo dokumentacijo, da
obvestite uporabnike o spremembi, (2) izdati novo manjšo verzijo z opuščenostjo
na mestu. Preden v celoti odstranite funkcionalnost v novi glavni izdaji
bi morala biti vsaj ena manjša izdaja, ki vsebuje opuščenost, da
lahko uporabniki gladko preidejo na nov API.\nAli ima semver omejitev velikosti na nizu verzije?\nNe, vendar uporabite dobro presojo. Na primer verzija z 255 dolgim nizom je verjetno pretiravanje.
Tudi določeni sistemi lahko nalagajo njihove lastne omejitve na velikosti
niza.\nSpecifikacija sementičnih verzij je avtorizirana s strani Toma
Preston-Werner-ja, izumitelja Gravatarjev in
soustanovitelja GitHub-a.\nToma
Preston-Werner-ja\nSlovenski prevod so prispevali:\nČe želite pustiti povratne informacije, prosimo, da odprete vprašanje na
GitHub-u.\nodprete vprašanje na
GitHub-u\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSemantičko Verzionisanje 2.0.0

Sažetak

Za dati broj verzije MAJOR.MINOR.PATCH, inkrementirajte:


  MAJOR (GLAVNU) verziju kada unesete nekompatibilne izmene API-ja
  MINOR (MANJU) verziju kada dodate unazad kompatibilnu funkcionalnost
  PATCH (ZAKRPU) verziju kada dodate unazad kompatibilne ispravke bug-ova (grešaka)


Dodatne oznake za predizdanja i metapodatke build-a (izrade) dostupne su kao proširenja
u formatu MAJOR.MINOR.PATCH.

Uvod

U svetu upravljanja softverom postoji užasno mesto koje nazivamo
„pakao zavisnosti“. Kako vaš sistem raste i što više paketa
integrišete u svoj softver, veća je verovatnoća da ćete se naći
u ovom stanju dubokog očaja.

U sistemima sa mnoštvom zavisnosti, objavljivanje novih verzija paketa može brzo
postati košmar. Ako su specifikacije zavisnosti suviše stroge, nalazite se u opasnosti
od zaključavanja verzije (nemogućnost nadogradnje paketa bez neophodne
objave nove verzije svakog zavisnog paketa). Takođe, ako su specifikacije zavisnosti isuviše labave, neizbežno će vas dovesti u situaciju verzijskog promiskuiteta
(pod pretpostavkom kompatibilnosti sa više budućih verzija nego što je razumno).
Pakao zavisnosti je situacija u kojoj se nalazite kada zaključavanje verzije i/ili verzijski promiskuitet sprečavaju jednostavno i bezbedno napredovanje projekta.

Kao rešenje ovog problema, predlažemo jednostavan skup pravila i
zahteva koji diktiraju kako se brojevi verzija dodeljuju i inkrementiraju.
Ova pravila su zasnovana, ali nisu nužno ograničena na već postojeće i
široko rasprostranjene uobičajene prakse koje se koriste u closed i open-source
softveru. Kako bi ovaj sistem funkcionisao, neophodno je prvo objaviti public (javni) API.
Možemo to primeniti u dokumentaciji ili u samom kodu. U svakom slučaju, važno je da
API bude jasan i precizan. Jednom kad identifkujemo public API, izmene prenosimo
kroz specifikovane inkrementacije broja verzije.
Razmotrimo format verzije X.Y.Z (Major.Minor.Patch). Ispravke bug-ova (grešaka) koji
ne utiču na API inkrementiraju patch (zakrpa) verziju, a unazad nekompatibilne promene API-ju inkrementiraju major (glavnu) verziju.

Ovaj sistem nazivamo „Semantičko Verzionisanje“. Prema ovoj šemi, brojevi verzija
i način na koji se menjaju daju informacije o osnovnom kodu koji se nalazi pod datom verzijom, kao i šta se menjalo od jedne verzije do sledeće.

Specifikacija Semantičkog Verzionisanja (SemVer)

Ključne reči “MUST” (“MORA”), “MUST NOT” (“NE SME”), “REQUIRED (“NEOPHODNO”), “SHALL”(“HOĆE”), “SHALL NOT” (“NEĆE”),”SHOULD” (“TREBA”), “SHOULD NOT” (“NE TREBA”), “RECOMMENDED” (“PREPORUČENO”), “MAY” (“MOŽE”) i “OPTIONAL” (“OPCIONO”) u ovom dokumentu treba tumačiti kako je opisano u RFC 2119.


  
    Softver koji koristi Semantičko Verzionisanje MUST (MORA) objaviti publlic (javni) API. Ovaj API može biti deklarisan u samom kodu ili postojati striktno u dokumentaciji.
U svakom slučaju, SHOULD (TREBA) da bude precizan i sveobuhvatan.
  
  
    Normalna oznaka verzije MUST (MORA) biti u formatu X.Y.Z gde su X, Y i Z ne-negativni
celi brojevi i ne smeju počinjati sa nulom. X označava glavnu verziju, Y manju
verziju, a Z zakrpu. Svaki element MUST (MORA) se numerički inkrementirati.
Na primer: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Jednom kad je verzionisani paket objavljen, sadržaj te verzije MUST NOT (NE SME) se
menjati. Svaka izmena MUST (MORA) se objavljivati kao nova verzija.
  
  
    MAJOR (GLAVNA) verzija nula (0.y.z) je za inicijalni razvoj. Bilo šta se MAY (MOŽE) menjati
u svakom trenutku. Ovaj public (javni) API SHOULD NOT (NE TREBA) smatrati stabilnim.
  
  
    Verzija 1.0.0 definiše public (javni) API. Način na koji će se oznaka verzije
inkrementirati nakon ove objave zavisi od ovog public (javnog) API-ja i izmena na njemu.
  
  
    Patch (zakrpa) verzija Z (x.y.Z | x > 0) MUST (MORA) se inkrementirati kada se dodaju samo unazad kompatibilne ispravke bug-ova (gresaka). Ispravke bug-ova (gresaka) su definisane kao promene koda
koje ispravljaju nepravilno ponašanje.
  
  
    
      
        
          Minor (manja) verzija Y (x.Y.z
          x > 0) MUST (MORA) se inkrementirati ako je nova, unazad kompatibilna funkcionalnost uvedena u javni API. Takođe MUST (MORA) se inkrementirati kada se neka od funkcionalnosti API-ja označi kao deprecated (zastarela). MAY (MOŽE) biti inkrementirana ukoliko se uvedu substancijalno nove funkcionalnosti ili poboljšanja u okviru privatnog koda. MAY (MOŽE) uključivati promene nivoa patch (zakrpe). Patch (Zakrpa) verzija MUST (MORA) se resetovati na 0 kada se minor (manja) verzija inkrementira.
        
      
    
  
  
    Major (glavna) verzija X (X.y.z | X > 0) MUST (MORA) se inkrementirati ako se unazad nekompatibilne promene uvode u javni API. MAY (MOŽE) uključivati i promene minor (manje) i promene na nivou patch
(zakrpe) verzije. Patch (zakrpe) i minor (manje) verzije MUST (MORA) da se resetuju na 0 kada se
major (glavna) verzija inkrementira.
  
  
    Verzija predizdanja MAY (MOŽE) biti označena dodavanjem hyphen-a (povlake) i serijom identifikatora razdvojenih tačkom neposredno nakon patch (zakrpe) verzije. Identifikatori MUST (MORAJU) sadržati samo ASCII alfanumeričke znakove i hyphen-e (povlake)
[0-9A-Za-z-]. Identifikatori MUST NOT (NE SMEJU) biti prazni. Numerički identifikatori MUST NOT (NE SMEJU) počinjati nulom. Verzije predizdanja imaju niži prioritet od povezane normalne verzije. Verzija predizdanja označava da je verzija nestabilna i da možda neće biti zadovoljeni predviđeni zahtevi kompatibilnosti kao što je označeno njenom povezanom normalnom verzijom. Primeri: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.--.
  
  
    Metadata (metapodaci) build-a (izrade) MAY (MOGU) biti označeni dodavanjem znaka plus
i niza identifikatora odvojenih tačkom, koji se odmah nastavljaju na patch (zakrpu) verziju ili verziju predizdanja. Identifikatori MUST (MORAJU) da sadrže iskljucivo ASCII alfanumeričke znakove i hyphen-e (povlake) [0-9A-Za-z-]. Identifikatori MUST NOT (NE SMEJU) da budu prazni. Metadata (metapodaci) o build-u (izgradnji) MUST (MORAJU) se zanemariti prilikom određivanja prioriteta verzije. Prema tome dve verzije koje se razlikuju samo u metapodacima build-a (izrade), imaju isti prioritet. Primeri:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85,
1.0.0+21AF26D3----117B344092BD.
  
  
    Prioritet se odnosi na način kojim se verzije u poretku međusobno upoređuju.

    
      
        Prioritet se MUST (MORA) izračunati razdvajanjem verzije na major (glavne),
 minor (manje), patch (zakrpe) i identifikatore predizdanja (metadata (metapodaci) build-a (izrade) nemaju ulogu u određivanju prioriteta).
      
      
        Prioritet se određuje prvom razlikom kada se upoređuje svaki od identifikatora sa leva na desno:
major (glavni), minor (manji) i patch (zakrpa). Verzije se uvek upoređuju brojčano.

        Primer: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Kada su major (glavna), minor (manja) i patch (zakrpa) jednake, verzija predizdanja ima niži
prioritet od normalne verzije.

        Primer: 1.0.0-alpha < 1.0.0.
      
      
        Prioritet između dve verzije predizdanja sa jednakim major (glavnom), minor (manjom) i patch
(zakrpom) MUST (MORA) biti određen upoređivanjem svakog identifikatora razdvojenog tačkama sa leva na desno dok se ne pronađe razlika na sledeći način:

        
          
            Identifikatori koji se sastoje samo od cifara upoređuju se numerički.
          
          
            Identifikatori sa slovima ili hyphen-ima (povlakama) se upoređuju leksički u ASCII
  poretku.
          
          
            Numerički identifikatori uvek imaju niži prioritet od nenumeričkih
  identifikatora.
          
          
            Veći skup oznaka predizdanja ima viši prioritet od manjeg skupa, ako su svi prethodni
  identifikatori jednaki.
          
        

        Primer: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
  1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
      
    
  


Backus–Naur Gramatički Obrazac za Validne SemVer Verzije

<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


Zašto koristiti Semantičko Verzionisanje?

Ovo nije nova ili revolucionarna ideja. Tačnije, verovatno već radite nešto vrlo slično. Problem je što nešto “slično” nije dovoljno dobro. Bez usaglašenosti sa nekom vrstom formalne specifikacije, brojevi verzija su
u suštini beskorisni za upravljanje zavisnostima. Davanjem imena i jasne
definicije gore navedenih ideja, postaje lako preneti svoje namere
korisnicima vašeg softvera. Jednom kada su ove namere jasne, fleksibilne (ali
ne previše fleksibilne) specifikacije zavisnosti konačno je moguće napraviti.

Jednostavan primer može pokazati kako pakao zavisnosti uz Semantičko Verzionisanje ostaje stvar prošlosti. Zamislite library (biblioteku) pod nazivom “Vatrogasno_vozilo”. Neophodan joj je Semantičko Verzionisani paket pod nazivom “Merdevine”. U trenutku kreiranja Vatrogasno_vozilo, Merdevine su u verziji 3.1.0. Pošto Vatrogasno_vozilo koristi neke funkcije prvobitno uvedene
u 3.1.0, možete bezbedno specifikovati zavisnost od Merdevine kao veću ili jednaku 3.1.0, ali manju od 4.0.0. Sada, kada Merdevine verzije 3.1.1 i 3.2.0 postanu dostupne, možete ih uneti u svoj sistem upravljanja paketima i biti siguni da će biti kompatibilni sa postojećim zavisnim softverom.

Kao odgovoran programer, vi ćete, naravno, želeti da verifikujete da li upgrade (nadgradnje) paketa funkcionišu kako je navedeno. Stvarni svet je mahom neuređeno mesto; ne možemo ništa uraditi povodom toga osim da budemo oprezni.
Ono što možemo uciniti je da usvojimo Semantičko Verzionisanje koje nam pruža razuman način za objavljivanje i nadogradnju paketa, bez potrebe za pokretanjem novih verzija zavisnih paketa, štedeći vreme i trud.

Ako vam ovo zvuči poželjno, sve što je potrebno uraditi da biste počeli da koristite Semantičko Verzionisanje je da se deklarišete kao korisnik i da potom
sledite pravila. Linkujte ovaj website sa vašim README-ma tako da bi i drugi bili svesni pravila i mogu imati koristi od njih.

FAQ

Kako se nositi sa revizijama 0.y.z u inicijalnoj fazi razvoja?

Najjednostavniji način je da započnete inicijalni razvoj objavom verzije
0.1.0 i potom inkrementirate oznaku minor (manje) verzije za svako sledeće izdanje.

Kako da znamo kada treba objaviti verziju 1.0.0??

Ako se softver koristi u produkciji, već bi verovatno trebalo biti 1.0.0. Ako već imate stabilni API, na koji se korisnici mogu pouzdati, trebalo bi
biti 1.0.0. Ukoliko ste prilično zabrinuti oko kompatibilnosti unazad, softver
bi već trebalo da je objavljen pod verzijom 1.0.0.

Zar to ne obeshrabruje rapidan razvoj i brzu iteraciju?

Major (glavna) verzija nula je zapravo predodređena rapidnom razvoju. Ako menjate API svaki dan, trebalo bi ostati na verziji 0.y.z ili na posebnoj grani za razvoj raditi na sledećoj major (glavnoj) verziji.

Ukoliko i najsitnije unazad nekompatibilne izmene u API-ju zahtevaju naglo uvećavanje major (glavne) verzije, nećemo li vrlo brzo doći do verzije 42.0.0?

Ovo je pitanje odgovornog razvoja i predviđanja. U softver koji ima puno
zavisnog koda, nekompatibilne promene ne treba olako uvoditi. Troškovi
nadogradnje mogu biti značajni. Ako morate povećati major (glavnu) verziju, kako biste objavili verziju sa nekompatibilnim izmenama, morate razmisliti o uticaju tih izmena i proceniti odnos uključenih troškova i koristi.

Dokumentacija celokupnog public (javnog) API-ja zahteva previše posla

Vaša je odgovornost kao profesionalnih programera da pravilno dokumentujete
softver koji je namenjen korisnicima. Upravljanje složenošću softvera je izuzetno važan deo održavanja efikasnosti projekta, što je teško ako korisnici ne znaju kako koristiti vaš softver ili koje metode mogu bezbedno pozvati. Dugoročno, Semantičko Verzionisanje i insistiranje na kvalitetno definisanom API-ju omogućiće da svi i sve rade glatko.

Šta ukoliko slučajno objavimo unazad nekompatibilne izmene kao minor (manju) verziju?

Čim primetite da ste prekršili specifikacije Semantičkog Verzionisanja,
potrebno je ispraviti grešku pa objaviti minor (manju) verziju koja će ispraviti problem i povratiti kompatibilnost unazad. Čak i u takvim uslovima, nije prihvatljivo modifikovati verzionisane objave. Ako je prikladno, dokumentujte verziju koja krši specifikaciju i tako obavestite korisnike kako bi bili svesni toga.

Šta činiti ukoliko izmenimo sopstvene zavisnosti bez promene public (javnog) API-ja?

Takve izmene smatramo kompatibilnima jer ne utiču na public (javni) API. Softver koji
eksplicitno zavisi od istih zavisnosti kao i naš sopstveni paket treba imati vlastite specifikacije zavisnosti, a autor će primetiti eventualne konflikte. Je li promjena na nivou patch (zakrpe) ili minor (manje) verzije, zavisi od toga da li ste dodavali svoje zavisnosti kao ispravke bug-ova (grešaka) ili ste ih uveli kao nove funkcionalnosti. U posljednjem slučaju
možemo očekivati i dodatni kod, pri čemu se očigledno radi o inkrementu minor (manje) verzije.

Šta ukoliko slučajno izmenimo public (javni) API na način koji ne odgovara izmeni broja verzije (npr. u kod neispravno uvedemo veću unazad nekompatibilnu izmenu u okviru objave patch (zakrpe))?

Koristite svoju najbolju procenu. Ako imate veliki broj korisnika, na koje će
značajno uticati promena unatrag, najbolje je da objavite major (glavnu) verziju, iako
bi takav ispravak mogli smatrati izdanjem zakrpe. Zapamtite, svrha Semantičkog
Verzionisanja je prenošenje značenja putem izmene broja verzije. Ako su takve
izmene važne za vaše korisnike, koristite broj verzije da biste ih informisali.

Kako postupati sa deprecating (zastarelim) funkcionalnostima?

Postojeće funkcionalnosti koje zastarevaju, sastavni su deo razvoja softvera
i često su neophodne kako bi razvoj napredovao. Kad označavate deo public (javnog) API-ja kao deprecated (zastareli), potrebno je učiniti dve stvari: (1) ažurirati dokumentaciju kako bismo informisali korisnike, (2) objaviti novu minor (manju) verziju sa definisanim deprecated (zastarelim) delovima softvera. Pre nego što potpuno uklonite funkcionalnost u novoj major (glavnoj) verziji, potrebno je izdati barem jednu minor (manju) verziju koja sadrži deprecated (zastarele) delove, kako bi korisnici nesmetano prešli na novu verziju API-ja.

Ima li SemVer ograničenu veličinu stringa verzije?

Ne, ali procenite sami. String verzije od 255 znakova je verovatno preteran,
na primer. Takođe, neki sistemi mogu imati svoja ograničenja veličine stringa.

Da li je “v1.2.3” semantička verzija?

Ne, “v1.2.3” nije semantička verzija. Međutim, prefiksiranje semantičke verzije
sa “v” je uobičajen način (na engleskom) da se naznači da je to broj verzije.
Skraćenje “verzije” kao “v” se često vidi sa kontrolom verzija. Primer:
git tag v1.2.3 -m "Release version 1.2.3", u kom slučaju je “v1.2.3” naziv
taga (oznake), a semantička verzija je “1.2.3”.

Da li postoji predloženi regularni izraz (RegEx) za proveru SemVer stringa?

Postoje dva. Jedan sa imenovanim grupama za one sisteme koji ih podržavaju
(PCRE [Perl Compatible Regular Expressions (Perl kompatibilni regularni izrazi), tj. Perl, PHP i R], Python
i Go).

Pogledajte: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


I drugi sa numerisanim grupama (znači ng1 = major (glavna), ng2 = minor (manja),
ng3 = patch (zakrpa), ng4 = prerelease (predizdanje) i ng5 = buildmetadata (metapodaci)) koji su kompatibilni
sa ECMA Script (JavaScript), PCRE [Perl Compatible Regular Expressions (Perl kompatibilni regularni izrazi),
tj. Perl, PHP i R], Python i Go.

Pogledajte: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


O projektu

Autor specifikacije Semantičkog Verzionisanja je Tom
Preston-Werner, pronalazač Gravatar-a i suosnivač GitHub-a.

Ako želite ostaviti povratne informacije, molimo otvorite issue na
GitHub-u.

Licenca

Creative Commons ― CC BY 3.0\nSemantičko Verzionisanje 2.0.0\nZa dati broj verzije MAJOR.MINOR.PATCH, inkrementirajte:\nMAJOR (GLAVNU) verziju kada unesete nekompatibilne izmene API-ja\nMINOR (MANJU) verziju kada dodate unazad kompatibilnu funkcionalnost\nPATCH (ZAKRPU) verziju kada dodate unazad kompatibilne ispravke bug-ova (grešaka)\nDodatne oznake za predizdanja i metapodatke build-a (izrade) dostupne su kao proširenja
u formatu MAJOR.MINOR.PATCH.\nU svetu upravljanja softverom postoji užasno mesto koje nazivamo
„pakao zavisnosti“. Kako vaš sistem raste i što više paketa
integrišete u svoj softver, veća je verovatnoća da ćete se naći
u ovom stanju dubokog očaja.\nU sistemima sa mnoštvom zavisnosti, objavljivanje novih verzija paketa može brzo
postati košmar. Ako su specifikacije zavisnosti suviše stroge, nalazite se u opasnosti
od zaključavanja verzije (nemogućnost nadogradnje paketa bez neophodne
objave nove verzije svakog zavisnog paketa). Takođe, ako su specifikacije zavisnosti isuviše labave, neizbežno će vas dovesti u situaciju verzijskog promiskuiteta
(pod pretpostavkom kompatibilnosti sa više budućih verzija nego što je razumno).
Pakao zavisnosti je situacija u kojoj se nalazite kada zaključavanje verzije i/ili verzijski promiskuitet sprečavaju jednostavno i bezbedno napredovanje projekta.\nKao rešenje ovog problema, predlažemo jednostavan skup pravila i
zahteva koji diktiraju kako se brojevi verzija dodeljuju i inkrementiraju.
Ova pravila su zasnovana, ali nisu nužno ograničena na već postojeće i
široko rasprostranjene uobičajene prakse koje se koriste u closed i open-source
softveru. Kako bi ovaj sistem funkcionisao, neophodno je prvo objaviti public (javni) API.
Možemo to primeniti u dokumentaciji ili u samom kodu. U svakom slučaju, važno je da
API bude jasan i precizan. Jednom kad identifkujemo public API, izmene prenosimo
kroz specifikovane inkrementacije broja verzije.
Razmotrimo format verzije X.Y.Z (Major.Minor.Patch). Ispravke bug-ova (grešaka) koji
ne utiču na API inkrementiraju patch (zakrpa) verziju, a unazad nekompatibilne promene API-ju inkrementiraju major (glavnu) verziju.\nOvaj sistem nazivamo „Semantičko Verzionisanje“. Prema ovoj šemi, brojevi verzija
i način na koji se menjaju daju informacije o osnovnom kodu koji se nalazi pod datom verzijom, kao i šta se menjalo od jedne verzije do sledeće.\nSpecifikacija Semantičkog Verzionisanja (SemVer)\nKljučne reči “MUST” (“MORA”), “MUST NOT” (“NE SME”), “REQUIRED (“NEOPHODNO”), “SHALL”(“HOĆE”), “SHALL NOT” (“NEĆE”),”SHOULD” (“TREBA”), “SHOULD NOT” (“NE TREBA”), “RECOMMENDED” (“PREPORUČENO”), “MAY” (“MOŽE”) i “OPTIONAL” (“OPCIONO”) u ovom dokumentu treba tumačiti kako je opisano u RFC 2119.\nSoftver koji koristi Semantičko Verzionisanje MUST (MORA) objaviti publlic (javni) API. Ovaj API može biti deklarisan u samom kodu ili postojati striktno u dokumentaciji.
U svakom slučaju, SHOULD (TREBA) da bude precizan i sveobuhvatan.\nSoftver koji koristi Semantičko Verzionisanje MUST (MORA) objaviti publlic (javni) API. Ovaj API može biti deklarisan u samom kodu ili postojati striktno u dokumentaciji.
U svakom slučaju, SHOULD (TREBA) da bude precizan i sveobuhvatan.\nNormalna oznaka verzije MUST (MORA) biti u formatu X.Y.Z gde su X, Y i Z ne-negativni
celi brojevi i ne smeju počinjati sa nulom. X označava glavnu verziju, Y manju
verziju, a Z zakrpu. Svaki element MUST (MORA) se numerički inkrementirati.
Na primer: 1.9.0 -> 1.10.0 -> 1.11.0.\nNormalna oznaka verzije MUST (MORA) biti u formatu X.Y.Z gde su X, Y i Z ne-negativni
celi brojevi i ne smeju počinjati sa nulom. X označava glavnu verziju, Y manju
verziju, a Z zakrpu. Svaki element MUST (MORA) se numerički inkrementirati.
Na primer: 1.9.0 -> 1.10.0 -> 1.11.0.\nJednom kad je verzionisani paket objavljen, sadržaj te verzije MUST NOT (NE SME) se
menjati. Svaka izmena MUST (MORA) se objavljivati kao nova verzija.\nJednom kad je verzionisani paket objavljen, sadržaj te verzije MUST NOT (NE SME) se
menjati. Svaka izmena MUST (MORA) se objavljivati kao nova verzija.\nMAJOR (GLAVNA) verzija nula (0.y.z) je za inicijalni razvoj. Bilo šta se MAY (MOŽE) menjati
u svakom trenutku. Ovaj public (javni) API SHOULD NOT (NE TREBA) smatrati stabilnim.\nMAJOR (GLAVNA) verzija nula (0.y.z) je za inicijalni razvoj. Bilo šta se MAY (MOŽE) menjati
u svakom trenutku. Ovaj public (javni) API SHOULD NOT (NE TREBA) smatrati stabilnim.\nVerzija 1.0.0 definiše public (javni) API. Način na koji će se oznaka verzije
inkrementirati nakon ove objave zavisi od ovog public (javnog) API-ja i izmena na njemu.\nVerzija 1.0.0 definiše public (javni) API. Način na koji će se oznaka verzije
inkrementirati nakon ove objave zavisi od ovog public (javnog) API-ja i izmena na njemu.\nPatch (zakrpa) verzija Z (x.y.Z | x > 0) MUST (MORA) se inkrementirati kada se dodaju samo unazad kompatibilne ispravke bug-ova (gresaka). Ispravke bug-ova (gresaka) su definisane kao promene koda
koje ispravljaju nepravilno ponašanje.\nPatch (zakrpa) verzija Z (x.y.Z | x > 0) MUST (MORA) se inkrementirati kada se dodaju samo unazad kompatibilne ispravke bug-ova (gresaka). Ispravke bug-ova (gresaka) su definisane kao promene koda
koje ispravljaju nepravilno ponašanje.\nMinor (manja) verzija Y (x.Y.z
          x > 0) MUST (MORA) se inkrementirati ako je nova, unazad kompatibilna funkcionalnost uvedena u javni API. Takođe MUST (MORA) se inkrementirati kada se neka od funkcionalnosti API-ja označi kao deprecated (zastarela). MAY (MOŽE) biti inkrementirana ukoliko se uvedu substancijalno nove funkcionalnosti ili poboljšanja u okviru privatnog koda. MAY (MOŽE) uključivati promene nivoa patch (zakrpe). Patch (Zakrpa) verzija MUST (MORA) se resetovati na 0 kada se minor (manja) verzija inkrementira.\nMinor (manja) verzija Y (x.Y.z\nx > 0) MUST (MORA) se inkrementirati ako je nova, unazad kompatibilna funkcionalnost uvedena u javni API. Takođe MUST (MORA) se inkrementirati kada se neka od funkcionalnosti API-ja označi kao deprecated (zastarela). MAY (MOŽE) biti inkrementirana ukoliko se uvedu substancijalno nove funkcionalnosti ili poboljšanja u okviru privatnog koda. MAY (MOŽE) uključivati promene nivoa patch (zakrpe). Patch (Zakrpa) verzija MUST (MORA) se resetovati na 0 kada se minor (manja) verzija inkrementira.\nMajor (glavna) verzija X (X.y.z | X > 0) MUST (MORA) se inkrementirati ako se unazad nekompatibilne promene uvode u javni API. MAY (MOŽE) uključivati i promene minor (manje) i promene na nivou patch
(zakrpe) verzije. Patch (zakrpe) i minor (manje) verzije MUST (MORA) da se resetuju na 0 kada se
major (glavna) verzija inkrementira.\nMajor (glavna) verzija X (X.y.z | X > 0) MUST (MORA) se inkrementirati ako se unazad nekompatibilne promene uvode u javni API. MAY (MOŽE) uključivati i promene minor (manje) i promene na nivou patch
(zakrpe) verzije. Patch (zakrpe) i minor (manje) verzije MUST (MORA) da se resetuju na 0 kada se
major (glavna) verzija inkrementira.\nVerzija predizdanja MAY (MOŽE) biti označena dodavanjem hyphen-a (povlake) i serijom identifikatora razdvojenih tačkom neposredno nakon patch (zakrpe) verzije. Identifikatori MUST (MORAJU) sadržati samo ASCII alfanumeričke znakove i hyphen-e (povlake)
[0-9A-Za-z-]. Identifikatori MUST NOT (NE SMEJU) biti prazni. Numerički identifikatori MUST NOT (NE SMEJU) počinjati nulom. Verzije predizdanja imaju niži prioritet od povezane normalne verzije. Verzija predizdanja označava da je verzija nestabilna i da možda neće biti zadovoljeni predviđeni zahtevi kompatibilnosti kao što je označeno njenom povezanom normalnom verzijom. Primeri: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.--.\nVerzija predizdanja MAY (MOŽE) biti označena dodavanjem hyphen-a (povlake) i serijom identifikatora razdvojenih tačkom neposredno nakon patch (zakrpe) verzije. Identifikatori MUST (MORAJU) sadržati samo ASCII alfanumeričke znakove i hyphen-e (povlake)
[0-9A-Za-z-]. Identifikatori MUST NOT (NE SMEJU) biti prazni. Numerički identifikatori MUST NOT (NE SMEJU) počinjati nulom. Verzije predizdanja imaju niži prioritet od povezane normalne verzije. Verzija predizdanja označava da je verzija nestabilna i da možda neće biti zadovoljeni predviđeni zahtevi kompatibilnosti kao što je označeno njenom povezanom normalnom verzijom. Primeri: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.--.\nMetadata (metapodaci) build-a (izrade) MAY (MOGU) biti označeni dodavanjem znaka plus
i niza identifikatora odvojenih tačkom, koji se odmah nastavljaju na patch (zakrpu) verziju ili verziju predizdanja. Identifikatori MUST (MORAJU) da sadrže iskljucivo ASCII alfanumeričke znakove i hyphen-e (povlake) [0-9A-Za-z-]. Identifikatori MUST NOT (NE SMEJU) da budu prazni. Metadata (metapodaci) o build-u (izgradnji) MUST (MORAJU) se zanemariti prilikom određivanja prioriteta verzije. Prema tome dve verzije koje se razlikuju samo u metapodacima build-a (izrade), imaju isti prioritet. Primeri:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85,
1.0.0+21AF26D3----117B344092BD.\nMetadata (metapodaci) build-a (izrade) MAY (MOGU) biti označeni dodavanjem znaka plus
i niza identifikatora odvojenih tačkom, koji se odmah nastavljaju na patch (zakrpu) verziju ili verziju predizdanja. Identifikatori MUST (MORAJU) da sadrže iskljucivo ASCII alfanumeričke znakove i hyphen-e (povlake) [0-9A-Za-z-]. Identifikatori MUST NOT (NE SMEJU) da budu prazni. Metadata (metapodaci) o build-u (izgradnji) MUST (MORAJU) se zanemariti prilikom određivanja prioriteta verzije. Prema tome dve verzije koje se razlikuju samo u metapodacima build-a (izrade), imaju isti prioritet. Primeri:
1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85,
1.0.0+21AF26D3----117B344092BD.\nPrioritet se odnosi na način kojim se verzije u poretku međusobno upoređuju.

    
      
        Prioritet se MUST (MORA) izračunati razdvajanjem verzije na major (glavne),
 minor (manje), patch (zakrpe) i identifikatore predizdanja (metadata (metapodaci) build-a (izrade) nemaju ulogu u određivanju prioriteta).
      
      
        Prioritet se određuje prvom razlikom kada se upoređuje svaki od identifikatora sa leva na desno:
major (glavni), minor (manji) i patch (zakrpa). Verzije se uvek upoređuju brojčano.

        Primer: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Kada su major (glavna), minor (manja) i patch (zakrpa) jednake, verzija predizdanja ima niži
prioritet od normalne verzije.

        Primer: 1.0.0-alpha < 1.0.0.
      
      
        Prioritet između dve verzije predizdanja sa jednakim major (glavnom), minor (manjom) i patch
(zakrpom) MUST (MORA) biti određen upoređivanjem svakog identifikatora razdvojenog tačkama sa leva na desno dok se ne pronađe razlika na sledeći način:

        
          
            Identifikatori koji se sastoje samo od cifara upoređuju se numerički.
          
          
            Identifikatori sa slovima ili hyphen-ima (povlakama) se upoređuju leksički u ASCII
  poretku.
          
          
            Numerički identifikatori uvek imaju niži prioritet od nenumeričkih
  identifikatora.
          
          
            Veći skup oznaka predizdanja ima viši prioritet od manjeg skupa, ako su svi prethodni
  identifikatori jednaki.
          
        

        Primer: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
  1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPrioritet se odnosi na način kojim se verzije u poretku međusobno upoređuju.\nPrioritet se MUST (MORA) izračunati razdvajanjem verzije na major (glavne),
 minor (manje), patch (zakrpe) i identifikatore predizdanja (metadata (metapodaci) build-a (izrade) nemaju ulogu u određivanju prioriteta).\nPrioritet se MUST (MORA) izračunati razdvajanjem verzije na major (glavne),
 minor (manje), patch (zakrpe) i identifikatore predizdanja (metadata (metapodaci) build-a (izrade) nemaju ulogu u određivanju prioriteta).\nPrioritet se određuje prvom razlikom kada se upoređuje svaki od identifikatora sa leva na desno:
major (glavni), minor (manji) i patch (zakrpa). Verzije se uvek upoređuju brojčano.

        Primer: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nPrioritet se određuje prvom razlikom kada se upoređuje svaki od identifikatora sa leva na desno:
major (glavni), minor (manji) i patch (zakrpa). Verzije se uvek upoređuju brojčano.\nPrimer: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nKada su major (glavna), minor (manja) i patch (zakrpa) jednake, verzija predizdanja ima niži
prioritet od normalne verzije.

        Primer: 1.0.0-alpha < 1.0.0.\nKada su major (glavna), minor (manja) i patch (zakrpa) jednake, verzija predizdanja ima niži
prioritet od normalne verzije.\nPrimer: 1.0.0-alpha < 1.0.0.\nPrioritet između dve verzije predizdanja sa jednakim major (glavnom), minor (manjom) i patch
(zakrpom) MUST (MORA) biti određen upoređivanjem svakog identifikatora razdvojenog tačkama sa leva na desno dok se ne pronađe razlika na sledeći način:

        
          
            Identifikatori koji se sastoje samo od cifara upoređuju se numerički.
          
          
            Identifikatori sa slovima ili hyphen-ima (povlakama) se upoređuju leksički u ASCII
  poretku.
          
          
            Numerički identifikatori uvek imaju niži prioritet od nenumeričkih
  identifikatora.
          
          
            Veći skup oznaka predizdanja ima viši prioritet od manjeg skupa, ako su svi prethodni
  identifikatori jednaki.
          
        

        Primer: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
  1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nPrioritet između dve verzije predizdanja sa jednakim major (glavnom), minor (manjom) i patch
(zakrpom) MUST (MORA) biti određen upoređivanjem svakog identifikatora razdvojenog tačkama sa leva na desno dok se ne pronađe razlika na sledeći način:\nIdentifikatori koji se sastoje samo od cifara upoređuju se numerički.\nIdentifikatori koji se sastoje samo od cifara upoređuju se numerički.\nIdentifikatori sa slovima ili hyphen-ima (povlakama) se upoređuju leksički u ASCII
  poretku.\nIdentifikatori sa slovima ili hyphen-ima (povlakama) se upoređuju leksički u ASCII
  poretku.\nNumerički identifikatori uvek imaju niži prioritet od nenumeričkih
  identifikatora.\nNumerički identifikatori uvek imaju niži prioritet od nenumeričkih
  identifikatora.\nVeći skup oznaka predizdanja ima viši prioritet od manjeg skupa, ako su svi prethodni
  identifikatori jednaki.\nVeći skup oznaka predizdanja ima viši prioritet od manjeg skupa, ako su svi prethodni
  identifikatori jednaki.\nPrimer: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
  1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nBackus–Naur Gramatički Obrazac za Validne SemVer Verzije\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nZašto koristiti Semantičko Verzionisanje?\nOvo nije nova ili revolucionarna ideja. Tačnije, verovatno već radite nešto vrlo slično. Problem je što nešto “slično” nije dovoljno dobro. Bez usaglašenosti sa nekom vrstom formalne specifikacije, brojevi verzija su
u suštini beskorisni za upravljanje zavisnostima. Davanjem imena i jasne
definicije gore navedenih ideja, postaje lako preneti svoje namere
korisnicima vašeg softvera. Jednom kada su ove namere jasne, fleksibilne (ali
ne previše fleksibilne) specifikacije zavisnosti konačno je moguće napraviti.\nJednostavan primer može pokazati kako pakao zavisnosti uz Semantičko Verzionisanje ostaje stvar prošlosti. Zamislite library (biblioteku) pod nazivom “Vatrogasno_vozilo”. Neophodan joj je Semantičko Verzionisani paket pod nazivom “Merdevine”. U trenutku kreiranja Vatrogasno_vozilo, Merdevine su u verziji 3.1.0. Pošto Vatrogasno_vozilo koristi neke funkcije prvobitno uvedene
u 3.1.0, možete bezbedno specifikovati zavisnost od Merdevine kao veću ili jednaku 3.1.0, ali manju od 4.0.0. Sada, kada Merdevine verzije 3.1.1 i 3.2.0 postanu dostupne, možete ih uneti u svoj sistem upravljanja paketima i biti siguni da će biti kompatibilni sa postojećim zavisnim softverom.\nKao odgovoran programer, vi ćete, naravno, želeti da verifikujete da li upgrade (nadgradnje) paketa funkcionišu kako je navedeno. Stvarni svet je mahom neuređeno mesto; ne možemo ništa uraditi povodom toga osim da budemo oprezni.
Ono što možemo uciniti je da usvojimo Semantičko Verzionisanje koje nam pruža razuman način za objavljivanje i nadogradnju paketa, bez potrebe za pokretanjem novih verzija zavisnih paketa, štedeći vreme i trud.\nAko vam ovo zvuči poželjno, sve što je potrebno uraditi da biste počeli da koristite Semantičko Verzionisanje je da se deklarišete kao korisnik i da potom
sledite pravila. Linkujte ovaj website sa vašim README-ma tako da bi i drugi bili svesni pravila i mogu imati koristi od njih.\nKako se nositi sa revizijama 0.y.z u inicijalnoj fazi razvoja?\nNajjednostavniji način je da započnete inicijalni razvoj objavom verzije
0.1.0 i potom inkrementirate oznaku minor (manje) verzije za svako sledeće izdanje.\nKako da znamo kada treba objaviti verziju 1.0.0??\nAko se softver koristi u produkciji, već bi verovatno trebalo biti 1.0.0. Ako već imate stabilni API, na koji se korisnici mogu pouzdati, trebalo bi
biti 1.0.0. Ukoliko ste prilično zabrinuti oko kompatibilnosti unazad, softver
bi već trebalo da je objavljen pod verzijom 1.0.0.\nZar to ne obeshrabruje rapidan razvoj i brzu iteraciju?\nMajor (glavna) verzija nula je zapravo predodređena rapidnom razvoju. Ako menjate API svaki dan, trebalo bi ostati na verziji 0.y.z ili na posebnoj grani za razvoj raditi na sledećoj major (glavnoj) verziji.\nUkoliko i najsitnije unazad nekompatibilne izmene u API-ju zahtevaju naglo uvećavanje major (glavne) verzije, nećemo li vrlo brzo doći do verzije 42.0.0?\nOvo je pitanje odgovornog razvoja i predviđanja. U softver koji ima puno
zavisnog koda, nekompatibilne promene ne treba olako uvoditi. Troškovi
nadogradnje mogu biti značajni. Ako morate povećati major (glavnu) verziju, kako biste objavili verziju sa nekompatibilnim izmenama, morate razmisliti o uticaju tih izmena i proceniti odnos uključenih troškova i koristi.\nDokumentacija celokupnog public (javnog) API-ja zahteva previše posla\nVaša je odgovornost kao profesionalnih programera da pravilno dokumentujete
softver koji je namenjen korisnicima. Upravljanje složenošću softvera je izuzetno važan deo održavanja efikasnosti projekta, što je teško ako korisnici ne znaju kako koristiti vaš softver ili koje metode mogu bezbedno pozvati. Dugoročno, Semantičko Verzionisanje i insistiranje na kvalitetno definisanom API-ju omogućiće da svi i sve rade glatko.\nŠta ukoliko slučajno objavimo unazad nekompatibilne izmene kao minor (manju) verziju?\nČim primetite da ste prekršili specifikacije Semantičkog Verzionisanja,
potrebno je ispraviti grešku pa objaviti minor (manju) verziju koja će ispraviti problem i povratiti kompatibilnost unazad. Čak i u takvim uslovima, nije prihvatljivo modifikovati verzionisane objave. Ako je prikladno, dokumentujte verziju koja krši specifikaciju i tako obavestite korisnike kako bi bili svesni toga.\nŠta činiti ukoliko izmenimo sopstvene zavisnosti bez promene public (javnog) API-ja?\nTakve izmene smatramo kompatibilnima jer ne utiču na public (javni) API. Softver koji
eksplicitno zavisi od istih zavisnosti kao i naš sopstveni paket treba imati vlastite specifikacije zavisnosti, a autor će primetiti eventualne konflikte. Je li promjena na nivou patch (zakrpe) ili minor (manje) verzije, zavisi od toga da li ste dodavali svoje zavisnosti kao ispravke bug-ova (grešaka) ili ste ih uveli kao nove funkcionalnosti. U posljednjem slučaju
možemo očekivati i dodatni kod, pri čemu se očigledno radi o inkrementu minor (manje) verzije.\nŠta ukoliko slučajno izmenimo public (javni) API na način koji ne odgovara izmeni broja verzije (npr. u kod neispravno uvedemo veću unazad nekompatibilnu izmenu u okviru objave patch (zakrpe))?\nKoristite svoju najbolju procenu. Ako imate veliki broj korisnika, na koje će
značajno uticati promena unatrag, najbolje je da objavite major (glavnu) verziju, iako
bi takav ispravak mogli smatrati izdanjem zakrpe. Zapamtite, svrha Semantičkog
Verzionisanja je prenošenje značenja putem izmene broja verzije. Ako su takve
izmene važne za vaše korisnike, koristite broj verzije da biste ih informisali.\nKako postupati sa deprecating (zastarelim) funkcionalnostima?\nPostojeće funkcionalnosti koje zastarevaju, sastavni su deo razvoja softvera
i često su neophodne kako bi razvoj napredovao. Kad označavate deo public (javnog) API-ja kao deprecated (zastareli), potrebno je učiniti dve stvari: (1) ažurirati dokumentaciju kako bismo informisali korisnike, (2) objaviti novu minor (manju) verziju sa definisanim deprecated (zastarelim) delovima softvera. Pre nego što potpuno uklonite funkcionalnost u novoj major (glavnoj) verziji, potrebno je izdati barem jednu minor (manju) verziju koja sadrži deprecated (zastarele) delove, kako bi korisnici nesmetano prešli na novu verziju API-ja.\nIma li SemVer ograničenu veličinu stringa verzije?\nNe, ali procenite sami. String verzije od 255 znakova je verovatno preteran,
na primer. Takođe, neki sistemi mogu imati svoja ograničenja veličine stringa.\nDa li je “v1.2.3” semantička verzija?\nNe, “v1.2.3” nije semantička verzija. Međutim, prefiksiranje semantičke verzije
sa “v” je uobičajen način (na engleskom) da se naznači da je to broj verzije.
Skraćenje “verzije” kao “v” se često vidi sa kontrolom verzija. Primer:
git tag v1.2.3 -m "Release version 1.2.3", u kom slučaju je “v1.2.3” naziv
taga (oznake), a semantička verzija je “1.2.3”.\nDa li postoji predloženi regularni izraz (RegEx) za proveru SemVer stringa?\nPostoje dva. Jedan sa imenovanim grupama za one sisteme koji ih podržavaju
(PCRE [Perl Compatible Regular Expressions (Perl kompatibilni regularni izrazi), tj. Perl, PHP i R], Python
i Go).\nPogledajte: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nI drugi sa numerisanim grupama (znači ng1 = major (glavna), ng2 = minor (manja),
ng3 = patch (zakrpa), ng4 = prerelease (predizdanje) i ng5 = buildmetadata (metapodaci)) koji su kompatibilni
sa ECMA Script (JavaScript), PCRE [Perl Compatible Regular Expressions (Perl kompatibilni regularni izrazi),
tj. Perl, PHP i R], Python i Go.\nPogledajte: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nAutor specifikacije Semantičkog Verzionisanja je Tom
Preston-Werner, pronalazač Gravatar-a i suosnivač GitHub-a.\nAko želite ostaviti povratne informacije, molimo otvorite issue na
GitHub-u.\notvorite issue na
GitHub-u\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSemantisk versionshantering 2.0.0

Sammanfattning

Givet ett versionsnummer på formen MAJOR.MINOR.PATCH, räkna upp varje del enligt följande:


  Öka MAJOR med 1 när du gör ändringar som påverkar bakåtkompatibiliteten för API:t.
  Öka MINOR med 1 när du lägg till ny funktionalitet men 100 % bakåtkompatibilitet bibehålls.
  Öka PATCH med 1 när du fixar buggar förutsatt att 100 % bakåtkompatibilitet bibehålls.


Ibland kan det även förekomma ytterligare delar i versionsnumret för att markera
t.ex. en test- eller betaversion.

Introduktion

I mjukvaruutvecklingens värld finns det en obehaglig plats, det så kallade “beroendeträsket”.
Ju större ditt system blir och ju fler paket du integrerar i ditt program, desto
större är risken att du en dag finner dig själv i förtvivlans grepp.

I system med många beroenden kan nya versioner av paket snabbt bli en mardröm. Om
de specificerade beroendena är för hårt satta är risken stor att du hamnar i ett
versionslås (oförmågan att uppgradera ett paket utan att släppa nya versioner av
alla paket det finns beroende till). Om beroendena är specificerade för löst kommer
du oundvikligen hamna i en versionsnaivitet (övertro på kompabilitet med nyare
versioner). Du är i ett beroendeträsk om versionslås och/eller versionsnaivitet
förhindrar dig att enkelt och säkert ta ditt projekt framåt.

Som en lösning på detta problem föreslår jag en enkel samling regler och krav som
beskriver hur versionsnummer ska tilldelas och räknas upp. Dessa regler är baserade
på, men inte nödvändigt begränsade till, redan existerande välkänd och vanlig praxis
som används både för sluten och öppen källkod. För att detta system ska fungera måste
du deklarera ett publikt API. Detta kan bestå av dokumentation eller vara en del av
själva källkoden. Oavsett vilket är det viktigt att detta API är klart och tydligt.
När du har identifierat ditt publika API kommunicerar du ändringar i det med
specifik ökning av versionsnumret. Överväg X.Y.Z (Major.Minor.Patch) som format på
versionsnumret. Buggfixar som ej påverkar API:t ökar patch-versionen, bakåtkompatibla
API-ändringar/tillägg ökar minor-versionen och icke bakåtkompatibla API-ändringar
ökar major-versionen.

Jag kallar detta system “Semantisk versionshantering”. Under detta schema förmedlar
versionsnumret och dess förändringar mening till den underliggande koden och hur den
har förändrats från en version till en annan.

Specifikation av Semantisk versionshantering (SemVer)

Nyckelorden “MÅSTE”/”FÅR ENBART” (MUST/SHALL/REQUIRED), “FÅR INTE” (MUST NOT/SHALL NOT),
“BÖR” (SHOULD/RECOMMENDED), “BÖR INTE” (SHOULD NOT) och “KAN” (MAY/OPTIONAL) i detta
dokument skall tolkas enligt beskrivning i RFC 2119.


  
    Program som använder Semantisk versionshantering MÅSTE deklarera ett publikt API.
Detta API kan deklareras i själva koden eller enbart existera i dokumentationen.
Oavsett hur det görs BÖR det vara precist och heltäckande.
  
  
    Ett normalt versionsnummer MÅSTE ha formen X.Y.Z där X, Y och Z är
positiva heltal och FÅR INTE innehålla inledande nollor. X är major-versionen,
Y är minor-versionen och Z är patch-versionen. Varje element MÅSTE ökas numeriskt,
t.ex. 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    När ett versionshanterat packet har släppts FÅR INTE innehållet i den versionen
förändras. Alla modifieringar MÅSTE vara relaterade till en ny version.
  
  
    Major-versionen noll (0.y.z) är för inledande utveckling. Allt KAN förändras när som helst.
Publikt API BÖR ej ses som stabilt.
  
  
    Version 1.0.0 definierar det publika API:t. Hur versionsnumret ökar efter detta släpp
är beroende på detta publika API och hur det förändras.
  
  
    Patch-version Z (x.y.Z | x > 0) FÅR ENBART ökas om bakåtkompatibla buggfixar är
introducerade. En buggfix definieras som en intern förändring som fixar ett felaktigt beteende.
  
  
    Minor-version Y (x.Y.z | x > 0) MÅSTE ökas om ny bakåtkompatibel funktionalitet introduceras
i det publika API:t. Det MÅSTE ökas om någon funktion i det publika API:t markeras som
föråldrat (deprecated). Det KAN ökas om väsentlig ny funktionalitet eller förbättringar
införs i den privata koden. Även förändringar på patch-nivå KAN ingå. Patch-versionen MÅSTE
återställas till 0 när minor-versionen ökar.
  
  
    Major-versionen X (X.y.z | X > 0) MÅSTE ökas om någon icke bakåtkompatibel förändring
introduceras i det publika API:t. Även förändringar på minor- och patch-nivå KAN ingå. Patch-
och minor-versionerna MÅSTE återställas till 0 när major-versionen ökar.
  
  
    En förhandsversion KAN markeras genom att lägga till ett bindestreck och en serie av
punktseparerade identiteter direkt efter patch-versionen.  Identiteterna FÅR ENBART innehålla
alfanumeriska ASCII-tecken och bindestreck [0-9A-Za-z-]. Identiteterna FÅR INTE vara tomma.
Numeriska identiteter FÅR INTE ha inledande nollor. En förhandsversion har en lägre prioritet
än tillhörande normal version. En förhandsversion indikerar att versionen är instabil och
kanske inte uppfyller avsedda kompabilitetskrav som utmärker dess tillhörande normala version.
Exempel: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Metadata för byggen KAN markeras genom att lägga till ett plustecken och en serie
punktseparerade identiteter direkt efter patch-versionen eller information om förhandsversion.
Identiteterna FÅR ENBART innehålla alfanumeriska ASCII-tecken och bindestreck [0-9A-Za-z-].
Identiteterna FÅR INTE vara tomma. Bygg-metadata MÅSTE ignoreras när versionsprioritet skall
fastställas. Således har två versioner som enbart skiljer i bygg-metadata samma prioritet.
Exempel: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    Versionsprioritet syftar på hur versioner jämförs när de sorteras. Prioritet MÅSTE beräknas
genom att separera versionen i major, minor, patch och identitet för förhandsversion i given
ordning (bygg-metadata påverkar ej rangordningen). Prioritet bestäms av första skillnaden
när var och en av dessa identiteter jämförs i tur och ordning från vänster till höger enligt:
Major-, minor- och patch-version jämförs alltid numeriskt.
Exempel: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. När major, minor och patch är lika har en förhandsversion
lägre prioritet än en normal version. Exempel: 1.0.0-alpha < 1.0.0. Prioritet för två
förhandsversioner med samma major-, minor- och patch-version MÅSTE bestämmas genom att jämföra
varje punktseparerad identitet från vänster till höger till dess att en skillnad hittas enligt
följande: Identiteter som enbart består av siffror jämförs numeriskt och identiteter med
bokstäver och bindestreck jämförs lexikalt enligt sorteringsordningen i ASCII. Numeriska
identiteter har alltid lägre prioritet än icke numeriska identiteter. En större uppsättning
förhandsversionsidentiteter har en högre prioritet än en med färre antal ifall alla inledande
identiteter är lika. Exempel: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Varför använda Semantisk versionshantering?

Detta är inte en ny eller revolutionerande idé. Faktum är att du förmodligen redan gör det på
nästan samma sätt. Problemet är att ”nästan” inte är tillräckligt bra. Utan någon form av formell
specifikation att följa är versionsnummer så gott som värdelösa när det gäller beroendehantering.
Genom att ge ett namn och tydlig definition till ovanstående idéer blir det enkelt att kommunicera
dina avsikter till användarna av din mjukvara. När dessa avsikter är tydliga kan flexibla
(men inte för flexibla) beroendespecifikationer göras.

Ett enkelt exempel kommer här demonstrera hur Semantisk versionshantering kan göra beroendeträsket
till ett minne blott. Tänk dig ett bibliotek kallat ”Brandbil”. Det kräver ett semantiskt
versionshanterat paket kallat ”Stege”. När Brandbil skapas finns Stege i version 3.1.0. Då Brandbil
använder funktionalitet som introducerades i version 3.1.0 av Stege, kan du med säkerhet specificera
ett beroende till versioner högre eller lika med 3.1.0 men lägre än 4.0.0. När sedan version 3.1.1
och 3.2.0 av Stege blir tillgängliga kan du släppa dem till ditt pakethanteringssystem och vara
säker på att de kommer vara kompatibla med existerande programvara.

Som en ansvarsfull utvecklare vill du förstås verifiera att varje paketuppgradering fungerar som väntat.
Verkligheten är en rörig plats, det finns inget vi kan göra åt det mer än att vara vaksamma. Vad du
kan göra är att låta Semantisk versionshantering ge dig ett sunt sätt att släppa och uppgradera paket
utan att behöva rulla ut nya versioner av paket beroende av det första, vilket kommer att bespara dig
tid och problem.

Låter detta attraktivt? Allt du behöver göra för att börja använda Semantisk versionshantering är
att ange att du gör det och börja följa reglerna. Länka till denna hemsida i din README så att andra
känner till reglerna och kan dra nytta av dem.

Vanliga frågor

Hur ska jag hantera revisioner i den inledande utvecklingsfasen (0.y.z)?

Enklast är att sätta versionsnummer 0.1.0 på den första utvecklingsversionen och sedan öka
minor-versionen för varje efterföljande version.

Hur vet jag när jag ska släppa version 1.0.0?

Om din mjukvara används i produktion borde det förmodligen redan heta 1.0.0. Om du har ett stabilt
API som användare redan har beroende till borde du använda 1.0.0. Om du oroar dig för bakåtkompabilitet
borde du sannolikt redan vara på 1.0.0.

Kommer inte detta avskräcka från snabb utveckling och snabba iterationer?

Major-version noll handlar helt om snabb utveckling. Om du ändrar API:t varje dag bör du antingen
vara kvar i version 0.y.z eller jobba med nästa stora version på en separat utvecklingsgren.

Även de minsta icke bakåtkompatibla ändringar förändrar det publika API:t, vilket kräver ett steg upp i major-versionen. Skulle jag inte då snabbt komma upp i version 42.0.0?

Detta är en fråga om ansvarsfull utveckling och planering. Inkompatibla förändringar bör inte
introduceras lättvindigt i mjukvara som många har beroende till. Kostnaden man drar på sig för
att uppgradera kan bli betydande. Att öka major-versionen för att släppa inkompatibla ändringar
innebär att du också måste tänka genom konsekvenserna av dina ändringar och utvärdera kostnad
kontra nytta.

Det är för mycket jobb att dokumentera hela det publika API:t!

Det är ditt ansvar som en professionell utvecklare att korrekt dokumentera mjukvara som är
avsedd att användas av andra. Att hantera mjukvarukomplexitet är en stor och viktig del i att
hålla ett projekt effektivt, och det blir svårt om ingen vet hur mjukvaran ska användas eller
vilka metoder som är säkra att anropa. I långa loppet gör Semantisk versionshantering och krav
på väl dokumenterat publikt API att allt flyter på smidigt.

Vad gör jag om jag av misstag släpper en icke bakåtkompatibel ändring som en minor-version?

Så fort du inser att du har brutit specifikationen i Semantisk versionshantering, fixa problemet
och släpp en ny minor-version som korrigerar problemet och återställer bakåtkompabiliteten.
Även under dessa omständigheter är det helt oacceptabelt att modifiera den släppta versionen.
Om lämpligt, dokumentera den felande versionen och informera dina användare om problemet så
att de är medvetna om den felande versionen.

Vad bör jag göra om jag uppdatera mina egna beroenden utan att ändra det publika API:t?

Det skulle kunna ses som kompatibelt då det inte påverka det publika API:t. Programvara som
uttryckligen är beroende av samma sak som ditt paket bör ha sin egen beroendespecifikation och
skaparen kommer att märka eventuella konflikter. Att avgöra om förändringen är på patch- eller
minor-nivå beror på om du uppdaterade beroendet för att fixa en bugg eller för att introducera
ny funktionalitet. För det senare fallet hade jag förväntat mig att ny kod hade skrivits då
det naturligtvis är på minor-nivå.

Vad gör jag om jag tvingas förändra det publika API:t på ett sätt som inte följer versionsnumrets förändring (d.v.s. koden introducerar en stor icke kompatibel förändring i en patch-version)?

Använd ditt omdöme. Om du har en stor publik som kommer att påverkas stort av att beteendet
förändras mot vad som förväntas av det, då är det bäst att skapa en major-version även om
ändringen strikt borde ses som en patch-version. Kom ihåg att Semantisk versionshantering
handlar om att förmedla innebörden av hur versionsnummer förändras. Om dessa förändringar
är viktiga för dina användare, använd versionsnumret för att informera dem.

Hur ska jag hantera föråldrad funktionalitet?

Att markera existerande funktionalitet som föråldrad är en normal del av mjukvaruutveckling
och krävs oftast för att komma framåt. När du markera delar av ditt publika API som föråldrat
bör du göra två saker: (1) uppdatera din dokumentation så att användarna blir medvetna om
ändringen, (2) skapa en ny minor-version med funktionaliteten markerad som föråldrad. Innan
du helt tar bort funktionaliteten i en ny major-version bör det vara minst en minor-version
innehållandes markering om föråldrad kod så att användarna smidigt kan gå över till det
nya API:t.

Har SemVer en storleksbegränsning på versionssträngen?

Nej, men använd sunt förnuft. En versionssträng på t.ex. 255 tecken är förmodligen overkill.
Dessutom kan vissa system ha egna begränsningar på hur lång den får vara.

Är “v1.2.3” en semantisk version?

Nej, “v1.2.3” är inte en semantisk version. Å andra sidan är det vanligt att (på engelska)
använda prefixet “v” på semantiska versionsnummer för att förtydliga att det är ett versionsnummer.
Förkortningen “v” för “version” syns ofta i samband med versionshantering.
Exempel: git tag v1.2.3 -m "Release version 1.2.3", i detta fallet är “v1.2.3” ett tagg-namn
och “1.2.3” den symantiska versionen.

Om

Specifikationen för Semantisk versionshantering är skriven av Tom
Preston-Werner, skapare av Gravatars och medgrundare av
GitHub.

Om du vill lämna feedback, öppna en fråga på GitHub.

Licens

Creative Commons ― CC BY 3.0\nSemantisk versionshantering 2.0.0\nGivet ett versionsnummer på formen MAJOR.MINOR.PATCH, räkna upp varje del enligt följande:\nÖka MAJOR med 1 när du gör ändringar som påverkar bakåtkompatibiliteten för API:t.\nÖka MINOR med 1 när du lägg till ny funktionalitet men 100 % bakåtkompatibilitet bibehålls.\nÖka PATCH med 1 när du fixar buggar förutsatt att 100 % bakåtkompatibilitet bibehålls.\nIbland kan det även förekomma ytterligare delar i versionsnumret för att markera
t.ex. en test- eller betaversion.\nI mjukvaruutvecklingens värld finns det en obehaglig plats, det så kallade “beroendeträsket”.
Ju större ditt system blir och ju fler paket du integrerar i ditt program, desto
större är risken att du en dag finner dig själv i förtvivlans grepp.\nI system med många beroenden kan nya versioner av paket snabbt bli en mardröm. Om
de specificerade beroendena är för hårt satta är risken stor att du hamnar i ett
versionslås (oförmågan att uppgradera ett paket utan att släppa nya versioner av
alla paket det finns beroende till). Om beroendena är specificerade för löst kommer
du oundvikligen hamna i en versionsnaivitet (övertro på kompabilitet med nyare
versioner). Du är i ett beroendeträsk om versionslås och/eller versionsnaivitet
förhindrar dig att enkelt och säkert ta ditt projekt framåt.\nSom en lösning på detta problem föreslår jag en enkel samling regler och krav som
beskriver hur versionsnummer ska tilldelas och räknas upp. Dessa regler är baserade
på, men inte nödvändigt begränsade till, redan existerande välkänd och vanlig praxis
som används både för sluten och öppen källkod. För att detta system ska fungera måste
du deklarera ett publikt API. Detta kan bestå av dokumentation eller vara en del av
själva källkoden. Oavsett vilket är det viktigt att detta API är klart och tydligt.
När du har identifierat ditt publika API kommunicerar du ändringar i det med
specifik ökning av versionsnumret. Överväg X.Y.Z (Major.Minor.Patch) som format på
versionsnumret. Buggfixar som ej påverkar API:t ökar patch-versionen, bakåtkompatibla
API-ändringar/tillägg ökar minor-versionen och icke bakåtkompatibla API-ändringar
ökar major-versionen.\nJag kallar detta system “Semantisk versionshantering”. Under detta schema förmedlar
versionsnumret och dess förändringar mening till den underliggande koden och hur den
har förändrats från en version till en annan.\nSpecifikation av Semantisk versionshantering (SemVer)\nNyckelorden “MÅSTE”/”FÅR ENBART” (MUST/SHALL/REQUIRED), “FÅR INTE” (MUST NOT/SHALL NOT),
“BÖR” (SHOULD/RECOMMENDED), “BÖR INTE” (SHOULD NOT) och “KAN” (MAY/OPTIONAL) i detta
dokument skall tolkas enligt beskrivning i RFC 2119.\nProgram som använder Semantisk versionshantering MÅSTE deklarera ett publikt API.
Detta API kan deklareras i själva koden eller enbart existera i dokumentationen.
Oavsett hur det görs BÖR det vara precist och heltäckande.\nProgram som använder Semantisk versionshantering MÅSTE deklarera ett publikt API.
Detta API kan deklareras i själva koden eller enbart existera i dokumentationen.
Oavsett hur det görs BÖR det vara precist och heltäckande.\nEtt normalt versionsnummer MÅSTE ha formen X.Y.Z där X, Y och Z är
positiva heltal och FÅR INTE innehålla inledande nollor. X är major-versionen,
Y är minor-versionen och Z är patch-versionen. Varje element MÅSTE ökas numeriskt,
t.ex. 1.9.0 -> 1.10.0 -> 1.11.0.\nEtt normalt versionsnummer MÅSTE ha formen X.Y.Z där X, Y och Z är
positiva heltal och FÅR INTE innehålla inledande nollor. X är major-versionen,
Y är minor-versionen och Z är patch-versionen. Varje element MÅSTE ökas numeriskt,
t.ex. 1.9.0 -> 1.10.0 -> 1.11.0.\nNär ett versionshanterat packet har släppts FÅR INTE innehållet i den versionen
förändras. Alla modifieringar MÅSTE vara relaterade till en ny version.\nNär ett versionshanterat packet har släppts FÅR INTE innehållet i den versionen
förändras. Alla modifieringar MÅSTE vara relaterade till en ny version.\nMajor-versionen noll (0.y.z) är för inledande utveckling. Allt KAN förändras när som helst.
Publikt API BÖR ej ses som stabilt.\nMajor-versionen noll (0.y.z) är för inledande utveckling. Allt KAN förändras när som helst.
Publikt API BÖR ej ses som stabilt.\nVersion 1.0.0 definierar det publika API:t. Hur versionsnumret ökar efter detta släpp
är beroende på detta publika API och hur det förändras.\nVersion 1.0.0 definierar det publika API:t. Hur versionsnumret ökar efter detta släpp
är beroende på detta publika API och hur det förändras.\nPatch-version Z (x.y.Z | x > 0) FÅR ENBART ökas om bakåtkompatibla buggfixar är
introducerade. En buggfix definieras som en intern förändring som fixar ett felaktigt beteende.\nPatch-version Z (x.y.Z | x > 0) FÅR ENBART ökas om bakåtkompatibla buggfixar är
introducerade. En buggfix definieras som en intern förändring som fixar ett felaktigt beteende.\nMinor-version Y (x.Y.z | x > 0) MÅSTE ökas om ny bakåtkompatibel funktionalitet introduceras
i det publika API:t. Det MÅSTE ökas om någon funktion i det publika API:t markeras som
föråldrat (deprecated). Det KAN ökas om väsentlig ny funktionalitet eller förbättringar
införs i den privata koden. Även förändringar på patch-nivå KAN ingå. Patch-versionen MÅSTE
återställas till 0 när minor-versionen ökar.\nMinor-version Y (x.Y.z | x > 0) MÅSTE ökas om ny bakåtkompatibel funktionalitet introduceras
i det publika API:t. Det MÅSTE ökas om någon funktion i det publika API:t markeras som
föråldrat (deprecated). Det KAN ökas om väsentlig ny funktionalitet eller förbättringar
införs i den privata koden. Även förändringar på patch-nivå KAN ingå. Patch-versionen MÅSTE
återställas till 0 när minor-versionen ökar.\nMajor-versionen X (X.y.z | X > 0) MÅSTE ökas om någon icke bakåtkompatibel förändring
introduceras i det publika API:t. Även förändringar på minor- och patch-nivå KAN ingå. Patch-
och minor-versionerna MÅSTE återställas till 0 när major-versionen ökar.\nMajor-versionen X (X.y.z | X > 0) MÅSTE ökas om någon icke bakåtkompatibel förändring
introduceras i det publika API:t. Även förändringar på minor- och patch-nivå KAN ingå. Patch-
och minor-versionerna MÅSTE återställas till 0 när major-versionen ökar.\nEn förhandsversion KAN markeras genom att lägga till ett bindestreck och en serie av
punktseparerade identiteter direkt efter patch-versionen.  Identiteterna FÅR ENBART innehålla
alfanumeriska ASCII-tecken och bindestreck [0-9A-Za-z-]. Identiteterna FÅR INTE vara tomma.
Numeriska identiteter FÅR INTE ha inledande nollor. En förhandsversion har en lägre prioritet
än tillhörande normal version. En förhandsversion indikerar att versionen är instabil och
kanske inte uppfyller avsedda kompabilitetskrav som utmärker dess tillhörande normala version.
Exempel: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nEn förhandsversion KAN markeras genom att lägga till ett bindestreck och en serie av
punktseparerade identiteter direkt efter patch-versionen.  Identiteterna FÅR ENBART innehålla
alfanumeriska ASCII-tecken och bindestreck [0-9A-Za-z-]. Identiteterna FÅR INTE vara tomma.
Numeriska identiteter FÅR INTE ha inledande nollor. En förhandsversion har en lägre prioritet
än tillhörande normal version. En förhandsversion indikerar att versionen är instabil och
kanske inte uppfyller avsedda kompabilitetskrav som utmärker dess tillhörande normala version.
Exempel: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nMetadata för byggen KAN markeras genom att lägga till ett plustecken och en serie
punktseparerade identiteter direkt efter patch-versionen eller information om förhandsversion.
Identiteterna FÅR ENBART innehålla alfanumeriska ASCII-tecken och bindestreck [0-9A-Za-z-].
Identiteterna FÅR INTE vara tomma. Bygg-metadata MÅSTE ignoreras när versionsprioritet skall
fastställas. Således har två versioner som enbart skiljer i bygg-metadata samma prioritet.
Exempel: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nMetadata för byggen KAN markeras genom att lägga till ett plustecken och en serie
punktseparerade identiteter direkt efter patch-versionen eller information om förhandsversion.
Identiteterna FÅR ENBART innehålla alfanumeriska ASCII-tecken och bindestreck [0-9A-Za-z-].
Identiteterna FÅR INTE vara tomma. Bygg-metadata MÅSTE ignoreras när versionsprioritet skall
fastställas. Således har två versioner som enbart skiljer i bygg-metadata samma prioritet.
Exempel: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nVersionsprioritet syftar på hur versioner jämförs när de sorteras. Prioritet MÅSTE beräknas
genom att separera versionen i major, minor, patch och identitet för förhandsversion i given
ordning (bygg-metadata påverkar ej rangordningen). Prioritet bestäms av första skillnaden
när var och en av dessa identiteter jämförs i tur och ordning från vänster till höger enligt:
Major-, minor- och patch-version jämförs alltid numeriskt.
Exempel: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. När major, minor och patch är lika har en förhandsversion
lägre prioritet än en normal version. Exempel: 1.0.0-alpha < 1.0.0. Prioritet för två
förhandsversioner med samma major-, minor- och patch-version MÅSTE bestämmas genom att jämföra
varje punktseparerad identitet från vänster till höger till dess att en skillnad hittas enligt
följande: Identiteter som enbart består av siffror jämförs numeriskt och identiteter med
bokstäver och bindestreck jämförs lexikalt enligt sorteringsordningen i ASCII. Numeriska
identiteter har alltid lägre prioritet än icke numeriska identiteter. En större uppsättning
förhandsversionsidentiteter har en högre prioritet än en med färre antal ifall alla inledande
identiteter är lika. Exempel: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nVersionsprioritet syftar på hur versioner jämförs när de sorteras. Prioritet MÅSTE beräknas
genom att separera versionen i major, minor, patch och identitet för förhandsversion i given
ordning (bygg-metadata påverkar ej rangordningen). Prioritet bestäms av första skillnaden
när var och en av dessa identiteter jämförs i tur och ordning från vänster till höger enligt:
Major-, minor- och patch-version jämförs alltid numeriskt.
Exempel: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. När major, minor och patch är lika har en förhandsversion
lägre prioritet än en normal version. Exempel: 1.0.0-alpha < 1.0.0. Prioritet för två
förhandsversioner med samma major-, minor- och patch-version MÅSTE bestämmas genom att jämföra
varje punktseparerad identitet från vänster till höger till dess att en skillnad hittas enligt
följande: Identiteter som enbart består av siffror jämförs numeriskt och identiteter med
bokstäver och bindestreck jämförs lexikalt enligt sorteringsordningen i ASCII. Numeriska
identiteter har alltid lägre prioritet än icke numeriska identiteter. En större uppsättning
förhandsversionsidentiteter har en högre prioritet än en med färre antal ifall alla inledande
identiteter är lika. Exempel: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta <
1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nVarför använda Semantisk versionshantering?\nDetta är inte en ny eller revolutionerande idé. Faktum är att du förmodligen redan gör det på
nästan samma sätt. Problemet är att ”nästan” inte är tillräckligt bra. Utan någon form av formell
specifikation att följa är versionsnummer så gott som värdelösa när det gäller beroendehantering.
Genom att ge ett namn och tydlig definition till ovanstående idéer blir det enkelt att kommunicera
dina avsikter till användarna av din mjukvara. När dessa avsikter är tydliga kan flexibla
(men inte för flexibla) beroendespecifikationer göras.\nEtt enkelt exempel kommer här demonstrera hur Semantisk versionshantering kan göra beroendeträsket
till ett minne blott. Tänk dig ett bibliotek kallat ”Brandbil”. Det kräver ett semantiskt
versionshanterat paket kallat ”Stege”. När Brandbil skapas finns Stege i version 3.1.0. Då Brandbil
använder funktionalitet som introducerades i version 3.1.0 av Stege, kan du med säkerhet specificera
ett beroende till versioner högre eller lika med 3.1.0 men lägre än 4.0.0. När sedan version 3.1.1
och 3.2.0 av Stege blir tillgängliga kan du släppa dem till ditt pakethanteringssystem och vara
säker på att de kommer vara kompatibla med existerande programvara.\nSom en ansvarsfull utvecklare vill du förstås verifiera att varje paketuppgradering fungerar som väntat.
Verkligheten är en rörig plats, det finns inget vi kan göra åt det mer än att vara vaksamma. Vad du
kan göra är att låta Semantisk versionshantering ge dig ett sunt sätt att släppa och uppgradera paket
utan att behöva rulla ut nya versioner av paket beroende av det första, vilket kommer att bespara dig
tid och problem.\nLåter detta attraktivt? Allt du behöver göra för att börja använda Semantisk versionshantering är
att ange att du gör det och börja följa reglerna. Länka till denna hemsida i din README så att andra
känner till reglerna och kan dra nytta av dem.\nHur ska jag hantera revisioner i den inledande utvecklingsfasen (0.y.z)?\nEnklast är att sätta versionsnummer 0.1.0 på den första utvecklingsversionen och sedan öka
minor-versionen för varje efterföljande version.\nHur vet jag när jag ska släppa version 1.0.0?\nOm din mjukvara används i produktion borde det förmodligen redan heta 1.0.0. Om du har ett stabilt
API som användare redan har beroende till borde du använda 1.0.0. Om du oroar dig för bakåtkompabilitet
borde du sannolikt redan vara på 1.0.0.\nKommer inte detta avskräcka från snabb utveckling och snabba iterationer?\nMajor-version noll handlar helt om snabb utveckling. Om du ändrar API:t varje dag bör du antingen
vara kvar i version 0.y.z eller jobba med nästa stora version på en separat utvecklingsgren.\nÄven de minsta icke bakåtkompatibla ändringar förändrar det publika API:t, vilket kräver ett steg upp i major-versionen. Skulle jag inte då snabbt komma upp i version 42.0.0?\nDetta är en fråga om ansvarsfull utveckling och planering. Inkompatibla förändringar bör inte
introduceras lättvindigt i mjukvara som många har beroende till. Kostnaden man drar på sig för
att uppgradera kan bli betydande. Att öka major-versionen för att släppa inkompatibla ändringar
innebär att du också måste tänka genom konsekvenserna av dina ändringar och utvärdera kostnad
kontra nytta.\nDet är för mycket jobb att dokumentera hela det publika API:t!\nDet är ditt ansvar som en professionell utvecklare att korrekt dokumentera mjukvara som är
avsedd att användas av andra. Att hantera mjukvarukomplexitet är en stor och viktig del i att
hålla ett projekt effektivt, och det blir svårt om ingen vet hur mjukvaran ska användas eller
vilka metoder som är säkra att anropa. I långa loppet gör Semantisk versionshantering och krav
på väl dokumenterat publikt API att allt flyter på smidigt.\nVad gör jag om jag av misstag släpper en icke bakåtkompatibel ändring som en minor-version?\nSå fort du inser att du har brutit specifikationen i Semantisk versionshantering, fixa problemet
och släpp en ny minor-version som korrigerar problemet och återställer bakåtkompabiliteten.
Även under dessa omständigheter är det helt oacceptabelt att modifiera den släppta versionen.
Om lämpligt, dokumentera den felande versionen och informera dina användare om problemet så
att de är medvetna om den felande versionen.\nVad bör jag göra om jag uppdatera mina egna beroenden utan att ändra det publika API:t?\nDet skulle kunna ses som kompatibelt då det inte påverka det publika API:t. Programvara som
uttryckligen är beroende av samma sak som ditt paket bör ha sin egen beroendespecifikation och
skaparen kommer att märka eventuella konflikter. Att avgöra om förändringen är på patch- eller
minor-nivå beror på om du uppdaterade beroendet för att fixa en bugg eller för att introducera
ny funktionalitet. För det senare fallet hade jag förväntat mig att ny kod hade skrivits då
det naturligtvis är på minor-nivå.\nVad gör jag om jag tvingas förändra det publika API:t på ett sätt som inte följer versionsnumrets förändring (d.v.s. koden introducerar en stor icke kompatibel förändring i en patch-version)?\nAnvänd ditt omdöme. Om du har en stor publik som kommer att påverkas stort av att beteendet
förändras mot vad som förväntas av det, då är det bäst att skapa en major-version även om
ändringen strikt borde ses som en patch-version. Kom ihåg att Semantisk versionshantering
handlar om att förmedla innebörden av hur versionsnummer förändras. Om dessa förändringar
är viktiga för dina användare, använd versionsnumret för att informera dem.\nHur ska jag hantera föråldrad funktionalitet?\nAtt markera existerande funktionalitet som föråldrad är en normal del av mjukvaruutveckling
och krävs oftast för att komma framåt. När du markera delar av ditt publika API som föråldrat
bör du göra två saker: (1) uppdatera din dokumentation så att användarna blir medvetna om
ändringen, (2) skapa en ny minor-version med funktionaliteten markerad som föråldrad. Innan
du helt tar bort funktionaliteten i en ny major-version bör det vara minst en minor-version
innehållandes markering om föråldrad kod så att användarna smidigt kan gå över till det
nya API:t.\nHar SemVer en storleksbegränsning på versionssträngen?\nNej, men använd sunt förnuft. En versionssträng på t.ex. 255 tecken är förmodligen overkill.
Dessutom kan vissa system ha egna begränsningar på hur lång den får vara.\nÄr “v1.2.3” en semantisk version?\nNej, “v1.2.3” är inte en semantisk version. Å andra sidan är det vanligt att (på engelska)
använda prefixet “v” på semantiska versionsnummer för att förtydliga att det är ett versionsnummer.
Förkortningen “v” för “version” syns ofta i samband med versionshantering.
Exempel: git tag v1.2.3 -m "Release version 1.2.3", i detta fallet är “v1.2.3” ett tagg-namn
och “1.2.3” den symantiska versionen.\nSpecifikationen för Semantisk versionshantering är skriven av Tom
Preston-Werner, skapare av Gravatars och medgrundare av
GitHub.\nOm du vill lämna feedback, öppna en fråga på GitHub.\nöppna en fråga på GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nAnlamsal Sürüm Numaralandırma 2.0.0

Özet

BÜYÜK.KÜÇÜK.YAMA diye belirtilen bir sürüm numaralandırmasında:


  Önceki sürüm ile uyumsuz API değişiklikleri yaptığınızda BÜYÜK sürümü,
  Önceki sürüm ile uyumlu bir özellik eklediğinizde KÜÇÜK sürümü
  Önceki sürüm ile uyumlu hata düzeltmeleri yaptığınızda YAMA sürümünü


yükseltin.

Ayrıca, BÜYÜK.KÜÇÜK.YAMA biçiminin sonuna ön-sunum (pre-release) ve derleme üstverisi (build metadata) gibi etiketler eklenebilmektedir.

Giriş

Yazılım yönetimi dünyasında “imkansız bağımlılıklar” (dependency hell) adında korkulu bir ihtimal vardır. Sisteminiz büyüdükçe ve yazılımınıza daha çok paket eklediğinizde, büyük ihtimalle bir gün gelecek ve kendinizi bu çaresizlik batağında bulacaksınız.

Birçok bağımlılığı olan sistemlerde, yeni bir paket sürümü çıkarmak bir kabusa dönüşebilir. Bağımlılıklar çok sıkı belirlenmişse, sürüm kilitlenmesi (bağımlı olunan tüm paketlerin yeni sürümünü yükseltmeden istenen paketin sürümünü yükseltememek) tehlikesiyle karşı karşıyasınız demektir. Eğer bağımlılıklar çok gevşek belirlenmişse, ister istemez sürüm çeşitliliği (gelecekteki sürümlerle aşırı uyumluluk varsaymak) tarafından etkileneceksiniz. Sürüm kilitlenmesi ve/veya sürüm çeşitliliği nedeniyle projenizi güvenli bir şekilde ilerletemediğinizde imkansız bağımlılıkların içindesiniz demektir.

Bu soruna bir çözüm olarak, sürüm numaralarının nasıl verildiği ve artırıldığı konusunda bazı basit kurallar ve gereklilikler öneriyoruz. Bu kurallar, genel kabul görmüş, hem kapalı hem de açık kaynak yazılım uygulamalarına dayansa da, sadece onlarla sınırlı değildir. Bu numaralandırma sisteminin çalışması için, öncelikle erişime açık bir API (public API) tanımlamanız gerekiyor. Bu, belgeleme veya kod tarafından konulmuş bir kuraldan oluşabilir. Ne şekilde olursa olsun, önemli olan bu API’ın açık ve kesin olmasıdır. Erişime açık API’ınızı tanımladığınız anda, bundan sonra geçireceği değişimleri, sürüm numaranızı belirli artırımlara tabi tutarak iletmelisiniz. Şu şekilde bir sürüm numarası ele alalım: X.Y.Z (Büyük.Küçük.Yama). API’ı etkilemeyen hata düzeltmeleri yama sürümünü artırır, önceki sürümlerle uyumlu API eklemeleri/değişiklikleri küçük sürümü artırır, ve önceki sürümler ile uyumsuz API değişikleri büyük sürümü artırır.

Bu sistemi “Anlamsal Sürüm Numaralandırma” diye nitelendiriyoruz. Bu taslak sayesinde, sürüm numaraları ve sürüm numaralarının değişim şekilleri, kodda, bir sürümden diğerine neyin değiştiğini anlatır hale gelmektedir.

Anlamsal Sürüm Numaralandırma Tanımı (SemVer)

Bu belge içindeki anahtar sözcükler ve/veya eklerinden oluşan “-MALI”, “-MELİ”, “-MAMALI”, “-MEMELİ”, “GEREKLİ”, “-ECEK”, “-ACAK”, “-MEYECEK”, “-MAYACAK”, “-EBİLİR”, ÖNERİLİR”, “OLABİLİR”, ve “İSTEĞE BAĞLI”, RFC 2119‘da belirtildiği şekilde anlaşılmalıdır.


  
    Anlamsal Sürüm Numaralandırma kullanan bir yazılım erişime açık bir API tanımlamalıdır. Bu API, kodun kendi içinde veya yalnızca zaten var olan bir belgelemenin içinde tanımlanabilir. Nasıl yapılırsa yapılsın, kesin ve eksiksiz olmalıdır.
  
  
    Normal bir sürüm numarası X.Y.Z biçimde OLMALIDIR; burada X, Y, ve Z negatif olmayan tam sayılardır ve başlarında sıfır İÇERMEMELİDİR. X büyük sürümdür, Y küçük sürümdür ve Z yama sürümüdür. Her öğe sayısal olarak ARTMALIDIR. Örnek: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Numaralandırılmış bir paket sunulduğunda, o sürümün içeriği DEĞİŞTİRİLMEMELİDİR. Yapılan herhangi bir değişim yeni bir sürüm olarak sunulmalıdır.
  
  
    Sıfır olan Büyük sürüm başlangıçta yapılan yazılım geliştirme içindir. Her şey her an değişebilir. Erişime açık API dengeli (stable) diye değerlendirilmemelidir.
  
  
    1.0.0 sürümü erişime açık API’ı tanımlar. Sürüm numarasının bu sürümden sonra nasıl artırılacağı bu erişime açık API’a ve nasıl değiştiğine bağlıdır.
  
  
    Yama sürümü Z (x.y.Z | X > 0) sadece önceki sürüm ile uyumlu hata düzeltmeleri yapıldığında ARTIRILMALIDIR. Hata düzeltmesi şöyle tanımlanır: Yanlış bir davranışı düzelten içsel bir değişiklik.
  
  
    Küçük sürüm Y (x.Y.z | x > 0), erişime açık API’a yeni, önceki sürüm ile uyumlu bir özellik eklendiğinde ARTIRILMALIDIR. Erişime açık API’daki bir özellik artık kullanmayan (deprecated) olarak işaretlendiğinde ARTIRILMALIDIR. Özel koda ciddi oranda yeni özellikler veya geliştirmeler katıldığında ARTTIRILABİLİR. Yama düzeyindeki değişiklikler buna dahil EDİLEBİLİR. Yama sürümü, küçük sürüm artırıldığında SIFIRLANMALIDIR.
  
  
    Büyük sürüm X (X.y.z | X > 0) önceki sürüm ile uyumsuz değişiklikler yapıldığında ARTIRILMALIDIR. Yama ve küçük düzeydeki değişiklikler buna dahil edilebilir. Büyük sürüm artırıldığında yama ve küçük sürüm SIFIRLANMALIDIR.
  
  
    Bir ön-sunum (pre-release) sürümü, yama sürümünden hemen sonraki kısımda, bir tire işaretiyle ve bir dizi nokta ayracıyla GÖSTERİLEBİLİR. Tanımlayıcılar yalnızca ASCII alfasayısal ve tire işaretlerinden [0-9A-Za-z-] OLUŞMALIDIR. Tanımlayıcılar boş OLMAMALIDIR. Sayısal tanımlayıcılar öncül sıfırlar İÇERMEMELİDİR. Ön-sunum sürümleri ilişkili normal sürümden daha düşük önceliğe sahiptir. İlişkili normal sürümün tersine, bir ön-sunum sürümü, sürümün kararsız olduğunu ve beklenen uyumluluk gereksinimlerini karşılayamayacağını gösterir. Örnekler: 1.0.0-ilk, 1.0.0-ilk.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Derleme üst verisi, yama sürümünü veya ön-sunum sürümünü hemen takip ederek eklenen bir artı işaretiyle ve bir dizi nokta ayracıyla GÖSTERİLEBİLİR. Tanımlayıcılar yalnızca ASCII alfasayısal ve tire işaretlerinden [0-9A-Za-z-] OLUŞMALIDIR. Tanımlayıcılar boş OLMAMALIDIR. Derleme üstverisi sürüm önceliği belirlenirken dikkate ALINMAMALIDIR. Böylece, yalnızca derleme üstverisiyle farklılık gösteren iki sürüm de aynı önceliğe sahip olacaktır. Örnekler: 1.0.0-ilk+001, 1.0.0+20130313144700, 1.0.0-ikincil+deneme.sha.5114f85.
  
  
    Öncelik, sürümlerin sıralandıklarında, birbirleriyle sıralarının nasıl karşılaştırılacaklarını belirtir.
  


Öncelik sürüm numarası büyük, küçük, yama ve ön-sunum tanımlayıcılarıyla, burada yazıldığı sırada (Derleme üstverisi öncelik belirlenirken anlamsızdır) ayırarak HESAPLANMALIDIR.

Öncelik, soldan sağa doğru tanımlayıcıların her birini şu şekilde karşılaştırırken belirlenir: Büyük, küçük, ve yama sürümleri daima sayısal olarak karşılaştırılır.

Örnek: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.

Büyük, küçük ve yama eşit olduğunda, bir ön-sunum sürümü, normal bir sürümden daha düşük önceliğe sahiptir.

Örnek: 1.0.0-ilk < 1.0.0.

Aynı büyük, küçük ve yama sürümüne sahip iki ön-sunum sürümünün önceliği, şu şekilde gösterildiği gibi, soldan sağa doğru her bir tanımlayıcıyı ayırıp karşılaştırarak BELİRLENMELİDİR:

Yalnızca rakamlardan oluşan tanımlayıcılar sayısal olarak karşılaştırılır

Harfli veya tire çizgili tanımlayıcılar ise ASCII sözcük sıralamalarına göre karşılaştırılırlar.

Sayısal tanımlayıcılar, sayısal olmayan tanımlayıcılardan daima daha düşük önceliğe sahiptirler.

Önce gelen tüm tanımlayıcıları eşitse, büyük bir dizi ön-sunumun alanlarının, daha küçük bir dizininkinden daha yüksek önceliği vardır.

Örneğin: 1.0.0-ilk < 1.0.0-ilk.1 < 1.0.0-ilk.ikincil < 1.0.0-ikincil < 1.0.0-ikincil.2 < 1.0.0-ikincil.11 < 1.0.0-sa.1 < 1.0.0.

Backus ― Naur formu grameri için geçerli SemVer versiyonları

<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


Anlamsal Sürüm Numaralandırma Neden Kullanılmalıdır?

Aslında, bu yeni veya çığır açan bir fikir değil. Büyük olasılıkla buna yakın bir şeyler zaten yapıyorsunuzdur. Sorun şudur: “yakın” olması yeterince iyi değildir. Bir şekilde belirlenmiş, resmi bir şartnameye uymadan, sürüm sayıları bağımlılık yönetimi için gerçek hayatta kullanışsızdır. Üstteki fikirleri isimlendirip, açık tanımlamalar yaparak, yazılımınızın kullanıcılarına niyetinizi iletmeniz kolaylaşır. Niyetler bir kere açık, esnek olduğunda (fakat aşırı esnekleştirmeden), bağımlılık tanımlamaları yapılabilir hale gelir.

Basit bir örnek Anlamsal Sürüm Numaralandırma’nın imkansız bağımlılıklar nasıl geçmişin bir parçası haline getirebildiğini gösterecek. “İtfaiye Aracı” isminde bir kütüphaneyi ele alalım. “Merdiven” adındaki Anlamsal Sürüm ile Numaralandırılmış bir pakete ihtiyaç duymaktadır. İtfaiye Aracı yaratıldığında, Merdiven 3.1.0 sürümündedir. İtfaiye Aracı 3.1.0’da eklenmiş bazı işlevlere ihtiyaç duyduğundan, Merdiven bağımlılığının 3.1.0’a eşit ya da daha büyük fakat 4.0.0’dan küçük olduğunu güvenle belirtebilirsiniz. Böylelikle, Merdiven sürüm 3.1.1 ve 3.2.0 kullanılabilir olduğunda, paket yönetim sisteminize bunları sunabilirsiniz ve halihazırdaki bağımlılığı bulunduğu yazılımla uyumlu olacağını bilirsiniz.

Sorumluluk sahibi bir yazılım geliştirici olarak, tabii ki her paket güncellemesinin duyurulduğu şekilde işlediğini kontrol etmek isteyeceksiniz. Gerçek dünya karışık bir yerdir; gözünüzü açık tutmak dışında yapabileceğiniz pek bir şey yoktur. Ancak, yapabileceğiniz şudur: Bağımlı olunan paketlerin yeni sürümlerini çıkarmaya gerek kalmadan paketleri sunmak ve yükseltmek için sizi zaman ve eziyetten kurtaracak mantıklı bir yol öneren Anlamsal Sürüm Numaralandırma’yi kullanmaktır.

Bütün bunlar size uygunsa, Anlamsal Sürüm Numaralandırma’yi kullanmaya başlamak için yapmanız gereken tek şey kullanmaya başladığınızı ve kurallarını takip ettiğinizi duyurmaktır. BENİOKU (README) dosyanızdan bu web sitesine bağlantı vererek diğerlerinin de kuralları bilmesini ve bunlardan yarar sağlamalarını sağlayabilirsiniz.

SSS

İlk geliştirme fazı olan 0.y.z’deki değişikliklerle nasıl başa çıkmalıyım?

Yapılabilecek en basit şey ilk geliştirme sürümünüzü 0.1.0’da başlatmaktır ve takip eden her sürüm için küçük sürümü artırmaktır.

1.0.0’ı ne zaman sunacağımı nasıl anlarım?

Yazılımınız kullanıma hazır (production) ortamında kullanılmaya başlanmışsa, sürümü zaten muhtemelen 1.0.0’dır. Kullanıcıların güvenebildiği kararlı bir API’a sahipseniz, 1.0.0’da olmalısınız. Önceki sürüm ile uyumlu olmayı dert ediyorsanız, büyük olasılıkla, çoktandır 1.0.0 olmalısınız.

Anlamsal Sürüm Numaralandırma, çabuk geliştirmeden ve hızlı özyinelemeden caydırmaz mı?

Büyük sürümün sıfır olması tamamen seri geliştirmeyle alakalıdır. Eğer API’ı her gün değiştiriyorsanız ya hala 0.y.z sürümü ya da sıradaki büyük sürümün üzerinde çalıştığınız ayrı bir geliştirme dalı (branch) üzerinde olmalısınız.

Erişime açık API’ımın önceki bir sürümüyle uyumsuz en küçük değişiklikler bile Büyük sürümü artıracaksa, kendimi birden 42.0.0 sürümünde bulmayacak mıyım?

Bu sorumluluk sahibi yazılım geliştirmekle ve ileri görüşlülükle alakalı bir sorudur. Birçok bağımlılığı olan bir yazılıma uyumsuz değişiklikler öylesine eklenmemelidir. Maruz kalınacak yükseltme maliyeti ciddi boyutlarda olabilir. Uyumsuz değişikliklerde büyük sürümü artırmak demek yaptığınız değişikliklerin etkileri hakkında etraflıca düşüneceğinizi, ve maliyet/kazanç oranına göre karar vermenizi gerektirecektir.

Erişime açık API’ın tamamını belgelendirmek büyük iş!

Başkaları tarafından kullanılacağı düşünülen bir yazılımı düzgün bir şekilde belgelendirmek usta bir yazılım geliştirici olarak sizin sorumluluğunuzdur. Yazılım karmaşıklığını yönetmek bir projeyi verimli tutmanın çok önemli bir kısmıdır ve kimse yazılımınızı nasıl kullanacağını ya da hangi yöntemleri (methods) çağırmanın güvenli olacağını bilemiyorsa bunu yapmak zordur. Anlamsal Sürüm Numaralandırma, uzun dönemde, ve iyi tanımlanmış erişime açık bir API ile herkesin ve her şeyin sorunsuzca devam etmesini sağlar.

Önceki sürüm ile uyumsuz bir değişikliği yanlışlıkla küçük bir sürüm olarak sunarsam ne yaparım?

Anlamsal Sürüm Numaralandırma şartnamesini bozduğunuzu farkettiğiniz anda, sorunu düzeltin ve sorunu düzelten ve önceki sürüm le uyumluluğunu sağlayan yeni bir küçük sürüm sunun. Bu şartlar altında bile, numaralandırılmış sunumları kesinlikle değiştirmeyin. Mümkünse, sıkıntı çıkaran sürümü belgelendirin ve kullanıcılarınızı sorunla alakalı olarak bilgilendirin böylece sıkıntı çıkaran sürümden haberleri olmuş olur.

Erişime açık API’ı değiştirmeden yazılımın bağımlılıklarını güncellersem ne yapmalıyım?

Erişime açık API’ı etkilemediğinden uyumlu olarak değerlendirilebilecek bir durumdur. Paketinizle aynı bağımlılıklara sahip olan bir yazılımın kendi bağımlılık şartnameleri olmalıdır ve yazılımcısı tüm uyuşmazlıkları farkedecektir. Bir hatayı düzeltmek ya da yeni bir işlev kazandırmak için bağımlılıklarınızı güncelleyip güncellemediğiniz, yama ya da küçük seviyede bir değişiklik yapıp yapmadığınızı belirler. İkinci örnekteki durum için genelde ilave kod bekleriz ki bu her iki durum da küçük seviye bir artırır.

Ya yanlışlıkla erişime açık API’ı sürüm numarasıyla uyumlu olmayacak bir şekilde değiştirmişsem (örn: yama sunumunda büyük bir kırılım oluşturan kod)?

Sağduyunuzu kullanın. Erişime açık API’ın davranışını beklenen, önceki haline geri getirmenizden etkilenecek büyük bir kullanıcı kitleniz varsa, düzeltmeniz bir yama sunumu gibi değerlendirilebilir olsa da, büyük bir sürüm sunumu yapmak en iyi seçenek olabilir. Anlamsal Sürüm Numaralandırma’nin tüm amacının sürüm numaralarının nasıl değiştiğini ifade ettiğini unutmayın. Eğer bu değişiklikler kullanıcılarınız için önemliyse, sürüm numarasını kullanarak onları bilgilendirin.

Artık kullanılamayacak bir işlevle nasıl başa çıkabilirim?

Var olan işlevlerin çürümesi yazılım geliştirmenin normal bir parçasıdır ve ileri adım atabilmek için genellikle gerekir. Erişime açık API’ınızın bir kısmını artık kullanılmayacak şekilde geliştirdiğinizde, iki şey yapmalısınız: (1) değişiklik konusunda kullanıcılarınızı bilgilendirmek için belgelendirmenizi güncelleyin, (2) artık kullanmayan yöntemleri içeren küçük bir sunum çıkarın. İşlevi büyük bir sunumla tamamen kaldırmadan önce, kullanıcılarınızın yeni API’a kolayca geçiş yapabilmeleri için artık kullanılmayan yöntemleri içeren en az bir adet küçük bir sunum olmalıdır.

SemVer, sürüm karakterlerinde (string)  bir sınıra sahip midir?

Hayır, fakat sağduyunuzu kullanın. Örneğin, 255 karaktere sahip bir sürüm karakteri muhtemelen gereksizdir. Ayrıca, karakterlerin uzunluğu konusunda bazı sistemler kendi sınırlarını koyabilirler.

“v1.2.3” bir Anlamsal Sürüm Numaralandırma mıdır?

Hayır, “v1.2.3” bir anlamsal sürüm bu maralandırma değildir. Yine de, bir anlamsal sürüm numaralandırmayı bir “v” (İngilizcede )ile başlatmak bunun bir versiyon numaralandırması olduğunu gösteren ortak bir yoldur. Versiyonu “v” olarak kısaltmak versiyon kontrolünde sıklıkla görülür. Örneğin: git tag v1.2.3 -m “Release version 1.2.3”, bu durumda “v1.2.3” bir etiket ismi ve “1.2.3” bir anlamsal sürüm numaralandırmadır.

SemVer kontrolü için önerilen bir regular expression (RegEx) var mıdır?

İki tane var. Adlandırılmış gruplara sahip birisi şunları destekler. (PCRE [Perl Compatible Regular Expressions, i.e. Perl, PHP and R], Python ve Go)

Bakınız: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Numaralandırılmış yakalama gruplarına sahip (yani cg1 = major, cg2 = minor, cg3 = patch, cg4 = prerelease ve cg5 = buildmetadata kullanmak yerine) ECMA Script (JavaScript),(Perl Compatible Regular Expressions, vb. Perl, PHP and R), Python ve Go destekleyen diğeri.

Bakınız: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Hakkında

Anlamsal Sürüm Numaralandırma şartnamesi, Gravatar’ların kaşifi ve GitHub’un kurucu ortaklarından olan Tom Preston-Werner tarafından yazılmıştır.

Geribildirim vermek isterseniz, lütfen GitHub’da bir konu açın.

Lisans

Creative Commons ― CC BY 3.0\nAnlamsal Sürüm Numaralandırma 2.0.0\nBÜYÜK.KÜÇÜK.YAMA diye belirtilen bir sürüm numaralandırmasında:\nÖnceki sürüm ile uyumsuz API değişiklikleri yaptığınızda BÜYÜK sürümü,\nÖnceki sürüm ile uyumlu bir özellik eklediğinizde KÜÇÜK sürümü\nÖnceki sürüm ile uyumlu hata düzeltmeleri yaptığınızda YAMA sürümünü\nAyrıca, BÜYÜK.KÜÇÜK.YAMA biçiminin sonuna ön-sunum (pre-release) ve derleme üstverisi (build metadata) gibi etiketler eklenebilmektedir.\nYazılım yönetimi dünyasında “imkansız bağımlılıklar” (dependency hell) adında korkulu bir ihtimal vardır. Sisteminiz büyüdükçe ve yazılımınıza daha çok paket eklediğinizde, büyük ihtimalle bir gün gelecek ve kendinizi bu çaresizlik batağında bulacaksınız.\nBirçok bağımlılığı olan sistemlerde, yeni bir paket sürümü çıkarmak bir kabusa dönüşebilir. Bağımlılıklar çok sıkı belirlenmişse, sürüm kilitlenmesi (bağımlı olunan tüm paketlerin yeni sürümünü yükseltmeden istenen paketin sürümünü yükseltememek) tehlikesiyle karşı karşıyasınız demektir. Eğer bağımlılıklar çok gevşek belirlenmişse, ister istemez sürüm çeşitliliği (gelecekteki sürümlerle aşırı uyumluluk varsaymak) tarafından etkileneceksiniz. Sürüm kilitlenmesi ve/veya sürüm çeşitliliği nedeniyle projenizi güvenli bir şekilde ilerletemediğinizde imkansız bağımlılıkların içindesiniz demektir.\nBu soruna bir çözüm olarak, sürüm numaralarının nasıl verildiği ve artırıldığı konusunda bazı basit kurallar ve gereklilikler öneriyoruz. Bu kurallar, genel kabul görmüş, hem kapalı hem de açık kaynak yazılım uygulamalarına dayansa da, sadece onlarla sınırlı değildir. Bu numaralandırma sisteminin çalışması için, öncelikle erişime açık bir API (public API) tanımlamanız gerekiyor. Bu, belgeleme veya kod tarafından konulmuş bir kuraldan oluşabilir. Ne şekilde olursa olsun, önemli olan bu API’ın açık ve kesin olmasıdır. Erişime açık API’ınızı tanımladığınız anda, bundan sonra geçireceği değişimleri, sürüm numaranızı belirli artırımlara tabi tutarak iletmelisiniz. Şu şekilde bir sürüm numarası ele alalım: X.Y.Z (Büyük.Küçük.Yama). API’ı etkilemeyen hata düzeltmeleri yama sürümünü artırır, önceki sürümlerle uyumlu API eklemeleri/değişiklikleri küçük sürümü artırır, ve önceki sürümler ile uyumsuz API değişikleri büyük sürümü artırır.\nBu sistemi “Anlamsal Sürüm Numaralandırma” diye nitelendiriyoruz. Bu taslak sayesinde, sürüm numaraları ve sürüm numaralarının değişim şekilleri, kodda, bir sürümden diğerine neyin değiştiğini anlatır hale gelmektedir.\nAnlamsal Sürüm Numaralandırma Tanımı (SemVer)\nBu belge içindeki anahtar sözcükler ve/veya eklerinden oluşan “-MALI”, “-MELİ”, “-MAMALI”, “-MEMELİ”, “GEREKLİ”, “-ECEK”, “-ACAK”, “-MEYECEK”, “-MAYACAK”, “-EBİLİR”, ÖNERİLİR”, “OLABİLİR”, ve “İSTEĞE BAĞLI”, RFC 2119‘da belirtildiği şekilde anlaşılmalıdır.\nAnlamsal Sürüm Numaralandırma kullanan bir yazılım erişime açık bir API tanımlamalıdır. Bu API, kodun kendi içinde veya yalnızca zaten var olan bir belgelemenin içinde tanımlanabilir. Nasıl yapılırsa yapılsın, kesin ve eksiksiz olmalıdır.\nAnlamsal Sürüm Numaralandırma kullanan bir yazılım erişime açık bir API tanımlamalıdır. Bu API, kodun kendi içinde veya yalnızca zaten var olan bir belgelemenin içinde tanımlanabilir. Nasıl yapılırsa yapılsın, kesin ve eksiksiz olmalıdır.\nNormal bir sürüm numarası X.Y.Z biçimde OLMALIDIR; burada X, Y, ve Z negatif olmayan tam sayılardır ve başlarında sıfır İÇERMEMELİDİR. X büyük sürümdür, Y küçük sürümdür ve Z yama sürümüdür. Her öğe sayısal olarak ARTMALIDIR. Örnek: 1.9.0 -> 1.10.0 -> 1.11.0.\nNormal bir sürüm numarası X.Y.Z biçimde OLMALIDIR; burada X, Y, ve Z negatif olmayan tam sayılardır ve başlarında sıfır İÇERMEMELİDİR. X büyük sürümdür, Y küçük sürümdür ve Z yama sürümüdür. Her öğe sayısal olarak ARTMALIDIR. Örnek: 1.9.0 -> 1.10.0 -> 1.11.0.\nNumaralandırılmış bir paket sunulduğunda, o sürümün içeriği DEĞİŞTİRİLMEMELİDİR. Yapılan herhangi bir değişim yeni bir sürüm olarak sunulmalıdır.\nNumaralandırılmış bir paket sunulduğunda, o sürümün içeriği DEĞİŞTİRİLMEMELİDİR. Yapılan herhangi bir değişim yeni bir sürüm olarak sunulmalıdır.\nSıfır olan Büyük sürüm başlangıçta yapılan yazılım geliştirme içindir. Her şey her an değişebilir. Erişime açık API dengeli (stable) diye değerlendirilmemelidir.\nSıfır olan Büyük sürüm başlangıçta yapılan yazılım geliştirme içindir. Her şey her an değişebilir. Erişime açık API dengeli (stable) diye değerlendirilmemelidir.\n1.0.0 sürümü erişime açık API’ı tanımlar. Sürüm numarasının bu sürümden sonra nasıl artırılacağı bu erişime açık API’a ve nasıl değiştiğine bağlıdır.\n1.0.0 sürümü erişime açık API’ı tanımlar. Sürüm numarasının bu sürümden sonra nasıl artırılacağı bu erişime açık API’a ve nasıl değiştiğine bağlıdır.\nYama sürümü Z (x.y.Z | X > 0) sadece önceki sürüm ile uyumlu hata düzeltmeleri yapıldığında ARTIRILMALIDIR. Hata düzeltmesi şöyle tanımlanır: Yanlış bir davranışı düzelten içsel bir değişiklik.\nYama sürümü Z (x.y.Z | X > 0) sadece önceki sürüm ile uyumlu hata düzeltmeleri yapıldığında ARTIRILMALIDIR. Hata düzeltmesi şöyle tanımlanır: Yanlış bir davranışı düzelten içsel bir değişiklik.\nKüçük sürüm Y (x.Y.z | x > 0), erişime açık API’a yeni, önceki sürüm ile uyumlu bir özellik eklendiğinde ARTIRILMALIDIR. Erişime açık API’daki bir özellik artık kullanmayan (deprecated) olarak işaretlendiğinde ARTIRILMALIDIR. Özel koda ciddi oranda yeni özellikler veya geliştirmeler katıldığında ARTTIRILABİLİR. Yama düzeyindeki değişiklikler buna dahil EDİLEBİLİR. Yama sürümü, küçük sürüm artırıldığında SIFIRLANMALIDIR.\nKüçük sürüm Y (x.Y.z | x > 0), erişime açık API’a yeni, önceki sürüm ile uyumlu bir özellik eklendiğinde ARTIRILMALIDIR. Erişime açık API’daki bir özellik artık kullanmayan (deprecated) olarak işaretlendiğinde ARTIRILMALIDIR. Özel koda ciddi oranda yeni özellikler veya geliştirmeler katıldığında ARTTIRILABİLİR. Yama düzeyindeki değişiklikler buna dahil EDİLEBİLİR. Yama sürümü, küçük sürüm artırıldığında SIFIRLANMALIDIR.\nBüyük sürüm X (X.y.z | X > 0) önceki sürüm ile uyumsuz değişiklikler yapıldığında ARTIRILMALIDIR. Yama ve küçük düzeydeki değişiklikler buna dahil edilebilir. Büyük sürüm artırıldığında yama ve küçük sürüm SIFIRLANMALIDIR.\nBüyük sürüm X (X.y.z | X > 0) önceki sürüm ile uyumsuz değişiklikler yapıldığında ARTIRILMALIDIR. Yama ve küçük düzeydeki değişiklikler buna dahil edilebilir. Büyük sürüm artırıldığında yama ve küçük sürüm SIFIRLANMALIDIR.\nBir ön-sunum (pre-release) sürümü, yama sürümünden hemen sonraki kısımda, bir tire işaretiyle ve bir dizi nokta ayracıyla GÖSTERİLEBİLİR. Tanımlayıcılar yalnızca ASCII alfasayısal ve tire işaretlerinden [0-9A-Za-z-] OLUŞMALIDIR. Tanımlayıcılar boş OLMAMALIDIR. Sayısal tanımlayıcılar öncül sıfırlar İÇERMEMELİDİR. Ön-sunum sürümleri ilişkili normal sürümden daha düşük önceliğe sahiptir. İlişkili normal sürümün tersine, bir ön-sunum sürümü, sürümün kararsız olduğunu ve beklenen uyumluluk gereksinimlerini karşılayamayacağını gösterir. Örnekler: 1.0.0-ilk, 1.0.0-ilk.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nBir ön-sunum (pre-release) sürümü, yama sürümünden hemen sonraki kısımda, bir tire işaretiyle ve bir dizi nokta ayracıyla GÖSTERİLEBİLİR. Tanımlayıcılar yalnızca ASCII alfasayısal ve tire işaretlerinden [0-9A-Za-z-] OLUŞMALIDIR. Tanımlayıcılar boş OLMAMALIDIR. Sayısal tanımlayıcılar öncül sıfırlar İÇERMEMELİDİR. Ön-sunum sürümleri ilişkili normal sürümden daha düşük önceliğe sahiptir. İlişkili normal sürümün tersine, bir ön-sunum sürümü, sürümün kararsız olduğunu ve beklenen uyumluluk gereksinimlerini karşılayamayacağını gösterir. Örnekler: 1.0.0-ilk, 1.0.0-ilk.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nDerleme üst verisi, yama sürümünü veya ön-sunum sürümünü hemen takip ederek eklenen bir artı işaretiyle ve bir dizi nokta ayracıyla GÖSTERİLEBİLİR. Tanımlayıcılar yalnızca ASCII alfasayısal ve tire işaretlerinden [0-9A-Za-z-] OLUŞMALIDIR. Tanımlayıcılar boş OLMAMALIDIR. Derleme üstverisi sürüm önceliği belirlenirken dikkate ALINMAMALIDIR. Böylece, yalnızca derleme üstverisiyle farklılık gösteren iki sürüm de aynı önceliğe sahip olacaktır. Örnekler: 1.0.0-ilk+001, 1.0.0+20130313144700, 1.0.0-ikincil+deneme.sha.5114f85.\nDerleme üst verisi, yama sürümünü veya ön-sunum sürümünü hemen takip ederek eklenen bir artı işaretiyle ve bir dizi nokta ayracıyla GÖSTERİLEBİLİR. Tanımlayıcılar yalnızca ASCII alfasayısal ve tire işaretlerinden [0-9A-Za-z-] OLUŞMALIDIR. Tanımlayıcılar boş OLMAMALIDIR. Derleme üstverisi sürüm önceliği belirlenirken dikkate ALINMAMALIDIR. Böylece, yalnızca derleme üstverisiyle farklılık gösteren iki sürüm de aynı önceliğe sahip olacaktır. Örnekler: 1.0.0-ilk+001, 1.0.0+20130313144700, 1.0.0-ikincil+deneme.sha.5114f85.\nÖncelik, sürümlerin sıralandıklarında, birbirleriyle sıralarının nasıl karşılaştırılacaklarını belirtir.\nÖncelik, sürümlerin sıralandıklarında, birbirleriyle sıralarının nasıl karşılaştırılacaklarını belirtir.\nÖncelik sürüm numarası büyük, küçük, yama ve ön-sunum tanımlayıcılarıyla, burada yazıldığı sırada (Derleme üstverisi öncelik belirlenirken anlamsızdır) ayırarak HESAPLANMALIDIR.\nÖncelik, soldan sağa doğru tanımlayıcıların her birini şu şekilde karşılaştırırken belirlenir: Büyük, küçük, ve yama sürümleri daima sayısal olarak karşılaştırılır.\nÖrnek: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nBüyük, küçük ve yama eşit olduğunda, bir ön-sunum sürümü, normal bir sürümden daha düşük önceliğe sahiptir.\nÖrnek: 1.0.0-ilk < 1.0.0.\nAynı büyük, küçük ve yama sürümüne sahip iki ön-sunum sürümünün önceliği, şu şekilde gösterildiği gibi, soldan sağa doğru her bir tanımlayıcıyı ayırıp karşılaştırarak BELİRLENMELİDİR:\nYalnızca rakamlardan oluşan tanımlayıcılar sayısal olarak karşılaştırılır\nHarfli veya tire çizgili tanımlayıcılar ise ASCII sözcük sıralamalarına göre karşılaştırılırlar.\nSayısal tanımlayıcılar, sayısal olmayan tanımlayıcılardan daima daha düşük önceliğe sahiptirler.\nÖnce gelen tüm tanımlayıcıları eşitse, büyük bir dizi ön-sunumun alanlarının, daha küçük bir dizininkinden daha yüksek önceliği vardır.\nÖrneğin: 1.0.0-ilk < 1.0.0-ilk.1 < 1.0.0-ilk.ikincil < 1.0.0-ikincil < 1.0.0-ikincil.2 < 1.0.0-ikincil.11 < 1.0.0-sa.1 < 1.0.0.\nBackus ― Naur formu grameri için geçerli SemVer versiyonları\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nAnlamsal Sürüm Numaralandırma Neden Kullanılmalıdır?\nAslında, bu yeni veya çığır açan bir fikir değil. Büyük olasılıkla buna yakın bir şeyler zaten yapıyorsunuzdur. Sorun şudur: “yakın” olması yeterince iyi değildir. Bir şekilde belirlenmiş, resmi bir şartnameye uymadan, sürüm sayıları bağımlılık yönetimi için gerçek hayatta kullanışsızdır. Üstteki fikirleri isimlendirip, açık tanımlamalar yaparak, yazılımınızın kullanıcılarına niyetinizi iletmeniz kolaylaşır. Niyetler bir kere açık, esnek olduğunda (fakat aşırı esnekleştirmeden), bağımlılık tanımlamaları yapılabilir hale gelir.\nBasit bir örnek Anlamsal Sürüm Numaralandırma’nın imkansız bağımlılıklar nasıl geçmişin bir parçası haline getirebildiğini gösterecek. “İtfaiye Aracı” isminde bir kütüphaneyi ele alalım. “Merdiven” adındaki Anlamsal Sürüm ile Numaralandırılmış bir pakete ihtiyaç duymaktadır. İtfaiye Aracı yaratıldığında, Merdiven 3.1.0 sürümündedir. İtfaiye Aracı 3.1.0’da eklenmiş bazı işlevlere ihtiyaç duyduğundan, Merdiven bağımlılığının 3.1.0’a eşit ya da daha büyük fakat 4.0.0’dan küçük olduğunu güvenle belirtebilirsiniz. Böylelikle, Merdiven sürüm 3.1.1 ve 3.2.0 kullanılabilir olduğunda, paket yönetim sisteminize bunları sunabilirsiniz ve halihazırdaki bağımlılığı bulunduğu yazılımla uyumlu olacağını bilirsiniz.\nSorumluluk sahibi bir yazılım geliştirici olarak, tabii ki her paket güncellemesinin duyurulduğu şekilde işlediğini kontrol etmek isteyeceksiniz. Gerçek dünya karışık bir yerdir; gözünüzü açık tutmak dışında yapabileceğiniz pek bir şey yoktur. Ancak, yapabileceğiniz şudur: Bağımlı olunan paketlerin yeni sürümlerini çıkarmaya gerek kalmadan paketleri sunmak ve yükseltmek için sizi zaman ve eziyetten kurtaracak mantıklı bir yol öneren Anlamsal Sürüm Numaralandırma’yi kullanmaktır.\nBütün bunlar size uygunsa, Anlamsal Sürüm Numaralandırma’yi kullanmaya başlamak için yapmanız gereken tek şey kullanmaya başladığınızı ve kurallarını takip ettiğinizi duyurmaktır. BENİOKU (README) dosyanızdan bu web sitesine bağlantı vererek diğerlerinin de kuralları bilmesini ve bunlardan yarar sağlamalarını sağlayabilirsiniz.\nİlk geliştirme fazı olan 0.y.z’deki değişikliklerle nasıl başa çıkmalıyım?\nYapılabilecek en basit şey ilk geliştirme sürümünüzü 0.1.0’da başlatmaktır ve takip eden her sürüm için küçük sürümü artırmaktır.\n1.0.0’ı ne zaman sunacağımı nasıl anlarım?\nYazılımınız kullanıma hazır (production) ortamında kullanılmaya başlanmışsa, sürümü zaten muhtemelen 1.0.0’dır. Kullanıcıların güvenebildiği kararlı bir API’a sahipseniz, 1.0.0’da olmalısınız. Önceki sürüm ile uyumlu olmayı dert ediyorsanız, büyük olasılıkla, çoktandır 1.0.0 olmalısınız.\nAnlamsal Sürüm Numaralandırma, çabuk geliştirmeden ve hızlı özyinelemeden caydırmaz mı?\nBüyük sürümün sıfır olması tamamen seri geliştirmeyle alakalıdır. Eğer API’ı her gün değiştiriyorsanız ya hala 0.y.z sürümü ya da sıradaki büyük sürümün üzerinde çalıştığınız ayrı bir geliştirme dalı (branch) üzerinde olmalısınız.\nErişime açık API’ımın önceki bir sürümüyle uyumsuz en küçük değişiklikler bile Büyük sürümü artıracaksa, kendimi birden 42.0.0 sürümünde bulmayacak mıyım?\nBu sorumluluk sahibi yazılım geliştirmekle ve ileri görüşlülükle alakalı bir sorudur. Birçok bağımlılığı olan bir yazılıma uyumsuz değişiklikler öylesine eklenmemelidir. Maruz kalınacak yükseltme maliyeti ciddi boyutlarda olabilir. Uyumsuz değişikliklerde büyük sürümü artırmak demek yaptığınız değişikliklerin etkileri hakkında etraflıca düşüneceğinizi, ve maliyet/kazanç oranına göre karar vermenizi gerektirecektir.\nErişime açık API’ın tamamını belgelendirmek büyük iş!\nBaşkaları tarafından kullanılacağı düşünülen bir yazılımı düzgün bir şekilde belgelendirmek usta bir yazılım geliştirici olarak sizin sorumluluğunuzdur. Yazılım karmaşıklığını yönetmek bir projeyi verimli tutmanın çok önemli bir kısmıdır ve kimse yazılımınızı nasıl kullanacağını ya da hangi yöntemleri (methods) çağırmanın güvenli olacağını bilemiyorsa bunu yapmak zordur. Anlamsal Sürüm Numaralandırma, uzun dönemde, ve iyi tanımlanmış erişime açık bir API ile herkesin ve her şeyin sorunsuzca devam etmesini sağlar.\nÖnceki sürüm ile uyumsuz bir değişikliği yanlışlıkla küçük bir sürüm olarak sunarsam ne yaparım?\nAnlamsal Sürüm Numaralandırma şartnamesini bozduğunuzu farkettiğiniz anda, sorunu düzeltin ve sorunu düzelten ve önceki sürüm le uyumluluğunu sağlayan yeni bir küçük sürüm sunun. Bu şartlar altında bile, numaralandırılmış sunumları kesinlikle değiştirmeyin. Mümkünse, sıkıntı çıkaran sürümü belgelendirin ve kullanıcılarınızı sorunla alakalı olarak bilgilendirin böylece sıkıntı çıkaran sürümden haberleri olmuş olur.\nErişime açık API’ı değiştirmeden yazılımın bağımlılıklarını güncellersem ne yapmalıyım?\nErişime açık API’ı etkilemediğinden uyumlu olarak değerlendirilebilecek bir durumdur. Paketinizle aynı bağımlılıklara sahip olan bir yazılımın kendi bağımlılık şartnameleri olmalıdır ve yazılımcısı tüm uyuşmazlıkları farkedecektir. Bir hatayı düzeltmek ya da yeni bir işlev kazandırmak için bağımlılıklarınızı güncelleyip güncellemediğiniz, yama ya da küçük seviyede bir değişiklik yapıp yapmadığınızı belirler. İkinci örnekteki durum için genelde ilave kod bekleriz ki bu her iki durum da küçük seviye bir artırır.\nYa yanlışlıkla erişime açık API’ı sürüm numarasıyla uyumlu olmayacak bir şekilde değiştirmişsem (örn: yama sunumunda büyük bir kırılım oluşturan kod)?\nSağduyunuzu kullanın. Erişime açık API’ın davranışını beklenen, önceki haline geri getirmenizden etkilenecek büyük bir kullanıcı kitleniz varsa, düzeltmeniz bir yama sunumu gibi değerlendirilebilir olsa da, büyük bir sürüm sunumu yapmak en iyi seçenek olabilir. Anlamsal Sürüm Numaralandırma’nin tüm amacının sürüm numaralarının nasıl değiştiğini ifade ettiğini unutmayın. Eğer bu değişiklikler kullanıcılarınız için önemliyse, sürüm numarasını kullanarak onları bilgilendirin.\nArtık kullanılamayacak bir işlevle nasıl başa çıkabilirim?\nVar olan işlevlerin çürümesi yazılım geliştirmenin normal bir parçasıdır ve ileri adım atabilmek için genellikle gerekir. Erişime açık API’ınızın bir kısmını artık kullanılmayacak şekilde geliştirdiğinizde, iki şey yapmalısınız: (1) değişiklik konusunda kullanıcılarınızı bilgilendirmek için belgelendirmenizi güncelleyin, (2) artık kullanmayan yöntemleri içeren küçük bir sunum çıkarın. İşlevi büyük bir sunumla tamamen kaldırmadan önce, kullanıcılarınızın yeni API’a kolayca geçiş yapabilmeleri için artık kullanılmayan yöntemleri içeren en az bir adet küçük bir sunum olmalıdır.\nSemVer, sürüm karakterlerinde (string)  bir sınıra sahip midir?\nHayır, fakat sağduyunuzu kullanın. Örneğin, 255 karaktere sahip bir sürüm karakteri muhtemelen gereksizdir. Ayrıca, karakterlerin uzunluğu konusunda bazı sistemler kendi sınırlarını koyabilirler.\n“v1.2.3” bir Anlamsal Sürüm Numaralandırma mıdır?\nHayır, “v1.2.3” bir anlamsal sürüm bu maralandırma değildir. Yine de, bir anlamsal sürüm numaralandırmayı bir “v” (İngilizcede )ile başlatmak bunun bir versiyon numaralandırması olduğunu gösteren ortak bir yoldur. Versiyonu “v” olarak kısaltmak versiyon kontrolünde sıklıkla görülür. Örneğin: git tag v1.2.3 -m “Release version 1.2.3”, bu durumda “v1.2.3” bir etiket ismi ve “1.2.3” bir anlamsal sürüm numaralandırmadır.\nSemVer kontrolü için önerilen bir regular expression (RegEx) var mıdır?\nİki tane var. Adlandırılmış gruplara sahip birisi şunları destekler. (PCRE [Perl Compatible Regular Expressions, i.e. Perl, PHP and R], Python ve Go)\nBakınız: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nNumaralandırılmış yakalama gruplarına sahip (yani cg1 = major, cg2 = minor, cg3 = patch, cg4 = prerelease ve cg5 = buildmetadata kullanmak yerine) ECMA Script (JavaScript),(Perl Compatible Regular Expressions, vb. Perl, PHP and R), Python ve Go destekleyen diğeri.\nBakınız: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nAnlamsal Sürüm Numaralandırma şartnamesi, Gravatar’ların kaşifi ve GitHub’un kurucu ortaklarından olan Tom Preston-Werner tarafından yazılmıştır.\nGeribildirim vermek isterseniz, lütfen GitHub’da bir konu açın.\nGitHub’da bir konu açın\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nСемантичне Версіонування 2.0.0

Коротко

У випадку, коли версія має вигляд МАЖОРНА.МІНОРНА.ПАТЧ, слід збільшувати:


  МАЖОРНУ версію, якщо зроблені зміни API, що несумісні з попередньою версією
  МІНОРНУ версію, якщо додана нова функціональність, що є сумісною з попередньою версією
  ПАТЧ версію, якщо були зроблені виправлення помилок, що не впливають на сумісність з попередньою версією


Додаткові позначки для передрелізних збірок дозволені, як розширення до формату МАЖОРНА.МІНОРНА.ПАТЧ.

Вступ

У світі управління програмним забезпеченням існує таке поняття, як  “dependency hell” (пекло залежностей). Із розростанням системи та інтеграцією в неї великої кількості пакетів дуже ймовірно опинитись у цій ситуації.

У системах з багатьма залежностями випуск нових версій пакетів може швидко перетворитись на жах. Якщо специфікації залежностей занадто жорсткі, існує небезпека блокування випуску нової версії (неможливість оновити пакет без випуску нових версій кожного залежного пакета). Якщо ж залежності специфіковані занадто вільно, ви неминуче будете покарані безладом у версіях (припускаючи сумісність з більшою кількістю майбутніх версій, ніж це доцільно). Пекло залежностей ― це ситуація, коли блокування версій та/або несумісність версій заважає легко і безпечно просувати ваш проект вперед.

В якості вирішення цієї проблеми пропонується простий набір правил і вимог, які визначають те, як призначаються та збільшуються номери версій. Ці правила ґрунтуються (але цим не обмежуються) на існуючих поширених практиках, що використовуються як в закритому, так і у відкритому програмному забезпеченні. Щоб ця система працювала, спочатку потрібно оголосити публічний API. Він може описуватись в  документації, або ж безпосередньо кодом. Незалежно від форми, важливо, щоб цей API був чітким і точним. Після того, як був визначений публічний API, ви сповіщаєте про його зміни шляхом збільшення певних номерів версії. Розглянемо формат версії X.Y.Z (МАЖОРНА.МІНОРНА.ПАТЧ). Виправлення помилок, які не впливають на API, збільшують ПАТЧ-версію. Розширення/зміни API, що сумісні з попередньою версією, збільшують МІНОРНУ версію. Ті ж зміни API, що несумісні із минулою версією, збільшують МАЖОРНУ версію.

Цю систему названо “Семантичне Версіонування”. Відповідно до неї, номери версій і спосіб їх зміни передають інформацію про базовий код і про те, що змінено від попередньої до нової версії.

Специфікація Семантичного Версіонування (SemVer)

Ключові слова “ПОВИНЕН” (MUST), “НЕ ПОВИНЕН” (MUST NOT), “ОБОВ’ЯЗКОВО” (REQUIRED), “МАЄ” (SHALL), “НЕ МАЄ” (SHALL NOT), “БАЖАНО” (SHOULD), “НЕ БАЖАНО” (SHOULD NOT), “РЕКОМЕНДОВАНО” (RECOMMENDED), “МОЖЕ” (MAY), та “НЕ ОБОВ’ЯЗКОВО” (OPTIONAL), що використані в цьому документі, повинні бути інтерпретовані за RFC 2119.


  
    Програмне забезпечення, що використовує Семантичне Версіонування, ПОВИННЕ оголосити публічний API. Цей API може бути оголошений безпосередньо в коді, або ж існувати лише у вигляді документації. Незалежно від типу оголошення, воно повинне бути точним і всебічним.
  
  
    Правильний номер версії ПОВИНЕН мати форму X.Y.Z, де X, Y і Z є невід’ємними цілими числами, і НЕ ПОВИННІ мати нулі на початку. X ― мажорна версія, Y ― мінорна версія, а Z ― патч версія. Кожен елемент повинен збільшуватися чисельно. Наприклад: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Після випуску пакета конкретної версії, він НЕ ПОВИНЕН змінюватись. Будь-які зміни ПОВИННІ бути випущені, як нова версія.
  
  
    Нульова мажорна версія (0.y.z) призначена для початкової розробки. Будь-що МОЖЕ змінюватись в будь-який час. Публічний API такої версії не слід вважати стабільним.
  
  
    Версія 1.0.0 визначає публічний API. Спосіб, яким збільшуються номери версій після цього випуску, залежить від цього публічного API і від того, як він змінюється.
  
  
    Патч версія Z (x.y.Z | x > 0) ПОВИННА бути збільшена тільки якщо вона містить лише зворотньосумісні виправлення помилок. Виправленою помилкою називається внутрішня зміна, яка виправляє неправильну поведінку.
  
  
    Мінорна версія Y (x.Y.z | x > 0) ПОВИННА бути збільшена, якщо до публічного API додана нова зворотньосумісна функціональність. Вона ПОВИННА бути збільшена, якщо будь-яка функціональність публічного API позначена, як застаріла (deprecated). Вона МОЖЕ бути збільшена, якщо в приватний код внесені істотні зміни функціональних можливостей або вдосконалення. Вона МОЖЕ включати зміни рівня патчів. Патч версія ПОВИННА бути скинута до 0 при збільшенні мінорної версії.
  
  
    Мажорна версія X (X.y.z | X > 0) ПОВИННА бути збільшена, якщо до публічного API внесені будь-які зміни, що не сумісні з попередньою версією. Вона може включати зміни рівня мінорної та патч версій. Номери патч версії та мінорної версії ПОВИННІ бути скинуті до 0 при збільшенні мажорної версії.
  
  
    Передрелізна версія МОЖЕ бути позначена шляхом додавання безпосередньо після патч версії дефісу і ряду ідентифікаторів, розділених крапками. Ідентифікатори ПОВИННІ містити лише алфавітно-цифрові символи ASCII та дефіс [0-9A-Za-z-]. Ідентифікатори НЕ ПОВИННІ бути порожніми. Числові ідентифікатори НЕ ПОВИННІ мати нулі на початку. Передрелізні версії мають менший пріорітет за відповідні нормальні версії. Передрелізна версія вказує, що версія нестабільна і може не відповідати вимогам сумісності, на які вказує номер пов’язаної із нею нормальної версії. Приклади: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Метадані збірки МОЖНА позначати додаванням знаку плюс і ряду ідентифікаторів, розділених крапками, відразу після номеру патч версії або передрелізної версії. Ідентифікатори ПОВИННІ містити лише алфавітно-цифрові символи ASCII та дефіс [0-9A-Za-z-]. Ідентифікатори НЕ ПОВИННІ бути порожніми. Метадані збірки ПОВИННІ ігноруватися при визначенні пріоритету версії. Таким чином, дві версії, які відрізняються тільки метаданими, мають однаковий пріоритет. Приклади: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    Пріоритет визначає, як версії порівнюються одна з одною при упорядкуванні. Пріоритет ПОВИНЕН визначатись шляхом поділу версії на мажорний, мінорний, патч та передрелізний ідентифікатори саме в такому порядку (метадані збірки не впливають на пріоритет). Пріоритет визначається першою відмінністю під час порівняння кожного з цих ідентифікаторів зліва направо наступним чином: мажорні, мінорні та патч версії завжди порівнюються чисельно. Приклад: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Коли мажорна, мінорна і патч версія збігаються, передрелізна версія має менший пріоритет за звичайну версію. Приклад: 1.0.0-alpha < 1.0.0. Пріоритет для двох передрелізних версій з однаковими мажорною, мінорною і патч версіями ПОВИНЕН визначатися шляхом порівняння кожного окремого ідентифікатора, що розділені крапками, зліва направо, поки не буде знайдена різниця, в такому порядку: ідентифікатори, що складаються тільки з цифр, порівнюються чисельно; ідентифікатори з літерами або дефісами порівнюються лексично в порядку сортування ASCII. Числові ідентифікатори завжди мають менший пріоритет за нечислові ідентифікатори. Більший набір передрелізних полів має вищий пріоритет, ніж менший набір, якщо всі попередні ідентифікатори збігаються. Приклад: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.
  


Нотація форм Бекуса–Наура для дійсних версій SemVer
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


Навіщо використовувати Семантичне Версіонування?

Це не нова або революційна ідея. Насправді, вже існує багато близького до того. Проблема в тому, що “близького до того” недостатньо. Без відповідності певній формальній специфікації, номери версій є майже непридатними для управління залежностями. Надавши назви та чіткі визначення вищенаведеним ідеям, стає легко повідомляти про свої наміри кінцевим користувачам програмного забезпечення. Після того, як ці наміри стануть зрозумілими, нарешті можуть бути зроблені гнучкі (але не занадто гнучкі) специфікації для ведення залежностей.

Простий приклад продемонструє, як Семантичне Версіонування може залишити “dependency hell” в минулому. Розглянемо бібліотеку під назвою “Firetruck”. Вона залежить від Семантично Версіонованого пакету під назвою “Ladder”. На момент створення Firetruck, Ladder мав версію 3.1.0. Оскільки Firetruck використовує деяку функціональність Ladder, яка вперше була введена у версії 3.1.0, можна сміливо вказати на залежність від версій пакету Ladder, які більші або дорівнюють 3.1.0, але менші за 4.0.0. Тепер, коли версії 3.1.1 та 3.2.0 пакету Ladder стають доступними, їх можна буде опублікувати за допомогою системи управління пакетами і бути певним, що вони будуть сумісні з існуючим залежним від нього програмним забезпеченням.

Відповідальний розробник, звичайно, бажає переконатися, що будь-які оновлення пакета функціонують згідно з документацією. Реальний світ ― це хаотичне місце і ми нічого не можемо зробити, окрім, як бути пильними. Що можна зробити, це використовувати Семантичне Версіонування для випуску та оновлення пакетів без необхідності оновлення залежностей, заощаджуючи час і нерви.

Якщо це звучить цікаво, то все що потрібно зробити ― це почати користуватися Семантичним Версіонуванням, заявити про це, і дотримуватись правил. Додайте посилання на цей веб-сайт у README до проекту, щоб інші мали змогу дізнатись правила та скористатися ними.

FAQ

Як працювати з релізами у початковій фазі розробки 0.y.z?

Найпростіше зробити початковий реліз на рівні 0.1.0, а потім збільшувати мінорну версію для кожного наступного випуску.

Як дізнатися, коли потрібно випустити 1.0.0?

Якщо програмне забезпечення вже знаходиться експлуатації, то вже має бути 1.0.0. Якщо існує стабільний API, від якого залежать користувачі, повинна бути версія 1.0.0. Якщо вже починаються турботи про зворотну сумісність, має бути 1.0.0.

Чи не перешкоджає це стрімкій розробці та швидким ітераціям?

Нульова мажорна версія ― це активна стадія розробки. Якщо API змінюється щодня, треба або залишатись у версії 0.y.z або на окремій гілці розробки, працюючи над наступною мажорною версією.

Якщо навіть найдрібніші зміни, що не сумісні з попередньою версією до публічного API, вимагають збільшення мажорної версії, чи не призведе це до версії 42.0.0 занадто швидко?

Це питання відповідального розвитку і передбачення. Не слід легковажно ставитись до публікації несумісних змін програмного забезпечення, яке має багато залежного від нього коду. Витрати на модернізацію можуть бути дуже значними. Реліз мажорної версії з несумісними змінами означає, що вплив змін детально обдуманий, а співвідношення витрати/користь ― оцінене.

Повне документування публічного API ― це забагато роботи!

Професійний розробник має нести відповідальність за належне документування програмного забезпечення, призначеного для використання іншими користувачами. Управління складністю проекту є надзвичайно важливим фактором його ефективності, і цього важко досяги, якщо ніхто не розуміє, як це програмне забезпечення використовувати, або які методи безпечні для виклику. У довгостроковій перспективі, Семантичне Версіонування та наполягання на чітко визначеному публічному API дозволить всім і всьому працювати безперешкодно.

Що робити, якщо у якості мінорної версії випадково була випущена зміна, що несумісна з попередньою версією?

Як тільки стало відомим, що порушена Специфікація Семантичного Версіонування, треба виправити проблему і випустити нову мінорну версію, яка виправляє проблему і відновлює зворотню сумісність. Та навіть за таких обставин неприпустимо вносити зміни до вже випущених версій коду. Якщо це доречно, є сенс задокументувати версію, що порушує правила, та поінформувати користувачів про проблему, щоб вони знали про версію, яка порушує правила.

Що робити при оновленні внутрішніх залежностей, якщо публічний API не змінений?

Такі зміни вважаються сумісними, оскільки не впливають на публічний API. Програмне забезпечення, яке явно залежить від тих самих залежностей, повинне мати власні специфікації залежностей, і автор помітить будь-які конфлікти. Визначення того, чи є така зміна модифікацією рівня патча або рівня мінорної версії, залежить від того, чи внутрішні залежності були оновлені з метою виправлення помилки або з метою введення нової функціональності. В останньому випадку зазвичай слід очікувати додавання деякої кількості коду, що, вочевидь, є зміною рівня мінорної версії.

Що робити, якщо випадково був змінений публічний API у спосіб, що не відповідає зміненій версії (тобто, код має несумісні зміни у патч-релізі)?

На ваш розсуд. Якщо у вас є величезна аудиторія, на яку буде сильно впливати зміна публічного API, то краще всього зробити реліз мажорної версії, навіть якщо фактичне виправлення всього лише рівня патч-версії. Пам’ятайте, що за Семантичним Версіонуванням зміна версії повинна давати розуміння значущості змін. Якщо ці зміни важливі для користувачів, використовуйте номер версії, щоб повідомити їх.

Як оголосити застарілою (deprecated) деяку функціональність?

Оголошення застарілими існуючих функціональних можливостей є звичайною частиною розробки програмного забезпечення і часто є необхідною умовою прогресу. Коли потрібно оголосити застарілим частину публічного API, слід виконати дві речі: (1) оновити документацію, щоб користувачі могли дізнатися про зміну, (2) випустити мінорний реліз, що містить застарілу функціональність. Перш ніж повністю видалити застарілу функціональність у новому мажорному релізі, має бути принаймні один мінорний реліз, який містить функції, що будуть видалені. Таким чином, користувачі зможуть плавно перейти до нового API.

Чи має semver обмеження на розмір рядка версії?

Ні, але будьте розсудливими. Номер версії з 255 символів ― це, можливо, забагато. До того ж, певні системи можуть накладати свої власні обмеження на розмір рядка.

Чи є “v1.2.3” семантичною версією?

Ні, “v1.2.3” не є семантичною версією. Однак префікс семантичної версії з “v” ― це поширений спосіб (англійською мовою) вказати, що це номер версії. Скорочення “version” як “v” часто зустрічається в системах контролю версій. Наприклад: git tag v1.2.3 -m "Release version 1.2.3", у цьому випадку “v1.2.3” є назвою тегу, а семантична версія ― “1.2.3”.

Чи існує запропонований регулярний вираз (RegEx) для перевірки рядка SemVer?

Є два. Один містить іменовані групи систем, які мають їх підтримку (PCRE [Perl Compatible Regular Expressions, напр. Perl, PHP або R], Python
або Go).

Див.: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Та інший, натомість, із пронумерованими групами захоплення ― capture groups (де cg1 = мажорна, cg2 = мінорна,
cg3 = патч, cg4 = передрелізна та cg5 = метадані збірки) які сумісні із ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
напр. Perl, PHP або R), Python або Go.

Див.: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Про проект

Автором Специфікації Семантичного Версіонування є Том Престон-Вернер, засновник Gravatars та співзасновник GitHub.

Якщо ви бажаєте залишити відгук, відкрийте issue на GitHub.

Ліцензія

Creative Commons ― CC BY 3.0\nСемантичне Версіонування 2.0.0\nУ випадку, коли версія має вигляд МАЖОРНА.МІНОРНА.ПАТЧ, слід збільшувати:\nМАЖОРНУ версію, якщо зроблені зміни API, що несумісні з попередньою версією\nМІНОРНУ версію, якщо додана нова функціональність, що є сумісною з попередньою версією\nПАТЧ версію, якщо були зроблені виправлення помилок, що не впливають на сумісність з попередньою версією\nДодаткові позначки для передрелізних збірок дозволені, як розширення до формату МАЖОРНА.МІНОРНА.ПАТЧ.\nУ світі управління програмним забезпеченням існує таке поняття, як  “dependency hell” (пекло залежностей). Із розростанням системи та інтеграцією в неї великої кількості пакетів дуже ймовірно опинитись у цій ситуації.\nУ системах з багатьма залежностями випуск нових версій пакетів може швидко перетворитись на жах. Якщо специфікації залежностей занадто жорсткі, існує небезпека блокування випуску нової версії (неможливість оновити пакет без випуску нових версій кожного залежного пакета). Якщо ж залежності специфіковані занадто вільно, ви неминуче будете покарані безладом у версіях (припускаючи сумісність з більшою кількістю майбутніх версій, ніж це доцільно). Пекло залежностей ― це ситуація, коли блокування версій та/або несумісність версій заважає легко і безпечно просувати ваш проект вперед.\nВ якості вирішення цієї проблеми пропонується простий набір правил і вимог, які визначають те, як призначаються та збільшуються номери версій. Ці правила ґрунтуються (але цим не обмежуються) на існуючих поширених практиках, що використовуються як в закритому, так і у відкритому програмному забезпеченні. Щоб ця система працювала, спочатку потрібно оголосити публічний API. Він може описуватись в  документації, або ж безпосередньо кодом. Незалежно від форми, важливо, щоб цей API був чітким і точним. Після того, як був визначений публічний API, ви сповіщаєте про його зміни шляхом збільшення певних номерів версії. Розглянемо формат версії X.Y.Z (МАЖОРНА.МІНОРНА.ПАТЧ). Виправлення помилок, які не впливають на API, збільшують ПАТЧ-версію. Розширення/зміни API, що сумісні з попередньою версією, збільшують МІНОРНУ версію. Ті ж зміни API, що несумісні із минулою версією, збільшують МАЖОРНУ версію.\nЦю систему названо “Семантичне Версіонування”. Відповідно до неї, номери версій і спосіб їх зміни передають інформацію про базовий код і про те, що змінено від попередньої до нової версії.\nСпецифікація Семантичного Версіонування (SemVer)\nКлючові слова “ПОВИНЕН” (MUST), “НЕ ПОВИНЕН” (MUST NOT), “ОБОВ’ЯЗКОВО” (REQUIRED), “МАЄ” (SHALL), “НЕ МАЄ” (SHALL NOT), “БАЖАНО” (SHOULD), “НЕ БАЖАНО” (SHOULD NOT), “РЕКОМЕНДОВАНО” (RECOMMENDED), “МОЖЕ” (MAY), та “НЕ ОБОВ’ЯЗКОВО” (OPTIONAL), що використані в цьому документі, повинні бути інтерпретовані за RFC 2119.\nПрограмне забезпечення, що використовує Семантичне Версіонування, ПОВИННЕ оголосити публічний API. Цей API може бути оголошений безпосередньо в коді, або ж існувати лише у вигляді документації. Незалежно від типу оголошення, воно повинне бути точним і всебічним.\nПрограмне забезпечення, що використовує Семантичне Версіонування, ПОВИННЕ оголосити публічний API. Цей API може бути оголошений безпосередньо в коді, або ж існувати лише у вигляді документації. Незалежно від типу оголошення, воно повинне бути точним і всебічним.\nПравильний номер версії ПОВИНЕН мати форму X.Y.Z, де X, Y і Z є невід’ємними цілими числами, і НЕ ПОВИННІ мати нулі на початку. X ― мажорна версія, Y ― мінорна версія, а Z ― патч версія. Кожен елемент повинен збільшуватися чисельно. Наприклад: 1.9.0 -> 1.10.0 -> 1.11.0.\nПравильний номер версії ПОВИНЕН мати форму X.Y.Z, де X, Y і Z є невід’ємними цілими числами, і НЕ ПОВИННІ мати нулі на початку. X ― мажорна версія, Y ― мінорна версія, а Z ― патч версія. Кожен елемент повинен збільшуватися чисельно. Наприклад: 1.9.0 -> 1.10.0 -> 1.11.0.\nПісля випуску пакета конкретної версії, він НЕ ПОВИНЕН змінюватись. Будь-які зміни ПОВИННІ бути випущені, як нова версія.\nПісля випуску пакета конкретної версії, він НЕ ПОВИНЕН змінюватись. Будь-які зміни ПОВИННІ бути випущені, як нова версія.\nНульова мажорна версія (0.y.z) призначена для початкової розробки. Будь-що МОЖЕ змінюватись в будь-який час. Публічний API такої версії не слід вважати стабільним.\nНульова мажорна версія (0.y.z) призначена для початкової розробки. Будь-що МОЖЕ змінюватись в будь-який час. Публічний API такої версії не слід вважати стабільним.\nВерсія 1.0.0 визначає публічний API. Спосіб, яким збільшуються номери версій після цього випуску, залежить від цього публічного API і від того, як він змінюється.\nВерсія 1.0.0 визначає публічний API. Спосіб, яким збільшуються номери версій після цього випуску, залежить від цього публічного API і від того, як він змінюється.\nПатч версія Z (x.y.Z | x > 0) ПОВИННА бути збільшена тільки якщо вона містить лише зворотньосумісні виправлення помилок. Виправленою помилкою називається внутрішня зміна, яка виправляє неправильну поведінку.\nПатч версія Z (x.y.Z | x > 0) ПОВИННА бути збільшена тільки якщо вона містить лише зворотньосумісні виправлення помилок. Виправленою помилкою називається внутрішня зміна, яка виправляє неправильну поведінку.\nМінорна версія Y (x.Y.z | x > 0) ПОВИННА бути збільшена, якщо до публічного API додана нова зворотньосумісна функціональність. Вона ПОВИННА бути збільшена, якщо будь-яка функціональність публічного API позначена, як застаріла (deprecated). Вона МОЖЕ бути збільшена, якщо в приватний код внесені істотні зміни функціональних можливостей або вдосконалення. Вона МОЖЕ включати зміни рівня патчів. Патч версія ПОВИННА бути скинута до 0 при збільшенні мінорної версії.\nМінорна версія Y (x.Y.z | x > 0) ПОВИННА бути збільшена, якщо до публічного API додана нова зворотньосумісна функціональність. Вона ПОВИННА бути збільшена, якщо будь-яка функціональність публічного API позначена, як застаріла (deprecated). Вона МОЖЕ бути збільшена, якщо в приватний код внесені істотні зміни функціональних можливостей або вдосконалення. Вона МОЖЕ включати зміни рівня патчів. Патч версія ПОВИННА бути скинута до 0 при збільшенні мінорної версії.\nМажорна версія X (X.y.z | X > 0) ПОВИННА бути збільшена, якщо до публічного API внесені будь-які зміни, що не сумісні з попередньою версією. Вона може включати зміни рівня мінорної та патч версій. Номери патч версії та мінорної версії ПОВИННІ бути скинуті до 0 при збільшенні мажорної версії.\nМажорна версія X (X.y.z | X > 0) ПОВИННА бути збільшена, якщо до публічного API внесені будь-які зміни, що не сумісні з попередньою версією. Вона може включати зміни рівня мінорної та патч версій. Номери патч версії та мінорної версії ПОВИННІ бути скинуті до 0 при збільшенні мажорної версії.\nПередрелізна версія МОЖЕ бути позначена шляхом додавання безпосередньо після патч версії дефісу і ряду ідентифікаторів, розділених крапками. Ідентифікатори ПОВИННІ містити лише алфавітно-цифрові символи ASCII та дефіс [0-9A-Za-z-]. Ідентифікатори НЕ ПОВИННІ бути порожніми. Числові ідентифікатори НЕ ПОВИННІ мати нулі на початку. Передрелізні версії мають менший пріорітет за відповідні нормальні версії. Передрелізна версія вказує, що версія нестабільна і може не відповідати вимогам сумісності, на які вказує номер пов’язаної із нею нормальної версії. Приклади: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nПередрелізна версія МОЖЕ бути позначена шляхом додавання безпосередньо після патч версії дефісу і ряду ідентифікаторів, розділених крапками. Ідентифікатори ПОВИННІ містити лише алфавітно-цифрові символи ASCII та дефіс [0-9A-Za-z-]. Ідентифікатори НЕ ПОВИННІ бути порожніми. Числові ідентифікатори НЕ ПОВИННІ мати нулі на початку. Передрелізні версії мають менший пріорітет за відповідні нормальні версії. Передрелізна версія вказує, що версія нестабільна і може не відповідати вимогам сумісності, на які вказує номер пов’язаної із нею нормальної версії. Приклади: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nМетадані збірки МОЖНА позначати додаванням знаку плюс і ряду ідентифікаторів, розділених крапками, відразу після номеру патч версії або передрелізної версії. Ідентифікатори ПОВИННІ містити лише алфавітно-цифрові символи ASCII та дефіс [0-9A-Za-z-]. Ідентифікатори НЕ ПОВИННІ бути порожніми. Метадані збірки ПОВИННІ ігноруватися при визначенні пріоритету версії. Таким чином, дві версії, які відрізняються тільки метаданими, мають однаковий пріоритет. Приклади: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nМетадані збірки МОЖНА позначати додаванням знаку плюс і ряду ідентифікаторів, розділених крапками, відразу після номеру патч версії або передрелізної версії. Ідентифікатори ПОВИННІ містити лише алфавітно-цифрові символи ASCII та дефіс [0-9A-Za-z-]. Ідентифікатори НЕ ПОВИННІ бути порожніми. Метадані збірки ПОВИННІ ігноруватися при визначенні пріоритету версії. Таким чином, дві версії, які відрізняються тільки метаданими, мають однаковий пріоритет. Приклади: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nПріоритет визначає, як версії порівнюються одна з одною при упорядкуванні. Пріоритет ПОВИНЕН визначатись шляхом поділу версії на мажорний, мінорний, патч та передрелізний ідентифікатори саме в такому порядку (метадані збірки не впливають на пріоритет). Пріоритет визначається першою відмінністю під час порівняння кожного з цих ідентифікаторів зліва направо наступним чином: мажорні, мінорні та патч версії завжди порівнюються чисельно. Приклад: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Коли мажорна, мінорна і патч версія збігаються, передрелізна версія має менший пріоритет за звичайну версію. Приклад: 1.0.0-alpha < 1.0.0. Пріоритет для двох передрелізних версій з однаковими мажорною, мінорною і патч версіями ПОВИНЕН визначатися шляхом порівняння кожного окремого ідентифікатора, що розділені крапками, зліва направо, поки не буде знайдена різниця, в такому порядку: ідентифікатори, що складаються тільки з цифр, порівнюються чисельно; ідентифікатори з літерами або дефісами порівнюються лексично в порядку сортування ASCII. Числові ідентифікатори завжди мають менший пріоритет за нечислові ідентифікатори. Більший набір передрелізних полів має вищий пріоритет, ніж менший набір, якщо всі попередні ідентифікатори збігаються. Приклад: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nПріоритет визначає, як версії порівнюються одна з одною при упорядкуванні. Пріоритет ПОВИНЕН визначатись шляхом поділу версії на мажорний, мінорний, патч та передрелізний ідентифікатори саме в такому порядку (метадані збірки не впливають на пріоритет). Пріоритет визначається першою відмінністю під час порівняння кожного з цих ідентифікаторів зліва направо наступним чином: мажорні, мінорні та патч версії завжди порівнюються чисельно. Приклад: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1. Коли мажорна, мінорна і патч версія збігаються, передрелізна версія має менший пріоритет за звичайну версію. Приклад: 1.0.0-alpha < 1.0.0. Пріоритет для двох передрелізних версій з однаковими мажорною, мінорною і патч версіями ПОВИНЕН визначатися шляхом порівняння кожного окремого ідентифікатора, що розділені крапками, зліва направо, поки не буде знайдена різниця, в такому порядку: ідентифікатори, що складаються тільки з цифр, порівнюються чисельно; ідентифікатори з літерами або дефісами порівнюються лексично в порядку сортування ASCII. Числові ідентифікатори завжди мають менший пріоритет за нечислові ідентифікатори. Більший набір передрелізних полів має вищий пріоритет, ніж менший набір, якщо всі попередні ідентифікатори збігаються. Приклад: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.\nНотація форм Бекуса–Наура для дійсних версій SemVer\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nНавіщо використовувати Семантичне Версіонування?\nЦе не нова або революційна ідея. Насправді, вже існує багато близького до того. Проблема в тому, що “близького до того” недостатньо. Без відповідності певній формальній специфікації, номери версій є майже непридатними для управління залежностями. Надавши назви та чіткі визначення вищенаведеним ідеям, стає легко повідомляти про свої наміри кінцевим користувачам програмного забезпечення. Після того, як ці наміри стануть зрозумілими, нарешті можуть бути зроблені гнучкі (але не занадто гнучкі) специфікації для ведення залежностей.\nПростий приклад продемонструє, як Семантичне Версіонування може залишити “dependency hell” в минулому. Розглянемо бібліотеку під назвою “Firetruck”. Вона залежить від Семантично Версіонованого пакету під назвою “Ladder”. На момент створення Firetruck, Ladder мав версію 3.1.0. Оскільки Firetruck використовує деяку функціональність Ladder, яка вперше була введена у версії 3.1.0, можна сміливо вказати на залежність від версій пакету Ladder, які більші або дорівнюють 3.1.0, але менші за 4.0.0. Тепер, коли версії 3.1.1 та 3.2.0 пакету Ladder стають доступними, їх можна буде опублікувати за допомогою системи управління пакетами і бути певним, що вони будуть сумісні з існуючим залежним від нього програмним забезпеченням.\nВідповідальний розробник, звичайно, бажає переконатися, що будь-які оновлення пакета функціонують згідно з документацією. Реальний світ ― це хаотичне місце і ми нічого не можемо зробити, окрім, як бути пильними. Що можна зробити, це використовувати Семантичне Версіонування для випуску та оновлення пакетів без необхідності оновлення залежностей, заощаджуючи час і нерви.\nЯкщо це звучить цікаво, то все що потрібно зробити ― це почати користуватися Семантичним Версіонуванням, заявити про це, і дотримуватись правил. Додайте посилання на цей веб-сайт у README до проекту, щоб інші мали змогу дізнатись правила та скористатися ними.\nЯк працювати з релізами у початковій фазі розробки 0.y.z?\nНайпростіше зробити початковий реліз на рівні 0.1.0, а потім збільшувати мінорну версію для кожного наступного випуску.\nЯк дізнатися, коли потрібно випустити 1.0.0?\nЯкщо програмне забезпечення вже знаходиться експлуатації, то вже має бути 1.0.0. Якщо існує стабільний API, від якого залежать користувачі, повинна бути версія 1.0.0. Якщо вже починаються турботи про зворотну сумісність, має бути 1.0.0.\nЧи не перешкоджає це стрімкій розробці та швидким ітераціям?\nНульова мажорна версія ― це активна стадія розробки. Якщо API змінюється щодня, треба або залишатись у версії 0.y.z або на окремій гілці розробки, працюючи над наступною мажорною версією.\nЯкщо навіть найдрібніші зміни, що не сумісні з попередньою версією до публічного API, вимагають збільшення мажорної версії, чи не призведе це до версії 42.0.0 занадто швидко?\nЦе питання відповідального розвитку і передбачення. Не слід легковажно ставитись до публікації несумісних змін програмного забезпечення, яке має багато залежного від нього коду. Витрати на модернізацію можуть бути дуже значними. Реліз мажорної версії з несумісними змінами означає, що вплив змін детально обдуманий, а співвідношення витрати/користь ― оцінене.\nПовне документування публічного API ― це забагато роботи!\nПрофесійний розробник має нести відповідальність за належне документування програмного забезпечення, призначеного для використання іншими користувачами. Управління складністю проекту є надзвичайно важливим фактором його ефективності, і цього важко досяги, якщо ніхто не розуміє, як це програмне забезпечення використовувати, або які методи безпечні для виклику. У довгостроковій перспективі, Семантичне Версіонування та наполягання на чітко визначеному публічному API дозволить всім і всьому працювати безперешкодно.\nЩо робити, якщо у якості мінорної версії випадково була випущена зміна, що несумісна з попередньою версією?\nЯк тільки стало відомим, що порушена Специфікація Семантичного Версіонування, треба виправити проблему і випустити нову мінорну версію, яка виправляє проблему і відновлює зворотню сумісність. Та навіть за таких обставин неприпустимо вносити зміни до вже випущених версій коду. Якщо це доречно, є сенс задокументувати версію, що порушує правила, та поінформувати користувачів про проблему, щоб вони знали про версію, яка порушує правила.\nЩо робити при оновленні внутрішніх залежностей, якщо публічний API не змінений?\nТакі зміни вважаються сумісними, оскільки не впливають на публічний API. Програмне забезпечення, яке явно залежить від тих самих залежностей, повинне мати власні специфікації залежностей, і автор помітить будь-які конфлікти. Визначення того, чи є така зміна модифікацією рівня патча або рівня мінорної версії, залежить від того, чи внутрішні залежності були оновлені з метою виправлення помилки або з метою введення нової функціональності. В останньому випадку зазвичай слід очікувати додавання деякої кількості коду, що, вочевидь, є зміною рівня мінорної версії.\nЩо робити, якщо випадково був змінений публічний API у спосіб, що не відповідає зміненій версії (тобто, код має несумісні зміни у патч-релізі)?\nНа ваш розсуд. Якщо у вас є величезна аудиторія, на яку буде сильно впливати зміна публічного API, то краще всього зробити реліз мажорної версії, навіть якщо фактичне виправлення всього лише рівня патч-версії. Пам’ятайте, що за Семантичним Версіонуванням зміна версії повинна давати розуміння значущості змін. Якщо ці зміни важливі для користувачів, використовуйте номер версії, щоб повідомити їх.\nЯк оголосити застарілою (deprecated) деяку функціональність?\nОголошення застарілими існуючих функціональних можливостей є звичайною частиною розробки програмного забезпечення і часто є необхідною умовою прогресу. Коли потрібно оголосити застарілим частину публічного API, слід виконати дві речі: (1) оновити документацію, щоб користувачі могли дізнатися про зміну, (2) випустити мінорний реліз, що містить застарілу функціональність. Перш ніж повністю видалити застарілу функціональність у новому мажорному релізі, має бути принаймні один мінорний реліз, який містить функції, що будуть видалені. Таким чином, користувачі зможуть плавно перейти до нового API.\nЧи має semver обмеження на розмір рядка версії?\nНі, але будьте розсудливими. Номер версії з 255 символів ― це, можливо, забагато. До того ж, певні системи можуть накладати свої власні обмеження на розмір рядка.\nЧи є “v1.2.3” семантичною версією?\nНі, “v1.2.3” не є семантичною версією. Однак префікс семантичної версії з “v” ― це поширений спосіб (англійською мовою) вказати, що це номер версії. Скорочення “version” як “v” часто зустрічається в системах контролю версій. Наприклад: git tag v1.2.3 -m "Release version 1.2.3", у цьому випадку “v1.2.3” є назвою тегу, а семантична версія ― “1.2.3”.\nЧи існує запропонований регулярний вираз (RegEx) для перевірки рядка SemVer?\nЄ два. Один містить іменовані групи систем, які мають їх підтримку (PCRE [Perl Compatible Regular Expressions, напр. Perl, PHP або R], Python
або Go).\nДив.: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nТа інший, натомість, із пронумерованими групами захоплення ― capture groups (де cg1 = мажорна, cg2 = мінорна,
cg3 = патч, cg4 = передрелізна та cg5 = метадані збірки) які сумісні із ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
напр. Perl, PHP або R), Python або Go.\nДив.: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nАвтором Специфікації Семантичного Версіонування є Том Престон-Вернер, засновник Gravatars та співзасновник GitHub.\nЯкщо ви бажаєте залишити відгук, відкрийте issue на GitHub.\nвідкрийте issue на GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\nSemantic Versioning 2.0.0

Tổng quan

Đưa ra một cấu trúc phiên bản MAJOR.MINOR.PATCH, gia tăng như sau:


  Số phiên bản MAJOR khi bạn có những thay đổi API lớn, không tương thích với phiên bản trước
  Số phiên bản MINOR khi bạn thêm chức năng tương thích ngược với phiên bản trước
  Số phiên bản PATCH khi bạn làm một bản vá lỗi tương thích ngược với phiên bản trước


Các nhãn (labels) bổ sung cho pre-release và các build metadata về quá trình dựng đươc coi là tiện ích mở rộng cho định dạng MAJOR.MINOR.PATCH.

Giới thiệu

Trong thế giới của quản lý phần mềm, ở đó tồn tại một nơi đáng sợ, được gọi là “địa ngục phụ thuộc”. Hệ thống của bạn ngày càng lớn hơn và bạn càng tích hợp nhiều gói vào trong phần mềm của mình hơn, đồng nghĩa với việc bạn càng lún sâu một cách tuyệt vọng vào địa ngục này.

Trong các hệ thống phụ thuộc nhiều vào các yếu tố khác (gói, hệ thống,…), phát hành một phiên bản mới có thể nhanh chóng trở thành một cơn ác mộng. Nếu các thông số kỹ thuật phụ thuộc quá chặt chẽ với nhau, bạn có nguy cơ bị khóa phiên bản (không có khả năng nâng cấp một gói mà không phải phát hành các phiên bản mới của mỗi gói phụ thuộc). Nếu các yếu tố phụ thuộc được chỉ định quá lỏng lẻo, chắc chắn bạn sẽ bị ảnh hưởng bởi tính hỗn tạp của phiên bản (giả định khả năng tương thích với nhiều phiên bản trong tương lai là hợp lý). Cả hai trường hợp này đều đưa bạn đến đích đến là địa ngục phụ thuộc, ngăn dự án của bạn tiếp tục phát triển.

Để giải quyết vấn đề này, chúng tôi đề xuất một bộ quy tắc và quy định để đánh phiên bản. Các quy tắc này không nhất thiết dựa trên các quy tắc đã phổ biến rộng rãi trong cả phần mềm nguồn đóng và nguồn mở. Để bộ quy tắc này hoạt động, đầu tiên bạn cần xác định một tập public API, bao gồm tài liệu mô tả hoặc chính mã nguồn của API. Điều quan trọng là API phải rõ ràng và chính xác. Một khi bạn đã xác định được tập public API, bạn thông báo các thay đổi của API bằng cách đánh các phiên bản tương ứng. Bạn hãy xem lại định dạng phiên bản ban đầu, X.Y.Z (Major.Minor.Patch). Đối với những bản vá lỗi không làm thay đổi API, chúng ta tăng phiên bản Patch (Vá lỗi); với các thay đổi liên quan API, có thể tương thích ngược với phiên bản trước, tăng phiên bản Minor (Phụ); còn lại, đối với các thay đổi API mà không thể tương thích ngược với phiên bản trước, tăng phiên bản Major (Chính).

Chúng tôi gọi hệ thống này là “Sematic Versioning”, hay “Phiên bản ngữ nghĩa”. Theo hệ thống này, số phiên bản và sự thay đổi của chúng truyền đạt lại sự thay đổi của mã nguồn giữa các phiên bản.

Thông số của Sematic Versioning (SemVer)

Các từ khóa “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, và “OPTIONAL” trong tài liệu này được mô tả trong RFC 2119.


  
    Phần mềm sử dụng Semantic Versioning PHẢI công bố một tập public API. API này cần công khai trong mã nguồn hoặc tài liệu mô tả. Tập API này NÊN hoàn chỉnh và chính xác.
  
  
    Một chữ số phiên bản bình thường PHẢI lấy từ mẫu X.Y.Z. X, Y và Z là một số nguyên không âm, và KHÔNG chứa số 0 ở đầu. X là phiên bản chính, Y là phiên bản Minor và Z là phiên bản Patch lỗi. Mỗi phần tử cần PHẢI là một số tăng dần. Cho ví dụ: 1.9.0 -> 1.10.0 -> 1.11.0.
  
  
    Một khi gói đã đánh phiên bản được phát hành, nội dung của phiên bản đó KHÔNG được sửa đổi. Mọi sửa đổi PHẢI được phát hành dưới dạng phiên bản mới.
  
  
    Phiên bản Major zero (0.y.z) dành cho giai đoạn phát triển sơ khai. Mọi thứ CÓ THỂ thay đổi bất cứ lúc nào. Public API KHÔNG NÊN được coi là ổn định.
  
  
    Phiên bản 1.0.0 được xác định public API. Cách tăng số phiên bản sau bản phát hành này phụ thuộc vào sự thay đổi của public API.
  
  
    Phiên bản Patch Z (x.y.Z) PHẢI được tăng dần nếu chỉ các bản vá tương thích ngược được tung ra.Một sửa lỗi được định nghĩa là một thay đổi nội bộ để sửa chửa một hành vi không chính xác.
  
  
    Phiên bản Minor Y (x.Y.z) PHẢI được tăng dần nếu có thêm thay đổi mới và tương thích ngược với phiên bản trước được đưa vào trong public API. Nó PHẢI được tăng dần nếu bất kỳ chức năng API công khai nào đã được đánh dấu là không còn dùng nữa. Nó CÓ THỂ tăng dần nếu chức năng mới hoặc cải tiến mới đáng kể được giới thiệu trong mã đóng. Nó CÓ THỂ bao gồm thay đổi cấp độ bản vá. Phiên bản vá PHẢI được đặt lại về bằng 0 khi tăng phiên bản Minor.
  
  
    
      
        
          Phiên bản Major X (X.y.z
          X > 0) PHẢI được tăng dần nếu bất kỳ một thay đổi không tương thích ngược đưa vào API công khai. Nó CÓ THỂ bao gồm phiên bản Minor và thay đổi cấp độ bản vá. Bản vá và phiên bản Minor PHẢI được đặt lại về số 0 khi phiên bản chính tăng lên.
        
      
    
  
  
    Phiên bản pre-release CÓ THỂ được mô tả bằng cách nối thêm một dấu gạch nối vào một loạt số nhận dạng được phân tách bằng dấu chấm ngay sau phiên bản Patch. Mã định danh PHẢI bao gồm chữ số trong bảng mã ASCII và dấu gạch nối [0-9A-Za-z]. Mã định danh KHÔNG được để trống. Số định danh KHÔNG được bao gồm các chữ số 0 đứng đầu. Các phiên bản pre-release có một độ ưu tiên thấp hơn so với các phiên bản bình thường có liên quan. Một phiên bản pre-release cho biết phiên bản này không ổn định và có thể không đáp ứng các yêu cầu tương thích như dự định giống như là các phiên bản bình thường của nó. Ví dụ: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.
  
  
    Build metadata CÓ THỂ được biểu thị bằng cách thêm một dấu cộng và một loạt các tiền tố nhận dạng được phân tách bằng dấu chấm ngay sau phiên bản Patch hoặc phiên bản pre-release. Mỗi định danh PHẢI bao gồm chỉ các chữ số trong bảng mã ASCII và gạch nối [0-9A-Za-z]. Mỗi định danh KHÔNG được rỗng. Build metadata NÊN bỏ qua khi xác định mức độ ưu tiên của phiên bản. Do đó hai phiên bản chỉ khác nhau trong build metadata, có cùng mức độ ưu tiên. Ví dụ: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.
  
  
    Mức độ ưu tiên đề cập đến cách các phiên bản được so sánh với nhau.

    
      
        Mức độ ưu tiên PHẢI được tính bằng cách phiên bản thành các mã định dạng phiên bản Major, phiên bản Minor và phiên bản Patch, theo thứ tự đã nêu. (Build metadata không tính vào mức độ ưu tiên)
      
      
        Mức độ ưu tiên được xác định bởi sự khác biệt đầu tiên khi so sánh từng mã định danh từ trái qua phải: phiên bản Major -> phiên bản Minor -> phiên bản Patch.

        Ví dụ: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Trong trường hợp phiên bản Major, Minor và Patch đều bằng nhau, phiên bản pre-release có mức độ ưu tiên thấp hơn.

        Ví dụ: 1.0.0-alpha < 1.0.0.
      
      
        Mức độ ưu tiên của hai phiên bản pre-release có cùng phiên bản Major, Minor và Patch PHẢI được xác định bằng cách so sánh từng mã định danh phân tách bằng dấu chấm từ trái sang phải cho đến khi tìm thấy sự khác biệt.

        
          
            Các mã định danh chỉ bao gồm các chữ số, được so sánh số học.
          
          
            Các mã định danh bao gồm chữ cái hoặc dấu gạch ngang được so sánh theo thứ tự sắp xếp trong bảng ASCII.
          
          
            Định danh dạng số luôn có mức độ mưu tiên thấp hơn định danh dạng chữ hoặc ký tự đặc biệt.
          
          
            Một tập các phiên bản pre-release lớn hơn có mức độ ưu tiên cao hơn một tập khác nhỏ hơn, nếu tất cả các phiên bản trước đó bằng nhau.

            Ví dụ: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0
          
        
      
    
  


Ngữ pháp Backus-Naur cho các phiên bản SemVer hợp lệ

<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


Tại sao nên sử dụng Sematic Versioning?

Đây không phải là một ý tưởng mới hay mang tính cách mạng. Trong thực tế, bạn có thể làm một cái gì đó gần tương tự rồi. Vấn đề là “gần” cũng có nghĩa nó chưa đủ tốt. Nếu không có tuân thủ một số loại đặc tả chính thức, số phiên bản về cơ bản là vô dụng để việc quản lý phụ thuộc. Bằng cách đặt tên và định nghĩa rõ ràng cho các ý tưởng trên, việc truyền đạt ý định của bạn tới người dùng phần mềm trở nên dễ dàng hơn. Một khi những ý định này đã rõ ràng, các đặc tả phụ thuộc linh hoạt (nhưng không nên quá linh hoạt) có thể được thực hiện.

Một ví dụ đơn giản chứng minh làm thế nào Sematic Versioning có thể biến địa ngục phụ thuộc thành dĩ vãng. Hãy xem xét một thư viện có tên là “Firetruck”. Nó yêu cầu một gói có tên “Ladder”. Tại thời điểm Firetruck được tạo ra, Ladder đang ở phiên bản 3.1.0. Vì Firetruck sử dụng một số tính năng mới được giới thiệu lần đầu trong 3.1.0, bạn hoàn toàn có thể chỉ định một cách an toàn phụ thuộc lớn hơn hoặc bằng 3.1.0 và nhỏ hơn 4.0.0. Giờ đây, khi Ladder phiên bản 3.1.1 và 3.2.0 ra mắt, bạn có thể cập nhật lên các phiên bản này, và bạn biết rằng chúng sẽ tương thích với phần mềm phụ thuộc hiện có.

Tất nhiên, với tư cách là nhà phát triển có trách nhiệm, bạn sẽ muốn xác minh rằng bất kỳ nâng cấp gói đều hoạt động như mong đợi. Thế giới thực là một nơi lộn xộn; không có gì chúng ta không thể làm nhưng hãy cảnh giác. Những gì bạn có thể làm là hãy để Sematic Versioning cung cấp cho bạn cách phát hành và nâng cấp các gói hợp lý, mà không cần phải tung ra các phiên bản mới của các gói phụ thuộc, giúp bạn tiết kiệm thời gian và giảm thiểu rắc rối.

Nếu bạn thấy tất cả những điều này hấp dẫn, hãy bắt đầu sử dụng Sematic Versioning. Liên kết trang web này từ README của bạn để những người khác có thể biết các quy tắc và có thể hưởng lợi từ chúng.

Câu hỏi thường gặp

Tôi nên xử lý các bản sửa đổi trong giai đoạn phát triển ban đầu 0.y.z như thế nào?

Điều đơn giản nhất cần làm là bắt đầu phát hành phiên bản sơ khai của bạn ở 0.1.0 và sau đó tăng phiên bản Minor cho mỗi lần phát hành tiếp theo.

Làm cách nào để biết khi nào phát hành 1.0.0?

Nếu phần mềm của bạn đang được sử dụng thực tế, nó có lẽ đã là 1.0.0. Nếu bạn có một API ổn định mà người dùng phụ thuộc vào, bạn phải là 1.0.0. Nếu bạn lo lắng rất nhiều về khả năng tương thích ngược, bạn có lẽ đã là 1.0.0.

Điều này có cản trở sự phát triển nhanh và lặp đi lặp lại nhanh chóng không?

Phiên bản chính số không (Major version zero) hoàn toàn phù hợp cho giai đoạn phát triển nhanh. Nếu bạn thay đổi API mỗi ngày, bạn nên vẫn ở phiên bản 0.y.z hoặc sử dụng một nhánh phát triển riêng để làm việc trên phiên bản chính tiếp theo.

Nếu ngay cả những thay đổi nhỏ nhất không tương thích ngược với public API đều yêu cầu tăng phiên bản chính, thì chẳng phải tôi sẽ đạt đến phiên bản 42.0.0 rất nhanh sao?

Đây là một câu hỏi về sự phát triển có trách nhiệm và tầm nhìn. Không nên đưa những thay đổi không tương thích vào dự án có quá nhiều phụ thuộc. Những thay đổi không tương thích không nên được đưa vào một cách dễ dàng cho phần mềm có nhiều mã phụ thuộc. Chi phí phải chịu để nâng cấp là đáng kể. Khi bạn phải xử lý các phiên bản chính để phát hành các thay đổi không tương thích có nghĩa là bạn đã suy nghĩ thấu đáo về tác động của các thay đổi và đánh giá tỉ lệ/lợi ích liên quan.

Tài liệu cho toàn bộ API tốn quá nhiều thời gian, công sức!

Với tư cách là một nhà phát triển phần mềm chuyên nghiệp, đây là trách nhiệm của bạn. Quản lý sự phức tạp của phần mềm là một phần cực kỳ quan trọng để giữ cho dự án hoạt động hiệu quả và điều đó khó thực hiện nếu không ai biết cách sử dụng phần mềm của bạn. Về lâu dài, Sematic Versioning và xác định rõ ràng public API có thể giữ cho mọi thứ hoạt động trơn tru.

Tôi phải làm gì nếu vô tình phát hành một phiên bản Minor có thay đổi không tương thích ngược?

Ngay khi bạn nhận ra rằng bạn đã phá vỡ Sematic Versioning, hãy khắc phục sự cố và phát hành một phiên bản Minor mới để khắc phục sự cố và khôi phục tính tương thích ngược. Ngay cả trong trường hợp này, việc sửa đổi các bản phát hành đã đánh phiên bản không thể chấp nhận được. Nếu được, hãy ghi lại phiên bản vi phạm và thông báo người dùng của bạn về vấn đề này để họ biết về phiên bản lỗi.

Tôi nên làm gì nếu tôi cập nhật các gói phụ thuộc mà không thay đổi public API?

Điều đó sẽ được coi là tương thích vì nó không ảnh hưởng đến public API. Bất kỳ phần mềm nào cũng phụ thuộc các gói phụ thuộc, bản thân các gói này cũng có những gói phụ thuộc riêng. Việc xác định thời điểm để thay đổi một phiên bản Patch hay phiên bản Minor tùy thuộc vào thời điểm đó, bạn cập nhật các phụ thuộc để sửa lỗi hay cho một chức năng mới. Nếu bạn xác định tiếp tục phát triển thêm thay đổi đó, đó rõ ràng là thay đổi ở mức phiên bản Minor.

Điều gì sẽ xảy ra nếu tôi vô tình thay đổi public API không tuân theo các quy tắc của Sematic Versioning? (ví dụ, thay đổi không tương thích ngược nhưng lại nằm trong phiên bản Patch)

Hãy thử phán đoán dựa theo tình huống. Nếu sản phẩm của bạn có lượng lớn người dùng, việc bạn cố gắng chuyển về phiên bản cũ hơn sẽ làm ảnh hưởng đến tất cả. Lúc này giải pháp tốt nhất là phát hành một phiên bản chính, nhằm thay thế cho phiên bản không tuân thủ trước đó. Hãy nhớ rằng, Sematic Versioning hướng tới việc truyền đạt đến người dùng về thay đổi của sản phẩm thông qua thay đổi phiên bản.

Tôi nên xử lý các chức năng không dùng nữa như thế nào?

Việc loại bỏ chức năng hiện có là một phần bình thường của quá trình phát triển phần mềm. Khi bạn không còn dùng một phần của public API, bạn nên làm hai việc: (1) cập nhật tài liệu để thông báo cho người dùng về thay đổi, (2) phát hành một phiên bản Minor có chứa phần không dùng nữa. Trước khi bạn loại bỏ hoàn toàn chức năng trong một bản phát hành phiên bản chính, nên có ít nhất một bản phát hành phiên bản Minor chứa phần không dùng nữa, để người dùng có thể chuyển đổi sang API mới.

SemVer có giới hạn kích thước đối với chuỗi phiên bản không?

Không, nhưng xem xét kỹ. Ví dụ, một chuỗi phiên bản 255 ký tự rõ ràng là không cần thiết. Ngoài ra, các hệ thống cụ thể cũng có thể có giới hạn riêng cho kích thước chuỗi phiên bản.

“v1.2.3” có phải là Sematic Versioning không?

Không, “v1.2.3” không phải là Sematic Versioning. Tuy nhiên, tiền tố “v” khá phổ biến (trong tiếng Anh) để cho biết đó là một phiên bản. Trong quản lý phiên bản, “phiên bản” (“version”) thường viết tắt là “v”. Ví dụ: git tag v1.2.3 -m "Release version 1.2.3", trong đó “v1.2.3” là tên tag và Sematic Versioning là “1.2.3”.

Có thể dùng biểu thức chính quy (RegEx) nào để kiểm tra SemVer không?

Chúng ta có hai loại RegEx. Một loại bao gồm các nhóm được đặt tên cho những hệ thống hỗ trợ (PCRE [Perl Compatible Regular Expressions, ví dụ, Perl, PHP và R], Python và Go).

Xem thêm tại: https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Loại còn lại gồm các nhóm được đánh số (cg1 = major (chính), cg2 = minor (phụ), cg3 = patch (vá), cg4 = prerelease (pre-release) và cg5 = buildmetadata (build metadata)), PCRE [Perl Compatible Regular Expressions, ví dụ, Perl, PHP và R], Python và Go.

Xem thêm tại: https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


Về chúng tôi

Đặc tả của Sematic Versioning được viết bởi Tom Preston-Werner, người sáng lập của Gravatars và đồng sáng lập GitHub.

Nếu bạn muốn để lại một phản hồi, vui lòng mở một vấn đề trên GitHub

Giấy phép

Creative Commons ― CC BY 3.0\nSemantic Versioning 2.0.0\nĐưa ra một cấu trúc phiên bản MAJOR.MINOR.PATCH, gia tăng như sau:\nSố phiên bản MAJOR khi bạn có những thay đổi API lớn, không tương thích với phiên bản trước\nSố phiên bản MINOR khi bạn thêm chức năng tương thích ngược với phiên bản trước\nSố phiên bản PATCH khi bạn làm một bản vá lỗi tương thích ngược với phiên bản trước\nCác nhãn (labels) bổ sung cho pre-release và các build metadata về quá trình dựng đươc coi là tiện ích mở rộng cho định dạng MAJOR.MINOR.PATCH.\nTrong thế giới của quản lý phần mềm, ở đó tồn tại một nơi đáng sợ, được gọi là “địa ngục phụ thuộc”. Hệ thống của bạn ngày càng lớn hơn và bạn càng tích hợp nhiều gói vào trong phần mềm của mình hơn, đồng nghĩa với việc bạn càng lún sâu một cách tuyệt vọng vào địa ngục này.\nTrong các hệ thống phụ thuộc nhiều vào các yếu tố khác (gói, hệ thống,…), phát hành một phiên bản mới có thể nhanh chóng trở thành một cơn ác mộng. Nếu các thông số kỹ thuật phụ thuộc quá chặt chẽ với nhau, bạn có nguy cơ bị khóa phiên bản (không có khả năng nâng cấp một gói mà không phải phát hành các phiên bản mới của mỗi gói phụ thuộc). Nếu các yếu tố phụ thuộc được chỉ định quá lỏng lẻo, chắc chắn bạn sẽ bị ảnh hưởng bởi tính hỗn tạp của phiên bản (giả định khả năng tương thích với nhiều phiên bản trong tương lai là hợp lý). Cả hai trường hợp này đều đưa bạn đến đích đến là địa ngục phụ thuộc, ngăn dự án của bạn tiếp tục phát triển.\nĐể giải quyết vấn đề này, chúng tôi đề xuất một bộ quy tắc và quy định để đánh phiên bản. Các quy tắc này không nhất thiết dựa trên các quy tắc đã phổ biến rộng rãi trong cả phần mềm nguồn đóng và nguồn mở. Để bộ quy tắc này hoạt động, đầu tiên bạn cần xác định một tập public API, bao gồm tài liệu mô tả hoặc chính mã nguồn của API. Điều quan trọng là API phải rõ ràng và chính xác. Một khi bạn đã xác định được tập public API, bạn thông báo các thay đổi của API bằng cách đánh các phiên bản tương ứng. Bạn hãy xem lại định dạng phiên bản ban đầu, X.Y.Z (Major.Minor.Patch). Đối với những bản vá lỗi không làm thay đổi API, chúng ta tăng phiên bản Patch (Vá lỗi); với các thay đổi liên quan API, có thể tương thích ngược với phiên bản trước, tăng phiên bản Minor (Phụ); còn lại, đối với các thay đổi API mà không thể tương thích ngược với phiên bản trước, tăng phiên bản Major (Chính).\nChúng tôi gọi hệ thống này là “Sematic Versioning”, hay “Phiên bản ngữ nghĩa”. Theo hệ thống này, số phiên bản và sự thay đổi của chúng truyền đạt lại sự thay đổi của mã nguồn giữa các phiên bản.\nThông số của Sematic Versioning (SemVer)\nCác từ khóa “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, và “OPTIONAL” trong tài liệu này được mô tả trong RFC 2119.\nPhần mềm sử dụng Semantic Versioning PHẢI công bố một tập public API. API này cần công khai trong mã nguồn hoặc tài liệu mô tả. Tập API này NÊN hoàn chỉnh và chính xác.\nPhần mềm sử dụng Semantic Versioning PHẢI công bố một tập public API. API này cần công khai trong mã nguồn hoặc tài liệu mô tả. Tập API này NÊN hoàn chỉnh và chính xác.\nMột chữ số phiên bản bình thường PHẢI lấy từ mẫu X.Y.Z. X, Y và Z là một số nguyên không âm, và KHÔNG chứa số 0 ở đầu. X là phiên bản chính, Y là phiên bản Minor và Z là phiên bản Patch lỗi. Mỗi phần tử cần PHẢI là một số tăng dần. Cho ví dụ: 1.9.0 -> 1.10.0 -> 1.11.0.\nMột chữ số phiên bản bình thường PHẢI lấy từ mẫu X.Y.Z. X, Y và Z là một số nguyên không âm, và KHÔNG chứa số 0 ở đầu. X là phiên bản chính, Y là phiên bản Minor và Z là phiên bản Patch lỗi. Mỗi phần tử cần PHẢI là một số tăng dần. Cho ví dụ: 1.9.0 -> 1.10.0 -> 1.11.0.\nMột khi gói đã đánh phiên bản được phát hành, nội dung của phiên bản đó KHÔNG được sửa đổi. Mọi sửa đổi PHẢI được phát hành dưới dạng phiên bản mới.\nMột khi gói đã đánh phiên bản được phát hành, nội dung của phiên bản đó KHÔNG được sửa đổi. Mọi sửa đổi PHẢI được phát hành dưới dạng phiên bản mới.\nPhiên bản Major zero (0.y.z) dành cho giai đoạn phát triển sơ khai. Mọi thứ CÓ THỂ thay đổi bất cứ lúc nào. Public API KHÔNG NÊN được coi là ổn định.\nPhiên bản Major zero (0.y.z) dành cho giai đoạn phát triển sơ khai. Mọi thứ CÓ THỂ thay đổi bất cứ lúc nào. Public API KHÔNG NÊN được coi là ổn định.\nPhiên bản 1.0.0 được xác định public API. Cách tăng số phiên bản sau bản phát hành này phụ thuộc vào sự thay đổi của public API.\nPhiên bản 1.0.0 được xác định public API. Cách tăng số phiên bản sau bản phát hành này phụ thuộc vào sự thay đổi của public API.\nPhiên bản Patch Z (x.y.Z) PHẢI được tăng dần nếu chỉ các bản vá tương thích ngược được tung ra.Một sửa lỗi được định nghĩa là một thay đổi nội bộ để sửa chửa một hành vi không chính xác.\nPhiên bản Patch Z (x.y.Z) PHẢI được tăng dần nếu chỉ các bản vá tương thích ngược được tung ra.Một sửa lỗi được định nghĩa là một thay đổi nội bộ để sửa chửa một hành vi không chính xác.\nPhiên bản Minor Y (x.Y.z) PHẢI được tăng dần nếu có thêm thay đổi mới và tương thích ngược với phiên bản trước được đưa vào trong public API. Nó PHẢI được tăng dần nếu bất kỳ chức năng API công khai nào đã được đánh dấu là không còn dùng nữa. Nó CÓ THỂ tăng dần nếu chức năng mới hoặc cải tiến mới đáng kể được giới thiệu trong mã đóng. Nó CÓ THỂ bao gồm thay đổi cấp độ bản vá. Phiên bản vá PHẢI được đặt lại về bằng 0 khi tăng phiên bản Minor.\nPhiên bản Minor Y (x.Y.z) PHẢI được tăng dần nếu có thêm thay đổi mới và tương thích ngược với phiên bản trước được đưa vào trong public API. Nó PHẢI được tăng dần nếu bất kỳ chức năng API công khai nào đã được đánh dấu là không còn dùng nữa. Nó CÓ THỂ tăng dần nếu chức năng mới hoặc cải tiến mới đáng kể được giới thiệu trong mã đóng. Nó CÓ THỂ bao gồm thay đổi cấp độ bản vá. Phiên bản vá PHẢI được đặt lại về bằng 0 khi tăng phiên bản Minor.\nPhiên bản Major X (X.y.z
          X > 0) PHẢI được tăng dần nếu bất kỳ một thay đổi không tương thích ngược đưa vào API công khai. Nó CÓ THỂ bao gồm phiên bản Minor và thay đổi cấp độ bản vá. Bản vá và phiên bản Minor PHẢI được đặt lại về số 0 khi phiên bản chính tăng lên.\nPhiên bản Major X (X.y.z\nX > 0) PHẢI được tăng dần nếu bất kỳ một thay đổi không tương thích ngược đưa vào API công khai. Nó CÓ THỂ bao gồm phiên bản Minor và thay đổi cấp độ bản vá. Bản vá và phiên bản Minor PHẢI được đặt lại về số 0 khi phiên bản chính tăng lên.\nPhiên bản pre-release CÓ THỂ được mô tả bằng cách nối thêm một dấu gạch nối vào một loạt số nhận dạng được phân tách bằng dấu chấm ngay sau phiên bản Patch. Mã định danh PHẢI bao gồm chữ số trong bảng mã ASCII và dấu gạch nối [0-9A-Za-z]. Mã định danh KHÔNG được để trống. Số định danh KHÔNG được bao gồm các chữ số 0 đứng đầu. Các phiên bản pre-release có một độ ưu tiên thấp hơn so với các phiên bản bình thường có liên quan. Một phiên bản pre-release cho biết phiên bản này không ổn định và có thể không đáp ứng các yêu cầu tương thích như dự định giống như là các phiên bản bình thường của nó. Ví dụ: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nPhiên bản pre-release CÓ THỂ được mô tả bằng cách nối thêm một dấu gạch nối vào một loạt số nhận dạng được phân tách bằng dấu chấm ngay sau phiên bản Patch. Mã định danh PHẢI bao gồm chữ số trong bảng mã ASCII và dấu gạch nối [0-9A-Za-z]. Mã định danh KHÔNG được để trống. Số định danh KHÔNG được bao gồm các chữ số 0 đứng đầu. Các phiên bản pre-release có một độ ưu tiên thấp hơn so với các phiên bản bình thường có liên quan. Một phiên bản pre-release cho biết phiên bản này không ổn định và có thể không đáp ứng các yêu cầu tương thích như dự định giống như là các phiên bản bình thường của nó. Ví dụ: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7, 1.0.0-x.7.z.92.\nBuild metadata CÓ THỂ được biểu thị bằng cách thêm một dấu cộng và một loạt các tiền tố nhận dạng được phân tách bằng dấu chấm ngay sau phiên bản Patch hoặc phiên bản pre-release. Mỗi định danh PHẢI bao gồm chỉ các chữ số trong bảng mã ASCII và gạch nối [0-9A-Za-z]. Mỗi định danh KHÔNG được rỗng. Build metadata NÊN bỏ qua khi xác định mức độ ưu tiên của phiên bản. Do đó hai phiên bản chỉ khác nhau trong build metadata, có cùng mức độ ưu tiên. Ví dụ: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nBuild metadata CÓ THỂ được biểu thị bằng cách thêm một dấu cộng và một loạt các tiền tố nhận dạng được phân tách bằng dấu chấm ngay sau phiên bản Patch hoặc phiên bản pre-release. Mỗi định danh PHẢI bao gồm chỉ các chữ số trong bảng mã ASCII và gạch nối [0-9A-Za-z]. Mỗi định danh KHÔNG được rỗng. Build metadata NÊN bỏ qua khi xác định mức độ ưu tiên của phiên bản. Do đó hai phiên bản chỉ khác nhau trong build metadata, có cùng mức độ ưu tiên. Ví dụ: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85.\nMức độ ưu tiên đề cập đến cách các phiên bản được so sánh với nhau.

    
      
        Mức độ ưu tiên PHẢI được tính bằng cách phiên bản thành các mã định dạng phiên bản Major, phiên bản Minor và phiên bản Patch, theo thứ tự đã nêu. (Build metadata không tính vào mức độ ưu tiên)
      
      
        Mức độ ưu tiên được xác định bởi sự khác biệt đầu tiên khi so sánh từng mã định danh từ trái qua phải: phiên bản Major -> phiên bản Minor -> phiên bản Patch.

        Ví dụ: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.
      
      
        Trong trường hợp phiên bản Major, Minor và Patch đều bằng nhau, phiên bản pre-release có mức độ ưu tiên thấp hơn.

        Ví dụ: 1.0.0-alpha < 1.0.0.
      
      
        Mức độ ưu tiên của hai phiên bản pre-release có cùng phiên bản Major, Minor và Patch PHẢI được xác định bằng cách so sánh từng mã định danh phân tách bằng dấu chấm từ trái sang phải cho đến khi tìm thấy sự khác biệt.

        
          
            Các mã định danh chỉ bao gồm các chữ số, được so sánh số học.
          
          
            Các mã định danh bao gồm chữ cái hoặc dấu gạch ngang được so sánh theo thứ tự sắp xếp trong bảng ASCII.
          
          
            Định danh dạng số luôn có mức độ mưu tiên thấp hơn định danh dạng chữ hoặc ký tự đặc biệt.
          
          
            Một tập các phiên bản pre-release lớn hơn có mức độ ưu tiên cao hơn một tập khác nhỏ hơn, nếu tất cả các phiên bản trước đó bằng nhau.

            Ví dụ: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0\nMức độ ưu tiên đề cập đến cách các phiên bản được so sánh với nhau.\nMức độ ưu tiên PHẢI được tính bằng cách phiên bản thành các mã định dạng phiên bản Major, phiên bản Minor và phiên bản Patch, theo thứ tự đã nêu. (Build metadata không tính vào mức độ ưu tiên)\nMức độ ưu tiên PHẢI được tính bằng cách phiên bản thành các mã định dạng phiên bản Major, phiên bản Minor và phiên bản Patch, theo thứ tự đã nêu. (Build metadata không tính vào mức độ ưu tiên)\nMức độ ưu tiên được xác định bởi sự khác biệt đầu tiên khi so sánh từng mã định danh từ trái qua phải: phiên bản Major -> phiên bản Minor -> phiên bản Patch.

        Ví dụ: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nMức độ ưu tiên được xác định bởi sự khác biệt đầu tiên khi so sánh từng mã định danh từ trái qua phải: phiên bản Major -> phiên bản Minor -> phiên bản Patch.\nVí dụ: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.\nTrong trường hợp phiên bản Major, Minor và Patch đều bằng nhau, phiên bản pre-release có mức độ ưu tiên thấp hơn.

        Ví dụ: 1.0.0-alpha < 1.0.0.\nTrong trường hợp phiên bản Major, Minor và Patch đều bằng nhau, phiên bản pre-release có mức độ ưu tiên thấp hơn.\nVí dụ: 1.0.0-alpha < 1.0.0.\nMức độ ưu tiên của hai phiên bản pre-release có cùng phiên bản Major, Minor và Patch PHẢI được xác định bằng cách so sánh từng mã định danh phân tách bằng dấu chấm từ trái sang phải cho đến khi tìm thấy sự khác biệt.

        
          
            Các mã định danh chỉ bao gồm các chữ số, được so sánh số học.
          
          
            Các mã định danh bao gồm chữ cái hoặc dấu gạch ngang được so sánh theo thứ tự sắp xếp trong bảng ASCII.
          
          
            Định danh dạng số luôn có mức độ mưu tiên thấp hơn định danh dạng chữ hoặc ký tự đặc biệt.
          
          
            Một tập các phiên bản pre-release lớn hơn có mức độ ưu tiên cao hơn một tập khác nhỏ hơn, nếu tất cả các phiên bản trước đó bằng nhau.

            Ví dụ: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0\nMức độ ưu tiên của hai phiên bản pre-release có cùng phiên bản Major, Minor và Patch PHẢI được xác định bằng cách so sánh từng mã định danh phân tách bằng dấu chấm từ trái sang phải cho đến khi tìm thấy sự khác biệt.\nCác mã định danh chỉ bao gồm các chữ số, được so sánh số học.\nCác mã định danh chỉ bao gồm các chữ số, được so sánh số học.\nCác mã định danh bao gồm chữ cái hoặc dấu gạch ngang được so sánh theo thứ tự sắp xếp trong bảng ASCII.\nCác mã định danh bao gồm chữ cái hoặc dấu gạch ngang được so sánh theo thứ tự sắp xếp trong bảng ASCII.\nĐịnh danh dạng số luôn có mức độ mưu tiên thấp hơn định danh dạng chữ hoặc ký tự đặc biệt.\nĐịnh danh dạng số luôn có mức độ mưu tiên thấp hơn định danh dạng chữ hoặc ký tự đặc biệt.\nMột tập các phiên bản pre-release lớn hơn có mức độ ưu tiên cao hơn một tập khác nhỏ hơn, nếu tất cả các phiên bản trước đó bằng nhau.

            Ví dụ: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0\nMột tập các phiên bản pre-release lớn hơn có mức độ ưu tiên cao hơn một tập khác nhỏ hơn, nếu tất cả các phiên bản trước đó bằng nhau.\nVí dụ: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0\nNgữ pháp Backus-Naur cho các phiên bản SemVer hợp lệ\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\nTại sao nên sử dụng Sematic Versioning?\nĐây không phải là một ý tưởng mới hay mang tính cách mạng. Trong thực tế, bạn có thể làm một cái gì đó gần tương tự rồi. Vấn đề là “gần” cũng có nghĩa nó chưa đủ tốt. Nếu không có tuân thủ một số loại đặc tả chính thức, số phiên bản về cơ bản là vô dụng để việc quản lý phụ thuộc. Bằng cách đặt tên và định nghĩa rõ ràng cho các ý tưởng trên, việc truyền đạt ý định của bạn tới người dùng phần mềm trở nên dễ dàng hơn. Một khi những ý định này đã rõ ràng, các đặc tả phụ thuộc linh hoạt (nhưng không nên quá linh hoạt) có thể được thực hiện.\nMột ví dụ đơn giản chứng minh làm thế nào Sematic Versioning có thể biến địa ngục phụ thuộc thành dĩ vãng. Hãy xem xét một thư viện có tên là “Firetruck”. Nó yêu cầu một gói có tên “Ladder”. Tại thời điểm Firetruck được tạo ra, Ladder đang ở phiên bản 3.1.0. Vì Firetruck sử dụng một số tính năng mới được giới thiệu lần đầu trong 3.1.0, bạn hoàn toàn có thể chỉ định một cách an toàn phụ thuộc lớn hơn hoặc bằng 3.1.0 và nhỏ hơn 4.0.0. Giờ đây, khi Ladder phiên bản 3.1.1 và 3.2.0 ra mắt, bạn có thể cập nhật lên các phiên bản này, và bạn biết rằng chúng sẽ tương thích với phần mềm phụ thuộc hiện có.\nTất nhiên, với tư cách là nhà phát triển có trách nhiệm, bạn sẽ muốn xác minh rằng bất kỳ nâng cấp gói đều hoạt động như mong đợi. Thế giới thực là một nơi lộn xộn; không có gì chúng ta không thể làm nhưng hãy cảnh giác. Những gì bạn có thể làm là hãy để Sematic Versioning cung cấp cho bạn cách phát hành và nâng cấp các gói hợp lý, mà không cần phải tung ra các phiên bản mới của các gói phụ thuộc, giúp bạn tiết kiệm thời gian và giảm thiểu rắc rối.\nNếu bạn thấy tất cả những điều này hấp dẫn, hãy bắt đầu sử dụng Sematic Versioning. Liên kết trang web này từ README của bạn để những người khác có thể biết các quy tắc và có thể hưởng lợi từ chúng.\nTôi nên xử lý các bản sửa đổi trong giai đoạn phát triển ban đầu 0.y.z như thế nào?\nĐiều đơn giản nhất cần làm là bắt đầu phát hành phiên bản sơ khai của bạn ở 0.1.0 và sau đó tăng phiên bản Minor cho mỗi lần phát hành tiếp theo.\nLàm cách nào để biết khi nào phát hành 1.0.0?\nNếu phần mềm của bạn đang được sử dụng thực tế, nó có lẽ đã là 1.0.0. Nếu bạn có một API ổn định mà người dùng phụ thuộc vào, bạn phải là 1.0.0. Nếu bạn lo lắng rất nhiều về khả năng tương thích ngược, bạn có lẽ đã là 1.0.0.\nĐiều này có cản trở sự phát triển nhanh và lặp đi lặp lại nhanh chóng không?\nPhiên bản chính số không (Major version zero) hoàn toàn phù hợp cho giai đoạn phát triển nhanh. Nếu bạn thay đổi API mỗi ngày, bạn nên vẫn ở phiên bản 0.y.z hoặc sử dụng một nhánh phát triển riêng để làm việc trên phiên bản chính tiếp theo.\nNếu ngay cả những thay đổi nhỏ nhất không tương thích ngược với public API đều yêu cầu tăng phiên bản chính, thì chẳng phải tôi sẽ đạt đến phiên bản 42.0.0 rất nhanh sao?\nĐây là một câu hỏi về sự phát triển có trách nhiệm và tầm nhìn. Không nên đưa những thay đổi không tương thích vào dự án có quá nhiều phụ thuộc. Những thay đổi không tương thích không nên được đưa vào một cách dễ dàng cho phần mềm có nhiều mã phụ thuộc. Chi phí phải chịu để nâng cấp là đáng kể. Khi bạn phải xử lý các phiên bản chính để phát hành các thay đổi không tương thích có nghĩa là bạn đã suy nghĩ thấu đáo về tác động của các thay đổi và đánh giá tỉ lệ/lợi ích liên quan.\nTài liệu cho toàn bộ API tốn quá nhiều thời gian, công sức!\nVới tư cách là một nhà phát triển phần mềm chuyên nghiệp, đây là trách nhiệm của bạn. Quản lý sự phức tạp của phần mềm là một phần cực kỳ quan trọng để giữ cho dự án hoạt động hiệu quả và điều đó khó thực hiện nếu không ai biết cách sử dụng phần mềm của bạn. Về lâu dài, Sematic Versioning và xác định rõ ràng public API có thể giữ cho mọi thứ hoạt động trơn tru.\nTôi phải làm gì nếu vô tình phát hành một phiên bản Minor có thay đổi không tương thích ngược?\nNgay khi bạn nhận ra rằng bạn đã phá vỡ Sematic Versioning, hãy khắc phục sự cố và phát hành một phiên bản Minor mới để khắc phục sự cố và khôi phục tính tương thích ngược. Ngay cả trong trường hợp này, việc sửa đổi các bản phát hành đã đánh phiên bản không thể chấp nhận được. Nếu được, hãy ghi lại phiên bản vi phạm và thông báo người dùng của bạn về vấn đề này để họ biết về phiên bản lỗi.\nTôi nên làm gì nếu tôi cập nhật các gói phụ thuộc mà không thay đổi public API?\nĐiều đó sẽ được coi là tương thích vì nó không ảnh hưởng đến public API. Bất kỳ phần mềm nào cũng phụ thuộc các gói phụ thuộc, bản thân các gói này cũng có những gói phụ thuộc riêng. Việc xác định thời điểm để thay đổi một phiên bản Patch hay phiên bản Minor tùy thuộc vào thời điểm đó, bạn cập nhật các phụ thuộc để sửa lỗi hay cho một chức năng mới. Nếu bạn xác định tiếp tục phát triển thêm thay đổi đó, đó rõ ràng là thay đổi ở mức phiên bản Minor.\nĐiều gì sẽ xảy ra nếu tôi vô tình thay đổi public API không tuân theo các quy tắc của Sematic Versioning? (ví dụ, thay đổi không tương thích ngược nhưng lại nằm trong phiên bản Patch)\nHãy thử phán đoán dựa theo tình huống. Nếu sản phẩm của bạn có lượng lớn người dùng, việc bạn cố gắng chuyển về phiên bản cũ hơn sẽ làm ảnh hưởng đến tất cả. Lúc này giải pháp tốt nhất là phát hành một phiên bản chính, nhằm thay thế cho phiên bản không tuân thủ trước đó. Hãy nhớ rằng, Sematic Versioning hướng tới việc truyền đạt đến người dùng về thay đổi của sản phẩm thông qua thay đổi phiên bản.\nTôi nên xử lý các chức năng không dùng nữa như thế nào?\nViệc loại bỏ chức năng hiện có là một phần bình thường của quá trình phát triển phần mềm. Khi bạn không còn dùng một phần của public API, bạn nên làm hai việc: (1) cập nhật tài liệu để thông báo cho người dùng về thay đổi, (2) phát hành một phiên bản Minor có chứa phần không dùng nữa. Trước khi bạn loại bỏ hoàn toàn chức năng trong một bản phát hành phiên bản chính, nên có ít nhất một bản phát hành phiên bản Minor chứa phần không dùng nữa, để người dùng có thể chuyển đổi sang API mới.\nSemVer có giới hạn kích thước đối với chuỗi phiên bản không?\nKhông, nhưng xem xét kỹ. Ví dụ, một chuỗi phiên bản 255 ký tự rõ ràng là không cần thiết. Ngoài ra, các hệ thống cụ thể cũng có thể có giới hạn riêng cho kích thước chuỗi phiên bản.\n“v1.2.3” có phải là Sematic Versioning không?\nKhông, “v1.2.3” không phải là Sematic Versioning. Tuy nhiên, tiền tố “v” khá phổ biến (trong tiếng Anh) để cho biết đó là một phiên bản. Trong quản lý phiên bản, “phiên bản” (“version”) thường viết tắt là “v”. Ví dụ: git tag v1.2.3 -m "Release version 1.2.3", trong đó “v1.2.3” là tên tag và Sematic Versioning là “1.2.3”.\nCó thể dùng biểu thức chính quy (RegEx) nào để kiểm tra SemVer không?\nChúng ta có hai loại RegEx. Một loại bao gồm các nhóm được đặt tên cho những hệ thống hỗ trợ (PCRE [Perl Compatible Regular Expressions, ví dụ, Perl, PHP và R], Python và Go).\nXem thêm tại: https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nLoại còn lại gồm các nhóm được đánh số (cg1 = major (chính), cg2 = minor (phụ), cg3 = patch (vá), cg4 = prerelease (pre-release) và cg5 = buildmetadata (build metadata)), PCRE [Perl Compatible Regular Expressions, ví dụ, Perl, PHP và R], Python và Go.\nXem thêm tại: https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\nĐặc tả của Sematic Versioning được viết bởi Tom Preston-Werner, người sáng lập của Gravatars và đồng sáng lập GitHub.\nNếu bạn muốn để lại một phản hồi, vui lòng mở một vấn đề trên GitHub\nmở một vấn đề trên GitHub\nCreative Commons ― CC BY 3.0\nCreative Commons ― CC BY 3.0\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\n语义化版本 2.0.0

摘要

版本格式：主版本号.次版本号.修订号，版本号递增规则如下：


  主版本号：当你做了不兼容的 API 修改，
  次版本号：当你做了向下兼容的功能性新增，
  修订号：当你做了向下兼容的问题修正。


先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。

简介

在软件管理的领域里存在着被称作“依赖地狱”的死亡之谷，系统规模越大，加入的包越多，你就越有可能在未来的某一天发现自己已深陷绝望之中。

在依赖高的系统中发布新版本包可能很快会成为噩梦。如果依赖关系过高，可能面临版本控制被锁死的风险（必须对每一个依赖包改版才能完成某次升级）。而如果依赖关系过于松散，又将无法避免版本的混乱（假设兼容于未来的多个版本已超出了合理数量）。当你项目的进展因为版本依赖被锁死或版本混乱变得不够简便和可靠，就意味着你正处于依赖地狱之中。

作为这个问题的解决方案之一，我提议用一组简单的规则及条件来约束版本号的配置和增长。这些规则是根据（但不局限于）已经被各种封闭、开放源码软件所广泛使用的惯例所设计。为了让这套理论运作，你必须先有定义好的公共 API。这可能包括文档或代码的强制要求。无论如何，这套 API 的清楚明了是十分重要的。一旦你定义了公共 API，你就可以透过修改相应的版本号来向大家说明你的修改。考虑使用这样的版本号格式：X.Y.Z（主版本号.次版本号.修订号）修复问题但不影响 API 时，递增修订号；API 保持向下兼容的新增及修改时，递增次版本号；进行不向下兼容的修改时，递增主版本号。

我称这套系统为“语义化的版本控制”，在这套约定下，版本号及其更新方式包含了相邻版本间的底层代码和修改内容的信息。

语义化版本控制规范（SemVer）

以下关键词 MUST、MUST NOT、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD NOT、 RECOMMENDED、MAY、OPTIONAL 依照 RFC 2119 的叙述解读。


  
    使用语义化版本控制的软件必须（MUST）定义公共 API。该 API 可以在代码中被定义或出现于严谨的文档内。无论何种形式都应该力求精确且完整。
  
  
    标准的版本号必须（MUST）采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止（MUST NOT）在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须（MUST）以数值来递增。例如：1.9.1 -> 1.10.0 -> 1.11.0。
  
  
    标记版本号的软件发行后，禁止（MUST NOT）改变该版本软件的内容。任何修改都必须（MUST）以新版本发行。
  
  
    主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。
  
  
    1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。
  
  
    修订号 Z（x.y.Z | x > 0）必须（MUST）在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。
  
  
    次版本号 Y（x.Y.z | x > 0）必须（MUST）在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也必须（MUST）递增。也可以（MAY）在内部程序有大量新功能或改进被加入时递增，其中可以（MAY）包括修订级别的改变。每当次版本号递增时，修订号必须（MUST）归零。
  
  
    主版本号 X（X.y.z | X > 0）必须（MUST）在有任何不兼容的修改被加入公共 API 时递增。其中可以（MAY）包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须（MUST）归零。
  
  
    先行版本号可以（MAY）被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。数字型的标识符禁止（MUST NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。
  
  
    版本编译信息可以（MAY）被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。当判断版本的优先层级时，版本编译信息可（SHOULD）被忽略。因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。
  
  
    版本的优先层级指的是不同版本在排序时如何比较。

    
      
        判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译信息不在这份比较的列表中）。
      
      
        由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较。

        例如：1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。
      
      
        当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。

        例如：1.0.0-alpha < 1.0.0。
      
      
        有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：

        
          
            只有数字的标识符以数值高低比较。
          
          
            有字母或连接号时则逐字以 ASCII 的排序来比较。
          
          
            数字的标识符比非数字的标识符优先层级低。
          
          
            若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。
          
        

        例如：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。
      
    
  


合法语义化版本的巴科斯范式语法
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


为什么要使用语义化的版本控制？

这并不是一个新的或者革命性的想法。实际上，你可能已经在做一些近似的事情了。问题在于只是“近似”还不够。如果没有某个正式的规范可循，版本号对于依赖的管理并无实质意义。将上述的想法命名并给予清楚的定义，让你对软件使用者传达意向变得容易。一旦这些意向变得清楚，弹性（但又不会太弹性）的依赖规范就能达成。

举个简单的例子就可以展示语义化的版本控制如何让依赖地狱成为过去。假设有个名为“救火车”的函数库，它需要另一个名为“梯子”并已经有使用语义化版本控制的包。当救火车创建时，梯子的版本号为 3.1.0。因为救火车使用了一些版本 3.1.0 所新增的功能，你可以放心地指定依赖于梯子的版本号大于等于 3.1.0 但小于 4.0.0。这样，当梯子版本 3.1.1 和 3.2.0 发布时，你可以将直接它们纳入你的包管理系统，因为它们能与原有依赖的软件兼容。

作为一位负责任的开发者，你理当确保每次包升级的运作与版本号的表述一致。现实世界是复杂的，我们除了提高警觉外能做的不多。你所能做的就是让语义化的版本控制为你提供一个健全的方式来发行以及升级包，而无需推出新的依赖包，节省你的时间及烦恼。

如果你对此认同，希望立即开始使用语义化版本控制，你只需声明你的函数库正在使用它并遵循这些规则就可以了。请在你的 README 文件中保留此页链接，让别人也知道这些规则并从中受益。

FAQ

在 0.y.z 初始开发阶段，我该如何进行版本控制？

最简单的做法是以 0.1.0 作为你的初始化开发版本，并在后续的每次发行时递增次版本号。

如何判断发布 1.0.0 版本的时机？

当你的软件被用于正式环境，它应该已经达到了 1.0.0 版。如果你已经有个稳定的 API 被使用者依赖，也会是 1.0.0 版。如果你很担心向下兼容的问题，也应该算是 1.0.0 版了。

这不会阻碍快速开发和迭代吗？

主版本号为零的时候就是为了做快速开发。如果你每天都在改变 API，那么你应该仍在主版本号为零的阶段（0.y.z），或是正在下个主版本的独立开发分支中。

对于公共 API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到 42.0.0 版？

这是开发的责任感和前瞻性的问题。不兼容的改变不应该轻易被加入到有许多依赖代码的软件中。升级所付出的代价可能是巨大的。要递增主版本号来发行不兼容的改版，意味着你必须为这些改变所带来的影响深思熟虑，并且评估所涉及的成本及效益比。

为整个公共 API 写文档太费事了！

为供他人使用的软件编写适当的文档，是你作为一名专业开发者应尽的职责。保持项目高效的一个非常重要的部份是掌控软件的复杂度，如果没有人知道如何使用你的软件或不知道哪些函数的调用是可靠的，要掌控复杂度会是困难的。长远来看，使用语义化版本控制以及对于公共 API 有良好规范的坚持，可以让每个人及每件事都运行顺畅。

万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？

一旦发现自己破坏了语义化版本控制的规范，就要修正这个问题，并发行一个新的次版本号来更正这个问题并且恢复向下兼容。即使是这种情况，也不能去修改已发行的版本。可以的话，将有问题的版本号记录到文档中，告诉使用者问题所在，让他们能够意识到这是有问题的版本。

如果我更新了自己的依赖但没有改变公共 API 该怎么办？

由于没有影响到公共 API，这可以被认定是兼容的。若某个软件和你的包有共同依赖，则它会有自己的依赖规范，作者也会告知可能的冲突。要判断改版是属于修订等级或是次版等级，是依据你更新的依赖关系是为了修复问题或是加入新功能。对于后者，我经常会预期伴随着更多的代码，这显然会是一个次版本号级别的递增。

如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）

自行做最佳的判断。如果你有庞大的使用者群在依照公共 API 的意图而变更行为后会大受影响，那么最好做一次主版本的发布，即使严格来说这个修复仅是修订等级的发布。记住， 语义化的版本控制就是透过版本号的改变来传达意义。若这些改变对你的使用者是重要的，那就透过版本号来向他们说明。

我该如何处理即将弃用的功能？

弃用现存的功能是软件开发中的家常便饭，也通常是向前发展所必须的。当你弃用部份公共 API 时，你应该做两件事：（1）更新你的文档让使用者知道这个改变，（2）在适当的时机将弃用的功能透过新的次版本号发布。在新的主版本完全移除弃用功能前，至少要有一个次版本包含这个弃用信息，这样使用者才能平顺地转移到新版 API。

语义化版本对于版本的字符串长度是否有限制呢？

没有，请自行做适当的判断。举例来说，长到 255 个字符的版本已过度夸张。再者，特定的系统对于字符串长度可能会有他们自己的限制。

“v1.2.3” 是一个语义化版本号吗？

“v1.2.3” 并不是的一个语义化的版本号。但是，在语义化版本号之前增加前缀 “v” 是用来表示版本号的常用做法。在版本控制系统中，将 “version” 缩写为 “v” 是很常见的。比如：git tag v1.2.3 -m "Release version 1.2.3" 中，“v1.2.3” 表示标签名称，而 “1.2.3” 是语义化版本号。

是否有推荐的正则表达式用以检查语义化版本号的正确性？

有两个推荐的正则表达式。第一个用于支持按组名称提取的语言（PCRE[Perl 兼容正则表达式，比如 Perl、PHP 和 R]、Python 和 Go）。

参见：https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


第二个用于支持按编号提取的语言（与第一个对应的提取项按顺序分别为：major、minor、patch、prerelease、buildmetadata）。主要包括 ECMA Script（JavaScript）、PCRE（Perl 兼容正则表达式，比如 Perl、PHP 和 R）、Python 和 Go。
参见：https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


关于

语义化版本控制的规范是由 Gravatars 创办者兼 GitHub 共同创办者 Tom Preston-Werner 所建立。

如果您有任何建议，请到 GitHub 上提出您的问题。

许可证

知识共享 署名 3.0 (CC BY 3.0)\n版本格式：主版本号.次版本号.修订号，版本号递增规则如下：\n主版本号：当你做了不兼容的 API 修改，\n先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。\n在软件管理的领域里存在着被称作“依赖地狱”的死亡之谷，系统规模越大，加入的包越多，你就越有可能在未来的某一天发现自己已深陷绝望之中。\n在依赖高的系统中发布新版本包可能很快会成为噩梦。如果依赖关系过高，可能面临版本控制被锁死的风险（必须对每一个依赖包改版才能完成某次升级）。而如果依赖关系过于松散，又将无法避免版本的混乱（假设兼容于未来的多个版本已超出了合理数量）。当你项目的进展因为版本依赖被锁死或版本混乱变得不够简便和可靠，就意味着你正处于依赖地狱之中。\n作为这个问题的解决方案之一，我提议用一组简单的规则及条件来约束版本号的配置和增长。这些规则是根据（但不局限于）已经被各种封闭、开放源码软件所广泛使用的惯例所设计。为了让这套理论运作，你必须先有定义好的公共 API。这可能包括文档或代码的强制要求。无论如何，这套 API 的清楚明了是十分重要的。一旦你定义了公共 API，你就可以透过修改相应的版本号来向大家说明你的修改。考虑使用这样的版本号格式：X.Y.Z（主版本号.次版本号.修订号）修复问题但不影响 API 时，递增修订号；API 保持向下兼容的新增及修改时，递增次版本号；进行不向下兼容的修改时，递增主版本号。\n我称这套系统为“语义化的版本控制”，在这套约定下，版本号及其更新方式包含了相邻版本间的底层代码和修改内容的信息。\n以下关键词 MUST、MUST NOT、REQUIRED、SHALL、SHALL NOT、SHOULD、SHOULD NOT、 RECOMMENDED、MAY、OPTIONAL 依照 RFC 2119 的叙述解读。\n使用语义化版本控制的软件必须（MUST）定义公共 API。该 API 可以在代码中被定义或出现于严谨的文档内。无论何种形式都应该力求精确且完整。\n使用语义化版本控制的软件必须（MUST）定义公共 API。该 API 可以在代码中被定义或出现于严谨的文档内。无论何种形式都应该力求精确且完整。\n标准的版本号必须（MUST）采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止（MUST NOT）在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须（MUST）以数值来递增。例如：1.9.1 -> 1.10.0 -> 1.11.0。\n标准的版本号必须（MUST）采用 X.Y.Z 的格式，其中 X、Y 和 Z 为非负的整数，且禁止（MUST NOT）在数字前方补零。X 是主版本号、Y 是次版本号、而 Z 为修订号。每个元素必须（MUST）以数值来递增。例如：1.9.1 -> 1.10.0 -> 1.11.0。\n标记版本号的软件发行后，禁止（MUST NOT）改变该版本软件的内容。任何修改都必须（MUST）以新版本发行。\n标记版本号的软件发行后，禁止（MUST NOT）改变该版本软件的内容。任何修改都必须（MUST）以新版本发行。\n主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。\n主版本号为零（0.y.z）的软件处于开发初始阶段，一切都可能随时被改变。这样的公共 API 不应该被视为稳定版。\n1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。\n1.0.0 的版本号用于界定公共 API 的形成。这一版本之后所有的版本号更新都基于公共 API 及其修改内容。\n修订号 Z（x.y.Z | x > 0）必须（MUST）在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。\n修订号 Z（x.y.Z | x > 0）必须（MUST）在只做了向下兼容的修正时才递增。这里的修正指的是针对不正确结果而进行的内部修改。\n次版本号 Y（x.Y.z | x > 0）必须（MUST）在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也必须（MUST）递增。也可以（MAY）在内部程序有大量新功能或改进被加入时递增，其中可以（MAY）包括修订级别的改变。每当次版本号递增时，修订号必须（MUST）归零。\n次版本号 Y（x.Y.z | x > 0）必须（MUST）在有向下兼容的新功能出现时递增。在任何公共 API 的功能被标记为弃用时也必须（MUST）递增。也可以（MAY）在内部程序有大量新功能或改进被加入时递增，其中可以（MAY）包括修订级别的改变。每当次版本号递增时，修订号必须（MUST）归零。\n主版本号 X（X.y.z | X > 0）必须（MUST）在有任何不兼容的修改被加入公共 API 时递增。其中可以（MAY）包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须（MUST）归零。\n主版本号 X（X.y.z | X > 0）必须（MUST）在有任何不兼容的修改被加入公共 API 时递增。其中可以（MAY）包括次版本号及修订级别的改变。每当主版本号递增时，次版本号和修订号必须（MUST）归零。\n先行版本号可以（MAY）被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。数字型的标识符禁止（MUST NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。\n先行版本号可以（MAY）被标注在修订版之后，先加上一个连接号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。数字型的标识符禁止（MUST NOT）在前方补零。先行版的优先级低于相关联的标准版本。被标上先行版本号则表示这个版本并非稳定而且可能无法满足预期的兼容性需求。范例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92。\n版本编译信息可以（MAY）被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。当判断版本的优先层级时，版本编译信息可（SHOULD）被忽略。因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。\n版本编译信息可以（MAY）被标注在修订版或先行版本号之后，先加上一个加号再加上一连串以句点分隔的标识符来修饰。标识符必须（MUST）由 ASCII 字母数字和连接号 [0-9A-Za-z-] 组成，且禁止（MUST NOT）留白。当判断版本的优先层级时，版本编译信息可（SHOULD）被忽略。因此当两个版本只有在版本编译信息有差别时，属于相同的优先层级。范例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85。\n版本的优先层级指的是不同版本在排序时如何比较。

    
      
        判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译信息不在这份比较的列表中）。
      
      
        由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较。

        例如：1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。
      
      
        当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。

        例如：1.0.0-alpha < 1.0.0。
      
      
        有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：

        
          
            只有数字的标识符以数值高低比较。
          
          
            有字母或连接号时则逐字以 ASCII 的排序来比较。
          
          
            数字的标识符比非数字的标识符优先层级低。
          
          
            若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。
          
        

        例如：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。\n版本的优先层级指的是不同版本在排序时如何比较。\n判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译信息不在这份比较的列表中）。\n判断优先层级时，必须（MUST）把版本依序拆分为主版本号、次版本号、修订号及先行版本号后进行比较（版本编译信息不在这份比较的列表中）。\n由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较。

        例如：1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。\n由左到右依序比较每个标识符，第一个差异值用来决定优先层级：主版本号、次版本号及修订号以数值比较。\n例如：1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。\n当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。

        例如：1.0.0-alpha < 1.0.0。\n当主版本号、次版本号及修订号都相同时，改以优先层级比较低的先行版本号决定。\n例如：1.0.0-alpha < 1.0.0。\n有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：

        
          
            只有数字的标识符以数值高低比较。
          
          
            有字母或连接号时则逐字以 ASCII 的排序来比较。
          
          
            数字的标识符比非数字的标识符优先层级低。
          
          
            若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。
          
        

        例如：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。\n有相同主版本号、次版本号及修订号的两个先行版本号，其优先层级必须（MUST）透过由左到右的每个被句点分隔的标识符来比较，直到找到一个差异值后决定：\n有字母或连接号时则逐字以 ASCII 的排序来比较。\n有字母或连接号时则逐字以 ASCII 的排序来比较。\n若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。\n若开头的标识符都相同时，栏位比较多的先行版本号优先层级比较高。\n例如：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n这并不是一个新的或者革命性的想法。实际上，你可能已经在做一些近似的事情了。问题在于只是“近似”还不够。如果没有某个正式的规范可循，版本号对于依赖的管理并无实质意义。将上述的想法命名并给予清楚的定义，让你对软件使用者传达意向变得容易。一旦这些意向变得清楚，弹性（但又不会太弹性）的依赖规范就能达成。\n举个简单的例子就可以展示语义化的版本控制如何让依赖地狱成为过去。假设有个名为“救火车”的函数库，它需要另一个名为“梯子”并已经有使用语义化版本控制的包。当救火车创建时，梯子的版本号为 3.1.0。因为救火车使用了一些版本 3.1.0 所新增的功能，你可以放心地指定依赖于梯子的版本号大于等于 3.1.0 但小于 4.0.0。这样，当梯子版本 3.1.1 和 3.2.0 发布时，你可以将直接它们纳入你的包管理系统，因为它们能与原有依赖的软件兼容。\n作为一位负责任的开发者，你理当确保每次包升级的运作与版本号的表述一致。现实世界是复杂的，我们除了提高警觉外能做的不多。你所能做的就是让语义化的版本控制为你提供一个健全的方式来发行以及升级包，而无需推出新的依赖包，节省你的时间及烦恼。\n如果你对此认同，希望立即开始使用语义化版本控制，你只需声明你的函数库正在使用它并遵循这些规则就可以了。请在你的 README 文件中保留此页链接，让别人也知道这些规则并从中受益。\n在 0.y.z 初始开发阶段，我该如何进行版本控制？\n最简单的做法是以 0.1.0 作为你的初始化开发版本，并在后续的每次发行时递增次版本号。\n当你的软件被用于正式环境，它应该已经达到了 1.0.0 版。如果你已经有个稳定的 API 被使用者依赖，也会是 1.0.0 版。如果你很担心向下兼容的问题，也应该算是 1.0.0 版了。\n主版本号为零的时候就是为了做快速开发。如果你每天都在改变 API，那么你应该仍在主版本号为零的阶段（0.y.z），或是正在下个主版本的独立开发分支中。\n对于公共 API，若即使是最小但不向下兼容的改变都需要产生新的主版本号，岂不是很快就达到 42.0.0 版？\n这是开发的责任感和前瞻性的问题。不兼容的改变不应该轻易被加入到有许多依赖代码的软件中。升级所付出的代价可能是巨大的。要递增主版本号来发行不兼容的改版，意味着你必须为这些改变所带来的影响深思熟虑，并且评估所涉及的成本及效益比。\n为供他人使用的软件编写适当的文档，是你作为一名专业开发者应尽的职责。保持项目高效的一个非常重要的部份是掌控软件的复杂度，如果没有人知道如何使用你的软件或不知道哪些函数的调用是可靠的，要掌控复杂度会是困难的。长远来看，使用语义化版本控制以及对于公共 API 有良好规范的坚持，可以让每个人及每件事都运行顺畅。\n万一不小心把一个不兼容的改版当成了次版本号发行了该怎么办？\n一旦发现自己破坏了语义化版本控制的规范，就要修正这个问题，并发行一个新的次版本号来更正这个问题并且恢复向下兼容。即使是这种情况，也不能去修改已发行的版本。可以的话，将有问题的版本号记录到文档中，告诉使用者问题所在，让他们能够意识到这是有问题的版本。\n如果我更新了自己的依赖但没有改变公共 API 该怎么办？\n由于没有影响到公共 API，这可以被认定是兼容的。若某个软件和你的包有共同依赖，则它会有自己的依赖规范，作者也会告知可能的冲突。要判断改版是属于修订等级或是次版等级，是依据你更新的依赖关系是为了修复问题或是加入新功能。对于后者，我经常会预期伴随着更多的代码，这显然会是一个次版本号级别的递增。\n如果我变更了公共 API 但无意中未遵循版本号的改动怎么办呢？（意即在修订等级的发布中，误将重大且不兼容的改变加到代码之中）\n自行做最佳的判断。如果你有庞大的使用者群在依照公共 API 的意图而变更行为后会大受影响，那么最好做一次主版本的发布，即使严格来说这个修复仅是修订等级的发布。记住， 语义化的版本控制就是透过版本号的改变来传达意义。若这些改变对你的使用者是重要的，那就透过版本号来向他们说明。\n弃用现存的功能是软件开发中的家常便饭，也通常是向前发展所必须的。当你弃用部份公共 API 时，你应该做两件事：（1）更新你的文档让使用者知道这个改变，（2）在适当的时机将弃用的功能透过新的次版本号发布。在新的主版本完全移除弃用功能前，至少要有一个次版本包含这个弃用信息，这样使用者才能平顺地转移到新版 API。\n语义化版本对于版本的字符串长度是否有限制呢？\n没有，请自行做适当的判断。举例来说，长到 255 个字符的版本已过度夸张。再者，特定的系统对于字符串长度可能会有他们自己的限制。\n“v1.2.3” 并不是的一个语义化的版本号。但是，在语义化版本号之前增加前缀 “v” 是用来表示版本号的常用做法。在版本控制系统中，将 “version” 缩写为 “v” 是很常见的。比如：git tag v1.2.3 -m "Release version 1.2.3" 中，“v1.2.3” 表示标签名称，而 “1.2.3” 是语义化版本号。\n是否有推荐的正则表达式用以检查语义化版本号的正确性？\n有两个推荐的正则表达式。第一个用于支持按组名称提取的语言（PCRE[Perl 兼容正则表达式，比如 Perl、PHP 和 R]、Python 和 Go）。\n参见：https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n第二个用于支持按编号提取的语言（与第一个对应的提取项按顺序分别为：major、minor、patch、prerelease、buildmetadata）。主要包括 ECMA Script（JavaScript）、PCRE（Perl 兼容正则表达式，比如 Perl、PHP 和 R）、Python 和 Go。
参见：https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n语义化版本控制的规范是由 Gravatars 创办者兼 GitHub 共同创办者 Tom Preston-Werner 所建立。\n如果您有任何建议，请到 GitHub 上提出您的问题。\n知识共享 署名 3.0 (CC BY 3.0)\n知识共享 署名 3.0 (CC BY 3.0)\n\n\nBahasa Indonesia (id)\nBahasa Indonesia (id)\nportuguês brasileiro (pt-BR)\nportuguês brasileiro (pt-BR)\n語意化版本 2.0.0

摘要

版本格式：主版號.次版號.修訂號，版號遞增規則如下：


  主版號：當你做了不相容的 API 修改，
  次版號：當你做了向下相容的功能性新增，
  修訂號：當你做了向下相容的問題修正。


先行版號及版本編譯資訊可以加到「主版號.次版號.修訂號」的後面，作為延伸。

簡介

在軟體管理的領域裡存在著被稱作「相依性地獄」的死亡之谷，系統規模越大，加入的套件越多，你就越有可能在未來的某一天發現自己已深陷絕望之中。

在相依性高的系統中發佈新版本套件可能很快會成為惡夢。如果相依性關係過高，可能面臨版本控制被鎖死的風險（必須對每一個相依套件改版才能完成某次升級）。而如果相依性關係過於鬆散，又將無法避免版本的混亂（假設相容於未來的多個版本已超出了合理數量）。當你專案的進展因為版本相依被鎖死或版本混亂變得不夠簡便和可靠，就意味著你正處於相依性地獄之中。

作為這個問題的解決方案之一，我提議用一組簡單的規則及條件來約束版號的配置和增長。這些規則是根據（但不局限於）已經被各種封閉、開放源碼軟體所廣泛使用的慣例所設計。為了讓這套理論運作，你必須先有定義好的公共 API。這可以透過文件定義或程式碼強制要求來實現。無論如何，這套 API 的清楚明瞭是十分重要的。一旦你定義了公共 API，你就可以透過修改相應的版號來向大家說明你的修改。考慮使用這樣的版號格式：X.Y.Z（主版號.次版號.修訂號）修復問題但不影響 API 時，遞增修訂號；API 保持向下相容的新增及修改時，遞增次版號；進行不向下相容的修改時，遞增主版號。

我稱這套系統為「語意化的版本控制」，在這套約定下，版號及其更新方式包含了相鄰版本間的底層程式碼和修改內容的訊息。

語意化版本控制規範（SemVer）

以下關鍵詞「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、「OPTIONAL」依照 RFC 2119 的敘述解讀。（譯著：為了保持語句順暢，以下文件遇到的關鍵詞將依照整句語意進行翻譯，在此先不進行個別翻譯。）


  
    使用語意化版本控制的軟體必須（MUST）定義公共 API。該 API 可以在程式碼中被定義或出現於嚴謹的文件內。無論何種形式都應該（SHOULD）力求精確且完整。
  
  
    標準的版號必須（MUST）採用 X.Y.Z 的格式，其中 X、Y 和 Z 為非負的整數，且禁止（MUST NOT）在數字前方補零。X 是主版號、Y 是次版號、而 Z 為修訂號。每個元素必須（MUST）以數值來遞增。例如：1.9.1 -> 1.10.0 -> 1.11.0。
  
  
    標記版號的軟體發行後，禁止（MUST NOT）改變該版本軟體的內容。任何修改都必須（MUST）以新版本發行。
  
  
    主版號為零（0.y.z）的軟體處於開發初始階段，一切都可以（MAY）隨時改變。這樣的公共 API 不應該（SHOULD NOT）被視為穩定版。
  
  
    1.0.0 的版號用於界定公共 API 的形成。這一版本之後所有的版號更新都基於公共 API及其修改內容。
  
  
    修訂號 Z（x.y.Z | x > 0）必須（MUST）在只做了向下相容的修正時才遞增。這裡的修正指的是針對不正確結果而進行的內部修改。
  
  
    次版號 Y（x.Y.z | x > 0）必須（MUST）在有向下相容的新功能出現時遞增。在任何公共 API 的功能被標記為棄用時也必須（MUST）遞增。也可以（MAY）在內部程式有大量新功能或改進被加入時遞增，其中可以（MAY）包括修訂級別的改變。每當次版號遞增時，修訂號必須（MUST）歸零。
  
  
    主版本號 X（X.y.z | X > 0）必須（MUST）在有任何不相容的修改被加入公共 API 時遞增。其中可以（MAY）包括次版號及修訂級別的改變。每當主版號遞增時，次版號和修訂號必須（MUST）歸零。
  
  
    先行版號可以（MAY）被標注在修訂版之後，先加上一個連接號再加上一連串以句點分隔的標識符號來修飾。標識符號必須（MUST）由 ASCII 碼的英數字和連接號[0-9A-Za-z-] 組成，且禁止（MUST NOT）留白。數字型的標識符號禁止（MUST NOT）在前方補零。先行版的優先級低於相關聯的標準版本。被標上先行版號則表示這個版本並非穩定而且可能無法達到相容的需求。範例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92、1.0.0-x-y-z.–。
  
  
    版本編譯資訊可以（MAY）被標注在修訂版或先行版號之後，先加上一個加號再加上一連串以句點分隔的標識符號來修飾。標識符號必須（MUST）由 ASCII 的英數字和連接號 [0-9A-Za-z-]組成，且禁止（MUST NOT）留白。當判斷版本的優先層級時，版本編譯資訊必須（MUST）被忽略。因此當兩個版本只有在版本編譯資訊有差別時，屬於相同的優先層級。範例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85、1.0.0+21AF26D3—-117B344092BD。
  
  
    版本的優先層級指的是不同版本在排序時如何比較。

    
      
        判斷優先層級時，必須（MUST）把版本依序拆分為主版號、次版號、修訂號及先行版號後進行比較（版本編譯資訊不在這份比較的列表中）。
      
      
        由左到右依序比較每個標識符號，第一個差異值用來決定優先層級：主版號、次版號及修訂號以數值比較。

        例如： 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。
      
      
        當主版號、次版號及修訂號都相同時，有先行版號者優先層級較低。

        例如：1.0.0-alpha < 1.0.0。
      
      
        有相同主版號、次版號及修訂號的兩個先行版號，其優先層級必須（MUST）透過由左到右的每個被句點分隔的標識符號來比較，直到找到一個差異值後決定：

        
          
            只有數字的標識符號以數值高低比較。
          
          
            有字母或連接號時則逐字以 ASCII 的排序來比較。
          
          
            數字的標識符號比非數字的標識符號優先層級低。
          
          
            若開頭的標識符號都相同時，欄位比較多的先行版號優先層級比較高。

            範例：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。
          
        
      
    
  


有效語意化版本的 Backus–Naur 範式語法
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"


為什麼要使用語意化的版本控制？

這並不是一個新的或者革命性的想法。實際上，你可能已經在做一些近似的事情了。問題在於只是「近似」還不夠。如果沒有某個正式的規範可循，版號對於相依性的管理並無實質意義。將上述的想法命名並給予清楚的定義，讓你對軟體使用者傳達意向變得容易。一旦這些意向變得清楚，彈性（但又不會太彈性）的相依性規範就能達成。

舉個簡單的例子就可以展示語意化的版本控制如何讓相依性地獄成為過去。假設有個名為「消防車」的函式庫，它需要另一個名為「梯子」並已經有使用語意化版本控制的套件。當消防車創建時，梯子的版號為 3.1.0。因為消防車使用了一些版本 3.1.0 所新增的功能，你可以放心地指定相依於梯子的版號大等於 3.1.0 但小於4.0.0。這樣，當梯子版本 3.1.1和 3.2.0 發佈時，你可以將直接它們納入你的套件管理系統，因為它們能與原有相依的軟體相容。

作為一位負責任的開發者，你理當確保每次套件升級的運作與版本號的表述一致。現實世界是複雜的，我們除了提高警覺外能做的不多。你所能做的就是讓語意化的版本控制為你提供一個健全的方式來發行以及升級套件，而無需推出新的相依套件，節省你的時間及煩惱。

如果你對此認同，希望立即開始使用語意化版本控制，你只需聲明你的函式庫正在使用它並遵循這些規則就可以了。請在你的 README 文件中保留此頁連結，讓別人也知道這些規則並從中受益。

FAQ

在 0.y.z 初始開發階段，我該如何進行版本控制？

最簡單的做法是以 0.1.0 作為你的初始化開發版本，並在後續的每次發行時遞增次版號。

如何判斷發佈 1.0.0 版本的時機？

當你的軟體被用於正式環境，它應該已經達到了 1.0.0 版。如果你已經有個穩定的 API 被使用者依賴，也會是 1.0.0 版。如果你很擔心向下相容的問題，也應該算是 1.0.0 版了。

這不會阻礙快速開發和迭代嗎？

主版號為零的時候就是為了做快速開發。如果你每天都在改變 API，那麼你應該仍在主版號為零的階段（0.y.z），或是正在下個主版本的獨立開發分支中。

對於公共 API，若即使是最小但不向下相容的改變都需要產生新的主版號，豈不是很快就達到 42.0.0 版？

這是開發的責任感和前瞻性的問題。不相容的改變不應該輕易被加入到有許多相依性程式碼的軟體中。升級所付出的代價可能是巨大的。要遞增主版號來發行不相容的改版，意味著你必須為這些改變所帶來的影響深思熟慮，並且評估所涉及的成本及效益比。

為整個公共 API 寫文件太費事了！

為供他人使用的軟體編寫適當的文件，是你作為一名專業開發者應盡的職責。保持專案高效一個非常重要的部份是掌控軟體的複雜度，如果沒有人知道如何使用你的軟體或不知道哪些函數的呼叫是可靠的，要掌控複雜度會是困難的。長遠來看，使用語意化版本控制以及對於公共 API 有良好規範的堅持，可以讓每個人及每件事都運行順暢。

萬一不小心把一個不相容的改版當成了次版號發行了該怎麼辦？

一旦發現自己破壞了語意化版本控制的規範，就要修正這個問題，並發行一個新的次版號來更正這個問題並且恢復向下相容。即使是這種情況，也不能去修改已發行的版本。可以的話，將有問題的版號記錄到文件中，告訴使用者問題所在，讓他們能夠意識到這是有問題的版本。

如果我更新了自己的相依性但沒有改變公共 API 該怎麼辦？

由於沒有影響到公共 API，這可以被認定是相容的。若某個軟體和你的套件有共同相依性，則它會有自己的相依性規範，作者也會告知可能的衝突。要判斷改版是屬於修訂等級或是次版等級，是依據你更新的相依性關係是為了修復問題或是加入新功能。對於後者，我經常會預期伴隨著更多的程式碼，這顯然會是一個次版號級別的遞增。

如果我變更了公共 API 但無意中未遵循版號的改動怎麼辦呢？（意即在修訂等級的發佈中，誤將重大且不相容的改變加到程式碼之中）

自行做最佳的判斷。如果你有龐大的使用者群在依照公共 API 的意圖而變更行為後會大受影響，那麼最好做一次主版本的發佈，即使嚴格來說這個修復僅是修訂等級的發佈。記住，語意化的版本控制就是透過版號的改變來傳達意義。若這些改變對你的使用者是重要的，那就透過版號來向他們說明。

我該如何處理即將棄用的功能？

棄用現存的功能是軟體開發中的家常便飯，也通常是向前發展所必須的。當你棄用部份公共 API 時，你應該做兩件事：（1）更新你的文件讓使用者知道這個改變，（2）在適當的時機將棄用的功能透過新的次版號發佈。在新的主版本完全移除棄用功能前，至少要有一個次版本包含這個棄用資訊，這樣使用者才能平順地轉移到新版 API。

語意化版本對於版本的字串長度是否有限制呢？

沒有，請自行做適當的判斷。舉例來說，長到 255 個字元的版本已過度誇張。再者，特定的系統對於字串長度可能會有他們自己的限制。

“v1.2.3” 是語意化版本嗎？

不，”v1.2.3” 不是語意化版本。然而在語意化版本前加上 “v” 表示其為版本號是很常見的做法（就英文而言）。用 “v” 表示 “version” 的縮寫是版本控制的常見做法。例如：git tag v1.2.3 -m "Release version 1.2.3"，此例 “v1.2.3” 是標籤名稱，而語意化版本是 “1.2.3”。

有建議用於檢查語意化版本的正規表示式（RegEx）嗎？

有兩種。一種用命名群組，須在支援的系統上使用（PCRE [Perl Compatible Regular Expressions, i.e. Perl, PHP and R]、Python、以及 Go）。

參見：https://regex101.com/r/Ly7O1x/3/

^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


另一種使用擷取群組編號（組1 = 主版號，組2 = 次版號，組3 = 修訂號，組4 = 先行版號，組5 = 編譯資訊），與 ECMA Script (JavaScript)、PCRE (Perl Compatible Regular Expressions, i.e. Perl, PHP and R)、Python、以及 Go 相容。

參見：https://regex101.com/r/vkijKf/1/

^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$


關於

語意化版本控制的規範最初是由 Gravatars 創辦者兼 GitHub 共同創辦者 Tom Preston-Werner 建立。

如果您有任何建議，請到 GitHub 上提出問題。

授權

創用 CC 姓名標示 3.0 授權條款\n版本格式：主版號.次版號.修訂號，版號遞增規則如下：\n先行版號及版本編譯資訊可以加到「主版號.次版號.修訂號」的後面，作為延伸。\n在軟體管理的領域裡存在著被稱作「相依性地獄」的死亡之谷，系統規模越大，加入的套件越多，你就越有可能在未來的某一天發現自己已深陷絕望之中。\n在相依性高的系統中發佈新版本套件可能很快會成為惡夢。如果相依性關係過高，可能面臨版本控制被鎖死的風險（必須對每一個相依套件改版才能完成某次升級）。而如果相依性關係過於鬆散，又將無法避免版本的混亂（假設相容於未來的多個版本已超出了合理數量）。當你專案的進展因為版本相依被鎖死或版本混亂變得不夠簡便和可靠，就意味著你正處於相依性地獄之中。\n作為這個問題的解決方案之一，我提議用一組簡單的規則及條件來約束版號的配置和增長。這些規則是根據（但不局限於）已經被各種封閉、開放源碼軟體所廣泛使用的慣例所設計。為了讓這套理論運作，你必須先有定義好的公共 API。這可以透過文件定義或程式碼強制要求來實現。無論如何，這套 API 的清楚明瞭是十分重要的。一旦你定義了公共 API，你就可以透過修改相應的版號來向大家說明你的修改。考慮使用這樣的版號格式：X.Y.Z（主版號.次版號.修訂號）修復問題但不影響 API 時，遞增修訂號；API 保持向下相容的新增及修改時，遞增次版號；進行不向下相容的修改時，遞增主版號。\n我稱這套系統為「語意化的版本控制」，在這套約定下，版號及其更新方式包含了相鄰版本間的底層程式碼和修改內容的訊息。\n以下關鍵詞「MUST」、「MUST NOT」、「REQUIRED」、「SHALL」、「SHALL NOT」、「SHOULD」、「SHOULD NOT」、「RECOMMENDED」、「MAY」、「OPTIONAL」依照 RFC 2119 的敘述解讀。（譯著：為了保持語句順暢，以下文件遇到的關鍵詞將依照整句語意進行翻譯，在此先不進行個別翻譯。）\n使用語意化版本控制的軟體必須（MUST）定義公共 API。該 API 可以在程式碼中被定義或出現於嚴謹的文件內。無論何種形式都應該（SHOULD）力求精確且完整。\n使用語意化版本控制的軟體必須（MUST）定義公共 API。該 API 可以在程式碼中被定義或出現於嚴謹的文件內。無論何種形式都應該（SHOULD）力求精確且完整。\n標準的版號必須（MUST）採用 X.Y.Z 的格式，其中 X、Y 和 Z 為非負的整數，且禁止（MUST NOT）在數字前方補零。X 是主版號、Y 是次版號、而 Z 為修訂號。每個元素必須（MUST）以數值來遞增。例如：1.9.1 -> 1.10.0 -> 1.11.0。\n標準的版號必須（MUST）採用 X.Y.Z 的格式，其中 X、Y 和 Z 為非負的整數，且禁止（MUST NOT）在數字前方補零。X 是主版號、Y 是次版號、而 Z 為修訂號。每個元素必須（MUST）以數值來遞增。例如：1.9.1 -> 1.10.0 -> 1.11.0。\n標記版號的軟體發行後，禁止（MUST NOT）改變該版本軟體的內容。任何修改都必須（MUST）以新版本發行。\n標記版號的軟體發行後，禁止（MUST NOT）改變該版本軟體的內容。任何修改都必須（MUST）以新版本發行。\n主版號為零（0.y.z）的軟體處於開發初始階段，一切都可以（MAY）隨時改變。這樣的公共 API 不應該（SHOULD NOT）被視為穩定版。\n主版號為零（0.y.z）的軟體處於開發初始階段，一切都可以（MAY）隨時改變。這樣的公共 API 不應該（SHOULD NOT）被視為穩定版。\n1.0.0 的版號用於界定公共 API 的形成。這一版本之後所有的版號更新都基於公共 API及其修改內容。\n1.0.0 的版號用於界定公共 API 的形成。這一版本之後所有的版號更新都基於公共 API及其修改內容。\n修訂號 Z（x.y.Z | x > 0）必須（MUST）在只做了向下相容的修正時才遞增。這裡的修正指的是針對不正確結果而進行的內部修改。\n修訂號 Z（x.y.Z | x > 0）必須（MUST）在只做了向下相容的修正時才遞增。這裡的修正指的是針對不正確結果而進行的內部修改。\n次版號 Y（x.Y.z | x > 0）必須（MUST）在有向下相容的新功能出現時遞增。在任何公共 API 的功能被標記為棄用時也必須（MUST）遞增。也可以（MAY）在內部程式有大量新功能或改進被加入時遞增，其中可以（MAY）包括修訂級別的改變。每當次版號遞增時，修訂號必須（MUST）歸零。\n次版號 Y（x.Y.z | x > 0）必須（MUST）在有向下相容的新功能出現時遞增。在任何公共 API 的功能被標記為棄用時也必須（MUST）遞增。也可以（MAY）在內部程式有大量新功能或改進被加入時遞增，其中可以（MAY）包括修訂級別的改變。每當次版號遞增時，修訂號必須（MUST）歸零。\n主版本號 X（X.y.z | X > 0）必須（MUST）在有任何不相容的修改被加入公共 API 時遞增。其中可以（MAY）包括次版號及修訂級別的改變。每當主版號遞增時，次版號和修訂號必須（MUST）歸零。\n主版本號 X（X.y.z | X > 0）必須（MUST）在有任何不相容的修改被加入公共 API 時遞增。其中可以（MAY）包括次版號及修訂級別的改變。每當主版號遞增時，次版號和修訂號必須（MUST）歸零。\n先行版號可以（MAY）被標注在修訂版之後，先加上一個連接號再加上一連串以句點分隔的標識符號來修飾。標識符號必須（MUST）由 ASCII 碼的英數字和連接號[0-9A-Za-z-] 組成，且禁止（MUST NOT）留白。數字型的標識符號禁止（MUST NOT）在前方補零。先行版的優先級低於相關聯的標準版本。被標上先行版號則表示這個版本並非穩定而且可能無法達到相容的需求。範例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92、1.0.0-x-y-z.–。\n先行版號可以（MAY）被標注在修訂版之後，先加上一個連接號再加上一連串以句點分隔的標識符號來修飾。標識符號必須（MUST）由 ASCII 碼的英數字和連接號[0-9A-Za-z-] 組成，且禁止（MUST NOT）留白。數字型的標識符號禁止（MUST NOT）在前方補零。先行版的優先級低於相關聯的標準版本。被標上先行版號則表示這個版本並非穩定而且可能無法達到相容的需求。範例：1.0.0-alpha、1.0.0-alpha.1、1.0.0-0.3.7、1.0.0-x.7.z.92、1.0.0-x-y-z.–。\n版本編譯資訊可以（MAY）被標注在修訂版或先行版號之後，先加上一個加號再加上一連串以句點分隔的標識符號來修飾。標識符號必須（MUST）由 ASCII 的英數字和連接號 [0-9A-Za-z-]組成，且禁止（MUST NOT）留白。當判斷版本的優先層級時，版本編譯資訊必須（MUST）被忽略。因此當兩個版本只有在版本編譯資訊有差別時，屬於相同的優先層級。範例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85、1.0.0+21AF26D3—-117B344092BD。\n版本編譯資訊可以（MAY）被標注在修訂版或先行版號之後，先加上一個加號再加上一連串以句點分隔的標識符號來修飾。標識符號必須（MUST）由 ASCII 的英數字和連接號 [0-9A-Za-z-]組成，且禁止（MUST NOT）留白。當判斷版本的優先層級時，版本編譯資訊必須（MUST）被忽略。因此當兩個版本只有在版本編譯資訊有差別時，屬於相同的優先層級。範例：1.0.0-alpha+001、1.0.0+20130313144700、1.0.0-beta+exp.sha.5114f85、1.0.0+21AF26D3—-117B344092BD。\n版本的優先層級指的是不同版本在排序時如何比較。

    
      
        判斷優先層級時，必須（MUST）把版本依序拆分為主版號、次版號、修訂號及先行版號後進行比較（版本編譯資訊不在這份比較的列表中）。
      
      
        由左到右依序比較每個標識符號，第一個差異值用來決定優先層級：主版號、次版號及修訂號以數值比較。

        例如： 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。
      
      
        當主版號、次版號及修訂號都相同時，有先行版號者優先層級較低。

        例如：1.0.0-alpha < 1.0.0。
      
      
        有相同主版號、次版號及修訂號的兩個先行版號，其優先層級必須（MUST）透過由左到右的每個被句點分隔的標識符號來比較，直到找到一個差異值後決定：

        
          
            只有數字的標識符號以數值高低比較。
          
          
            有字母或連接號時則逐字以 ASCII 的排序來比較。
          
          
            數字的標識符號比非數字的標識符號優先層級低。
          
          
            若開頭的標識符號都相同時，欄位比較多的先行版號優先層級比較高。

            範例：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。\n版本的優先層級指的是不同版本在排序時如何比較。\n判斷優先層級時，必須（MUST）把版本依序拆分為主版號、次版號、修訂號及先行版號後進行比較（版本編譯資訊不在這份比較的列表中）。\n判斷優先層級時，必須（MUST）把版本依序拆分為主版號、次版號、修訂號及先行版號後進行比較（版本編譯資訊不在這份比較的列表中）。\n由左到右依序比較每個標識符號，第一個差異值用來決定優先層級：主版號、次版號及修訂號以數值比較。

        例如： 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。\n由左到右依序比較每個標識符號，第一個差異值用來決定優先層級：主版號、次版號及修訂號以數值比較。\n例如： 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1。\n當主版號、次版號及修訂號都相同時，有先行版號者優先層級較低。

        例如：1.0.0-alpha < 1.0.0。\n當主版號、次版號及修訂號都相同時，有先行版號者優先層級較低。\n例如：1.0.0-alpha < 1.0.0。\n有相同主版號、次版號及修訂號的兩個先行版號，其優先層級必須（MUST）透過由左到右的每個被句點分隔的標識符號來比較，直到找到一個差異值後決定：

        
          
            只有數字的標識符號以數值高低比較。
          
          
            有字母或連接號時則逐字以 ASCII 的排序來比較。
          
          
            數字的標識符號比非數字的標識符號優先層級低。
          
          
            若開頭的標識符號都相同時，欄位比較多的先行版號優先層級比較高。

            範例：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。\n有相同主版號、次版號及修訂號的兩個先行版號，其優先層級必須（MUST）透過由左到右的每個被句點分隔的標識符號來比較，直到找到一個差異值後決定：\n有字母或連接號時則逐字以 ASCII 的排序來比較。\n有字母或連接號時則逐字以 ASCII 的排序來比較。\n數字的標識符號比非數字的標識符號優先層級低。\n數字的標識符號比非數字的標識符號優先層級低。\n若開頭的標識符號都相同時，欄位比較多的先行版號優先層級比較高。

            範例：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。\n若開頭的標識符號都相同時，欄位比較多的先行版號優先層級比較高。\n範例：1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0。\n有效語意化版本的 Backus–Naur 範式語法\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"\n這並不是一個新的或者革命性的想法。實際上，你可能已經在做一些近似的事情了。問題在於只是「近似」還不夠。如果沒有某個正式的規範可循，版號對於相依性的管理並無實質意義。將上述的想法命名並給予清楚的定義，讓你對軟體使用者傳達意向變得容易。一旦這些意向變得清楚，彈性（但又不會太彈性）的相依性規範就能達成。\n舉個簡單的例子就可以展示語意化的版本控制如何讓相依性地獄成為過去。假設有個名為「消防車」的函式庫，它需要另一個名為「梯子」並已經有使用語意化版本控制的套件。當消防車創建時，梯子的版號為 3.1.0。因為消防車使用了一些版本 3.1.0 所新增的功能，你可以放心地指定相依於梯子的版號大等於 3.1.0 但小於4.0.0。這樣，當梯子版本 3.1.1和 3.2.0 發佈時，你可以將直接它們納入你的套件管理系統，因為它們能與原有相依的軟體相容。\n作為一位負責任的開發者，你理當確保每次套件升級的運作與版本號的表述一致。現實世界是複雜的，我們除了提高警覺外能做的不多。你所能做的就是讓語意化的版本控制為你提供一個健全的方式來發行以及升級套件，而無需推出新的相依套件，節省你的時間及煩惱。\n如果你對此認同，希望立即開始使用語意化版本控制，你只需聲明你的函式庫正在使用它並遵循這些規則就可以了。請在你的 README 文件中保留此頁連結，讓別人也知道這些規則並從中受益。\n在 0.y.z 初始開發階段，我該如何進行版本控制？\n最簡單的做法是以 0.1.0 作為你的初始化開發版本，並在後續的每次發行時遞增次版號。\n當你的軟體被用於正式環境，它應該已經達到了 1.0.0 版。如果你已經有個穩定的 API 被使用者依賴，也會是 1.0.0 版。如果你很擔心向下相容的問題，也應該算是 1.0.0 版了。\n主版號為零的時候就是為了做快速開發。如果你每天都在改變 API，那麼你應該仍在主版號為零的階段（0.y.z），或是正在下個主版本的獨立開發分支中。\n對於公共 API，若即使是最小但不向下相容的改變都需要產生新的主版號，豈不是很快就達到 42.0.0 版？\n這是開發的責任感和前瞻性的問題。不相容的改變不應該輕易被加入到有許多相依性程式碼的軟體中。升級所付出的代價可能是巨大的。要遞增主版號來發行不相容的改版，意味著你必須為這些改變所帶來的影響深思熟慮，並且評估所涉及的成本及效益比。\n為供他人使用的軟體編寫適當的文件，是你作為一名專業開發者應盡的職責。保持專案高效一個非常重要的部份是掌控軟體的複雜度，如果沒有人知道如何使用你的軟體或不知道哪些函數的呼叫是可靠的，要掌控複雜度會是困難的。長遠來看，使用語意化版本控制以及對於公共 API 有良好規範的堅持，可以讓每個人及每件事都運行順暢。\n萬一不小心把一個不相容的改版當成了次版號發行了該怎麼辦？\n一旦發現自己破壞了語意化版本控制的規範，就要修正這個問題，並發行一個新的次版號來更正這個問題並且恢復向下相容。即使是這種情況，也不能去修改已發行的版本。可以的話，將有問題的版號記錄到文件中，告訴使用者問題所在，讓他們能夠意識到這是有問題的版本。\n如果我更新了自己的相依性但沒有改變公共 API 該怎麼辦？\n由於沒有影響到公共 API，這可以被認定是相容的。若某個軟體和你的套件有共同相依性，則它會有自己的相依性規範，作者也會告知可能的衝突。要判斷改版是屬於修訂等級或是次版等級，是依據你更新的相依性關係是為了修復問題或是加入新功能。對於後者，我經常會預期伴隨著更多的程式碼，這顯然會是一個次版號級別的遞增。\n如果我變更了公共 API 但無意中未遵循版號的改動怎麼辦呢？（意即在修訂等級的發佈中，誤將重大且不相容的改變加到程式碼之中）\n自行做最佳的判斷。如果你有龐大的使用者群在依照公共 API 的意圖而變更行為後會大受影響，那麼最好做一次主版本的發佈，即使嚴格來說這個修復僅是修訂等級的發佈。記住，語意化的版本控制就是透過版號的改變來傳達意義。若這些改變對你的使用者是重要的，那就透過版號來向他們說明。\n棄用現存的功能是軟體開發中的家常便飯，也通常是向前發展所必須的。當你棄用部份公共 API 時，你應該做兩件事：（1）更新你的文件讓使用者知道這個改變，（2）在適當的時機將棄用的功能透過新的次版號發佈。在新的主版本完全移除棄用功能前，至少要有一個次版本包含這個棄用資訊，這樣使用者才能平順地轉移到新版 API。\n語意化版本對於版本的字串長度是否有限制呢？\n沒有，請自行做適當的判斷。舉例來說，長到 255 個字元的版本已過度誇張。再者，特定的系統對於字串長度可能會有他們自己的限制。\n不，”v1.2.3” 不是語意化版本。然而在語意化版本前加上 “v” 表示其為版本號是很常見的做法（就英文而言）。用 “v” 表示 “version” 的縮寫是版本控制的常見做法。例如：git tag v1.2.3 -m "Release version 1.2.3"，此例 “v1.2.3” 是標籤名稱，而語意化版本是 “1.2.3”。\n有建議用於檢查語意化版本的正規表示式（RegEx）嗎？\n有兩種。一種用命名群組，須在支援的系統上使用（PCRE [Perl Compatible Regular Expressions, i.e. Perl, PHP and R]、Python、以及 Go）。\n參見：https://regex101.com/r/Ly7O1x/3/\nhttps://regex101.com/r/Ly7O1x/3/\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n另一種使用擷取群組編號（組1 = 主版號，組2 = 次版號，組3 = 修訂號，組4 = 先行版號，組5 = 編譯資訊），與 ECMA Script (JavaScript)、PCRE (Perl Compatible Regular Expressions, i.e. Perl, PHP and R)、Python、以及 Go 相容。\n參見：https://regex101.com/r/vkijKf/1/\nhttps://regex101.com/r/vkijKf/1/\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$\n語意化版本控制的規範最初是由 Gravatars 創辦者兼 GitHub 共同創辦者 Tom Preston-Werner 建立。\n如果您有任何建議，請到 GitHub 上提出問題。\n\n\n