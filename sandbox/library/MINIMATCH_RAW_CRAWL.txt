minimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).\n\nminimatch10.0.1 • Public • Published 10 months ago ReadmeCode Beta1 Dependency9,779 Dependents110 Versionsminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).
ReadmeKeywordsnonePackage SidebarInstallnpm i minimatchRepositorygithub.com/isaacs/minimatchHomepagegithub.com/isaacs/minimatch#readmeFund this packageWeekly Downloads241,301,126Version10.0.1LicenseISCUnpacked Size439 kBTotal Files53Last publish10 months agoCollaboratorsTry on RunKitReport malware\n\nminimatch10.0.1 • Public • Published 10 months ago ReadmeCode Beta1 Dependency9,779 Dependents110 Versionsminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).
ReadmeKeywordsnonePackage SidebarInstallnpm i minimatchRepositorygithub.com/isaacs/minimatchHomepagegithub.com/isaacs/minimatch#readmeFund this packageWeekly Downloads241,301,126Version10.0.1LicenseISCUnpacked Size439 kBTotal Files53Last publish10 months agoCollaboratorsTry on RunKitReport malware\n\n\n\nminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).\n\nminimatch10.0.1 • Public • Published 10 months ago ReadmeCode Beta1 Dependency9,779 Dependents110 Versionsminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).
ReadmeKeywordsnonePackage SidebarInstallnpm i minimatchRepositorygithub.com/isaacs/minimatchHomepagegithub.com/isaacs/minimatch#readmeFund this packageWeekly Downloads241,301,126Version10.0.1LicenseISCUnpacked Size439 kBTotal Files53Last publish10 months agoCollaboratorsTry on RunKitReport malware\n\nminimatch10.0.1 • Public • Published 10 months ago ReadmeCode Beta1 Dependency9,779 Dependents110 Versionsminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).
ReadmeKeywordsnonePackage SidebarInstallnpm i minimatchRepositorygithub.com/isaacs/minimatchHomepagegithub.com/isaacs/minimatch#readmeFund this packageWeekly Downloads241,301,126Version10.0.1LicenseISCUnpacked Size439 kBTotal Files53Last publish10 months agoCollaboratorsTry on RunKitReport malware\n\n\n\nminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).\n\nminimatch10.0.1 • Public • Published 10 months ago ReadmeCode Beta1 Dependency9,779 Dependents110 Versionsminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).
ReadmeKeywordsnonePackage SidebarInstallnpm i minimatchRepositorygithub.com/isaacs/minimatchHomepagegithub.com/isaacs/minimatch#readmeFund this packageWeekly Downloads241,301,126Version10.0.1LicenseISCUnpacked Size439 kBTotal Files53Last publish10 months agoCollaboratorsTry on RunKitReport malware\n\nminimatch10.0.1 • Public • Published 10 months ago ReadmeCode Beta1 Dependency9,779 Dependents110 Versionsminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).
ReadmeKeywordsnonePackage SidebarInstallnpm i minimatchRepositorygithub.com/isaacs/minimatchHomepagegithub.com/isaacs/minimatch#readmeFund this packageWeekly Downloads241,301,126Version10.0.1LicenseISCUnpacked Size439 kBTotal Files53Last publish10 months agoCollaboratorsTry on RunKitReport malware\n\n\n\nminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).\n\nminimatch10.0.1 • Public • Published 10 months ago ReadmeCode Beta1 Dependency9,779 Dependents110 Versionsminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).
ReadmeKeywordsnonePackage SidebarInstallnpm i minimatchRepositorygithub.com/isaacs/minimatchHomepagegithub.com/isaacs/minimatch#readmeFund this packageWeekly Downloads241,301,126Version10.0.1LicenseISCUnpacked Size439 kBTotal Files53Last publish10 months agoCollaboratorsTry on RunKitReport malware\n\nminimatch10.0.1 • Public • Published 10 months ago ReadmeCode Beta1 Dependency9,779 Dependents110 Versionsminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).
ReadmeKeywordsnonePackage SidebarInstallnpm i minimatchRepositorygithub.com/isaacs/minimatchHomepagegithub.com/isaacs/minimatch#readmeFund this packageWeekly Downloads241,301,126Version10.0.1LicenseISCUnpacked Size439 kBTotal Files53Last publish10 months agoCollaboratorsTry on RunKitReport malware\n\n\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\n\n\nnpm Teams
      
        Share code and collaborate with the tools that make JavaScript the world's best software ecosystem
      
      
        Get started
      
    
  
  
    
      
        
          
        
        Unlimited public packages
        Bring the best of open source JavaScript development to your own projects.
      
      
        
          
        
        Unlimited private packages
        Seamlessly integrate public and private packages into your development cycle.
      
      
        
          
        
        Package-based permissions
        Add collaborators to work on your public and private packages together.
      
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      
        Get Started\n\nnpm Teams
      
        Share code and collaborate with the tools that make JavaScript the world's best software ecosystem
      
      
        Get started
      
    
  
  
    
      
        
          
        
        Unlimited public packages
        Bring the best of open source JavaScript development to your own projects.
      
      
        
          
        
        Unlimited private packages
        Seamlessly integrate public and private packages into your development cycle.
      
      
        
          
        
        Package-based permissions
        Add collaborators to work on your public and private packages together.
      
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      
        Get Started\n\nnpm Teams
      
        Share code and collaborate with the tools that make JavaScript the world's best software ecosystem
      
      
        Get started
      
    
  
  
    
      
        
          
        
        Unlimited public packages
        Bring the best of open source JavaScript development to your own projects.
      
      
        
          
        
        Unlimited private packages
        Seamlessly integrate public and private packages into your development cycle.
      
      
        
          
        
        Package-based permissions
        Add collaborators to work on your public and private packages together.
      
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      
        Get Started\n\n\n\nPricing
    
    
      
        
          
            For Public Package Authors
          
          
            
              
            
          
          
            Free
            
              $
              0
            
            
              
                Unlimited 
                  public packages
              
            
             Create 
          
        
      
      
        
          
            For Individual 
            Creators
          
          
            
          
          
            Pro
            
              $
              7
            
            per month
             
            
              
                Unlimited 
                  public packages
              
              
                Unlimited 
                  private packages
              
              
                Package-based 
                  permissions
              
            
            
              Get Started With Pro
            
          
        
      
      
        
          
            For Teams & 
            Organizations
          
          
            
          
          
            Teams
            
              $
              7
            
            per user 
              per month
            
              
                Unlimited 
                  public packages
              
              
                Unlimited 
                  private packages
              
              
                Team-based 
                  permissions
              
            
            
              Get Started With Teams
            
          
        
      
    
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support\n\nPricing
    
    
      
        
          
            For Public Package Authors
          
          
            
              
            
          
          
            Free
            
              $
              0
            
            
              
                Unlimited 
                  public packages
              
            
             Create 
          
        
      
      
        
          
            For Individual 
            Creators
          
          
            
          
          
            Pro
            
              $
              7
            
            per month
             
            
              
                Unlimited 
                  public packages
              
              
                Unlimited 
                  private packages
              
              
                Package-based 
                  permissions
              
            
            
              Get Started With Pro
            
          
        
      
      
        
          
            For Teams & 
            Organizations
          
          
            
          
          
            Teams
            
              $
              7
            
            per user 
              per month
            
              
                Unlimited 
                  public packages
              
              
                Unlimited 
                  private packages
              
              
                Team-based 
                  permissions
              
            
            
              Get Started With Teams
            
          
        
      
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support\n\nPricing
    
    
      
        
          
            For Public Package Authors
          
          
            
              
            
          
          
            Free
            
              $
              0
            
            
              
                Unlimited 
                  public packages
              
            
             Create 
          
        
      
      
        
          
            For Individual 
            Creators
          
          
            
          
          
            Pro
            
              $
              7
            
            per month
             
            
              
                Unlimited 
                  public packages
              
              
                Unlimited 
                  private packages
              
              
                Package-based 
                  permissions
              
            
            
              Get Started With Pro
            
          
        
      
      
        
          
            For Teams & 
            Organizations
          
          
            
          
          
            Teams
            
              $
              7
            
            per user 
              per month
            
              
                Unlimited 
                  public packages
              
              
                Unlimited 
                  private packages
              
              
                Team-based 
                  permissions
              
            
            
              Get Started With Teams
            
          
        
      
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support\n\n\n\nBuild amazing thingsWe're GitHub, the company behind the npm Registry and npm CLI. We offer those to the community for free, but our day job is building and selling useful tools for developers like you.Take your JavaScript development up a notchGet started today for free, or step up to npm Pro to enjoy a premium JavaScript development experience, with features like private packages.Sign up for freeLearn about ProBring the best of open source to you, your team, and your companyRelied upon by more than 17 million developers worldwide, npm is committed to making JavaScript development elegant, productive, and safe. The free npm Registry has become the center of JavaScript code sharing, and with more than two million packages, the largest software registry in the world. Our other tools and services take the Registry, and the work you do around it, to the next level.\n\nBuild amazing thingsWe're GitHub, the company behind the npm Registry and npm CLI. We offer those to the community for free, but our day job is building and selling useful tools for developers like you.Take your JavaScript development up a notchGet started today for free, or step up to npm Pro to enjoy a premium JavaScript development experience, with features like private packages.Sign up for freeLearn about ProBring the best of open source to you, your team, and your companyRelied upon by more than 17 million developers worldwide, npm is committed to making JavaScript development elegant, productive, and safe. The free npm Registry has become the center of JavaScript code sharing, and with more than two million packages, the largest software registry in the world. Our other tools and services take the Registry, and the work you do around it, to the next level.\n\nBuild amazing thingsWe're GitHub, the company behind the npm Registry and npm CLI. We offer those to the community for free, but our day job is building and selling useful tools for developers like you.Take your JavaScript development up a notchGet started today for free, or step up to npm Pro to enjoy a premium JavaScript development experience, with features like private packages.Sign up for freeLearn about ProBring the best of open source to you, your team, and your companyRelied upon by more than 17 million developers worldwide, npm is committed to making JavaScript development elegant, productive, and safe. The free npm Registry has become the center of JavaScript code sharing, and with more than two million packages, the largest software registry in the world. Our other tools and services take the Registry, and the work you do around it, to the next level.\n\n\n\nSign UpUsername *Email addressYour email address will be added to the metadata of packages that you publish, so it may be seen publicly.PasswordShowMinimum of 10 characters and must meet our  password guidelinesI agree to the End User License Agreement and the Privacy Policy. *Create an AccountAlready have an account?Sign In\n\nSign UpUsername *Email addressYour email address will be added to the metadata of packages that you publish, so it may be seen publicly.PasswordShowMinimum of 10 characters and must meet our  password guidelinesI agree to the End User License Agreement and the Privacy Policy. *Create an AccountAlready have an account?Sign In\n\n\n\nSign InUsernameForgot password?PasswordShowSign InCreate Account\n\nSign InUsernameForgot password?PasswordShowSign InCreate Account\n\n\n\nminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).\n\nminimatch10.0.1 • Public • Published 10 months ago ReadmeCode Beta1 Dependency9,779 Dependents110 Versionsminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).
ReadmeKeywordsnonePackage SidebarInstallnpm i minimatchRepositorygithub.com/isaacs/minimatchHomepagegithub.com/isaacs/minimatch#readmeFund this packageWeekly Downloads241,301,126Version10.0.1LicenseISCUnpacked Size439 kBTotal Files53Last publish10 months agoCollaboratorsTry on RunKitReport malware\n\nminimatch10.0.1 • Public • Published 10 months ago ReadmeCode Beta1 Dependency9,779 Dependents110 Versionsminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).
ReadmeKeywordsnonePackage SidebarInstallnpm i minimatchRepositorygithub.com/isaacs/minimatchHomepagegithub.com/isaacs/minimatch#readmeFund this packageWeekly Downloads241,301,126Version10.0.1LicenseISCUnpacked Size439 kBTotal Files53Last publish10 months agoCollaboratorsTry on RunKitReport malware\n\n\n\nminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).\n\nminimatch10.0.1 • Public • Published 10 months ago ReadmeCode Beta1 Dependency9,779 Dependents110 Versionsminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).
/minimatch//minimatch/Package SidebarInstallnpm i minimatchRepositorygithub.com/isaacs/minimatchHomepagegithub.com/isaacs/minimatch#readmeFund this packageWeekly Downloads241,301,126Version10.0.1LicenseISCUnpacked Size439 kBTotal Files53Last publish10 months agoCollaboratorsTry on RunKitReport malware\n\nminimatch10.0.1 • Public • Published 10 months ago ReadmeCode Beta1 Dependency9,779 Dependents110 Versionsminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).
/minimatch//minimatch/Package SidebarInstallnpm i minimatchRepositorygithub.com/isaacs/minimatchHomepagegithub.com/isaacs/minimatch#readmeFund this packageWeekly Downloads241,301,126Version10.0.1LicenseISCUnpacked Size439 kBTotal Files53Last publish10 months agoCollaboratorsTry on RunKitReport malware\n\n\n\nminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).\n\nminimatch10.0.1 • Public • Published 10 months ago ReadmeCode Beta1 Dependency9,779 Dependents110 Versionsminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).
Dependencies (1)brace-expansionDev Dependencies (8)@types/brace-expansion@types/nodemkdirpprettiertaptshytypedoctypescriptPackage SidebarInstallnpm i minimatchRepositorygithub.com/isaacs/minimatchHomepagegithub.com/isaacs/minimatch#readmeFund this packageWeekly Downloads241,301,126Version10.0.1LicenseISCUnpacked Size439 kBTotal Files53Last publish10 months agoCollaboratorsTry on RunKitReport malware\n\nminimatch10.0.1 • Public • Published 10 months ago ReadmeCode Beta1 Dependency9,779 Dependents110 Versionsminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).
Dependencies (1)brace-expansionDev Dependencies (8)@types/brace-expansion@types/nodemkdirpprettiertaptshytypedoctypescriptPackage SidebarInstallnpm i minimatchRepositorygithub.com/isaacs/minimatchHomepagegithub.com/isaacs/minimatch#readmeFund this packageWeekly Downloads241,301,126Version10.0.1LicenseISCUnpacked Size439 kBTotal Files53Last publish10 months agoCollaboratorsTry on RunKitReport malware\n\n\n\nminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).\n\nminimatch10.0.1 • Public • Published 10 months ago ReadmeCode Beta1 Dependency9,779 Dependents110 Versionsminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).
Dependents (9779)proper-import-jsdeep-filesbroccoli-jstransformtarosmackdownid-projectwatch-networkasdgulp-watch-networknode-kpcfirebase-http-servergulp-asidejbuildase2stylusreplaceifyis_file_injshint-semicolon-hacksass-indexurlspacekarma-global-dfpgrunt-lock-extendedraptor-templatesfile-cleanerautocomplete-plus-async-plusks-twigbinder-jsgulp-cogkarma-generic-preprocessoraster-srcgulp-modulizekarma-coverage-blamerstatus-collectoransgrunt-static-versioning-requirejsgulp-semiflats3globvalidify.jsraptor-optimizer-clidcatjt-cliarkroots-joshrowleyunglobgrunt-image-checkgmanextract-requiredhtml.twiglrbower-cleanhardware-resolveand more...Package SidebarInstallnpm i minimatchRepositorygithub.com/isaacs/minimatchHomepagegithub.com/isaacs/minimatch#readmeFund this packageWeekly Downloads241,301,126Version10.0.1LicenseISCUnpacked Size439 kBTotal Files53Last publish10 months agoCollaboratorsTry on RunKitReport malware\n\nminimatch10.0.1 • Public • Published 10 months ago ReadmeCode Beta1 Dependency9,779 Dependents110 Versionsminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).
Dependents (9779)proper-import-jsdeep-filesbroccoli-jstransformtarosmackdownid-projectwatch-networkasdgulp-watch-networknode-kpcfirebase-http-servergulp-asidejbuildase2stylusreplaceifyis_file_injshint-semicolon-hacksass-indexurlspacekarma-global-dfpgrunt-lock-extendedraptor-templatesfile-cleanerautocomplete-plus-async-plusks-twigbinder-jsgulp-cogkarma-generic-preprocessoraster-srcgulp-modulizekarma-coverage-blamerstatus-collectoransgrunt-static-versioning-requirejsgulp-semiflats3globvalidify.jsraptor-optimizer-clidcatjt-cliarkroots-joshrowleyunglobgrunt-image-checkgmanextract-requiredhtml.twiglrbower-cleanhardware-resolveand more...Package SidebarInstallnpm i minimatchRepositorygithub.com/isaacs/minimatchHomepagegithub.com/isaacs/minimatch#readmeFund this packageWeekly Downloads241,301,126Version10.0.1LicenseISCUnpacked Size439 kBTotal Files53Last publish10 months agoCollaboratorsTry on RunKitReport malware\n\n\n\nminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).\n\nminimatch10.0.1 • Public • Published 10 months ago ReadmeCode Beta1 Dependency9,779 Dependents110 Versionsminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).
VersionsCurrent TagsVersionDownloads (Last 7 Days)Tag3.1.296,228,636v3-legacy5.1.631,413,033legacy-v510.0.17,507,540latest3.0.84,510,401v3.0-legacy7.4.63,134,251legacy-v74.2.31,227,566legacy-v4Version Historyshow deprecated versionsVersionDownloads (Last 7 Days)Published10.0.17,507,54010 months ago10.0.049210 months ago9.0.549,863,50410 months ago9.0.44,526,985a year ago9.0.313,644,7542 years ago9.0.2138,3232 years ago9.0.13,814,3462 years ago9.0.0216,9232 years ago7.4.63,134,2512 years ago8.0.45,693,9602 years ago8.0.321,0192 years ago7.4.58,4032 years ago8.0.25,0512 years ago8.0.1642 years ago8.0.0402 years ago7.4.41,7742 years ago7.4.397,3732 years ago7.4.2108,0782 years ago7.4.17002 years ago7.4.0342 years ago7.3.01,7702 years ago7.2.09,3852 years ago7.1.4312 years ago7.1.3412 years ago7.1.2282 years ago7.1.1212 years ago7.1.03332 years ago7.0.17002 years ago7.0.0682 years ago6.2.01,117,2612 years ago6.1.10302 years ago6.1.9312 years ago6.1.82,0502 years ago6.1.7522 years ago6.1.675,4642 years ago6.1.5562 years ago4.2.31,227,5662 years ago5.1.631,413,0332 years ago6.1.4392 years ago6.1.3302 years ago4.2.2542 years ago5.1.573,9312 years ago6.1.2352 years ago6.1.1182 years ago6.1.0372 years ago6.0.44,7272 years ago6.0.3222 years ago6.0.2252 years ago6.0.1232 years ago6.0.0392 years ago5.1.456,7582 years ago5.1.3312 years ago5.1.2447,6522 years ago5.1.1186,9042 years ago5.1.01,928,0833 years ago5.0.12,318,2513 years ago3.0.84,510,4013 years ago3.1.296,228,6363 years ago5.0.02,9083 years ago4.2.1977,0083 years ago4.2.0333 years ago4.1.11,2823 years ago3.0.74,4363 years ago3.1.147,1633 years ago3.1.03173 years ago4.1.0343 years ago4.0.03103 years ago3.0.61113 years ago3.0.52,519,6523 years ago3.0.47,698,4708 years ago3.0.3172,4259 years ago3.0.230,2989 years agoPackage SidebarInstallnpm i minimatchRepositorygithub.com/isaacs/minimatchHomepagegithub.com/isaacs/minimatch#readmeFund this packageWeekly Downloads241,301,126Version10.0.1LicenseISCUnpacked Size439 kBTotal Files53Last publish10 months agoCollaboratorsTry on RunKitReport malware\n\nminimatch10.0.1 • Public • Published 10 months ago ReadmeCode Beta1 Dependency9,779 Dependents110 Versionsminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).
VersionsCurrent TagsVersionDownloads (Last 7 Days)Tag3.1.296,228,636v3-legacy5.1.631,413,033legacy-v510.0.17,507,540latest3.0.84,510,401v3.0-legacy7.4.63,134,251legacy-v74.2.31,227,566legacy-v4Version Historyshow deprecated versionsVersionDownloads (Last 7 Days)Published10.0.17,507,54010 months ago10.0.049210 months ago9.0.549,863,50410 months ago9.0.44,526,985a year ago9.0.313,644,7542 years ago9.0.2138,3232 years ago9.0.13,814,3462 years ago9.0.0216,9232 years ago7.4.63,134,2512 years ago8.0.45,693,9602 years ago8.0.321,0192 years ago7.4.58,4032 years ago8.0.25,0512 years ago8.0.1642 years ago8.0.0402 years ago7.4.41,7742 years ago7.4.397,3732 years ago7.4.2108,0782 years ago7.4.17002 years ago7.4.0342 years ago7.3.01,7702 years ago7.2.09,3852 years ago7.1.4312 years ago7.1.3412 years ago7.1.2282 years ago7.1.1212 years ago7.1.03332 years ago7.0.17002 years ago7.0.0682 years ago6.2.01,117,2612 years ago6.1.10302 years ago6.1.9312 years ago6.1.82,0502 years ago6.1.7522 years ago6.1.675,4642 years ago6.1.5562 years ago4.2.31,227,5662 years ago5.1.631,413,0332 years ago6.1.4392 years ago6.1.3302 years ago4.2.2542 years ago5.1.573,9312 years ago6.1.2352 years ago6.1.1182 years ago6.1.0372 years ago6.0.44,7272 years ago6.0.3222 years ago6.0.2252 years ago6.0.1232 years ago6.0.0392 years ago5.1.456,7582 years ago5.1.3312 years ago5.1.2447,6522 years ago5.1.1186,9042 years ago5.1.01,928,0833 years ago5.0.12,318,2513 years ago3.0.84,510,4013 years ago3.1.296,228,6363 years ago5.0.02,9083 years ago4.2.1977,0083 years ago4.2.0333 years ago4.1.11,2823 years ago3.0.74,4363 years ago3.1.147,1633 years ago3.1.03173 years ago4.1.0343 years ago4.0.03103 years ago3.0.61113 years ago3.0.52,519,6523 years ago3.0.47,698,4708 years ago3.0.3172,4259 years ago3.0.230,2989 years agoPackage SidebarInstallnpm i minimatchRepositorygithub.com/isaacs/minimatchHomepagegithub.com/isaacs/minimatch#readmeFund this packageWeekly Downloads241,301,126Version10.0.1LicenseISCUnpacked Size439 kBTotal Files53Last publish10 months agoCollaboratorsTry on RunKitReport malware\n\n\n\nminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).\n\nminimatch10.0.1 • Public • Published 10 months ago ReadmeCode Beta1 Dependency9,779 Dependents110 Versionsminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).
ReadmeKeywordsnonePackage SidebarInstallnpm i minimatchRepositorygithub.com/isaacs/minimatchHomepagegithub.com/isaacs/minimatch#readmeFund this packageWeekly Downloads241,301,126Version10.0.1LicenseISCUnpacked Size439 kBTotal Files53Last publish10 months agoCollaboratorsTry on RunKitReport malware\n\nminimatch10.0.1 • Public • Published 10 months ago ReadmeCode Beta1 Dependency9,779 Dependents110 Versionsminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).
ReadmeKeywordsnonePackage SidebarInstallnpm i minimatchRepositorygithub.com/isaacs/minimatchHomepagegithub.com/isaacs/minimatch#readmeFund this packageWeekly Downloads241,301,126Version10.0.1LicenseISCUnpacked Size439 kBTotal Files53Last publish10 months agoCollaboratorsTry on RunKitReport malware\n\n\n\nminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).\n\nminimatch10.0.1 • Public • Published 10 months ago ReadmeCode Beta1 Dependency9,779 Dependents110 Versionsminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).
ReadmeKeywordsnonePackage SidebarInstallnpm i minimatchRepositorygithub.com/isaacs/minimatchHomepagegithub.com/isaacs/minimatch#readmeFund this packageWeekly Downloads241,301,126Version10.0.1LicenseISCUnpacked Size439 kBTotal Files53Last publish10 months agoCollaboratorsTry on RunKitReport malware\n\nminimatch10.0.1 • Public • Published 10 months ago ReadmeCode Beta1 Dependency9,779 Dependents110 Versionsminimatch
A minimal matching utility.
This is the matching library used internally by npm.
It works by converting glob expressions into JavaScript RegExp
objects.
Usage
// hybrid module, load with require() or import
import { minimatch } from 'minimatch'
// or:
const { minimatch } = require('minimatch')

minimatch('bar.foo', '*.foo') // true!
minimatch('bar.foo', '*.bar') // false!
minimatch('bar.foo', '*.+(bar|foo)', { debug: true }) // true, and noisy!
Features
Supports these glob features:

Brace Expansion
Extended glob matching
"Globstar" ** matching

Posix character
classes,
like [[:alpha:]], supporting the full range of Unicode
characters. For example, [[:alpha:]] will match against
'é', though [a-zA-Z] will not. Collating symbol and set
matching is not supported, so [[=e=]] will not match 'é'
and [[.ch.]] will not match 'ch' in locales where ch is
considered a single character.

See:

man sh

man bash Pattern
Matching

man 3 fnmatch
man 5 gitignore

Windows
Please only use forward-slashes in glob expressions.
Though windows uses either / or \ as its path separator, only /
characters are used by this glob implementation. You must use
forward-slashes only in glob expressions. Back-slashes in patterns
will always be interpreted as escape characters, not path separators.
Note that \ or / will be interpreted as path separators in paths on
Windows, and will match against / in glob expressions.
So just always use / in patterns.
UNC Paths
On Windows, UNC paths like //?/c:/... or
//ComputerName/Share/... are handled specially.

Patterns starting with a double-slash followed by some
non-slash characters will preserve their double-slash. As a
result, a pattern like //* will match //x, but not /x.
Patterns staring with //?/<drive letter>: will not treat
the ? as a wildcard character. Instead, it will be treated
as a normal string.
Patterns starting with //?/<drive letter>:/... will match
file paths starting with <drive letter>:/..., and vice versa,
as if the //?/ was not present. This behavior only is
present when the drive letters are a case-insensitive match to
one another. The remaining portions of the path/pattern are
compared case sensitively, unless nocase:true is set.

Note that specifying a UNC path using \ characters as path
separators is always allowed in the file path argument, but only
allowed in the pattern argument when windowsPathsNoEscape: true
is set in the options.
Minimatch Class
Create a minimatch object by instantiating the minimatch.Minimatch class.
var Minimatch = require('minimatch').Minimatch
var mm = new Minimatch(pattern, options)
Properties


pattern The original pattern the minimatch object represents.


options The options supplied to the constructor.


set A 2-dimensional array of regexp or string expressions.
Each row in the
array corresponds to a brace-expanded pattern. Each item in the row
corresponds to a single path-part. For example, the pattern
{a,b/c}/d would expand to a set of patterns like:
  [ [ a, d ]
  , [ b, c, d ] ]

If a portion of the pattern doesn't have any "magic" in it
(that is, it's something like "foo" rather than fo*o?), then it
will be left as a string rather than converted to a regular
expression.


regexp Created by the makeRe method. A single regular expression
expressing the entire pattern. This is useful in cases where you wish
to use the pattern somewhat like fnmatch(3) with FNM_PATH enabled.


negate True if the pattern is negated.


comment True if the pattern is a comment.


empty True if the pattern is "".


Methods


makeRe() Generate the regexp member if necessary, and return it.
Will return false if the pattern is invalid.


match(fname) Return true if the filename matches the pattern, or
false otherwise.


matchOne(fileArray, patternArray, partial) Take a /-split
filename, and match it against a single row in the regExpSet. This
method is mainly for internal use, but is exposed so that it can be
used by a glob-walker that needs to avoid excessive filesystem calls.


hasMagic() Returns true if the parsed pattern contains any
magic characters. Returns false if all comparator parts are
string literals. If the magicalBraces option is set on the
constructor, then it will consider brace expansions which are
not otherwise magical to be magic. If not set, then a pattern
like a{b,c}d will return false, because neither abd nor
acd contain any special glob characters.
This does not mean that the pattern string can be used as a
literal filename, as it may contain magic glob characters that
are escaped. For example, the pattern \\* or [*] would not
be considered to have magic, as the matching portion parses to
the literal string '*' and would match a path named '*',
not '\\*' or '[*]'. The minimatch.unescape() method may
be used to remove escape characters.


All other methods are internal, and will be called as necessary.
minimatch(path, pattern, options)
Main export. Tests a path against the pattern using the options.
var isJS = minimatch(file, '*.js', { matchBase: true })
minimatch.filter(pattern, options)
Returns a function that tests its
supplied argument, suitable for use with Array.filter. Example:
var javascripts = fileList.filter(minimatch.filter('*.js', { matchBase: true }))
minimatch.escape(pattern, options = {})
Escape all magic characters in a glob pattern, so that it will
only ever match literal strings
If the windowsPathsNoEscape option is used, then characters are
escaped by wrapping in [], because a magic character wrapped in
a character class can only be satisfied by that exact character.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.unescape(pattern, options = {})
Un-escape a glob string that may contain some escaped characters.
If the windowsPathsNoEscape option is used, then square-brace
escapes are removed, but not backslash escapes. For example, it
will turn the string '[*]' into *, but it will not turn
'\\*' into '*', because \ is a path separator in
windowsPathsNoEscape mode.
When windowsPathsNoEscape is not set, then both brace escapes
and backslash escapes are removed.
Slashes (and backslashes in windowsPathsNoEscape mode) cannot
be escaped or unescaped.
minimatch.match(list, pattern, options)
Match against the list of
files, in the style of fnmatch or glob. If nothing is matched, and
options.nonull is set, then return a list containing the pattern itself.
var javascripts = minimatch.match(fileList, '*.js', { matchBase: true })
minimatch.makeRe(pattern, options)
Make a regular expression object from the pattern.
Options
All options are false by default.
debug
Dump a ton of stuff to stderr.
nobrace
Do not expand {a,b} and {1..3} brace sets.
noglobstar
Disable ** matching against multiple folder names.
dot
Allow patterns to match filenames starting with a period, even if
the pattern does not explicitly have a period in that spot.
Note that by default, a/**/b will not match a/.d/b, unless dot
is set.
noext
Disable "extglob" style patterns like +(a|b).
nocase
Perform a case-insensitive match.
nocaseMagicOnly
When used with {nocase: true}, create regular expressions that
are case-insensitive, but leave string match portions untouched.
Has no effect when used without {nocase: true}
Useful when some other form of case-insensitive matching is used,
or if the original string representation is useful in some other
way.
nonull
When a match is not found by minimatch.match, return a list containing
the pattern itself if this option is set. When not set, an empty list
is returned if there are no matches.
magicalBraces
This only affects the results of the Minimatch.hasMagic method.
If the pattern contains brace expansions, such as a{b,c}d, but
no other magic characters, then the Minimatch.hasMagic() method
will return false by default. When this option set, it will
return true for brace expansion as well as other magic glob
characters.
matchBase
If set, then patterns without slashes will be matched
against the basename of the path if it contains slashes. For example,
a?b would match the path /xyz/123/acb, but not /xyz/acb/123.
nocomment
Suppress the behavior of treating # at the start of a pattern as a
comment.
nonegate
Suppress the behavior of treating a leading ! character as negation.
flipNegate
Returns from negate expressions the same as if they were not negated.
(Ie, true on a hit, false on a miss.)
partial
Compare a partial path to a pattern. As long as the parts of the path that
are present are not contradicted by the pattern, it will be treated as a
match. This is useful in applications where you're walking through a
folder structure, and don't yet have the full path, but want to ensure that
you do not walk down paths that can never be a match.
For example,
minimatch('/a/b', '/a/*/c/d', { partial: true }) // true, might be /a/b/c/d
minimatch('/a/b', '/**/d', { partial: true }) // true, might be /a/b/.../d
minimatch('/x/y/z', '/a/**/z', { partial: true }) // false, because x !== a
windowsPathsNoEscape
Use \\ as a path separator only, and never as an escape
character. If set, all \\ characters are replaced with / in
the pattern. Note that this makes it impossible to match
against paths containing literal glob pattern characters, but
allows matching with patterns constructed using path.join() and
path.resolve() on Windows platforms, mimicking the (buggy!)
behavior of earlier versions on Windows. Please use with
caution, and be mindful of the caveat about Windows
paths.
For legacy reasons, this is also set if
options.allowWindowsEscape is set to the exact value false.
windowsNoMagicRoot
When a pattern starts with a UNC path or drive letter, and in
nocase:true mode, do not convert the root portions of the
pattern into a case-insensitive regular expression, and instead
leave them as strings.
This is the default when the platform is win32 and
nocase:true is set.
preserveMultipleSlashes
By default, multiple / characters (other than the leading //
in a UNC path, see "UNC Paths" above) are treated as a single
/.
That is, a pattern like a///b will match the file path a/b.
Set preserveMultipleSlashes: true to suppress this behavior.
optimizationLevel
A number indicating the level of optimization that should be done
to the pattern prior to parsing and using it for matches.
Globstar parts ** are always converted to * when noglobstar
is set, and multiple adjacent ** parts are converted into a
single ** (ie, a/**/**/b will be treated as a/**/b, as this
is equivalent in all cases).


0 - Make no further changes. In this mode, . and .. are
maintained in the pattern, meaning that they must also appear
in the same position in the test path string. Eg, a pattern
like a/*/../c will match the string a/b/../c but not the
string a/c.


1 - (default) Remove cases where a double-dot .. follows a
pattern portion that is not **, ., .., or empty ''. For
example, the pattern ./a/b/../* is converted to ./a/*, and
so it will match the path string ./a/c, but not the path
string ./a/b/../c. Dots and empty path portions in the
pattern are preserved.


2 (or higher) - Much more aggressive optimizations, suitable
for use with file-walking cases:

Remove cases where a double-dot .. follows a pattern
portion that is not **, ., or empty ''. Remove empty
and . portions of the pattern, where safe to do so (ie,
anywhere other than the last position, the first position, or
the second position in a pattern starting with /, as this
may indicate a UNC path on Windows).
Convert patterns containing <pre>/**/../<p>/<rest> into the
equivalent <pre>/{..,**}/<p>/<rest>, where <p> is a
a pattern portion other than ., .., **, or empty
''.
Dedupe patterns where a ** portion is present in one and
omitted in another, and it is not the final path portion, and
they are otherwise equivalent. So {a/**/b,a/b} becomes
a/**/b, because ** matches against an empty path portion.
Dedupe patterns where a * portion is present in one, and a
non-dot pattern other than **, ., .., or '' is in the
same position in the other. So a/{*,x}/b becomes a/*/b,
because * can match against x.

While these optimizations improve the performance of
file-walking use cases such as glob (ie,
the reason this module exists), there are cases where it will
fail to match a literal string that would have been matched in
optimization level 1 or 0.
Specifically, while the Minimatch.match() method will
optimize the file path string in the same ways, resulting in
the same matches, it will fail when tested with the regular
expression provided by Minimatch.makeRe(), unless the path
string is first processed with
minimatch.levelTwoFileOptimize() or similar.


platform
When set to win32, this will trigger all windows-specific
behaviors (special handling for UNC paths, and treating \ as
separators in file paths for comparison.)
Defaults to the value of process.platform.
Comparisons to other fnmatch/glob implementations
While strict compliance with the existing standards is a
worthwhile goal, some discrepancies exist between minimatch and
other implementations. Some are intentional, and some are
unavoidable.
If the pattern starts with a ! character, then it is negated. Set the
nonegate flag to suppress this behavior, and treat leading !
characters normally. This is perhaps relevant if you wish to start the
pattern with a negative extglob pattern like !(a|B). Multiple !
characters at the start of a pattern will negate the pattern multiple
times.
If a pattern starts with #, then it is treated as a comment, and
will not match anything. Use \# to match a literal # at the
start of a line, or set the nocomment flag to suppress this behavior.
The double-star character ** is supported by default, unless the
noglobstar flag is set. This is supported in the manner of bsdglob
and bash 4.1, where ** only has special significance if it is the only
thing in a path part. That is, a/**/b will match a/x/y/b, but
a/**b will not.
If an escaped pattern has no matches, and the nonull flag is set,
then minimatch.match returns the pattern as-provided, rather than
interpreting the character escapes. For example,
minimatch.match([], "\\*a\\?") will return "\\*a\\?" rather than
"*a?". This is akin to setting the nullglob option in bash, except
that it does not resolve escaped pattern characters.
If brace expansion is not disabled, then it is performed before any
other interpretation of the glob pattern. Thus, a pattern like
+(a|{b),c)}, which would not be valid in bash or zsh, is expanded
first into the set of +(a|b) and +(a|c), and those patterns are
checked for validity. Since those two are valid, matching proceeds.
Negated extglob patterns are handled as closely as possible to
Bash semantics, but there are some cases with negative extglobs
which are exceedingly difficult to express in a JavaScript
regular expression. In particular the negated pattern
<start>!(<pattern>*|)* will in bash match anything that does
not start with <start><pattern>. However,
<start>!(<pattern>*)* will match paths starting with
<start><pattern>, because the empty string can match against
the negated portion. In this library, <start>!(<pattern>*|)*
will not match any pattern starting with <start>, due to a
difference in precisely which patterns are considered "greedy" in
Regular Expressions vs bash path expansion. This may be fixable,
but not without incurring some complexity and performance costs,
and the trade-off seems to not be worth pursuing.
Note that fnmatch(3) in libc is an extremely naive string comparison
matcher, which does not do anything special for slashes. This library is
designed to be used in glob searching and file walkers, and so it does do
special things with /. Thus, foo* will not match foo/bar in this
library, even though it would in fnmatch(3).
ReadmeKeywordsnonePackage SidebarInstallnpm i minimatchRepositorygithub.com/isaacs/minimatchHomepagegithub.com/isaacs/minimatch#readmeFund this packageWeekly Downloads241,301,126Version10.0.1LicenseISCUnpacked Size439 kBTotal Files53Last publish10 months agoCollaboratorsTry on RunKitReport malware\n\n\n\nisaacsisaacs486 Packages0 OrganizationsPackages 486node-dateisaacspublished 0.0.1 • 14 years agopublished version 0.0.1, 14 years agosodnSelf-organizing dnode networkpublished 0.0.0 • 14 years agopublished version 0.0.0, 14 years agotap-global-harnessA default harness for running TAP testpublished 0.0.1 • 14 years agopublished version 0.0.1, 14 years agotap-harnessA harness for TAP Tests to usepublished 0.0.3 • 14 years agopublished version 0.0.3, 14 years agotap-assertAn assertion module that returns TAP result objectsisaacspublished 0.0.11 • 10 years agopublished version 0.0.11, 10 years agotap-consumerA module for consuming TAP outputpublished 0.0.1 • 14 years agopublished version 0.0.1, 14 years agotap-producerA module for producing TAP outputpublished 0.0.1 • 14 years agopublished version 0.0.1, 14 years agotap-resultsA util for keeping track of tap result objectspublished 0.0.2 • 14 years agopublished version 0.0.2, 14 years agotap-testA test framework for running TAP testpublished 0.0.2 • 14 years agopublished version 0.0.2, 14 years agotap-runnerA module for running all the tests in a directoryisaacspublished 0.0.7 • 14 years agopublished version 0.0.7, 14 years agocluster-callrespA call-and-response message passing system for node's cluster builtinisaacspublished 0.0.1 • 13 years agopublished version 0.0.1, 13 years agoelizaThe classic Elizaisaacspublished 0.0.1-2 • 13 years agopublished version 0.0.1-2, 13 years agotako-session-tokensession tokens for takoisaacspublished 0.0.2 • 13 years agopublished version 0.0.2, 13 years agovoxer-blog-demoA demo blog written live at Voxer HQ so it probably isn't great.isaacspublished 0.0.1 • 13 years agopublished version 0.0.1, 13 years agohexeditHexadecimal Editorisaacspublished 1.0.3 • 3 years agopublished version 1.0.3, 3 years agoirssi-questionsA filter stream to pull out the questions from an irssi log fileisaacspublished 0.0.4 • 10 years agopublished version 0.0.4, 10 years agogithub-flavored-markdownThe port of Showdown used on github.comisaacspublished 1.0.1 • 13 years agopublished version 1.0.1, 13 years agocanonical-hostRedirect users to the canonical hostname for your site.isaacspublished 0.0.5 • 10 years agopublished version 0.0.5, 10 years agochownrlike `chown -R`isaacspublished 3.0.0 • a year agopublished version 3.0.0, a year agocouchdb-log-parseA program for parsing CouchDB logsisaacspublished 0.0.4 • 10 years agopublished version 0.0.4, 10 years agotako-cookiesA cookie middleware for takoisaacspublished 0.0.4 • 13 years agopublished version 0.0.4, 13 years agonpm-docsiteA website that serves the docs of npm packages.published 0.0.1 • 14 years agopublished version 0.0.1, 14 years agocsrf-litecsrf protection for framework-less node sitesisaacspublished 1.0.0 • 9 years agopublished version 1.0.0, 9 years agosimple-protocolA very simple json-header-and-body protocolisaacspublished 1.1.1 • 10 years agopublished version 1.1.1, 10 years agonosyncPrevent *Sync functions from being run after the first tickisaacspublished 1.0.0 • 13 years agopublished version 1.0.0, 13 years agoshow more packages\n\nisaacsisaacs486 Packages0 OrganizationsPackages 486node-dateisaacspublished 0.0.1 • 14 years agopublished version 0.0.1, 14 years agosodnSelf-organizing dnode networkpublished 0.0.0 • 14 years agopublished version 0.0.0, 14 years agotap-global-harnessA default harness for running TAP testpublished 0.0.1 • 14 years agopublished version 0.0.1, 14 years agotap-harnessA harness for TAP Tests to usepublished 0.0.3 • 14 years agopublished version 0.0.3, 14 years agotap-assertAn assertion module that returns TAP result objectsisaacspublished 0.0.11 • 10 years agopublished version 0.0.11, 10 years agotap-consumerA module for consuming TAP outputpublished 0.0.1 • 14 years agopublished version 0.0.1, 14 years agotap-producerA module for producing TAP outputpublished 0.0.1 • 14 years agopublished version 0.0.1, 14 years agotap-resultsA util for keeping track of tap result objectspublished 0.0.2 • 14 years agopublished version 0.0.2, 14 years agotap-testA test framework for running TAP testpublished 0.0.2 • 14 years agopublished version 0.0.2, 14 years agotap-runnerA module for running all the tests in a directoryisaacspublished 0.0.7 • 14 years agopublished version 0.0.7, 14 years agocluster-callrespA call-and-response message passing system for node's cluster builtinisaacspublished 0.0.1 • 13 years agopublished version 0.0.1, 13 years agoelizaThe classic Elizaisaacspublished 0.0.1-2 • 13 years agopublished version 0.0.1-2, 13 years agotako-session-tokensession tokens for takoisaacspublished 0.0.2 • 13 years agopublished version 0.0.2, 13 years agovoxer-blog-demoA demo blog written live at Voxer HQ so it probably isn't great.isaacspublished 0.0.1 • 13 years agopublished version 0.0.1, 13 years agohexeditHexadecimal Editorisaacspublished 1.0.3 • 3 years agopublished version 1.0.3, 3 years agoirssi-questionsA filter stream to pull out the questions from an irssi log fileisaacspublished 0.0.4 • 10 years agopublished version 0.0.4, 10 years agogithub-flavored-markdownThe port of Showdown used on github.comisaacspublished 1.0.1 • 13 years agopublished version 1.0.1, 13 years agocanonical-hostRedirect users to the canonical hostname for your site.isaacspublished 0.0.5 • 10 years agopublished version 0.0.5, 10 years agochownrlike `chown -R`isaacspublished 3.0.0 • a year agopublished version 3.0.0, a year agocouchdb-log-parseA program for parsing CouchDB logsisaacspublished 0.0.4 • 10 years agopublished version 0.0.4, 10 years agotako-cookiesA cookie middleware for takoisaacspublished 0.0.4 • 13 years agopublished version 0.0.4, 13 years agonpm-docsiteA website that serves the docs of npm packages.published 0.0.1 • 14 years agopublished version 0.0.1, 14 years agocsrf-litecsrf protection for framework-less node sitesisaacspublished 1.0.0 • 9 years agopublished version 1.0.0, 9 years agosimple-protocolA very simple json-header-and-body protocolisaacspublished 1.1.1 • 10 years agopublished version 1.1.1, 10 years agonosyncPrevent *Sync functions from being run after the first tickisaacspublished 1.0.0 • 13 years agopublished version 1.0.0, 13 years agoshow more packages\n\n\n\nContact UsGet help with the npm registry or your npm account.Please contact us if you need help with the npm registry or with your npm account, if you are reporting security concerns in an npm product, or if you need to report malicious or abusive behavior in a package in the registry.How can we help?I'm reporting spam, abuse or a security issueMy Security IssueI am reporting malware in a package on npmjs.comAsterisk (*) Indicates Required Field Name *Email *Subject *Package *Version *How can we help? *Verify you are a humanSubmitnpm command-lineIf you're having trouble using the npm command-line interface, or you need help with a project that you’re working on, we recommend that you check out the Software Development board of the GitHub Community forums.Giving FeedbackIf you have suggestions for how we can improve npm please open a discussion in our feedback forum.Press RelationsPress inquiries should be addressed to  press@npmjs.comPress inquiries should be addressed to press@npmjs.com\n\nContact UsGet help with the npm registry or your npm account.Please contact us if you need help with the npm registry or with your npm account, if you are reporting security concerns in an npm product, or if you need to report malicious or abusive behavior in a package in the registry.How can we help?I'm reporting spam, abuse or a security issueMy Security IssueI am reporting malware in a package on npmjs.comAsterisk (*) Indicates Required Field Name *Email *Subject *Package *Version *How can we help? *Verify you are a humanSubmitnpm command-lineIf you're having trouble using the npm command-line interface, or you need help with a project that you’re working on, we recommend that you check out the Software Development board of the GitHub Community forums.Giving FeedbackIf you have suggestions for how we can improve npm please open a discussion in our feedback forum.Press RelationsPress inquiries should be addressed to  press@npmjs.comPress inquiries should be addressed to press@npmjs.com\n\n\n\nContact UsYou need to be signed in to get help with npm.Sign in for assistanceCan't sign in, or don't have an account?Choose one of these categories to continue.Account or billing issuesCopyright or trademark data removalDispute a package, org, or usernameReport a security issue or abusenpm command-lineIf you're having trouble using the npm command-line interface, or you need help with a project that you’re working on, we recommend that you check out the Software Development board of the GitHub Community forums.Giving FeedbackIf you have suggestions for how we can improve npm please open a discussion in our feedback forum.Press RelationsPress inquiries should be addressed to  press@npmjs.comPress inquiries should be addressed to press@npmjs.com\n\nContact UsYou need to be signed in to get help with npm.Sign in for assistanceCan't sign in, or don't have an account?Choose one of these categories to continue.Account or billing issuesCopyright or trademark data removalDispute a package, org, or usernameReport a security issue or abusenpm command-lineIf you're having trouble using the npm command-line interface, or you need help with a project that you’re working on, we recommend that you check out the Software Development board of the GitHub Community forums.Giving FeedbackIf you have suggestions for how we can improve npm please open a discussion in our feedback forum.Press RelationsPress inquiries should be addressed to  press@npmjs.comPress inquiries should be addressed to press@npmjs.com\n\n\n\nAbout npm
      
        npm, Inc. is a company founded in 2014, and was acquired by GitHub in 2020. npm is a critical part of the
        JavaScript community and helps support one of the largest developer ecosystems in the world.
      
      npm is lots of things.
      
        
          
            npm is the package manager for Node.js. It was created in
            2009 as an open source project  to help JavaScript
            developers easily share packaged modules of code.
          
        
        
          
            The npm Registry is a public collection of packages of open-source code for Node.js, front-end web apps,
            mobile apps, robots, routers, and countless other needs of the JavaScript community.
          
        
        
          
            npm is the command line client that allows developers to install and publish those packages.\n\nAbout npm
      
        npm, Inc. is a company founded in 2014, and was acquired by GitHub in 2020. npm is a critical part of the
        JavaScript community and helps support one of the largest developer ecosystems in the world.
      
      npm is lots of things.
      
        
          
            npm is the package manager for Node.js. It was created in
            2009 as an open source project  to help JavaScript
            developers easily share packaged modules of code.
          
        
        
          
            The npm Registry is a public collection of packages of open-source code for Node.js, front-end web apps,
            mobile apps, robots, routers, and countless other needs of the JavaScript community.
          
        
        
          
            npm is the command line client that allows developers to install and publish those packages.\n\n\n\nAbout
      Press
  



    
    
    
    

    Press

    


  
    
  
    

    
        Founded in February, 2008
    
  

  
    

    
      HQ in San Francisco
    
  

  
    

    
      Product updates
    
  

  
    

    
      GitHub glossary
    
  

  
    

    
      Media resources
    
  

  
    

    
       press@github.com
     
  


  

  
      
  
    
      ZDNet Korea
      [현장] 깃허브 "코파일럿, 개발 패러다임 바꿔…ROI 달성 가능"
    
    Mar 26, 2025


      
  
    
      Practical AI Podcast
      AI-assisted coding with GitHub's COO
    
    Mar 21, 2025


      
  
    
      No Priors 
      Episode 106: GitHub CEO Thomas Dohmke
    
    Mar 13, 2025


      
  
    
      The Guardian
      How ‘AI agents’ will change the internet 
    
    Mar 9, 2025


      
  
    
      WirtschaftsWoche
      Ein Büro? Gibt’s bei uns nicht
    
    Mar 4, 2025


      
  
    
      Wall Street Journal
      How AI Tools Are Reshaping the Coding Workforce
    
    Mar 4, 2025


      
  
    
      TI Inside
      Exposição total: uma abordagem prática para lidar com vazamentos de dados sensíveis
    
    Mar 3, 2025


      
  
    
      The New York Times 
      A.I. is Prompting an Evolution, Not Extinction, for Coders 
    
    Feb 20, 2025


      
  
    
      itforum
      Boticário inova com uso do GitHub Copilot, gera menos tarefas repetitivas e foca em valor ao negócio
    
    Feb 19, 2025


      
  
    
      IT Forum
      Boticário inova com uso do GitHub Copilot, gera menos tarefas repetitivas e foca em valor ao negócio
    
    Feb 19, 2025


      
  
    
      Infosecurity Magazine
      Full Exposure: A Practical Approach to Handling Sensitive Data Leaks
    
    Feb 7, 2025


      
  
    
      TechCrunch
      GitHub Copilot brings mockups to life by generating code from images
    
    Feb 6, 2025


      
  
    
      Forbes
      GitHub code now has ‘data residency’ in Australia
    
    Feb 5, 2025


      
  
    
      Accessibility and GenAI 
      Ep 5 - Ed Summers - Head of Accessibility, GitHub
    
    Feb 4, 2025


      
  
    
      FAZ
      DLD: Technologien und Talente prägen den Arbeitsmarkt im KI-Zeitalter
    
    Jan 22, 2025


      
  
    
      Financial Express
      ‘Where developers reside, innovation blooms’
    
    Jan 20, 2025


      
  
    
      Inforchannel
      GitHub anuncia três tendências de desenvolvimento de software para 2025
    
    Jan 17, 2025


      
  
    
      Help Net Security 
      GitHub CISO on security strategy and collaborating with the open source community
    
    Jan 13, 2025


  

    
      
        Previous 1 2 3 4 5 … 58 59 Next\n\n\n\nPoliciesThese are the legal policies of npm, Inc.
Terms of UseOpen Source TermsPrivate TermsCode of ConductPackage Name Disputesnpm LicensePrivacy PolicyUnpublish PolicyCopyright and DMCA PolicyLogos and UsageSecurityReplication and web crawler policy
These are updated from time to time. Their sources are stored in a git repository at https://github.com/npm/documentation/tree/main/content/policies.\n\n\n\nPoliciesTerms of UseTerms and LicensesSee DetailsTable of contentsSoftware from npmFree to use npm servicesPaid npm servicesnpm, Inc. offers software and services under a few different licenses and terms of use.
Software from npm
License terms and notices for the npm command-line program can be found in the LICENSE file of the project's source code at https://www.github.com/npm/cli.
Free to use npm services
Free usage of https://www.npmjs.com, and the npm public registry are covered by the npm Open Source Terms at https://docs.npmjs.com/policies/open-source-terms. These terms include several important policies, including:


What npm considers acceptable package content.


npm's Code of Conduct, which includes our policy on harassment.


npm's Privacy Policy, which limits use and sharing of information about you collected by npm Services.


npm's policy on copyright including how to report violations thereof.


npm's Dispute Policy which addresses how to resolve disputes over the control of a package name, user name, or organization name in the Public Registry. This includes our policy on users "squatting" on these names.


Use of npm's trademarks is governed by our Trademark Policy. If you have concerns about your own trademark's use on npm please see our Disputes Policy.


Paid npm services
npm's paid products, including the npm Solo and Orgs plans, are covered by the npm Paid Services Terms at https://docs.npmjs.com/policies/private-terms.
The npm Solo Payment Plan and the npm Orgs Payment Plan govern payment for these services.\n\n\n\nPoliciesCode of Conductnpm Code of ConductSee DetailsTable of contentstl;drScopeFriendly Harassment-Free SpaceAcceptable UseReporting Violations of this Code of ConductConsequencesAppeal and ReinstatementContact InfoChangesCredit and Licensenpm exists to facilitate sharing code, by making it easy for JavaScript module developers to publish and distribute packages.
npm is a piece of technology, but more importantly, it is a community.
We believe that our mission is best served in an environment that is friendly, safe, and accepting; free from intimidation or harassment.
Towards this end, certain behaviors and practices will not be tolerated.
tl;dr

Be respectful.
We're here to help
Abusive behavior is never tolerated.
Data published to npm is hosted at the discretion of the service administrators, and may be removed.
Violations of this code may result in swift and permanent expulsion from the npm community.

Scope
We expect all members of the npm community, including paid and unpaid agents, administrators, users, and customers of npm, Inc., to abide by this Code of Conduct at all times in all npm community venues, online and in person, and in one-on-one communications pertaining to npm affairs.
This policy covers the usage of the npm registry, as well as the npm website, npm related events, and any other services offered by or on behalf of npm, Inc. (collectively, the "Service"). It also applies to behavior in the context of the npm Open Source project communities, including but not limited to public GitHub repositories, IRC channels, social media, mailing lists, and public events.
This Code of Conduct is in addition to, and does not in any way nullify or invalidate, any other terms or conditions related to use of the Service.
The definitions of various subjective terms such as "discriminatory", "hateful", or "confusing" will be decided at the sole discretion of the npm abuse team.
Friendly Harassment-Free Space
We are committed to providing a friendly, safe and welcoming environment for all, regardless of gender identity, sexual orientation, ability, ethnicity, religion, age, physical appearance, body size, race, or similar personal characteristics.
We ask that you please respect that people have differences of opinion regarding technical choices, and that every design or implementation choice carries a trade-off and numerous costs. There is seldom a single right answer. A difference of technology preferences is not a license to be rude.
Disputes over package rights must be handled respectfully, according to the terms described in the Disputes Policy. There is never a good reason to be rude over package name disputes.
Any spamming, trolling, flaming, baiting, or other attention-stealing behavior is not welcome, and will not be tolerated.
Harassing other users of the Service is never tolerated, whether via public or private media.
Avoid using offensive or harassing package names, nicknames, or other identifiers that might detract from a friendly, safe, and welcoming environment for all.
Harassment includes, but is not limited to: harmful or prejudicial verbal or written comments related to gender identity, sexual orientation, ability, ethnicity, religion, age, physical appearance, body size, race, or similar personal characteristics; inappropriate use of nudity, sexual images, and/or sexually explicit language in public spaces; threats of physical or non-physical harm; deliberate intimidation, stalking or following; harassing photography or recording; sustained disruption of talks or other events; inappropriate physical contact; and unwelcome sexual attention.
Acceptable Use
The Service administrators reserve the right to make judgment calls about what is and isn't appropriate in published packages, package names, user and organization names, and other public content. Package that violates the npm Service's Acceptable Use rules including its Acceptable Content rules will be deleted, at the discretion of npm.
Reporting Violations of this Code of Conduct
Please select the method of contact you think is most appropriate for the form of violation:


For urgent security issues, please open a ticket at https://npmjs.com/support. Requests to un-publish packages are not usually considered urgent security issues, as it is possible to un-publish a package within 24 hours of its first publish. Any publicly published package is immediately replicated to thousands of third-party mirrors, so any confidential information contained in a package should be considered immediately compromised.


If you believe someone is harassing you or is demonstrating some other form of malicious or inappropriate behavior, open a support ticket at https://npmjs.com/support. If this is the initial report of a problem, please include as much detail as possible. It is easiest for us to address issues when we have more context.


If you have concerns about a potential copyright violation, please refer to our Copyright Policy and take action as recommended by that policy.


If you think a package or other content is "squatting" on a name, follow the process described in the Disputes Policy.


For any other issues, or if in doubt, contact support.
Consequences
All content published to the Service, including user account credentials, is hosted at the sole discretion of the npm administrators.
Unacceptable behavior from any community member, including sponsors, employees, customers, or others with decision-making authority, will not be tolerated.
Anyone asked to stop unacceptable behavior is expected to comply immediately.
If a community member engages in unacceptable behavior, the npm administrators may take any action they deem appropriate, up to and including a temporary ban or permanent expulsion from the community without warning (and without refund in the case of a paid event or service).
Appeal and Reinstatement
If your content or account has been disabled or restricted and you seek reinstatement or wish to appeal, please review GitHub's Appeal and Reinstatement page for information about the process and use the Appeal and Reinstatement form to submit a request.
Contact Info
Please open a support ticket at https://npmjs.com/support if you need to report a problem or address a grievance related to an abuse report.
You are also encouraged to contact us if you are curious about something that might be "on the line" between appropriate and inappropriate content. We are happy to provide guidance to help you be a successful part of our community.
Changes
This is a living document and may be updated from time to time. Please refer to the git history for this document to view the changes.
Credit and License
This Code of Conduct borrows heavily from the Stumptown Syndicate Citizen's Code of Conduct, and the Rust Project Code of Conduct.
This document may be reused under a Creative Commons Attribution-ShareAlike License.\n\n\n\nPoliciesPrivacy PolicyPrivacy Questions and AnswersSee DetailsTable of contentsWhat's most important?How does npm collect data about me?What data does npm collect about me, and why?npm collects data about how you use npm software and registriesnpm collects data about how you use the websitenpm collects account datanpm collects package datanpm collects payment card datanpm collects data about correspondencenpm collects data about use of npm.communityDoes npm share data about me with others?npm uses cookiesHow can I make choices about data collection?Where does npm keep data about me?How does npm handle data under the EU General Data Protection Regulation?How does npm handle data under the California Consumer Privacy Act?How can I see what data is publicly available about me?How can I change data about me?What is npm's policy on unpublishing packages?How does npm notify others about published data that's erased?What happens if npm merges with or is bought by another company?What are npm's information practices regarding information belonging to children?Who can I contact about npm and my privacy?How can I find out about changes?This notice describes how npm, Inc., or npm for short, collects and uses data about you.
What's most important?
That depends on your personal situation, which is why you should read on and decide for yourself. But at a minimum, absolutely every npm user should understand:
The npm public registry is for making software available to everyone online.
But: Software comes from people, and says something about us.
So: Think carefully about what packages to publish, what data you put in those packages, and what others might do with that data.
When you create an account, certain contact information is displayed publicly in the npm platform. And when you upload a package, your name and contact information may become associated with that package.
If you find yourself in a jam, open a support ticket.
How does npm collect data about me?
npm collects data about you:


when you use the npm command, the npx command or another program to access the npm public registry, Enterprise registries that npm hosts, private packages, such as when you're publishing a software package, and APIs for functionality like account and permissions management


when you browse the npm website, npmjs.com


when you use either the npm command or the website to create an npm account, update your account, and sign up for npm services


when you send support, privacy, legal, and other requests to npm


when working with and researching current and potential customers


When researching potential customers, npm staff sometimes search the public World Wide Web or paid business databases. Otherwise, npm doesn't buy or receive data about you from data brokers or other private services.
npm may inadvertently collect data about you if it is included in software packages that you or others upload.
What data does npm collect about me, and why?
npm collects data about how you use npm software and registries
When you use the npm command, the npx command, or other software to work with the npm public registry, an Enterprise registry that npm hosts, or private packages, npm logs data that might be identified to you:


a random, unique identifier, called npm-session, for each time you run commands like npm install


the names and versions of your project's dependencies, their dependencies, and so on, that come from the npm public registry, but not of other dependencies, like Git dependencies


the versions of Node.js, the npm command, and the operating system you are using


an npm-in-ci header, showing whether the command was run on a continuous integration server


the scope of the package for which you ran npm install, as an npm-scope header


a referrer header that shows the command you ran, with any file or directory paths redacted


data about the software you're using to access the registry, such as the User-Agent string


network request data, such as the date and time, your IP address, and the URL


npm uses this data to:


fulfill your requests, such as by sending the packages you ask for


send you alerts about security vulnerabilities that may affect the software you're building, when you run npm install or npm audit


keep registries working quickly and reliably


debug and develop the npm command and other software


defend registries from abuse and technical attacks


compile statistics on package usage and popularity


prepare reports on trends in the developer community


improve search results on the website


recommend packages that may be relevant to your work


npm collects data about how you use the website
When you visit www.npmjs.com, docs.npmjs.com, and other npm websites, npm uses cookies, server logs, and other methods to collect data about what pages you visit, and when. npm also collects technical information about the software and computer you use, such as:


your IP address


your preferred language


the web browser software you use


the kind of computer you use


the website that referred you


npm uses data about how you use the website to:


optimize the website, so that it's quick and easy to use


diagnose and debug technical errors


defend the website from abuse and technical attacks


compile statistics on package popularity


compile statistics on the kinds of software and computers visitors use


compile statistics on visitor searches and needs, to guide development of new website pages and functionality


decide who to contact about about product announcements, service changes, and new features


npm collects account data
Many features of npm services require an npm account. For example, you must have an npm account to publish packages to the npm public registry.
To create an npm account, npm requires a working email address and an available user name. npm uses this data to provide you access to features and identify you across npm services, publicly and within npm.
You do not have to give your personal or legal name to create an npm account. You can use a pseudonym instead. You can also open more than one account.
If you sign up for an account, then npm will publish account data for the whole world to see on user pages like this one. npm also publishes account data through the npm public registry, which is available for everyone to see, and Enterprise registries that npm hosts for others to find with commands like npm owner ls tap.
If you give npm a personal name or names on social media like GitHub and Twitter through the website, like when you include this on your profile or user page, npm publishes that data along with the email address and user name for the account. You don't have to give npm a personal name or any social media names, and you can remove this data at any time by updating your user page.
npm uses your email to:


notify you about packages published using your account


reset your password and help keep your account secure


add metadata to packages that you publish


contact you in special circumstances related to your account or packages


contact you about support requests


contact you about legal requests, like DMCA takedown requests and privacy complaints


announce new npm product offerings, service changes, and features


send you tips about how to better use free and paid services


send you messages about paid services you might want


npm collects package data
When you use npm publish or other software to publish packages to the npm public registry, an Enterprise registry that npm hosts, or as a private package, npm collects the contents of the package, plus metadata, including your account data. Other npm users may also publish packages that include data about you, such as the fact that you contributed code to a package.
npm uses data in packages to provide those packages to you and others who request them:


When you publish a package to the npm public registry, or change a package from private to public, npm makes the package and metadata available to everyone, online.


When you publish a package to an Enterprise registry that npm hosts, or as a private package, npm makes all of that data available to other users according to how the registry or the private packages account is configured. You may be able to configure who can access the package, or that may be up to others, such as the administrator of your company's Enterprise registry.


Making package data available to others allows them to download, build on, and depend on your work.
npm collects payment card data
To sign up for paid services, npm requires your payment card data. npm itself does not collect or store enough information to charge your card itself. Rather, Stripe collects that data on npm's behalf, and gives npm security tokens that allow npm to create charges and subscriptions.
npm uses your payment card data only to charge for npm services.
npm instructs Stripe to store your payment card data only as long as you use paid npm services.
npm collects data about correspondence
npm collects data about you when you send npm support requests, legal complaints, privacy inquiries, and business inquiries. Those data usually include your name and email address, and may include your company or other affiliation.
npm uses contact data to:


respond to you


compile aggregate statistics about correspondence


train support staff and other npm personnel


review the performance of npm personnel who respond


defend npm from legal claims


npm collects data about use of npm.community
npm collects data about visits, user accounts, and forum data on npm.community, the discussion forum for users of npm products and services. npm uses data from npm.community to collaborate with the development community, and to inform development decisions about the command-line interface and other software.
Does npm share data about me with others?
npm shares account data with others as mentioned in the section about account data.
npm shares package data with others as mentioned in the section about package data.
npm publishes posts and other content you submit to npm.community.
npm does not sell information about you to others. However, npm uses services provided by other companies to provide npm services. The types of service providers that npm uses include:


Companies that enable us to offer features on our website, such as to display your avatar


Companies that facilitate the efficient distribution of content


Cloud computing platforms and services that host our discussion forums


Services that assist with the detection of spam, scams, abuse others, or other violations of our terms of service


Payment processors


Platforms to help us receive, manage, and respond to support requests


Platforms for internal communication


npm uses cookies
npm's website only uses cookies strictly necessary to provide, optimize and secure the website. For example, we use them to keep you logged in, remember your preferences, authenticate your device for security purposes, analyze your use of the service, compile statistical reports, and provide information for future development of npm. The website uses internal cookies for analytics purposes, not any third-party analytics or service providers.
By using the website, you agree that we can place these types of cookies on your computer or device. If you disable your browser or device’s ability to accept these cookies, you will not be able to log in or use the website.
How can I make choices about data collection?
You choose what data the npm publish command includes in package data. You can use an .npmignore file in your package to keep specific files out of the package. You can also use a files list in package.json files to instruct npm to include only specific files that you name, in addition to standard files like README files, LICENSE files, and package.json.
To double check the data that you will share in a package that you plan to publish, run the npm publish --dry-run command. If you are running an older version of the npm command, run the npm pack command to create a tarball, then check its contents, such as with tar tvzf $tarball.
To publish a package to the npm public registry, npm's terms of service require you to license npm to share it. If a package is made public, it is available for everyone online to see. However, your choice of public license for your package may affect what others can do with data about you in your package.
npm does not respond to the Do Not Track HTTP header.
Where does npm keep data about me?
npm stores account data, data about website use, data about registry use, and private packages on servers in the United States of America. metadata about those packages worldwide, via content delivery networks.
npm stores package data published to Enterprise registries that npm hosts, plus metadata about them, in cloud computing zones of customers' choosing.
By using the npm platform, you consent to the collection and storage of your data as outlined in this section.
How does npm handle data under the EU General Data Protection Regulation?
npm respects privacy rights under Regulation (EU) 2016/679, the European Union's General Data Protection Regulation (GDPR). npm processes "Personal Data" on the following legal bases: (1) with your consent; (2) as necessary to perform our agreement to provide our services; and (3) as necessary for our legitimate interests in providing our services where those interests do not override your fundamental rights and freedom related to data privacy. Information we collect may be transferred to, and stored and processed in, the United States or any other country in which we or our affiliates or subcontractors maintain facilities, as described above.
If you reside in the EEA, Switzerland, or United Kingdom, you are entitled to certain rights, like the right to:


complain about our data collection or processing actions with the supervisor authority concerned. You can find a list of data protection authorities here.


access to information held about you.


ask us to correct or amend inaccurate or incomplete information we have about you.


ask us to erase data that under certain circumstances, like (1) when it is no longer necessary for the purpose for which it was collected, (2) you withdraw consent and no other legal basis for processing exists, or (3) you believe your fundamental rights to data privacy and protection outweigh our legitimate interest in continuing the processing.


request that we restrict our processing if we are processing your data based on legitimate interests or the performance of a task in the public interest as an exercise of official authority (including profiling); using your data for direct marketing (including profiling); or processing your data for purposes of scientific or historical research and statistics.


When you exercise your rights, npm may need to verify your identity and provide us with information before we access records containing your information. If you want to exercise your rights, please contact npm by opening a support ticket. We may have a reason under the law why we do not have to comply with your request or may comply with it in a more limited way than you anticipated. If we do, we will explain that to you in our response.
How does npm handle data under the California Consumer Privacy Act?
npm respects the rights of California residents under the California Consumer Privacy Act (CCPA). Where we collect information that is subject to the CCPA, that information we collect and your rights are described below.
Categories of personal information we collect:


Personal Identifiers:


Name and email address when you create an account. You will also be asked to create a username and we will assign one or more unique identifiers to your profile. We use this information to provide our services, respond to your requests, and send information to you.


We also collect your social media handle and basic account information if you provide it to us or interact with our services, such as our help desk, through social media.


We collect your payment information through our service provider, Stripe, as described above.




Internet or Other Electronic Network Activity Information: device identifiers such as IP address and user agent; the assigned unique IDs in cookies (as described below); information about how you arrived at and navigated through our Services.


Geolocation Data: We do not collect your specific longitude and latitude. However, we do collect imprecise location (e.g., your IP address).


Professional or employment-related information: If you apply for employment with us, information about your employment history.


Education information: If you apply for employment with us, information about your educational history.


We may collect any other information about you contained in software packages uploaded to our site, as described above under the "npm collects package data" section. We also collect the contents of your communications with us, e.g., when you submit a question to us through a web form or comments to us on social media.
We may disclose any of the categories of personal information listed above and use them for the above-listed purposes or for other business or operational purposes compatible with the context in which the personal information was collected. Our disclosures of personal information include disclosures to our "service providers," which are companies that we engage for business purposes to conduct activities on our behalf. The categories of service providers with whom we share information and the services they provide are described below.
Rights under CCPA:


Access/Right to Know: You have the right to request access to personal information we collected about you and information regarding the source of that personal information, the purposes for which we collect it, and the third parties and service providers with whom we share it.


Deletion: You have the right to request that we erase data we have collected from you. Please note that we may have a reason to deny your deletion request or delete data in a more limited way than you anticipated, e.g., because of a legal obligation to retain it.


To exercise your rights above, you can open a support ticket. When we process your request, we must verify your identity by asking you to (1) provide personal identifiers that we can match against information we may have collected from you previously; and (2) confirm your request using the email stated in the request.
Opt-out of sale:
California residents have the right to request that we stop "selling" their personal information. A "sale" of personal information is defined broadly: "selling, renting, releasing, disclosing, disseminating, making available, transferring, or otherwise communicating orally, in writing, or by electronic or other means, a consumer's personal information by the business to another business or a third party for monetary or other valuable consideration." We do not sell your information as defined by the CCPA.
Please note that your right to opt out does not apply to our sharing of personal information with service providers, who are parties we engage to perform a function on our behalf and are contractually obligated to use the Personal Information only for that function.
We may also disclose information to other entities who are not listed here when required by law or to protect our Company or other persons, as described in our Privacy Policy.
How can I see what data is publicly available about me?
You can access your account data at any time by visiting your account page on www.npmjs.com. Your account page also lists all the packages published under your account or other accounts.
You can access package data by downloading the packages, as long as they're public or you have permission to access them.
You can see metadata about packages by running npm info $package, or by accessing the appropriate registry's API. Registry APIs provide metadata in standard JSON format, and packages as tarballs.
How can I change data about me?
You can change your personal account data and payment card data at any time by visiting your account settings page on www.npmjs.com. You can change account and payment data for Enterprise by contacting support.
You can close your npm account at any time by e-mailing contacting support. Closing your account removes the profile from the public registry but does not automatically erase packages published under your account. We may retain some data about you internally even where you close your account.
npm's unpublish policy determines when you can erase packages from the npm public registry. The unpublish policy strikes a difficult balance between the purpose of publishing and hosting packages, others' reliance on what has been made public, and individual rights and freedoms.
If another user improperly publishes personal data about you, in a package or otherwise, open a support ticket.
Please note that while npm publishes notices about published data that's been erased, npm can't make everyone who has downloaded published package data or account data erase that data on your behalf. Choosing a public license, such as an open source software license, may encourage and allow storage, distribution, and use of package data indefinitely. Nearly all popular open source software licenses actually require preserving personal data that attributes the software to you, such as copyright notices, as a condition of permission for the software.
What is npm's policy on unpublishing packages?
Please see our policy on "unpublishing" packages or our terms of service for more information on erasing packages.
If you accidentally publish a package that threatens your privacy, or discover someone else has published a package that does, open a support ticket. npm can and will take down packages in specific, exceptional situations to protect you, especially if others violate your privacy. Using npm to violate others' privacy is against our terms of service.
How does npm notify others about published data that's erased?
npm takes a few steps to notify others who may be copying data from the npm public registry that published data has been erased:


npm publishes new placeholder versions of some erased packages, with README files that mention the package has been erased, and why.


npm's registry APIs, special software services that others use to copy data from the npm public registry, send update messages about packages that have been erased.


What happens if npm merges with or is bought by another company?
We may transfer to another entity or its affiliates or service providers some or all information about you in connection with, or during negotiations of, any merger, acquisition, sale of assets or any line of business, change in ownership control, or financing transaction. We cannot promise that an acquiring party or the merged entity will have the same privacy practices or treat your information the same as described in this Policy.
What are npm's information practices regarding information belonging to children?
npm's site and services are intended for users age sixteen and older. npm does not knowingly collect information from children. If we discover that we have inadvertently collected information from anyone younger than the age of 16, we will delete that information.
Who can I contact about npm and my privacy?
Please open a support ticket. You may also contact our Data Protection Officer directly.
Our United States HQ:
GitHub Data Protection Officer
Attention: npm Data Protection
88 Colin P. Kelly Jr. St.
San Francisco, CA 94107
United States
or our EU Office:
GitHub BV
Vijzelstraat 68-72
1017 HL Amsterdam
The Netherlands
How can I find out about changes?
This version of npm's privacy questions and answers took effect June 3, 2020.
npm will announce the next version on the npm blog. In the meantime, npm may update its contact information by updating the page at https://docs.npmjs.com/privacy, without an announcement. npm may change how it announces changes in future privacy versions.
You can review the history of changes in the Git repository for npm's public policies.\n\n\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\n\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\n\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\n\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\nnpm Pro
        
          Publish your own packages to the world's most popular software ecosystem
        
        
          Get started
        
        
          
            
          
          Unlimited public packages
          Bring the best of open source JavaScript development to your own projects.
        
        
          
            
          
          Unlimited private packages
          Seamlessly integrate public and private packages into your development cycle.
        
        
          
            
          
          Package-based permissions
          Add collaborators to work on your public and private packages together.
        
      
    
  
  
    
      
        
      
      Working on a team?
      Try npm Teams.
      Team-based access controls to manage package permissions across your organization.
       Learn about Teams 
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      Get Started
      
        
        
          1
          Create an account
          
            If you don't have one yet,
             create a free npm account 
          
        
      
      
        
        
          2
          Upgrade your account
          
            Log into your account and
             upgrade your plan\n\n\n\nSign InUsernameForgot password?PasswordShowSign InCreate Account\n\nSign InUsernameForgot password?PasswordShowSign InCreate Account\n\n\n\nnpm Teams
      
        Share code and collaborate with the tools that make JavaScript the world's best software ecosystem
      
      
        Get started
      
    
  
  
    
      
        
          
        
        Unlimited public packages
        Bring the best of open source JavaScript development to your own projects.
      
      
        
          
        
        Unlimited private packages
        Seamlessly integrate public and private packages into your development cycle.
      
      
        
          
        
        Package-based permissions
        Add collaborators to work on your public and private packages together.
      
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      
        Get Started\n\nnpm Teams
      
        Share code and collaborate with the tools that make JavaScript the world's best software ecosystem
      
      
        Get started
      
    
  
  
    
      
        
          
        
        Unlimited public packages
        Bring the best of open source JavaScript development to your own projects.
      
      
        
          
        
        Unlimited private packages
        Seamlessly integrate public and private packages into your development cycle.
      
      
        
          
        
        Package-based permissions
        Add collaborators to work on your public and private packages together.
      
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      
        Get Started\n\nnpm Teams
      
        Share code and collaborate with the tools that make JavaScript the world's best software ecosystem
      
      
        Get started
      
    
  
  
    
      
        
          
        
        Unlimited public packages
        Bring the best of open source JavaScript development to your own projects.
      
      
        
          
        
        Unlimited private packages
        Seamlessly integrate public and private packages into your development cycle.
      
      
        
          
        
        Package-based permissions
        Add collaborators to work on your public and private packages together.
      
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      
        Get Started\n\n\n\nnpm Teams
      
        Share code and collaborate with the tools that make JavaScript the world's best software ecosystem
      
      
        Get started
      
    
  
  
    
      
        
          
        
        Unlimited public packages
        Bring the best of open source JavaScript development to your own projects.
      
      
        
          
        
        Unlimited private packages
        Seamlessly integrate public and private packages into your development cycle.
      
      
        
          
        
        Package-based permissions
        Add collaborators to work on your public and private packages together.
      
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      
        Get Started\n\nnpm Teams
      
        Share code and collaborate with the tools that make JavaScript the world's best software ecosystem
      
      
        Get started
      
    
  
  
    
      
        
          
        
        Unlimited public packages
        Bring the best of open source JavaScript development to your own projects.
      
      
        
          
        
        Unlimited private packages
        Seamlessly integrate public and private packages into your development cycle.
      
      
        
          
        
        Package-based permissions
        Add collaborators to work on your public and private packages together.
      
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      
        Get Started\n\nnpm Teams
      
        Share code and collaborate with the tools that make JavaScript the world's best software ecosystem
      
      
        Get started
      
    
  
  
    
      
        
          
        
        Unlimited public packages
        Bring the best of open source JavaScript development to your own projects.
      
      
        
          
        
        Unlimited private packages
        Seamlessly integrate public and private packages into your development cycle.
      
      
        
          
        
        Package-based permissions
        Add collaborators to work on your public and private packages together.
      
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      
        Get Started\n\n\n\nnpm Teams
      
        Share code and collaborate with the tools that make JavaScript the world's best software ecosystem
      
      
        Get started
      
    
  
  
    
      
        
          
        
        Unlimited public packages
        Bring the best of open source JavaScript development to your own projects.
      
      
        
          
        
        Unlimited private packages
        Seamlessly integrate public and private packages into your development cycle.
      
      
        
          
        
        Package-based permissions
        Add collaborators to work on your public and private packages together.
      
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      
        Get Started\n\nnpm Teams
      
        Share code and collaborate with the tools that make JavaScript the world's best software ecosystem
      
      
        Get started
      
    
  
  
    
      
        
          
        
        Unlimited public packages
        Bring the best of open source JavaScript development to your own projects.
      
      
        
          
        
        Unlimited private packages
        Seamlessly integrate public and private packages into your development cycle.
      
      
        
          
        
        Package-based permissions
        Add collaborators to work on your public and private packages together.
      
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      
        Get Started\n\nnpm Teams
      
        Share code and collaborate with the tools that make JavaScript the world's best software ecosystem
      
      
        Get started
      
    
  
  
    
      
        
          
        
        Unlimited public packages
        Bring the best of open source JavaScript development to your own projects.
      
      
        
          
        
        Unlimited private packages
        Seamlessly integrate public and private packages into your development cycle.
      
      
        
          
        
        Package-based permissions
        Add collaborators to work on your public and private packages together.
      
    
  
  
    
      
        
        
          Feature Comparison
        
        
          
            Unlimited public packages &
            automatic security warnings
          
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited private packages
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
          Unlimited team-based management
          
            
              Free
              
                
              
            
            
              Pro
              
                
              
            
            
              Teams
              
                
              
            
          
        
        
      
       All versions include basic support 
    
  
  
    
      
        Get Started\n\n\n\nSign InUsernameForgot password?PasswordShowSign InCreate Account\n\nSign InUsernameForgot password?PasswordShowSign InCreate Account\n\n\n\n