commit ab376d3d1ab0a2ef5675246cfb008367cc94330e
Author: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>
Date:   Fri Feb 21 17:47:59 2025 +0000

    Fixed interactive input splitting to use semicolon as delimiter and updated README instructions for consistency. (fixes #216) (#217)
    
    Co-authored-by: GitHub Actions[bot] <action@github.com>

diff --git a/src/lib/main.js b/src/lib/main.js
index a6f3daf..0563ae9 100755
--- a/src/lib/main.js
+++ b/src/lib/main.js
@@ -1210,8 +1210,8 @@ Formula String Formats:
   // Interactive CLI mode support
   if (args.includes("--interactive")) {
     const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
-    rl.question("Enter formula strings (comma-separated): ", (answer) => {
-      const interactiveFormulas = answer.split(",").map(s => s.trim()).filter(Boolean);
+    rl.question("Enter formula strings (semicolon-separated): ", (answer) => {
+      const interactiveFormulas = answer.split(";").map(s => s.trim()).filter(Boolean);
       // Remove the interactive flag for further processing
       const filteredArgs = args.filter(arg => arg !== "--interactive");
       // Use interactive formulas if provided, otherwise fall back to default

commit 299835b13b6f5efd3b3b6f4ba7f905dba262c98d
Author: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>
Date:   Fri Feb 21 16:23:31 2025 +0000

    Added interactive CLI mode support for real-time user input and updated tests and documentation accordingly. (fixes #213) (#215)
    
    Co-authored-by: GitHub Actions[bot] <action@github.com>

diff --git a/src/lib/main.js b/src/lib/main.js
index 184b394..a6f3daf 100755
--- a/src/lib/main.js
+++ b/src/lib/main.js
@@ -5,6 +5,7 @@
 
 import { fileURLToPath } from "url";
 import fs from "fs";
+import readline from "readline";
 
 // Custom range function to generate a sequence of numbers
 const range = (start, end, step = 1) => {
@@ -1183,13 +1184,16 @@ Options:
   --json             Generate output as JSON instead of SVG
   --csv              Generate output as CSV instead of SVG
   --ascii            Generate output as ASCII art instead of SVG
+  --md               Generate output as Markdown instead of SVG
+  --html             Generate output as HTML
   --grid             Overlay grid lines on SVG plots
   --debug            Output internal parsed plot data for debugging
   --dealers-choice   Use randomized color palette for SVG plots
+  --interactive      Enable interactive CLI mode for real-time user input
   --demo             Run demo test output
   --version          Show version information
-  (output file extension .html will generate HTML output,
-   .md for Markdown output, .txt or .ascii for ASCII output)
+(output file extension .html will generate HTML output,
+ .md for Markdown output, .txt or .ascii for ASCII output)
 
 Formula String Formats:
   Quadratic: "quad:y=x^2+2*x+1" or "quadratic:y=x^2+2*x+1" or "x^2+y-1=0" (or with range e.g., "y=x^2+2*x+1:-10,10,1")
@@ -1203,10 +1207,82 @@ Formula String Formats:
     process.exit(0);
   }
 
-  // If --demo flag is provided, run the demo test and exit
-  if (args.includes("--demo")) {
-    demoTest();
-    process.exit(0);
+  // Interactive CLI mode support
+  if (args.includes("--interactive")) {
+    const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
+    rl.question("Enter formula strings (comma-separated): ", (answer) => {
+      const interactiveFormulas = answer.split(",").map(s => s.trim()).filter(Boolean);
+      // Remove the interactive flag for further processing
+      const filteredArgs = args.filter(arg => arg !== "--interactive");
+      // Use interactive formulas if provided, otherwise fall back to default
+      const formulasList = interactiveFormulas.length ? interactiveFormulas : [];
+
+      // Determine output options from remaining args
+      let outputFileName = "output.svg";
+      let isJson = filteredArgs.includes("--json");
+      let isCsv = filteredArgs.includes("--csv");
+      let isHtml = false;
+      let isAscii = filteredArgs.includes("--ascii");
+      let isMarkdown = filteredArgs.includes("--md");
+      const isDebug = filteredArgs.includes("--debug");
+      const gridEnabled = filteredArgs.includes("--grid");
+      const isDealersChoice = filteredArgs.includes("--dealers-choice");
+
+      const nonFormulaArgs = filteredArgs.filter(
+        (arg) =>
+          !arg.includes(":") &&
+          !arg.includes("=") &&
+          !["--json", "--csv", "--version", "--ascii", "--debug", "--grid", "--dealers-choice", "--interactive", "--md", "--html"].includes(arg)
+      );
+      if (nonFormulaArgs.length > 0) {
+        outputFileName = nonFormulaArgs[0];
+      }
+      if (outputFileName.toLowerCase().endsWith(".json")) {
+        isJson = true;
+      } else if (outputFileName.toLowerCase().endsWith(".csv")) {
+        isCsv = true;
+      } else if (outputFileName.toLowerCase().endsWith(".html")) {
+        isHtml = true;
+      } else if (outputFileName.toLowerCase().endsWith(".md")) {
+        isMarkdown = true;
+      } else if (outputFileName.toLowerCase().endsWith(".txt") || outputFileName.toLowerCase().endsWith(".ascii")) {
+        isAscii = true;
+      }
+
+      if (isDebug) {
+        console.log("\nDebug: Internal parsed plot data:");
+        console.log(JSON.stringify(getPlotsFromFormulas(formulasList), null, 2));
+      }
+
+      let fileContent = "";
+      if (isJson) {
+        fileContent = JSON.stringify(plotToJson({ formulas: formulasList }), null, 2);
+      } else if (isCsv) {
+        fileContent = plotToCsv({ formulas: formulasList });
+      } else if (isHtml) {
+        fileContent = plotToHtml({ formulas: formulasList, grid: gridEnabled, dealersChoice: isDealersChoice });
+      } else if (isMarkdown) {
+        fileContent = plotToMarkdown({ formulas: formulasList });
+      } else if (isAscii) {
+        fileContent = plotToAscii({ formulas: formulasList });
+      } else {
+        fileContent = plotToSvg({ formulas: formulasList, grid: gridEnabled, dealersChoice: isDealersChoice });
+      }
+
+      try {
+        fs.writeFileSync(outputFileName, fileContent, "utf8");
+        console.log(`\n${isJson ? "JSON" : isCsv ? "CSV" : isHtml ? "HTML" : isMarkdown ? "Markdown" : isAscii ? "ASCII" : "SVG"} file generated: ${outputFileName}`);
+      } catch (err) {
+        console.error(`Error writing file:`, err.message);
+        process.exit(1);
+      }
+
+      console.log("\nText Representation of Plots:");
+      console.log(plotToText({ formulas: formulasList }));
+      rl.close();
+      process.exit(0);
+    });
+    return;
   }
 
   let outputFileName = "output.svg";
@@ -1214,7 +1290,7 @@ Formula String Formats:
   let isCsv = args.includes("--csv");
   let isHtml = false;
   let isAscii = args.includes("--ascii");
-  let isMarkdown = false;
+  let isMarkdown = args.includes("--md");
   const isDebug = args.includes("--debug");
   const gridEnabled = args.includes("--grid");
   const isDealersChoice = args.includes("--dealers-choice");
@@ -1223,7 +1299,7 @@ Formula String Formats:
     (arg) =>
       !arg.includes(":") &&
       !arg.includes("=") &&
-      !["--json", "--csv", "--version", "--ascii", "--debug", "--grid", "--dealers-choice"].includes(arg),
+      !["--json", "--csv", "--version", "--ascii", "--debug", "--grid", "--dealers-choice", "--interactive", "--md", "--html"].includes(arg)
   );
   if (nonFormulaArgs.length > 0) {
     outputFileName = nonFormulaArgs[0];
@@ -1244,7 +1320,7 @@ Formula String Formats:
 
   if (formulasList.length === 0) {
     console.log(
-      "No formulas provided. Using default plot functions for quadratic, linear, sine, cosine, polar, exponential, and logarithmic plots.",
+      "No formulas provided. Using default plot functions for quadratic, linear, sine, cosine, polar, exponential, and logarithmic plots."
     );
   }
 
@@ -1271,7 +1347,7 @@ Formula String Formats:
   try {
     fs.writeFileSync(outputFileName, fileContent, "utf8");
     console.log(
-      `\n${isJson ? "JSON" : isCsv ? "CSV" : isHtml ? "HTML" : isMarkdown ? "Markdown" : isAscii ? "ASCII" : "SVG"} file generated: ${outputFileName}`,
+      `\n${isJson ? "JSON" : isCsv ? "CSV" : isHtml ? "HTML" : isMarkdown ? "Markdown" : isAscii ? "ASCII" : "SVG"} file generated: ${outputFileName}`
     );
   } catch (err) {
     console.error(`Error writing file:`, err.message);

commit a592171d8065ef4c8e688291aea5f1e48e8f3f25
Author: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>
Date:   Fri Feb 21 14:04:15 2025 +0000

    Updated README Next Up section with additional enhancements to attempt. (fixes #211) (#212)
    
    Co-authored-by: GitHub Actions[bot] <action@github.com>

diff --git a/src/lib/main.js b/src/lib/main.js
index 310afd1..184b394 100755
--- a/src/lib/main.js
+++ b/src/lib/main.js
@@ -571,7 +571,7 @@ const generateSvg = (
     });
     range(0, hCount + 1, 1).forEach((i) => {
       const gy = y + i * (h / hCount);
-      grid += `  <line x1="${formatNumber(x)}" y1="${formatNumber(gy)}" x2="${formatNumber(x + w)}" y2="${formatNumber(gy)}" stroke="#eee" stroke-width="1" />\n`;
+      grid += `  <line x1="${formatNumber(x)}" y1="${formatNumber(gy)}" x2="${formatNumber(x + w)}" y2="${formatNumber(y + h)}" stroke="#eee" stroke-width="1" />\n`;
     });
     return grid;
   };

commit b69cf4c4f320ee7ec2b5c779d5c788b6605fb4e8
Author: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>
Date:   Fri Feb 21 08:23:37 2025 +0000

    Updated version string in main.js and README to 0.2.0-6 to align with package.json. (fixes #209) (#210)
    
    Co-authored-by: GitHub Actions[bot] <action@github.com>

diff --git a/src/lib/main.js b/src/lib/main.js
index 3ff5162..310afd1 100755
--- a/src/lib/main.js
+++ b/src/lib/main.js
@@ -1171,7 +1171,7 @@ const main = () => {
   const args = process.argv.slice(2);
 
   if (args.includes("--version")) {
-    console.log("Equation Plotter Library version 0.2.0-3");
+    console.log("Equation Plotter Library version 0.2.0-6");
     process.exit(0);
   }
 

commit a951c17ac2b21e0d1892355dea0440029eeee414
Author: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>
Date:   Fri Feb 21 06:23:59 2025 +0000

    Removed duplicate openai dependency and updated ESLint config packages to contemporary versions. (fixes #207) (#208)
    
    Co-authored-by: GitHub Actions[bot] <action@github.com>

diff --git a/src/lib/main.js b/src/lib/main.js
index 5a205dc..3ff5162 100755
--- a/src/lib/main.js
+++ b/src/lib/main.js
@@ -204,7 +204,7 @@ const parseGenericLinear = (formulaStr) => {
 // Parse a generic quadratic formula in standard algebraic form with optional range
 const parseGenericQuadratic = (formulaStr) => {
   const parts = formulaStr.split(":");
-  const mainPart = parts[0].replace(/\s+/g, "");
+  const mainPart = parts[0].replace(/\s+/g, "").toLowerCase();
   const rangePart = parts.length > 1 ? parts[1].trim() : "";
   let xMin = -10;
   let xMax = 10;
@@ -216,7 +216,7 @@ const parseGenericQuadratic = (formulaStr) => {
     if (rangeParams.length > 2 && !isNaN(rangeParams[2])) step = rangeParams[2];
   }
 
-  if (mainPart.toLowerCase().startsWith("y=")) {
+  if (mainPart.startsWith("y=")) {
     const yExpr = mainPart.substring(2);
     const coeffs = extractQuadraticCoefficients(yExpr);
     return plotQuadraticParam({ ...coeffs, xMin, xMax, step });

commit dcce4b86cfb86c8adecfb04ad837da1d540bf63f
Author: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>
Date:   Fri Feb 21 02:38:55 2025 +0000

    Disabled no-console in main.js to satisfy linting with max warnings --max-warnings10. (fixes #200) (#204)
    
    Co-authored-by: GitHub Actions[bot] <action@github.com>

diff --git a/src/lib/main.js b/src/lib/main.js
index 1068c94..5a205dc 100755
--- a/src/lib/main.js
+++ b/src/lib/main.js
@@ -1,4 +1,5 @@
 #!/usr/bin/env node
+/* eslint-disable no-console */
 
 "use strict";
 

commit fb71b80c5d7082ab0d5235780cc678bbdc2f506d
Author: GitHub Actions[bot] <action@github.com>
Date:   Fri Feb 21 00:16:06 2025 +0000

    Updated version to 0.2.0-3 and enhanced unit tests for error handling and branch coverage. (fixes #195)

diff --git a/src/lib/main.js b/src/lib/main.js
index 4bc5198..1068c94 100755
--- a/src/lib/main.js
+++ b/src/lib/main.js
@@ -516,7 +516,7 @@ const generateSvg = (
   exponentialPlots,
   logarithmicPlots,
   gridEnabled = false,
-  dealersChoice = false,
+  dealersChoice = false
 ) => {
   const width = 800;
   const height = 1700;
@@ -600,7 +600,7 @@ const generateSvg = (
       Math.min(...quadraticPlots.flat().map((p) => p.x)),
       Math.max(...quadraticPlots.flat().map((p) => p.x)),
       Math.min(...quadraticPlots.flat().map((p) => p.y)),
-      Math.max(...quadraticPlots.flat().map((p) => p.y)),
+      Math.max(...quadraticPlots.flat().map((p) => p.y))
     );
   }
   const qAllPoints = quadraticPlots.flat();
@@ -643,7 +643,7 @@ const generateSvg = (
       Math.min(...linearPlots.flat().map((p) => p.x)),
       Math.max(...linearPlots.flat().map((p) => p.x)),
       Math.min(...linearPlots.flat().map((p) => p.y)),
-      Math.max(...linearPlots.flat().map((p) => p.y)),
+      Math.max(...linearPlots.flat().map((p) => p.y))
     );
   }
   const lAllPoints = linearPlots.flat();
@@ -686,7 +686,7 @@ const generateSvg = (
       Math.min(...sinePlots.flat().map((p) => p.x)),
       Math.max(...sinePlots.flat().map((p) => p.x)),
       Math.min(...sinePlots.flat().map((p) => p.y)),
-      Math.max(...sinePlots.flat().map((p) => p.y)),
+      Math.max(...sinePlots.flat().map((p) => p.y))
     );
   }
   const sAllPoints = sinePlots.flat();
@@ -729,7 +729,7 @@ const generateSvg = (
       Math.min(...cosinePlots.flat().map((p) => p.x)),
       Math.max(...cosinePlots.flat().map((p) => p.x)),
       Math.min(...cosinePlots.flat().map((p) => p.y)),
-      Math.max(...cosinePlots.flat().map((p) => p.y)),
+      Math.max(...cosinePlots.flat().map((p) => p.y))
     );
   }
   const cAllPoints = cosinePlots.flat();
@@ -796,7 +796,7 @@ const generateSvg = (
       Math.min(...exponentialPlots.flat().map((p) => p.x)),
       Math.max(...exponentialPlots.flat().map((p) => p.x)),
       Math.min(...exponentialPlots.flat().map((p) => p.y)),
-      Math.max(...exponentialPlots.flat().map((p) => p.y)),
+      Math.max(...exponentialPlots.flat().map((p) => p.y))
     );
   }
   const expAllPoints = exponentialPlots.flat();
@@ -839,7 +839,7 @@ const generateSvg = (
       Math.min(...logarithmicPlots.flat().map((p) => p.x)),
       Math.max(...logarithmicPlots.flat().map((p) => p.x)),
       Math.min(...logarithmicPlots.flat().map((p) => p.y)),
-      Math.max(...logarithmicPlots.flat().map((p) => p.y)),
+      Math.max(...logarithmicPlots.flat().map((p) => p.y))
     );
   }
   const logAllPoints = logarithmicPlots.flat();
@@ -971,7 +971,7 @@ const plotToText = ({ formulas = [] } = {}) => {
     quadratic
       .map(
         (points, i) =>
-          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")
       )
       .join("\n") +
     "\n\n";
@@ -980,7 +980,7 @@ const plotToText = ({ formulas = [] } = {}) => {
     linear
       .map(
         (points, i) =>
-          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")
       )
       .join("\n") +
     "\n\n";
@@ -989,7 +989,7 @@ const plotToText = ({ formulas = [] } = {}) => {
     sine
       .map(
         (points, i) =>
-          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")
       )
       .join("\n") +
     "\n\n";
@@ -998,7 +998,7 @@ const plotToText = ({ formulas = [] } = {}) => {
     cosine
       .map(
         (points, i) =>
-          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")
       )
       .join("\n") +
     "\n\n";
@@ -1007,7 +1007,7 @@ const plotToText = ({ formulas = [] } = {}) => {
     polar
       .map(
         (points, i) =>
-          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")
       )
       .join("\n") +
     "\n\n";
@@ -1016,7 +1016,7 @@ const plotToText = ({ formulas = [] } = {}) => {
     exponential
       .map(
         (points, i) =>
-          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")
       )
       .join("\n") +
     "\n\n";
@@ -1025,7 +1025,7 @@ const plotToText = ({ formulas = [] } = {}) => {
     logarithmic
       .map(
         (points, i) =>
-          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")
       )
       .join("\n") +
     "\n";
@@ -1170,7 +1170,7 @@ const main = () => {
   const args = process.argv.slice(2);
 
   if (args.includes("--version")) {
-    console.log("Equation Plotter Library version 0.2.0-1");
+    console.log("Equation Plotter Library version 0.2.0-3");
     process.exit(0);
   }
 

commit 8989eed54fbe7ff4fe434059e1494a6fa7d51a29
Author: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>
Date:   Thu Feb 20 11:37:58 2025 +0000

    Updated by `npm run formatting-fix -- "." ; npm run linting-fix "." -- --max-warnings=10` (#194)
    
    Co-authored-by: GitHub Actions[bot] <action@github.com>

diff --git a/src/lib/main.js b/src/lib/main.js
index e27b3f3..4bc5198 100755
--- a/src/lib/main.js
+++ b/src/lib/main.js
@@ -516,7 +516,7 @@ const generateSvg = (
   exponentialPlots,
   logarithmicPlots,
   gridEnabled = false,
-  dealersChoice = false
+  dealersChoice = false,
 ) => {
   const width = 800;
   const height = 1700;
@@ -600,7 +600,7 @@ const generateSvg = (
       Math.min(...quadraticPlots.flat().map((p) => p.x)),
       Math.max(...quadraticPlots.flat().map((p) => p.x)),
       Math.min(...quadraticPlots.flat().map((p) => p.y)),
-      Math.max(...quadraticPlots.flat().map((p) => p.y))
+      Math.max(...quadraticPlots.flat().map((p) => p.y)),
     );
   }
   const qAllPoints = quadraticPlots.flat();
@@ -643,7 +643,7 @@ const generateSvg = (
       Math.min(...linearPlots.flat().map((p) => p.x)),
       Math.max(...linearPlots.flat().map((p) => p.x)),
       Math.min(...linearPlots.flat().map((p) => p.y)),
-      Math.max(...linearPlots.flat().map((p) => p.y))
+      Math.max(...linearPlots.flat().map((p) => p.y)),
     );
   }
   const lAllPoints = linearPlots.flat();
@@ -686,7 +686,7 @@ const generateSvg = (
       Math.min(...sinePlots.flat().map((p) => p.x)),
       Math.max(...sinePlots.flat().map((p) => p.x)),
       Math.min(...sinePlots.flat().map((p) => p.y)),
-      Math.max(...sinePlots.flat().map((p) => p.y))
+      Math.max(...sinePlots.flat().map((p) => p.y)),
     );
   }
   const sAllPoints = sinePlots.flat();
@@ -729,7 +729,7 @@ const generateSvg = (
       Math.min(...cosinePlots.flat().map((p) => p.x)),
       Math.max(...cosinePlots.flat().map((p) => p.x)),
       Math.min(...cosinePlots.flat().map((p) => p.y)),
-      Math.max(...cosinePlots.flat().map((p) => p.y))
+      Math.max(...cosinePlots.flat().map((p) => p.y)),
     );
   }
   const cAllPoints = cosinePlots.flat();
@@ -796,7 +796,7 @@ const generateSvg = (
       Math.min(...exponentialPlots.flat().map((p) => p.x)),
       Math.max(...exponentialPlots.flat().map((p) => p.x)),
       Math.min(...exponentialPlots.flat().map((p) => p.y)),
-      Math.max(...exponentialPlots.flat().map((p) => p.y))
+      Math.max(...exponentialPlots.flat().map((p) => p.y)),
     );
   }
   const expAllPoints = exponentialPlots.flat();
@@ -839,7 +839,7 @@ const generateSvg = (
       Math.min(...logarithmicPlots.flat().map((p) => p.x)),
       Math.max(...logarithmicPlots.flat().map((p) => p.x)),
       Math.min(...logarithmicPlots.flat().map((p) => p.y)),
-      Math.max(...logarithmicPlots.flat().map((p) => p.y))
+      Math.max(...logarithmicPlots.flat().map((p) => p.y)),
     );
   }
   const logAllPoints = logarithmicPlots.flat();
@@ -971,7 +971,7 @@ const plotToText = ({ formulas = [] } = {}) => {
     quadratic
       .map(
         (points, i) =>
-          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
       )
       .join("\n") +
     "\n\n";
@@ -980,7 +980,7 @@ const plotToText = ({ formulas = [] } = {}) => {
     linear
       .map(
         (points, i) =>
-          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
       )
       .join("\n") +
     "\n\n";
@@ -989,7 +989,7 @@ const plotToText = ({ formulas = [] } = {}) => {
     sine
       .map(
         (points, i) =>
-          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
       )
       .join("\n") +
     "\n\n";
@@ -998,7 +998,7 @@ const plotToText = ({ formulas = [] } = {}) => {
     cosine
       .map(
         (points, i) =>
-          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
       )
       .join("\n") +
     "\n\n";
@@ -1007,7 +1007,7 @@ const plotToText = ({ formulas = [] } = {}) => {
     polar
       .map(
         (points, i) =>
-          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
       )
       .join("\n") +
     "\n\n";
@@ -1016,7 +1016,7 @@ const plotToText = ({ formulas = [] } = {}) => {
     exponential
       .map(
         (points, i) =>
-          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
       )
       .join("\n") +
     "\n\n";
@@ -1025,7 +1025,7 @@ const plotToText = ({ formulas = [] } = {}) => {
     logarithmic
       .map(
         (points, i) =>
-          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
       )
       .join("\n") +
     "\n";
@@ -1222,7 +1222,7 @@ Formula String Formats:
     (arg) =>
       !arg.includes(":") &&
       !arg.includes("=") &&
-      !["--json", "--csv", "--version", "--ascii", "--debug", "--grid", "--dealers-choice"].includes(arg)
+      !["--json", "--csv", "--version", "--ascii", "--debug", "--grid", "--dealers-choice"].includes(arg),
   );
   if (nonFormulaArgs.length > 0) {
     outputFileName = nonFormulaArgs[0];
@@ -1243,7 +1243,7 @@ Formula String Formats:
 
   if (formulasList.length === 0) {
     console.log(
-      "No formulas provided. Using default plot functions for quadratic, linear, sine, cosine, polar, exponential, and logarithmic plots."
+      "No formulas provided. Using default plot functions for quadratic, linear, sine, cosine, polar, exponential, and logarithmic plots.",
     );
   }
 
@@ -1270,7 +1270,7 @@ Formula String Formats:
   try {
     fs.writeFileSync(outputFileName, fileContent, "utf8");
     console.log(
-      `\n${isJson ? "JSON" : isCsv ? "CSV" : isHtml ? "HTML" : isMarkdown ? "Markdown" : isAscii ? "ASCII" : "SVG"} file generated: ${outputFileName}`
+      `\n${isJson ? "JSON" : isCsv ? "CSV" : isHtml ? "HTML" : isMarkdown ? "Markdown" : isAscii ? "ASCII" : "SVG"} file generated: ${outputFileName}`,
     );
   } catch (err) {
     console.error(`Error writing file:`, err.message);
@@ -1305,5 +1305,5 @@ export {
   parseGenericQuadratic,
   parseGenericExponential,
   parseCosine,
-  main
+  main,
 };

commit e334da094c13abd35f859f9224f765798d1b6208
Author: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>
Date:   Thu Feb 20 11:33:04 2025 +0000

    Removed lodash dependency by replacing _.range with a custom range function. (fixes #192) (#193)
    
    Co-authored-by: GitHub Actions[bot] <action@github.com>

diff --git a/src/lib/main.js b/src/lib/main.js
index 3a4de55..e27b3f3 100755
--- a/src/lib/main.js
+++ b/src/lib/main.js
@@ -4,7 +4,21 @@
 
 import { fileURLToPath } from "url";
 import fs from "fs";
-import _ from "lodash"; // Using lodash for range generation to reduce code size
+
+// Custom range function to generate a sequence of numbers
+const range = (start, end, step = 1) => {
+  const arr = [];
+  if (step > 0) {
+    for (let i = start; i < end; i += step) {
+      arr.push(i);
+    }
+  } else {
+    for (let i = start; i > end; i += step) {
+      arr.push(i);
+    }
+  }
+  return arr;
+};
 
 /*
  Next Up:
@@ -22,12 +36,12 @@ const formatNumber = (n) => {
 // Plotting Functions
 
 const plotQuadraticParam = ({ a = 1, b = 0, c = 0, xMin = -10, xMax = 10, step = 1 } = {}) => {
-  const points = _.range(xMin, xMax + step, step).map((x) => ({ x, y: a * x * x + b * x + c }));
+  const points = range(xMin, xMax + step, step).map((x) => ({ x, y: a * x * x + b * x + c }));
   return points;
 };
 
 const plotSineParam = ({ amplitude = 1, frequency = 1, phase = 0, xMin = 0, xMax = 360, step = 10 } = {}) => {
-  const points = _.range(xMin, xMax + step, step).map((deg) => {
+  const points = range(xMin, xMax + step, step).map((deg) => {
     const rad = deg * (Math.PI / 180);
     return { x: deg, y: amplitude * Math.sin(frequency * rad + phase) };
   });
@@ -35,7 +49,7 @@ const plotSineParam = ({ amplitude = 1, frequency = 1, phase = 0, xMin = 0, xMax
 };
 
 const plotCosineParam = ({ amplitude = 1, frequency = 1, phase = 0, xMin = 0, xMax = 360, step = 10 } = {}) => {
-  const points = _.range(xMin, xMax + step, step).map((deg) => {
+  const points = range(xMin, xMax + step, step).map((deg) => {
     const rad = deg * (Math.PI / 180);
     return { x: deg, y: amplitude * Math.cos(frequency * rad + phase) };
   });
@@ -43,7 +57,7 @@ const plotCosineParam = ({ amplitude = 1, frequency = 1, phase = 0, xMin = 0, xM
 };
 
 const plotPolarParam = ({ scale = 200, multiplier = 2, step = 5, degMin = 0, degMax = 360 } = {}) => {
-  const points = _.range(degMin, degMax + step, step).map((deg) => {
+  const points = range(degMin, degMax + step, step).map((deg) => {
     const rad = deg * (Math.PI / 180);
     const r = scale * Math.abs(Math.sin(multiplier * rad));
     return { x: r * Math.cos(rad), y: r * Math.sin(rad) };
@@ -52,17 +66,17 @@ const plotPolarParam = ({ scale = 200, multiplier = 2, step = 5, degMin = 0, deg
 };
 
 const plotLinearParam = ({ m = 1, b = 0, xMin = -10, xMax = 10, step = 1 } = {}) => {
-  const points = _.range(xMin, xMax + step, step).map((x) => ({ x, y: m * x + b }));
+  const points = range(xMin, xMax + step, step).map((x) => ({ x, y: m * x + b }));
   return points;
 };
 
 const plotExponentialParam = ({ a = 1, b = 1, xMin = -10, xMax = 10, step = 1 } = {}) => {
-  const points = _.range(xMin, xMax + step, step).map((x) => ({ x, y: a * Math.exp(b * x) }));
+  const points = range(xMin, xMax + step, step).map((x) => ({ x, y: a * Math.exp(b * x) }));
   return points;
 };
 
 const plotLogarithmicParam = ({ a = 1, base = Math.E, xMin = 1, xMax = 10, step = 1 } = {}) => {
-  const points = _.range(xMin, xMax + step, step).reduce((arr, x) => {
+  const points = range(xMin, xMax + step, step).reduce((arr, x) => {
     if (x > 0) arr.push({ x, y: a * (Math.log(x) / Math.log(base)) });
     return arr;
   }, []);
@@ -550,11 +564,11 @@ const generateSvg = (
 
   const drawRectGrid = (x, y, w, h, vCount, hCount) => {
     let grid = "";
-    _.range(0, vCount + 1).forEach((i) => {
+    range(0, vCount + 1, 1).forEach((i) => {
       const gx = x + i * (w / vCount);
       grid += `  <line x1="${formatNumber(gx)}" y1="${formatNumber(y)}" x2="${formatNumber(gx)}" y2="${formatNumber(y + h)}" stroke="#eee" stroke-width="1" />\n`;
     });
-    _.range(0, hCount + 1).forEach((i) => {
+    range(0, hCount + 1, 1).forEach((i) => {
       const gy = y + i * (h / hCount);
       grid += `  <line x1="${formatNumber(x)}" y1="${formatNumber(gy)}" x2="${formatNumber(x + w)}" y2="${formatNumber(gy)}" stroke="#eee" stroke-width="1" />\n`;
     });

commit 6b47ccf3068d2aadc53a944a345a8999c5fdcddf
Author: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>
Date:   Thu Feb 20 10:23:06 2025 +0000

    Added Next Up section in README and added next-up comment block in main.js. (fixes #174) (#191)
    
    Co-authored-by: GitHub Actions[bot] <action@github.com>

diff --git a/src/lib/main.js b/src/lib/main.js
index c2320a9..3a4de55 100755
--- a/src/lib/main.js
+++ b/src/lib/main.js
@@ -6,6 +6,13 @@ import { fileURLToPath } from "url";
 import fs from "fs";
 import _ from "lodash"; // Using lodash for range generation to reduce code size
 
+/*
+ Next Up:
+ - Refactor plotting functions for better performance.
+ - Add interactive CLI mode for user inputs.
+ - Enhance error handling and logging.
+*/
+
 // Helper function to format numbers to two decimals and avoid negative zero
 const formatNumber = (n) => {
   const s = n.toFixed(2);

commit 21914b85b9be2f892702187c2d37f352a288b622
Author: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>
Date:   Thu Feb 20 09:04:36 2025 +0000

    Refresh README and update CLI help text to document new output options. (fixes #175) (#190)
    
    Co-authored-by: GitHub Actions[bot] <action@github.com>

diff --git a/src/lib/main.js b/src/lib/main.js
index 290e0d4..c2320a9 100755
--- a/src/lib/main.js
+++ b/src/lib/main.js
@@ -1157,16 +1157,17 @@ const main = () => {
     console.log(`Usage: node src/lib/main.js [outputFileName] [formulaStrings...]
 
 Options:
-  --help, -h       Show this help message
-  --json           Generate output as JSON instead of SVG
-  --csv            Generate output as CSV instead of SVG
-  --ascii          Generate output as ASCII art instead of SVG
-  --grid           Overlay grid lines on SVG plots
-  --debug          Output internal parsed plot data for debugging
-  --dealers-choice Use randomized color palette for SVG plots
-  --demo           Run demo test output
-  --version        Show version information
-  (output file extension .html will generate HTML output)
+  --help, -h         Show this help message
+  --json             Generate output as JSON instead of SVG
+  --csv              Generate output as CSV instead of SVG
+  --ascii            Generate output as ASCII art instead of SVG
+  --grid             Overlay grid lines on SVG plots
+  --debug            Output internal parsed plot data for debugging
+  --dealers-choice   Use randomized color palette for SVG plots
+  --demo             Run demo test output
+  --version          Show version information
+  (output file extension .html will generate HTML output,
+   .md for Markdown output, .txt or .ascii for ASCII output)
 
 Formula String Formats:
   Quadratic: "quad:y=x^2+2*x+1" or "quadratic:y=x^2+2*x+1" or "x^2+y-1=0" (or with range e.g., "y=x^2+2*x+1:-10,10,1")

commit a4f9fd03b99a0a02c660b8ba4d22ee22ceed5ce6
Author: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>
Date:   Thu Feb 20 08:23:46 2025 +0000

    Changed default linear plot to y 2x 3 for better alignment with the README. (fixes #188) (#189)
    
    Co-authored-by: GitHub Actions[bot] <action@github.com>

diff --git a/src/lib/main.js b/src/lib/main.js
index b4ed541..290e0d4 100755
--- a/src/lib/main.js
+++ b/src/lib/main.js
@@ -67,7 +67,8 @@ const plotQuadratic = () => plotQuadraticParam();
 const plotSine = () => plotSineParam();
 const plotCosine = () => plotCosineParam();
 const plotPolar = () => plotPolarParam();
-const plotLinear = () => plotLinearParam();
+// Changed default linear plot to use y = 2x + 3 for better demonstration
+const plotLinear = () => plotLinearParam({ m: 2, b: 3 });
 const plotExponential = () => plotExponentialParam();
 const plotLogarithmic = () => plotLogarithmicParam();
 

commit b86163f0c14eabac22206761a50b28f82ac16158
Author: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>
Date:   Thu Feb 20 04:23:17 2025 +0000

    Added markdown output support based on output file extension in main script and updated tests accordingly. (fixes #176) (#187)
    
    Co-authored-by: GitHub Actions[bot] <action@github.com>

diff --git a/src/lib/main.js b/src/lib/main.js
index cd3cf04..b4ed541 100755
--- a/src/lib/main.js
+++ b/src/lib/main.js
@@ -494,7 +494,7 @@ const generateSvg = (
   exponentialPlots,
   logarithmicPlots,
   gridEnabled = false,
-  dealersChoice = false,
+  dealersChoice = false
 ) => {
   const width = 800;
   const height = 1700;
@@ -578,7 +578,7 @@ const generateSvg = (
       Math.min(...quadraticPlots.flat().map((p) => p.x)),
       Math.max(...quadraticPlots.flat().map((p) => p.x)),
       Math.min(...quadraticPlots.flat().map((p) => p.y)),
-      Math.max(...quadraticPlots.flat().map((p) => p.y)),
+      Math.max(...quadraticPlots.flat().map((p) => p.y))
     );
   }
   const qAllPoints = quadraticPlots.flat();
@@ -621,7 +621,7 @@ const generateSvg = (
       Math.min(...linearPlots.flat().map((p) => p.x)),
       Math.max(...linearPlots.flat().map((p) => p.x)),
       Math.min(...linearPlots.flat().map((p) => p.y)),
-      Math.max(...linearPlots.flat().map((p) => p.y)),
+      Math.max(...linearPlots.flat().map((p) => p.y))
     );
   }
   const lAllPoints = linearPlots.flat();
@@ -664,7 +664,7 @@ const generateSvg = (
       Math.min(...sinePlots.flat().map((p) => p.x)),
       Math.max(...sinePlots.flat().map((p) => p.x)),
       Math.min(...sinePlots.flat().map((p) => p.y)),
-      Math.max(...sinePlots.flat().map((p) => p.y)),
+      Math.max(...sinePlots.flat().map((p) => p.y))
     );
   }
   const sAllPoints = sinePlots.flat();
@@ -707,7 +707,7 @@ const generateSvg = (
       Math.min(...cosinePlots.flat().map((p) => p.x)),
       Math.max(...cosinePlots.flat().map((p) => p.x)),
       Math.min(...cosinePlots.flat().map((p) => p.y)),
-      Math.max(...cosinePlots.flat().map((p) => p.y)),
+      Math.max(...cosinePlots.flat().map((p) => p.y))
     );
   }
   const cAllPoints = cosinePlots.flat();
@@ -774,7 +774,7 @@ const generateSvg = (
       Math.min(...exponentialPlots.flat().map((p) => p.x)),
       Math.max(...exponentialPlots.flat().map((p) => p.x)),
       Math.min(...exponentialPlots.flat().map((p) => p.y)),
-      Math.max(...exponentialPlots.flat().map((p) => p.y)),
+      Math.max(...exponentialPlots.flat().map((p) => p.y))
     );
   }
   const expAllPoints = exponentialPlots.flat();
@@ -817,7 +817,7 @@ const generateSvg = (
       Math.min(...logarithmicPlots.flat().map((p) => p.x)),
       Math.max(...logarithmicPlots.flat().map((p) => p.x)),
       Math.min(...logarithmicPlots.flat().map((p) => p.y)),
-      Math.max(...logarithmicPlots.flat().map((p) => p.y)),
+      Math.max(...logarithmicPlots.flat().map((p) => p.y))
     );
   }
   const logAllPoints = logarithmicPlots.flat();
@@ -949,7 +949,7 @@ const plotToText = ({ formulas = [] } = {}) => {
     quadratic
       .map(
         (points, i) =>
-          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")
       )
       .join("\n") +
     "\n\n";
@@ -958,7 +958,7 @@ const plotToText = ({ formulas = [] } = {}) => {
     linear
       .map(
         (points, i) =>
-          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")
       )
       .join("\n") +
     "\n\n";
@@ -967,7 +967,7 @@ const plotToText = ({ formulas = [] } = {}) => {
     sine
       .map(
         (points, i) =>
-          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")
       )
       .join("\n") +
     "\n\n";
@@ -976,7 +976,7 @@ const plotToText = ({ formulas = [] } = {}) => {
     cosine
       .map(
         (points, i) =>
-          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")
       )
       .join("\n") +
     "\n\n";
@@ -985,7 +985,7 @@ const plotToText = ({ formulas = [] } = {}) => {
     polar
       .map(
         (points, i) =>
-          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")
       )
       .join("\n") +
     "\n\n";
@@ -994,7 +994,7 @@ const plotToText = ({ formulas = [] } = {}) => {
     exponential
       .map(
         (points, i) =>
-          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")
       )
       .join("\n") +
     "\n\n";
@@ -1003,7 +1003,7 @@ const plotToText = ({ formulas = [] } = {}) => {
     logarithmic
       .map(
         (points, i) =>
-          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")
       )
       .join("\n") +
     "\n";
@@ -1190,6 +1190,7 @@ Formula String Formats:
   let isCsv = args.includes("--csv");
   let isHtml = false;
   let isAscii = args.includes("--ascii");
+  let isMarkdown = false;
   const isDebug = args.includes("--debug");
   const gridEnabled = args.includes("--grid");
   const isDealersChoice = args.includes("--dealers-choice");
@@ -1198,7 +1199,7 @@ Formula String Formats:
     (arg) =>
       !arg.includes(":") &&
       !arg.includes("=") &&
-      !["--json", "--csv", "--version", "--ascii", "--debug", "--grid", "--dealers-choice"].includes(arg),
+      !["--json", "--csv", "--version", "--ascii", "--debug", "--grid", "--dealers-choice"].includes(arg)
   );
   if (nonFormulaArgs.length > 0) {
     outputFileName = nonFormulaArgs[0];
@@ -1209,6 +1210,8 @@ Formula String Formats:
     isCsv = true;
   } else if (outputFileName.toLowerCase().endsWith(".html")) {
     isHtml = true;
+  } else if (outputFileName.toLowerCase().endsWith(".md")) {
+    isMarkdown = true;
   } else if (outputFileName.toLowerCase().endsWith(".txt") || outputFileName.toLowerCase().endsWith(".ascii")) {
     isAscii = true;
   }
@@ -1217,7 +1220,7 @@ Formula String Formats:
 
   if (formulasList.length === 0) {
     console.log(
-      "No formulas provided. Using default plot functions for quadratic, linear, sine, cosine, polar, exponential, and logarithmic plots.",
+      "No formulas provided. Using default plot functions for quadratic, linear, sine, cosine, polar, exponential, and logarithmic plots."
     );
   }
 
@@ -1233,6 +1236,8 @@ Formula String Formats:
     fileContent = plotToCsv({ formulas: formulasList });
   } else if (isHtml) {
     fileContent = plotToHtml({ formulas: formulasList, grid: gridEnabled, dealersChoice: isDealersChoice });
+  } else if (isMarkdown) {
+    fileContent = plotToMarkdown({ formulas: formulasList });
   } else if (isAscii) {
     fileContent = plotToAscii({ formulas: formulasList });
   } else {
@@ -1242,7 +1247,7 @@ Formula String Formats:
   try {
     fs.writeFileSync(outputFileName, fileContent, "utf8");
     console.log(
-      `\n${isJson ? "JSON" : isCsv ? "CSV" : isHtml ? "HTML" : isAscii ? "ASCII" : "SVG"} file generated: ${outputFileName}`,
+      `\n${isJson ? "JSON" : isCsv ? "CSV" : isHtml ? "HTML" : isMarkdown ? "Markdown" : isAscii ? "ASCII" : "SVG"} file generated: ${outputFileName}`
     );
   } catch (err) {
     console.error(`Error writing file:`, err.message);
@@ -1277,4 +1282,5 @@ export {
   parseGenericQuadratic,
   parseGenericExponential,
   parseCosine,
+  main
 };

commit 6ef0d5da1fc0497e11ccf0123b27ebdb078d7b55
Author: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>
Date:   Thu Feb 20 03:36:39 2025 +0000

    Updated by `npm run formatting-fix -- "." ; npm run linting-fix "." -- --max-warnings=10` (#186)
    
    Co-authored-by: GitHub Actions[bot] <action@github.com>

diff --git a/src/lib/main.js b/src/lib/main.js
index 5274d9b..cd3cf04 100755
--- a/src/lib/main.js
+++ b/src/lib/main.js
@@ -15,12 +15,12 @@ const formatNumber = (n) => {
 // Plotting Functions
 
 const plotQuadraticParam = ({ a = 1, b = 0, c = 0, xMin = -10, xMax = 10, step = 1 } = {}) => {
-  const points = _.range(xMin, xMax + step, step).map(x => ({ x, y: a * x * x + b * x + c }));
+  const points = _.range(xMin, xMax + step, step).map((x) => ({ x, y: a * x * x + b * x + c }));
   return points;
 };
 
 const plotSineParam = ({ amplitude = 1, frequency = 1, phase = 0, xMin = 0, xMax = 360, step = 10 } = {}) => {
-  const points = _.range(xMin, xMax + step, step).map(deg => {
+  const points = _.range(xMin, xMax + step, step).map((deg) => {
     const rad = deg * (Math.PI / 180);
     return { x: deg, y: amplitude * Math.sin(frequency * rad + phase) };
   });
@@ -28,7 +28,7 @@ const plotSineParam = ({ amplitude = 1, frequency = 1, phase = 0, xMin = 0, xMax
 };
 
 const plotCosineParam = ({ amplitude = 1, frequency = 1, phase = 0, xMin = 0, xMax = 360, step = 10 } = {}) => {
-  const points = _.range(xMin, xMax + step, step).map(deg => {
+  const points = _.range(xMin, xMax + step, step).map((deg) => {
     const rad = deg * (Math.PI / 180);
     return { x: deg, y: amplitude * Math.cos(frequency * rad + phase) };
   });
@@ -36,7 +36,7 @@ const plotCosineParam = ({ amplitude = 1, frequency = 1, phase = 0, xMin = 0, xM
 };
 
 const plotPolarParam = ({ scale = 200, multiplier = 2, step = 5, degMin = 0, degMax = 360 } = {}) => {
-  const points = _.range(degMin, degMax + step, step).map(deg => {
+  const points = _.range(degMin, degMax + step, step).map((deg) => {
     const rad = deg * (Math.PI / 180);
     const r = scale * Math.abs(Math.sin(multiplier * rad));
     return { x: r * Math.cos(rad), y: r * Math.sin(rad) };
@@ -45,12 +45,12 @@ const plotPolarParam = ({ scale = 200, multiplier = 2, step = 5, degMin = 0, deg
 };
 
 const plotLinearParam = ({ m = 1, b = 0, xMin = -10, xMax = 10, step = 1 } = {}) => {
-  const points = _.range(xMin, xMax + step, step).map(x => ({ x, y: m * x + b }));
+  const points = _.range(xMin, xMax + step, step).map((x) => ({ x, y: m * x + b }));
   return points;
 };
 
 const plotExponentialParam = ({ a = 1, b = 1, xMin = -10, xMax = 10, step = 1 } = {}) => {
-  const points = _.range(xMin, xMax + step, step).map(x => ({ x, y: a * Math.exp(b * x) }));
+  const points = _.range(xMin, xMax + step, step).map((x) => ({ x, y: a * Math.exp(b * x) }));
   return points;
 };
 
@@ -84,7 +84,7 @@ const parseQuadratic = (formulaStr) => {
     c: isNaN(c) ? 0 : c,
     xMin: isNaN(xMin) ? -10 : xMin,
     xMax: isNaN(xMax) ? 10 : xMax,
-    step: isNaN(step) ? 1 : step
+    step: isNaN(step) ? 1 : step,
   });
 };
 
@@ -99,7 +99,7 @@ const parseSine = (formulaStr) => {
     phase: isNaN(phase) ? 0 : phase,
     xMin: isNaN(xMin) ? 0 : xMin,
     xMax: isNaN(xMax) ? 360 : xMax,
-    step: isNaN(step) ? 10 : step
+    step: isNaN(step) ? 10 : step,
   });
 };
 
@@ -114,7 +114,7 @@ const parseCosine = (formulaStr) => {
     phase: isNaN(phase) ? 0 : phase,
     xMin: isNaN(xMin) ? 0 : xMin,
     xMax: isNaN(xMax) ? 360 : xMax,
-    step: isNaN(step) ? 10 : step
+    step: isNaN(step) ? 10 : step,
   });
 };
 
@@ -124,9 +124,9 @@ const parsePolar = (formulaStr) => {
   const params = parts[1].split(",").map(Number);
   const scale = isNaN(params[0]) ? 200 : params[0];
   const multiplier = isNaN(params[1]) ? 2 : params[1];
-  let step = params.length >= 3 ? (isNaN(params[2]) ? 5 : params[2]) : 5;
-  let degMin = params.length >= 5 ? (isNaN(params[3]) ? 0 : params[3]) : 0;
-  let degMax = params.length >= 5 ? (isNaN(params[4]) ? 360 : params[4]) : 360;
+  const step = params.length >= 3 ? (isNaN(params[2]) ? 5 : params[2]) : 5;
+  const degMin = params.length >= 5 ? (isNaN(params[3]) ? 0 : params[3]) : 0;
+  const degMax = params.length >= 5 ? (isNaN(params[4]) ? 360 : params[4]) : 360;
   return plotPolarParam({ scale, multiplier, step, degMin, degMax });
 };
 
@@ -140,7 +140,7 @@ const parseLinear = (formulaStr) => {
     b: isNaN(b) ? 0 : b,
     xMin: isNaN(xMin) ? -10 : xMin,
     xMax: isNaN(xMax) ? 10 : xMax,
-    step: isNaN(step) ? 1 : step
+    step: isNaN(step) ? 1 : step,
   });
 };
 
@@ -156,16 +156,19 @@ const parseGenericLinear = (formulaStr) => {
   if (expr.includes("x^2")) {
     throw new Error("Detected quadratic term in what should be a linear formula: " + formulaStr);
   }
-  let m = 1, b = 0;
+  let m = 1;
+  let b = 0;
   const mMatch = expr.match(/^([+-]?\d*\.?\d+)?\*?x/);
   if (mMatch) {
-    m = (mMatch[1] === "" || mMatch[1] === undefined) ? 1 : parseFloat(mMatch[1]);
+    m = mMatch[1] === "" || mMatch[1] === undefined ? 1 : parseFloat(mMatch[1]);
   }
   const bMatch = expr.match(/([+-]\d*\.?\d+)(?!\*?x)/);
   if (bMatch) {
     b = parseFloat(bMatch[1]);
   }
-  let xMin = -10, xMax = 10, step = 1;
+  let xMin = -10;
+  let xMax = 10;
+  let step = 1;
   if (rangePart) {
     const rangeParams = rangePart.split(",").map(Number);
     if (rangeParams.length > 0 && !isNaN(rangeParams[0])) xMin = rangeParams[0];
@@ -180,7 +183,9 @@ const parseGenericQuadratic = (formulaStr) => {
   const parts = formulaStr.split(":");
   const mainPart = parts[0].replace(/\s+/g, "");
   const rangePart = parts.length > 1 ? parts[1].trim() : "";
-  let xMin = -10, xMax = 10, step = 1;
+  let xMin = -10;
+  let xMax = 10;
+  let step = 1;
   if (rangePart) {
     const rangeParams = rangePart.split(",").map(Number);
     if (rangeParams.length > 0 && !isNaN(rangeParams[0])) xMin = rangeParams[0];
@@ -198,7 +203,7 @@ const parseGenericQuadratic = (formulaStr) => {
     const yMatch = left.match(yRegex);
     if (!yMatch) throw new Error("No y term found in equation: " + formulaStr);
     const coeffStr = yMatch[1];
-    const yCoeff = (coeffStr === "" || coeffStr === "+") ? 1 : (coeffStr === "-") ? -1 : parseFloat(coeffStr);
+    const yCoeff = coeffStr === "" || coeffStr === "+" ? 1 : coeffStr === "-" ? -1 : parseFloat(coeffStr);
     const remaining = left.replace(yRegex, "");
     const cleanedRemaining = remaining.replace(/^\+/, "");
     const coeffs = extractQuadraticCoefficients(cleanedRemaining);
@@ -208,7 +213,7 @@ const parseGenericQuadratic = (formulaStr) => {
       c: -coeffs.c / yCoeff,
       xMin,
       xMax,
-      step
+      step,
     });
   } else {
     const partsEq = mainPart.split("=");
@@ -233,7 +238,7 @@ const parseGenericQuadratic = (formulaStr) => {
         c: (constantRight - coeffs.c) / yCoeff,
         xMin,
         xMax,
-        step
+        step,
       });
     } else if (right.includes("y")) {
       const yMatch = right.match(/([+-]?\d*\.?\d*)y/);
@@ -253,7 +258,7 @@ const parseGenericQuadratic = (formulaStr) => {
         c: (constantLeft - coeffs.c) / yCoeff,
         xMin,
         xMax,
-        step
+        step,
       });
     } else {
       const nonYPart = left;
@@ -274,7 +279,7 @@ const parseExponential = (formulaStr) => {
     b: isNaN(b) ? 1 : b,
     xMin: isNaN(xMin) ? -10 : xMin,
     xMax: isNaN(xMax) ? 10 : xMax,
-    step: isNaN(step) ? 1 : step
+    step: isNaN(step) ? 1 : step,
   });
 };
 
@@ -283,7 +288,9 @@ const parseGenericExponential = (formulaStr) => {
   const parts = formulaStr.split(":");
   const exprPart = parts[0].replace(/\s+/g, "");
   const rangePart = parts.length > 1 ? parts[1].trim() : "";
-  let xMin = -10, xMax = 10, step = 1;
+  let xMin = -10;
+  let xMax = 10;
+  let step = 1;
   if (rangePart) {
     const rangeParams = rangePart.split(",").map(Number);
     if (rangeParams.length > 0 && !isNaN(rangeParams[0])) xMin = rangeParams[0];
@@ -312,24 +319,26 @@ const parseLogarithmic = (formulaStr) => {
     base: isNaN(base) ? Math.E : base,
     xMin: isNaN(xMin) ? 1 : xMin,
     xMax: isNaN(xMax) ? 10 : xMax,
-    step: isNaN(step) ? 1 : step
+    step: isNaN(step) ? 1 : step,
   });
 };
 
 // Extract quadratic coefficients from an expression of form ax^2+bx+c
 const extractQuadraticCoefficients = (expr) => {
   let cleanedExpr = expr.replace(/\s+/g, "").replace(/\+\-/g, "-");
-  let a = 0, b = 0, c = 0;
+  let a = 0;
+  let b = 0;
+  let c = 0;
   const aMatch = cleanedExpr.match(/([+-]?\d*\.?\d*)x\^2/);
   if (aMatch) {
     const coeff = aMatch[1];
-    a = (coeff === "" || coeff === "+") ? 1 : (coeff === "-") ? -1 : parseFloat(coeff);
+    a = coeff === "" || coeff === "+" ? 1 : coeff === "-" ? -1 : parseFloat(coeff);
     cleanedExpr = cleanedExpr.replace(aMatch[0], "");
   }
   const bMatch = cleanedExpr.match(/([+-]?\d*\.?\d+)x(?!\^)/);
   if (bMatch) {
     const coeff = bMatch[1];
-    b = (coeff === "" || coeff === "+") ? 1 : (coeff === "-") ? -1 : parseFloat(coeff);
+    b = coeff === "" || coeff === "+" ? 1 : coeff === "-" ? -1 : parseFloat(coeff);
     cleanedExpr = cleanedExpr.replace(bMatch[0], "");
   }
   const constantMatches = cleanedExpr.match(/([+-]?\d*\.?\d+)/g);
@@ -419,7 +428,11 @@ const getPlotsFromFormulas = (formulas = []) => {
   formulas.forEach((formula) => {
     const lower = formula.toLowerCase();
     try {
-      if (lower.startsWith("quad:") || lower.startsWith("quadratic:") || (formula.includes("x^2") && formula.includes("="))) {
+      if (
+        lower.startsWith("quad:") ||
+        lower.startsWith("quadratic:") ||
+        (formula.includes("x^2") && formula.includes("="))
+      ) {
         quadratic.push(plotFromString(formula));
       } else if (lower.startsWith("sine:")) {
         sine.push(plotFromString(formula));
@@ -427,11 +440,25 @@ const getPlotsFromFormulas = (formulas = []) => {
         cosine.push(parseCosine(formula));
       } else if (lower.startsWith("polar:")) {
         polar.push(plotFromString(formula));
-      } else if (lower.startsWith("linear:") || (lower.startsWith("y=") && !formula.includes("x^2") && !formula.toLowerCase().includes("e^") && !formula.toLowerCase().includes("log("))) {
+      } else if (
+        lower.startsWith("linear:") ||
+        (lower.startsWith("y=") &&
+          !formula.includes("x^2") &&
+          !formula.toLowerCase().includes("e^") &&
+          !formula.toLowerCase().includes("log("))
+      ) {
         linear.push(plotFromString(formula));
-      } else if (lower.startsWith("exponential:") || lower.startsWith("exp:") || (lower.startsWith("y=") && formula.toLowerCase().includes("e^"))) {
+      } else if (
+        lower.startsWith("exponential:") ||
+        lower.startsWith("exp:") ||
+        (lower.startsWith("y=") && formula.toLowerCase().includes("e^"))
+      ) {
         exponential.push(plotFromString(formula));
-      } else if (lower.startsWith("log:") || lower.startsWith("ln:") || (lower.startsWith("y=") && formula.toLowerCase().includes("log("))) {
+      } else if (
+        lower.startsWith("log:") ||
+        lower.startsWith("ln:") ||
+        (lower.startsWith("y=") && formula.toLowerCase().includes("log("))
+      ) {
         logarithmic.push(plotFromString(formula));
       } else {
         console.error("Unrecognized formula: " + formula);
@@ -458,14 +485,28 @@ const displayPlot = (plotName, points) => {
 };
 
 // SVG Generation Function
-const generateSvg = (quadraticPlots, linearPlots, sinePlots, cosinePlots, polarPlots, exponentialPlots, logarithmicPlots, gridEnabled = false, dealersChoice = false) => {
+const generateSvg = (
+  quadraticPlots,
+  linearPlots,
+  sinePlots,
+  cosinePlots,
+  polarPlots,
+  exponentialPlots,
+  logarithmicPlots,
+  gridEnabled = false,
+  dealersChoice = false,
+) => {
   const width = 800;
   const height = 1700;
   let svg = `<?xml version="1.0" encoding="UTF-8"?>\n`;
   svg += `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">\n`;
   svg += `  <rect width="100%" height="100%" fill="white" />\n`;
 
-  const randomColor = () => '#' + Math.floor(Math.random() * 16777216).toString(16).padStart(6, '0');
+  const randomColor = () =>
+    "#" +
+    Math.floor(Math.random() * 16777216)
+      .toString(16)
+      .padStart(6, "0");
   const generateUniqueColors = (n) => {
     const colors = new Set();
     while (colors.size < n) {
@@ -474,7 +515,13 @@ const generateSvg = (quadraticPlots, linearPlots, sinePlots, cosinePlots, polarP
     return Array.from(colors);
   };
 
-  let quadraticColors, linearColors, sineColors, cosineColors, polarColors, exponentialColors, logarithmicColors;
+  let quadraticColors;
+  let linearColors;
+  let sineColors;
+  let cosineColors;
+  let polarColors;
+  let exponentialColors;
+  let logarithmicColors;
   if (dealersChoice) {
     quadraticColors = generateUniqueColors(quadraticPlots.length);
     linearColors = generateUniqueColors(linearPlots.length);
@@ -495,11 +542,11 @@ const generateSvg = (quadraticPlots, linearPlots, sinePlots, cosinePlots, polarP
 
   const drawRectGrid = (x, y, w, h, vCount, hCount) => {
     let grid = "";
-    _.range(0, vCount + 1).forEach(i => {
+    _.range(0, vCount + 1).forEach((i) => {
       const gx = x + i * (w / vCount);
       grid += `  <line x1="${formatNumber(gx)}" y1="${formatNumber(y)}" x2="${formatNumber(gx)}" y2="${formatNumber(y + h)}" stroke="#eee" stroke-width="1" />\n`;
     });
-    _.range(0, hCount + 1).forEach(i => {
+    _.range(0, hCount + 1).forEach((i) => {
       const gy = y + i * (h / hCount);
       grid += `  <line x1="${formatNumber(x)}" y1="${formatNumber(gy)}" x2="${formatNumber(x + w)}" y2="${formatNumber(gy)}" stroke="#eee" stroke-width="1" />\n`;
     });
@@ -523,24 +570,41 @@ const generateSvg = (quadraticPlots, linearPlots, sinePlots, cosinePlots, polarP
   svg += `  <text x="${width / 2}" y="30" font-size="16" text-anchor="middle">Quadratic Plot: y = ax² + bx + c</text>\n`;
   if (gridEnabled) {
     svg += drawRectGrid(50, 50, 700, 180, 10, 5);
-    svg += drawRectAxes(50, 50, 700, 180, Math.min(...quadraticPlots.flat().map(p => p.x)), Math.max(...quadraticPlots.flat().map(p => p.x)), Math.min(...quadraticPlots.flat().map(p => p.y)), Math.max(...quadraticPlots.flat().map(p => p.y)));
+    svg += drawRectAxes(
+      50,
+      50,
+      700,
+      180,
+      Math.min(...quadraticPlots.flat().map((p) => p.x)),
+      Math.max(...quadraticPlots.flat().map((p) => p.x)),
+      Math.min(...quadraticPlots.flat().map((p) => p.y)),
+      Math.max(...quadraticPlots.flat().map((p) => p.y)),
+    );
   }
   const qAllPoints = quadraticPlots.flat();
-  const qValues = qAllPoints.map(p => p.y);
+  const qValues = qAllPoints.map((p) => p.y);
   let qMinY = Math.min(...qValues);
   let qMaxY = Math.max(...qValues);
-  if (qMinY === qMaxY) { qMinY -= 10; qMaxY += 10; }
-  const qAllX = qAllPoints.map(p => p.x);
+  if (qMinY === qMaxY) {
+    qMinY -= 10;
+    qMaxY += 10;
+  }
+  const qAllX = qAllPoints.map((p) => p.x);
   let qMinX = Math.min(...qAllX);
   let qMaxX = Math.max(...qAllX);
-  if (qMinX === qMaxX) { qMinX -= 10; qMaxX += 10; }
+  if (qMinX === qMaxX) {
+    qMinX -= 10;
+    qMaxX += 10;
+  }
   quadraticPlots.forEach((points, idx) => {
     const color = quadraticColors[idx % quadraticColors.length];
-    const pts = points.map(p => {
-      const px = 50 + ((p.x - qMinX) / (qMaxX - qMinX)) * 700;
-      const py = 230 - ((p.y - qMinY) / (qMaxY - qMinY)) * 180;
-      return `${formatNumber(px)},${formatNumber(py)}`;
-    }).join(" ");
+    const pts = points
+      .map((p) => {
+        const px = 50 + ((p.x - qMinX) / (qMaxX - qMinX)) * 700;
+        const py = 230 - ((p.y - qMinY) / (qMaxY - qMinY)) * 180;
+        return `${formatNumber(px)},${formatNumber(py)}`;
+      })
+      .join(" ");
     svg += `  <polyline points="${pts}" fill="none" stroke="${color}" stroke-width="2" />\n`;
   });
   svg += "\n";
@@ -549,24 +613,41 @@ const generateSvg = (quadraticPlots, linearPlots, sinePlots, cosinePlots, polarP
   svg += `  <text x="${width / 2}" y="250" font-size="16" text-anchor="middle">Linear Plot: y = m*x + b</text>\n`;
   if (gridEnabled) {
     svg += drawRectGrid(50, 270, 700, 180, 10, 5);
-    svg += drawRectAxes(50, 270, 700, 180, Math.min(...linearPlots.flat().map(p => p.x)), Math.max(...linearPlots.flat().map(p => p.x)), Math.min(...linearPlots.flat().map(p => p.y)), Math.max(...linearPlots.flat().map(p => p.y)));
+    svg += drawRectAxes(
+      50,
+      270,
+      700,
+      180,
+      Math.min(...linearPlots.flat().map((p) => p.x)),
+      Math.max(...linearPlots.flat().map((p) => p.x)),
+      Math.min(...linearPlots.flat().map((p) => p.y)),
+      Math.max(...linearPlots.flat().map((p) => p.y)),
+    );
   }
   const lAllPoints = linearPlots.flat();
-  const lValues = lAllPoints.map(p => p.y);
+  const lValues = lAllPoints.map((p) => p.y);
   let lMinY = Math.min(...lValues);
   let lMaxY = Math.max(...lValues);
-  if (lMinY === lMaxY) { lMinY -= 10; lMaxY += 10; }
-  const lAllX = lAllPoints.map(p => p.x);
+  if (lMinY === lMaxY) {
+    lMinY -= 10;
+    lMaxY += 10;
+  }
+  const lAllX = lAllPoints.map((p) => p.x);
   let lMinX = Math.min(...lAllX);
   let lMaxX = Math.max(...lAllX);
-  if (lMinX === lMaxX) { lMinX -= 10; lMaxX += 10; }
+  if (lMinX === lMaxX) {
+    lMinX -= 10;
+    lMaxX += 10;
+  }
   linearPlots.forEach((points, idx) => {
     const color = linearColors[idx % linearColors.length];
-    const pts = points.map(p => {
-      const px = 50 + ((p.x - lMinX) / (lMaxX - lMinX)) * 700;
-      const py = 450 - ((p.y - lMinY) / (lMaxY - lMinY)) * 180;
-      return `${formatNumber(px)},${formatNumber(py)}`;
-    }).join(" ");
+    const pts = points
+      .map((p) => {
+        const px = 50 + ((p.x - lMinX) / (lMaxX - lMinX)) * 700;
+        const py = 450 - ((p.y - lMinY) / (lMaxY - lMinY)) * 180;
+        return `${formatNumber(px)},${formatNumber(py)}`;
+      })
+      .join(" ");
     svg += `  <polyline points="${pts}" fill="none" stroke="${color}" stroke-width="2" />\n`;
   });
   svg += "\n";
@@ -575,24 +656,41 @@ const generateSvg = (quadraticPlots, linearPlots, sinePlots, cosinePlots, polarP
   svg += `  <text x="${width / 2}" y="470" font-size="16" text-anchor="middle">Sine Plot: y = A*sin(B*x + C)</text>\n`;
   if (gridEnabled) {
     svg += drawRectGrid(50, 490, 700, 180, 10, 5);
-    svg += drawRectAxes(50, 490, 700, 180, Math.min(...sinePlots.flat().map(p => p.x)), Math.max(...sinePlots.flat().map(p => p.x)), Math.min(...sinePlots.flat().map(p => p.y)), Math.max(...sinePlots.flat().map(p => p.y)));
+    svg += drawRectAxes(
+      50,
+      490,
+      700,
+      180,
+      Math.min(...sinePlots.flat().map((p) => p.x)),
+      Math.max(...sinePlots.flat().map((p) => p.x)),
+      Math.min(...sinePlots.flat().map((p) => p.y)),
+      Math.max(...sinePlots.flat().map((p) => p.y)),
+    );
   }
   const sAllPoints = sinePlots.flat();
-  const sValues = sAllPoints.map(p => p.y);
+  const sValues = sAllPoints.map((p) => p.y);
   let sMinY = Math.min(...sValues);
   let sMaxY = Math.max(...sValues);
-  if (sMinY === sMaxY) { sMinY -= 1; sMaxY += 1; }
-  const sAllX = sinePlots.flat().map(p => p.x);
+  if (sMinY === sMaxY) {
+    sMinY -= 1;
+    sMaxY += 1;
+  }
+  const sAllX = sinePlots.flat().map((p) => p.x);
   let sMinX = Math.min(...sAllX);
   let sMaxX = Math.max(...sAllX);
-  if (sMinX === sMaxX) { sMinX -= 10; sMaxX += 10; }
+  if (sMinX === sMaxX) {
+    sMinX -= 10;
+    sMaxX += 10;
+  }
   sinePlots.forEach((points, idx) => {
     const color = sineColors[idx % sineColors.length];
-    const pts = points.map(p => {
-      const px = 50 + ((p.x - sMinX) / (sMaxX - sMinX)) * 700;
-      const py = 670 - ((p.y - sMinY) / (sMaxY - sMinY)) * 180;
-      return `${formatNumber(px)},${formatNumber(py)}`;
-    }).join(" ");
+    const pts = points
+      .map((p) => {
+        const px = 50 + ((p.x - sMinX) / (sMaxX - sMinX)) * 700;
+        const py = 670 - ((p.y - sMinY) / (sMaxY - sMinY)) * 180;
+        return `${formatNumber(px)},${formatNumber(py)}`;
+      })
+      .join(" ");
     svg += `  <polyline points="${pts}" fill="none" stroke="${color}" stroke-width="2" />\n`;
   });
   svg += "\n";
@@ -601,24 +699,41 @@ const generateSvg = (quadraticPlots, linearPlots, sinePlots, cosinePlots, polarP
   svg += `  <text x="${width / 2}" y="690" font-size="16" text-anchor="middle">Cosine Plot: y = A*cos(B*x + C)</text>\n`;
   if (gridEnabled) {
     svg += drawRectGrid(50, 710, 700, 180, 10, 5);
-    svg += drawRectAxes(50, 710, 700, 180, Math.min(...cosinePlots.flat().map(p => p.x)), Math.max(...cosinePlots.flat().map(p => p.x)), Math.min(...cosinePlots.flat().map(p => p.y)), Math.max(...cosinePlots.flat().map(p => p.y)));
+    svg += drawRectAxes(
+      50,
+      710,
+      700,
+      180,
+      Math.min(...cosinePlots.flat().map((p) => p.x)),
+      Math.max(...cosinePlots.flat().map((p) => p.x)),
+      Math.min(...cosinePlots.flat().map((p) => p.y)),
+      Math.max(...cosinePlots.flat().map((p) => p.y)),
+    );
   }
   const cAllPoints = cosinePlots.flat();
-  const cValues = cAllPoints.map(p => p.y);
+  const cValues = cAllPoints.map((p) => p.y);
   let cMinY = Math.min(...cValues);
   let cMaxY = Math.max(...cValues);
-  if (cMinY === cMaxY) { cMinY -= 1; cMaxY += 1; }
-  const cAllX = cosinePlots.flat().map(p => p.x);
+  if (cMinY === cMaxY) {
+    cMinY -= 1;
+    cMaxY += 1;
+  }
+  const cAllX = cosinePlots.flat().map((p) => p.x);
   let cMinX = Math.min(...cAllX);
   let cMaxX = Math.max(...cAllX);
-  if (cMinX === cMaxX) { cMinX -= 10; cMaxX += 10; }
+  if (cMinX === cMaxX) {
+    cMinX -= 10;
+    cMaxX += 10;
+  }
   cosinePlots.forEach((points, idx) => {
     const color = cosineColors[idx % cosineColors.length];
-    const pts = points.map(p => {
-      const px = 50 + ((p.x - cMinX) / (cMaxX - cMinX)) * 700;
-      const py = 890 - ((p.y - cMinY) / (cMaxY - cMinY)) * 180;
-      return `${formatNumber(px)},${formatNumber(py)}`;
-    }).join(" ");
+    const pts = points
+      .map((p) => {
+        const px = 50 + ((p.x - cMinX) / (cMaxX - cMinX)) * 700;
+        const py = 890 - ((p.y - cMinY) / (cMaxY - cMinY)) * 180;
+        return `${formatNumber(px)},${formatNumber(py)}`;
+      })
+      .join(" ");
     svg += `  <polyline points="${pts}" fill="none" stroke="${color}" stroke-width="2" />\n`;
   });
   svg += "\n";
@@ -628,7 +743,7 @@ const generateSvg = (quadraticPlots, linearPlots, sinePlots, cosinePlots, polarP
   const centerX = width / 2;
   const centerY = 970;
   if (gridEnabled) {
-    [50, 100, 150].forEach(r => {
+    [50, 100, 150].forEach((r) => {
       svg += `  <circle cx="${formatNumber(centerX)}" cy="${formatNumber(centerY)}" r="${r}" stroke="#eee" stroke-width="1" fill="none" />\n`;
     });
     svg += `  <line x1="${formatNumber(centerX - 150)}" y1="${formatNumber(centerY)}" x2="${formatNumber(centerX + 150)}" y2="${formatNumber(centerY)}" stroke="black" stroke-width="1" />\n`;
@@ -636,11 +751,13 @@ const generateSvg = (quadraticPlots, linearPlots, sinePlots, cosinePlots, polarP
   }
   polarPlots.forEach((points, idx) => {
     const color = polarColors[idx % polarColors.length];
-    const pts = points.map(p => {
-      const px = centerX + p.x;
-      const py = centerY - p.y;
-      return `${formatNumber(px)},${formatNumber(py)}`;
-    }).join(" ");
+    const pts = points
+      .map((p) => {
+        const px = centerX + p.x;
+        const py = centerY - p.y;
+        return `${formatNumber(px)},${formatNumber(py)}`;
+      })
+      .join(" ");
     svg += `  <polyline points="${pts}" fill="none" stroke="${color}" stroke-width="2" />\n`;
   });
   svg += "\n";
@@ -649,24 +766,41 @@ const generateSvg = (quadraticPlots, linearPlots, sinePlots, cosinePlots, polarP
   svg += `  <text x="${width / 2}" y="1150" font-size="16" text-anchor="middle">Exponential Plot: y = a * e^(b*x)</text>\n`;
   if (gridEnabled) {
     svg += drawRectGrid(50, 1170, 700, 180, 10, 5);
-    svg += drawRectAxes(50, 1170, 700, 180, Math.min(...exponentialPlots.flat().map(p => p.x)), Math.max(...exponentialPlots.flat().map(p => p.x)), Math.min(...exponentialPlots.flat().map(p => p.y)), Math.max(...exponentialPlots.flat().map(p => p.y)));
+    svg += drawRectAxes(
+      50,
+      1170,
+      700,
+      180,
+      Math.min(...exponentialPlots.flat().map((p) => p.x)),
+      Math.max(...exponentialPlots.flat().map((p) => p.x)),
+      Math.min(...exponentialPlots.flat().map((p) => p.y)),
+      Math.max(...exponentialPlots.flat().map((p) => p.y)),
+    );
   }
   const expAllPoints = exponentialPlots.flat();
-  const expValues = expAllPoints.map(p => p.y);
+  const expValues = expAllPoints.map((p) => p.y);
   let expMinY = Math.min(...expValues);
   let expMaxY = Math.max(...expValues);
-  if (expMinY === expMaxY) { expMinY -= 10; expMaxY += 10; }
-  const expAllX = exponentialPlots.flat().map(p => p.x);
+  if (expMinY === expMaxY) {
+    expMinY -= 10;
+    expMaxY += 10;
+  }
+  const expAllX = exponentialPlots.flat().map((p) => p.x);
   let expMinX = Math.min(...expAllX);
   let expMaxX = Math.max(...expAllX);
-  if (expMinX === expMaxX) { expMinX -= 10; expMaxX += 10; }
+  if (expMinX === expMaxX) {
+    expMinX -= 10;
+    expMaxX += 10;
+  }
   exponentialPlots.forEach((points, idx) => {
     const color = exponentialColors[idx % exponentialColors.length];
-    const pts = points.map(p => {
-      const px = 50 + ((p.x - expMinX) / (expMaxX - expMinX)) * 700;
-      const py = 1350 - ((p.y - expMinY) / (expMaxY - expMinY)) * 180;
-      return `${formatNumber(px)},${formatNumber(py)}`;
-    }).join(" ");
+    const pts = points
+      .map((p) => {
+        const px = 50 + ((p.x - expMinX) / (expMaxX - expMinX)) * 700;
+        const py = 1350 - ((p.y - expMinY) / (expMaxY - expMinY)) * 180;
+        return `${formatNumber(px)},${formatNumber(py)}`;
+      })
+      .join(" ");
     svg += `  <polyline points="${pts}" fill="none" stroke="${color}" stroke-width="2" />\n`;
   });
   svg += "\n";
@@ -675,24 +809,41 @@ const generateSvg = (quadraticPlots, linearPlots, sinePlots, cosinePlots, polarP
   svg += `  <text x="${width / 2}" y="1370" font-size="16" text-anchor="middle">Logarithmic Plot: y = a * log_b(x)</text>\n`;
   if (gridEnabled) {
     svg += drawRectGrid(50, 1390, 700, 180, 10, 5);
-    svg += drawRectAxes(50, 1390, 700, 180, Math.min(...logarithmicPlots.flat().map(p => p.x)), Math.max(...logarithmicPlots.flat().map(p => p.x)), Math.min(...logarithmicPlots.flat().map(p => p.y)), Math.max(...logarithmicPlots.flat().map(p => p.y)));
+    svg += drawRectAxes(
+      50,
+      1390,
+      700,
+      180,
+      Math.min(...logarithmicPlots.flat().map((p) => p.x)),
+      Math.max(...logarithmicPlots.flat().map((p) => p.x)),
+      Math.min(...logarithmicPlots.flat().map((p) => p.y)),
+      Math.max(...logarithmicPlots.flat().map((p) => p.y)),
+    );
   }
   const logAllPoints = logarithmicPlots.flat();
-  const logValues = logAllPoints.map(p => p.y);
+  const logValues = logAllPoints.map((p) => p.y);
   let logMinY = Math.min(...logValues);
   let logMaxY = Math.max(...logValues);
-  if (logMinY === logMaxY) { logMinY -= 10; logMaxY += 10; }
-  const logAllX = logarithmicPlots.flat().map(p => p.x);
+  if (logMinY === logMaxY) {
+    logMinY -= 10;
+    logMaxY += 10;
+  }
+  const logAllX = logarithmicPlots.flat().map((p) => p.x);
   let logMinX = Math.min(...logAllX);
   let logMaxX = Math.max(...logAllX);
-  if (logMinX === logMaxX) { logMinX -= 10; logMaxX += 10; }
+  if (logMinX === logMaxX) {
+    logMinX -= 10;
+    logMaxX += 10;
+  }
   logarithmicPlots.forEach((points, idx) => {
     const color = logarithmicColors[idx % logarithmicColors.length];
-    const pts = points.map(p => {
-      const px = 50 + ((p.x - logMinX) / (logMaxX - logMinX)) * 700;
-      const py = 1570 - ((p.y - logMinY) / (logMaxY - logMinY)) * 180;
-      return `${formatNumber(px)},${formatNumber(py)}`;
-    }).join(" ");
+    const pts = points
+      .map((p) => {
+        const px = 50 + ((p.x - logMinX) / (logMaxX - logMinX)) * 700;
+        const py = 1570 - ((p.y - logMinY) / (logMaxY - logMinY)) * 180;
+        return `${formatNumber(px)},${formatNumber(py)}`;
+      })
+      .join(" ");
     svg += `  <polyline points="${pts}" fill="none" stroke="${color}" stroke-width="2" />\n`;
   });
 
@@ -724,31 +875,38 @@ const plotToMarkdown = ({ formulas = [] } = {}) => {
   let md = "# Plot Data\n\n";
   md += "## Quadratic Plot:\n";
   quadratic.forEach((points, i) => {
-    md += `**Formula ${i + 1}:** ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ") + "\n\n";
+    md +=
+      `**Formula ${i + 1}:** ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ") + "\n\n";
   });
   md += "## Linear Plot:\n";
   linear.forEach((points, i) => {
-    md += `**Formula ${i + 1}:** ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ") + "\n\n";
+    md +=
+      `**Formula ${i + 1}:** ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ") + "\n\n";
   });
   md += "## Sine Plot:\n";
   sine.forEach((points, i) => {
-    md += `**Formula ${i + 1}:** ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ") + "\n\n";
+    md +=
+      `**Formula ${i + 1}:** ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ") + "\n\n";
   });
   md += "## Cosine Plot:\n";
   cosine.forEach((points, i) => {
-    md += `**Formula ${i + 1}:** ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ") + "\n\n";
+    md +=
+      `**Formula ${i + 1}:** ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ") + "\n\n";
   });
   md += "## Polar Plot:\n";
   polar.forEach((points, i) => {
-    md += `**Formula ${i + 1}:** ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ") + "\n\n";
+    md +=
+      `**Formula ${i + 1}:** ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ") + "\n\n";
   });
   md += "## Exponential Plot:\n";
   exponential.forEach((points, i) => {
-    md += `**Formula ${i + 1}:** ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ") + "\n\n";
+    md +=
+      `**Formula ${i + 1}:** ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ") + "\n\n";
   });
   md += "## Logarithmic Plot:\n";
   logarithmic.forEach((points, i) => {
-    md += `**Formula ${i + 1}:** ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ") + "\n\n";
+    md +=
+      `**Formula ${i + 1}:** ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ") + "\n\n";
   });
   return md;
 };
@@ -778,7 +936,7 @@ const plotToAscii = ({ formulas = [] } = {}) => {
     for (let col = 0; col < cols; col++) {
       if (grid[xAxisRow][col] === " ") grid[xAxisRow][col] = "-";
     }
-    result += header + grid.map(row => row.join(" ")).join("\n") + "\n\n";
+    result += header + grid.map((row) => row.join(" ")).join("\n") + "\n\n";
   });
   return result;
 };
@@ -786,26 +944,68 @@ const plotToAscii = ({ formulas = [] } = {}) => {
 const plotToText = ({ formulas = [] } = {}) => {
   const { quadratic, linear, sine, cosine, polar, exponential, logarithmic } = getPlotsFromFormulas(formulas);
   let output = "";
-  output += "Quadratic Plot:\n" +
-    quadratic.map((points, i) => `Formula ${i + 1}: ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")).join("\n") +
+  output +=
+    "Quadratic Plot:\n" +
+    quadratic
+      .map(
+        (points, i) =>
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
+      )
+      .join("\n") +
     "\n\n";
-  output += "Linear Plot:\n" +
-    linear.map((points, i) => `Formula ${i + 1}: ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")).join("\n") +
+  output +=
+    "Linear Plot:\n" +
+    linear
+      .map(
+        (points, i) =>
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
+      )
+      .join("\n") +
     "\n\n";
-  output += "Sine Plot:\n" +
-    sine.map((points, i) => `Formula ${i + 1}: ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")).join("\n") +
+  output +=
+    "Sine Plot:\n" +
+    sine
+      .map(
+        (points, i) =>
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
+      )
+      .join("\n") +
     "\n\n";
-  output += "Cosine Plot:\n" +
-    cosine.map((points, i) => `Formula ${i + 1}: ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")).join("\n") +
+  output +=
+    "Cosine Plot:\n" +
+    cosine
+      .map(
+        (points, i) =>
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
+      )
+      .join("\n") +
     "\n\n";
-  output += "Polar Plot:\n" +
-    polar.map((points, i) => `Formula ${i + 1}: ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")).join("\n") +
+  output +=
+    "Polar Plot:\n" +
+    polar
+      .map(
+        (points, i) =>
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
+      )
+      .join("\n") +
     "\n\n";
-  output += "Exponential Plot:\n" +
-    exponential.map((points, i) => `Formula ${i + 1}: ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")).join("\n") +
+  output +=
+    "Exponential Plot:\n" +
+    exponential
+      .map(
+        (points, i) =>
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
+      )
+      .join("\n") +
     "\n\n";
-  output += "Logarithmic Plot:\n" +
-    logarithmic.map((points, i) => `Formula ${i + 1}: ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")).join("\n") +
+  output +=
+    "Logarithmic Plot:\n" +
+    logarithmic
+      .map(
+        (points, i) =>
+          `Formula ${i + 1}: ` + points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "),
+      )
+      .join("\n") +
     "\n";
   return output;
 };
@@ -819,7 +1019,7 @@ const plotToJson = ({ formulas = [] } = {}) => {
     cosine,
     polar,
     exponential,
-    logarithmic
+    logarithmic,
   };
 };
 
@@ -829,49 +1029,49 @@ const plotToCsv = ({ formulas = [] } = {}) => {
   lines.push("Plot, Formula, x, y");
   lines.push("--Quadratic Plot--");
   quadratic.forEach((points, i) => {
-    points.forEach(p => {
+    points.forEach((p) => {
       lines.push(`Quadratic,Formula ${i + 1},${formatNumber(p.x)},${formatNumber(p.y)}`);
     });
   });
   lines.push("");
   lines.push("--Linear Plot--");
   linear.forEach((points, i) => {
-    points.forEach(p => {
+    points.forEach((p) => {
       lines.push(`Linear,Formula ${i + 1},${formatNumber(p.x)},${formatNumber(p.y)}`);
     });
   });
   lines.push("");
   lines.push("--Sine Plot--");
   sine.forEach((points, i) => {
-    points.forEach(p => {
+    points.forEach((p) => {
       lines.push(`Sine,Formula ${i + 1},${formatNumber(p.x)},${formatNumber(p.y)}`);
     });
   });
   lines.push("");
   lines.push("--Cosine Plot--");
   cosine.forEach((points, i) => {
-    points.forEach(p => {
+    points.forEach((p) => {
       lines.push(`Cosine,Formula ${i + 1},${formatNumber(p.x)},${formatNumber(p.y)}`);
     });
   });
   lines.push("");
   lines.push("--Polar Plot--");
   polar.forEach((points, i) => {
-    points.forEach(p => {
+    points.forEach((p) => {
       lines.push(`Polar,Formula ${i + 1},${formatNumber(p.x)},${formatNumber(p.y)}`);
     });
   });
   lines.push("");
   lines.push("--Exponential Plot--");
   exponential.forEach((points, i) => {
-    points.forEach(p => {
+    points.forEach((p) => {
       lines.push(`Exponential,Formula ${i + 1},${formatNumber(p.x)},${formatNumber(p.y)}`);
     });
   });
   lines.push("");
   lines.push("--Logarithmic Plot--");
   logarithmic.forEach((points, i) => {
-    points.forEach(p => {
+    points.forEach((p) => {
       lines.push(`Logarithmic,Formula ${i + 1},${formatNumber(p.x)},${formatNumber(p.y)}`);
     });
   });
@@ -994,10 +1194,11 @@ Formula String Formats:
   const gridEnabled = args.includes("--grid");
   const isDealersChoice = args.includes("--dealers-choice");
 
-  const nonFormulaArgs = args.filter(arg =>
-    !arg.includes(":") &&
-    !arg.includes("=") &&
-    !["--json", "--csv", "--version", "--ascii", "--debug", "--grid", "--dealers-choice"].includes(arg)
+  const nonFormulaArgs = args.filter(
+    (arg) =>
+      !arg.includes(":") &&
+      !arg.includes("=") &&
+      !["--json", "--csv", "--version", "--ascii", "--debug", "--grid", "--dealers-choice"].includes(arg),
   );
   if (nonFormulaArgs.length > 0) {
     outputFileName = nonFormulaArgs[0];
@@ -1012,10 +1213,12 @@ Formula String Formats:
     isAscii = true;
   }
 
-  const formulasList = args.filter(arg => arg.includes(":") || arg.includes("="));
+  const formulasList = args.filter((arg) => arg.includes(":") || arg.includes("="));
 
   if (formulasList.length === 0) {
-    console.log("No formulas provided. Using default plot functions for quadratic, linear, sine, cosine, polar, exponential, and logarithmic plots.");
+    console.log(
+      "No formulas provided. Using default plot functions for quadratic, linear, sine, cosine, polar, exponential, and logarithmic plots.",
+    );
   }
 
   if (isDebug) {
@@ -1038,7 +1241,9 @@ Formula String Formats:
 
   try {
     fs.writeFileSync(outputFileName, fileContent, "utf8");
-    console.log(`\n${isJson ? "JSON" : isCsv ? "CSV" : isHtml ? "HTML" : isAscii ? "ASCII" : "SVG"} file generated: ${outputFileName}`);
+    console.log(
+      `\n${isJson ? "JSON" : isCsv ? "CSV" : isHtml ? "HTML" : isAscii ? "ASCII" : "SVG"} file generated: ${outputFileName}`,
+    );
   } catch (err) {
     console.error(`Error writing file:`, err.message);
     process.exit(1);
@@ -1071,5 +1276,5 @@ export {
   plotLogarithmic,
   parseGenericQuadratic,
   parseGenericExponential,
-  parseCosine
+  parseCosine,
 };

commit 76e886de9feda1aa0682d9d246959ba140480601
Author: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>
Date:   Thu Feb 20 02:38:09 2025 +0000

    Fixed algebraic formula parsing to correctly handle formulas with range e.g. y2x3-10101 and updated version info. (fixes #181) (#185)
    
    Co-authored-by: GitHub Actions[bot] <action@github.com>

diff --git a/src/lib/main.js b/src/lib/main.js
index 0b13e71..5274d9b 100755
--- a/src/lib/main.js
+++ b/src/lib/main.js
@@ -354,8 +354,38 @@ const invertExpression = (expr) => {
 // Delegate plotting based on formula string content
 const plotFromString = (formulaStr) => {
   const lowerStr = formulaStr.toLowerCase();
-  if (lowerStr.startsWith("log:") || lowerStr.startsWith("ln:")) return parseLogarithmic(formulaStr);
-  if (formulaStr.includes(":")) {
+  if (lowerStr.startsWith("y=")) {
+    if (formulaStr.toLowerCase().includes("e^")) {
+      try {
+        return parseGenericExponential(formulaStr);
+      } catch (e) {
+        console.error("Error parsing exponential formula: " + e.message);
+        return [];
+      }
+    } else if (formulaStr.toLowerCase().includes("log(")) {
+      try {
+        return parseLogarithmic(formulaStr);
+      } catch (e) {
+        console.error("Error parsing logarithmic formula: " + e.message);
+        return [];
+      }
+    } else if (!formulaStr.includes("x^2")) {
+      try {
+        return parseGenericLinear(formulaStr);
+      } catch (e) {
+        console.error("Error parsing linear formula: " + e.message);
+        return [];
+      }
+    } else {
+      try {
+        return parseGenericQuadratic(formulaStr);
+      } catch (e) {
+        console.error("Error parsing generic quadratic formula: " + e.message);
+        return [];
+      }
+    }
+  } else if (formulaStr.includes(":")) {
+    if (lowerStr.startsWith("log:") || lowerStr.startsWith("ln:")) return parseLogarithmic(formulaStr);
     if (lowerStr.startsWith("quadratic:") || lowerStr.startsWith("quad:")) return parseQuadratic(formulaStr);
     if (lowerStr.startsWith("sine:")) return parseSine(formulaStr);
     if (lowerStr.startsWith("cosine:") || lowerStr.startsWith("cos:")) return parseCosine(formulaStr);
@@ -365,43 +395,11 @@ const plotFromString = (formulaStr) => {
     console.error("Unknown prefixed formula type for formula: " + formulaStr);
     return [];
   } else if (formulaStr.includes("=")) {
-    if (lowerStr.startsWith("y=")) {
-      if (formulaStr.toLowerCase().includes("e^")) {
-        try {
-          return parseGenericExponential(formulaStr);
-        } catch (e) {
-          console.error("Error parsing exponential formula: " + e.message);
-          return [];
-        }
-      } else if (formulaStr.toLowerCase().includes("log(")) {
-        try {
-          return parseLogarithmic(formulaStr);
-        } catch (e) {
-          console.error("Error parsing logarithmic formula: " + e.message);
-          return [];
-        }
-      } else if (!formulaStr.includes("x^2")) {
-        try {
-          return parseGenericLinear(formulaStr);
-        } catch (e) {
-          console.error("Error parsing linear formula: " + e.message);
-          return [];
-        }
-      } else {
-        try {
-          return parseGenericQuadratic(formulaStr);
-        } catch (e) {
-          console.error("Error parsing generic quadratic formula: " + e.message);
-          return [];
-        }
-      }
-    } else {
-      try {
-        return parseGenericQuadratic(formulaStr);
-      } catch (e) {
-        console.error("Error parsing generic quadratic formula: " + e.message);
-        return [];
-      }
+    try {
+      return parseGenericQuadratic(formulaStr);
+    } catch (e) {
+      console.error("Error parsing generic quadratic formula: " + e.message);
+      return [];
     }
   } else {
     console.error("Formula string is not in a recognized format: " + formulaStr);
@@ -950,7 +948,7 @@ const main = () => {
   const args = process.argv.slice(2);
 
   if (args.includes("--version")) {
-    console.log("Equation Plotter Library version 0.1.1-74");
+    console.log("Equation Plotter Library version 0.2.0-1");
     process.exit(0);
   }
 

commit 8ab53eed72bca99166dbd2d15beb4e0bd3151124
Author: Antony at Polycode <antony@polycode.co.uk>
Date:   Thu Feb 20 02:50:55 2025 +0100

    Prepare release

diff --git a/src/lib/main.js b/src/lib/main.js
new file mode 100755
index 0000000..0b13e71
--- /dev/null
+++ b/src/lib/main.js
@@ -0,0 +1,1077 @@
+#!/usr/bin/env node
+
+"use strict";
+
+import { fileURLToPath } from "url";
+import fs from "fs";
+import _ from "lodash"; // Using lodash for range generation to reduce code size
+
+// Helper function to format numbers to two decimals and avoid negative zero
+const formatNumber = (n) => {
+  const s = n.toFixed(2);
+  return s === "-0.00" ? "0.00" : s;
+};
+
+// Plotting Functions
+
+const plotQuadraticParam = ({ a = 1, b = 0, c = 0, xMin = -10, xMax = 10, step = 1 } = {}) => {
+  const points = _.range(xMin, xMax + step, step).map(x => ({ x, y: a * x * x + b * x + c }));
+  return points;
+};
+
+const plotSineParam = ({ amplitude = 1, frequency = 1, phase = 0, xMin = 0, xMax = 360, step = 10 } = {}) => {
+  const points = _.range(xMin, xMax + step, step).map(deg => {
+    const rad = deg * (Math.PI / 180);
+    return { x: deg, y: amplitude * Math.sin(frequency * rad + phase) };
+  });
+  return points;
+};
+
+const plotCosineParam = ({ amplitude = 1, frequency = 1, phase = 0, xMin = 0, xMax = 360, step = 10 } = {}) => {
+  const points = _.range(xMin, xMax + step, step).map(deg => {
+    const rad = deg * (Math.PI / 180);
+    return { x: deg, y: amplitude * Math.cos(frequency * rad + phase) };
+  });
+  return points;
+};
+
+const plotPolarParam = ({ scale = 200, multiplier = 2, step = 5, degMin = 0, degMax = 360 } = {}) => {
+  const points = _.range(degMin, degMax + step, step).map(deg => {
+    const rad = deg * (Math.PI / 180);
+    const r = scale * Math.abs(Math.sin(multiplier * rad));
+    return { x: r * Math.cos(rad), y: r * Math.sin(rad) };
+  });
+  return points;
+};
+
+const plotLinearParam = ({ m = 1, b = 0, xMin = -10, xMax = 10, step = 1 } = {}) => {
+  const points = _.range(xMin, xMax + step, step).map(x => ({ x, y: m * x + b }));
+  return points;
+};
+
+const plotExponentialParam = ({ a = 1, b = 1, xMin = -10, xMax = 10, step = 1 } = {}) => {
+  const points = _.range(xMin, xMax + step, step).map(x => ({ x, y: a * Math.exp(b * x) }));
+  return points;
+};
+
+const plotLogarithmicParam = ({ a = 1, base = Math.E, xMin = 1, xMax = 10, step = 1 } = {}) => {
+  const points = _.range(xMin, xMax + step, step).reduce((arr, x) => {
+    if (x > 0) arr.push({ x, y: a * (Math.log(x) / Math.log(base)) });
+    return arr;
+  }, []);
+  return points;
+};
+
+// Backward compatible wrappers
+const plotQuadratic = () => plotQuadraticParam();
+const plotSine = () => plotSineParam();
+const plotCosine = () => plotCosineParam();
+const plotPolar = () => plotPolarParam();
+const plotLinear = () => plotLinearParam();
+const plotExponential = () => plotExponentialParam();
+const plotLogarithmic = () => plotLogarithmicParam();
+
+// Formula Parsing Functions
+
+const parseQuadratic = (formulaStr) => {
+  const parts = formulaStr.split(":");
+  if (parts.length < 2) throw new Error("Invalid quadratic formula string: " + formulaStr);
+  const params = parts[1].split(",").map(Number);
+  const [a, b, c, xMin, xMax, step] = params;
+  return plotQuadraticParam({
+    a: isNaN(a) ? 1 : a,
+    b: isNaN(b) ? 0 : b,
+    c: isNaN(c) ? 0 : c,
+    xMin: isNaN(xMin) ? -10 : xMin,
+    xMax: isNaN(xMax) ? 10 : xMax,
+    step: isNaN(step) ? 1 : step
+  });
+};
+
+const parseSine = (formulaStr) => {
+  const parts = formulaStr.split(":");
+  if (parts.length < 2) throw new Error("Invalid sine formula string: " + formulaStr);
+  const params = parts[1].split(",").map(Number);
+  const [amplitude, frequency, phase, xMin, xMax, step] = params;
+  return plotSineParam({
+    amplitude: isNaN(amplitude) ? 1 : amplitude,
+    frequency: isNaN(frequency) ? 1 : frequency,
+    phase: isNaN(phase) ? 0 : phase,
+    xMin: isNaN(xMin) ? 0 : xMin,
+    xMax: isNaN(xMax) ? 360 : xMax,
+    step: isNaN(step) ? 10 : step
+  });
+};
+
+const parseCosine = (formulaStr) => {
+  const parts = formulaStr.split(":");
+  if (parts.length < 2) throw new Error("Invalid cosine formula string: " + formulaStr);
+  const params = parts[1].split(",").map(Number);
+  const [amplitude, frequency, phase, xMin, xMax, step] = params;
+  return plotCosineParam({
+    amplitude: isNaN(amplitude) ? 1 : amplitude,
+    frequency: isNaN(frequency) ? 1 : frequency,
+    phase: isNaN(phase) ? 0 : phase,
+    xMin: isNaN(xMin) ? 0 : xMin,
+    xMax: isNaN(xMax) ? 360 : xMax,
+    step: isNaN(step) ? 10 : step
+  });
+};
+
+const parsePolar = (formulaStr) => {
+  const parts = formulaStr.split(":");
+  if (parts.length < 2) throw new Error("Invalid polar formula string: " + formulaStr);
+  const params = parts[1].split(",").map(Number);
+  const scale = isNaN(params[0]) ? 200 : params[0];
+  const multiplier = isNaN(params[1]) ? 2 : params[1];
+  let step = params.length >= 3 ? (isNaN(params[2]) ? 5 : params[2]) : 5;
+  let degMin = params.length >= 5 ? (isNaN(params[3]) ? 0 : params[3]) : 0;
+  let degMax = params.length >= 5 ? (isNaN(params[4]) ? 360 : params[4]) : 360;
+  return plotPolarParam({ scale, multiplier, step, degMin, degMax });
+};
+
+const parseLinear = (formulaStr) => {
+  const parts = formulaStr.split(":");
+  if (parts.length < 2) throw new Error("Invalid linear formula string: " + formulaStr);
+  const params = parts[1].split(",").map(Number);
+  const [m, b, xMin, xMax, step] = params;
+  return plotLinearParam({
+    m: isNaN(m) ? 1 : m,
+    b: isNaN(b) ? 0 : b,
+    xMin: isNaN(xMin) ? -10 : xMin,
+    xMax: isNaN(xMax) ? 10 : xMax,
+    step: isNaN(step) ? 1 : step
+  });
+};
+
+// Parse a generic linear formula in algebraic form, e.g., "y=2x+3" with optional range parameters
+const parseGenericLinear = (formulaStr) => {
+  const parts = formulaStr.split(":");
+  const exprPart = parts[0].replace(/\s+/g, "");
+  const rangePart = parts.length > 1 ? parts[1].trim() : "";
+  if (!exprPart.toLowerCase().startsWith("y=")) {
+    throw new Error("Linear formula must start with 'y=': " + formulaStr);
+  }
+  const expr = exprPart.substring(2);
+  if (expr.includes("x^2")) {
+    throw new Error("Detected quadratic term in what should be a linear formula: " + formulaStr);
+  }
+  let m = 1, b = 0;
+  const mMatch = expr.match(/^([+-]?\d*\.?\d+)?\*?x/);
+  if (mMatch) {
+    m = (mMatch[1] === "" || mMatch[1] === undefined) ? 1 : parseFloat(mMatch[1]);
+  }
+  const bMatch = expr.match(/([+-]\d*\.?\d+)(?!\*?x)/);
+  if (bMatch) {
+    b = parseFloat(bMatch[1]);
+  }
+  let xMin = -10, xMax = 10, step = 1;
+  if (rangePart) {
+    const rangeParams = rangePart.split(",").map(Number);
+    if (rangeParams.length > 0 && !isNaN(rangeParams[0])) xMin = rangeParams[0];
+    if (rangeParams.length > 1 && !isNaN(rangeParams[1])) xMax = rangeParams[1];
+    if (rangeParams.length > 2 && !isNaN(rangeParams[2])) step = rangeParams[2];
+  }
+  return plotLinearParam({ m, b, xMin, xMax, step });
+};
+
+// Parse a generic quadratic formula in standard algebraic form with optional range
+const parseGenericQuadratic = (formulaStr) => {
+  const parts = formulaStr.split(":");
+  const mainPart = parts[0].replace(/\s+/g, "");
+  const rangePart = parts.length > 1 ? parts[1].trim() : "";
+  let xMin = -10, xMax = 10, step = 1;
+  if (rangePart) {
+    const rangeParams = rangePart.split(",").map(Number);
+    if (rangeParams.length > 0 && !isNaN(rangeParams[0])) xMin = rangeParams[0];
+    if (rangeParams.length > 1 && !isNaN(rangeParams[1])) xMax = rangeParams[1];
+    if (rangeParams.length > 2 && !isNaN(rangeParams[2])) step = rangeParams[2];
+  }
+
+  if (mainPart.toLowerCase().startsWith("y=")) {
+    const yExpr = mainPart.substring(2);
+    const coeffs = extractQuadraticCoefficients(yExpr);
+    return plotQuadraticParam({ ...coeffs, xMin, xMax, step });
+  } else if (mainPart.endsWith("=0")) {
+    const left = mainPart.split("=")[0];
+    const yRegex = /([+-]?(?:\d*\.?\d*)?)y/;
+    const yMatch = left.match(yRegex);
+    if (!yMatch) throw new Error("No y term found in equation: " + formulaStr);
+    const coeffStr = yMatch[1];
+    const yCoeff = (coeffStr === "" || coeffStr === "+") ? 1 : (coeffStr === "-") ? -1 : parseFloat(coeffStr);
+    const remaining = left.replace(yRegex, "");
+    const cleanedRemaining = remaining.replace(/^\+/, "");
+    const coeffs = extractQuadraticCoefficients(cleanedRemaining);
+    return plotQuadraticParam({
+      a: -coeffs.a / yCoeff,
+      b: -coeffs.b / yCoeff,
+      c: -coeffs.c / yCoeff,
+      xMin,
+      xMax,
+      step
+    });
+  } else {
+    const partsEq = mainPart.split("=");
+    if (partsEq.length !== 2) throw new Error("Unsupported formula format for quadratic parsing: " + formulaStr);
+    const left = partsEq[0];
+    const right = partsEq[1] || "0";
+    if (left.includes("y")) {
+      const yMatch = left.match(/([+-]?\d*\.?\d*)y/);
+      let yCoeff = 1;
+      if (yMatch) {
+        const coeffStr = yMatch[1];
+        if (coeffStr === "" || coeffStr === "+") yCoeff = 1;
+        else if (coeffStr === "-") yCoeff = -1;
+        else yCoeff = parseFloat(coeffStr);
+      }
+      const remaining = left.replace(/([+-]?\d*\.?\d*)y/, "");
+      const constantRight = parseFloat(right) || 0;
+      const coeffs = extractQuadraticCoefficients(remaining);
+      return plotQuadraticParam({
+        a: -coeffs.a / yCoeff,
+        b: -coeffs.b / yCoeff,
+        c: (constantRight - coeffs.c) / yCoeff,
+        xMin,
+        xMax,
+        step
+      });
+    } else if (right.includes("y")) {
+      const yMatch = right.match(/([+-]?\d*\.?\d*)y/);
+      let yCoeff = 1;
+      if (yMatch) {
+        const coeffStr = yMatch[1];
+        if (coeffStr === "" || coeffStr === "+") yCoeff = 1;
+        else if (coeffStr === "-") yCoeff = -1;
+        else yCoeff = parseFloat(coeffStr);
+      }
+      const remaining = right.replace(/([+-]?\d*\.?\d*)y/, "");
+      const constantLeft = parseFloat(left) || 0;
+      const coeffs = extractQuadraticCoefficients(remaining);
+      return plotQuadraticParam({
+        a: -coeffs.a / yCoeff,
+        b: -coeffs.b / yCoeff,
+        c: (constantLeft - coeffs.c) / yCoeff,
+        xMin,
+        xMax,
+        step
+      });
+    } else {
+      const nonYPart = left;
+      const newExpr = (right || "0") + invertExpression(nonYPart);
+      return plotQuadraticParam({ ...extractQuadraticCoefficients(newExpr), xMin, xMax, step });
+    }
+  }
+};
+
+// Parse exponential formula string in the format "exponential:a,b,xMin,xMax,step" or "exp:a,b,xMin,xMax,step" or in algebraic form
+const parseExponential = (formulaStr) => {
+  const parts = formulaStr.split(":");
+  if (parts.length < 2) throw new Error("Invalid exponential formula string: " + formulaStr);
+  const params = parts[1].split(",").map(Number);
+  const [a, b, xMin, xMax, step] = params;
+  return plotExponentialParam({
+    a: isNaN(a) ? 1 : a,
+    b: isNaN(b) ? 1 : b,
+    xMin: isNaN(xMin) ? -10 : xMin,
+    xMax: isNaN(xMax) ? 10 : xMax,
+    step: isNaN(step) ? 1 : step
+  });
+};
+
+// Parse a generic exponential formula in algebraic form, e.g., "y=2*e^(0.5x)" optionally with range
+const parseGenericExponential = (formulaStr) => {
+  const parts = formulaStr.split(":");
+  const exprPart = parts[0].replace(/\s+/g, "");
+  const rangePart = parts.length > 1 ? parts[1].trim() : "";
+  let xMin = -10, xMax = 10, step = 1;
+  if (rangePart) {
+    const rangeParams = rangePart.split(",").map(Number);
+    if (rangeParams.length > 0 && !isNaN(rangeParams[0])) xMin = rangeParams[0];
+    if (rangeParams.length > 1 && !isNaN(rangeParams[1])) xMax = rangeParams[1];
+    if (rangeParams.length > 2 && !isNaN(rangeParams[2])) step = rangeParams[2];
+  }
+  const regex = /^y=([+-]?\d*\.?\d+)?\*?e\^\(?([+-]?\d*\.?\d+)(?:\*?x)\)?/i;
+  const match = exprPart.match(regex);
+  if (match) {
+    const a = match[1] ? parseFloat(match[1]) : 1;
+    const b = parseFloat(match[2]);
+    return plotExponentialParam({ a, b, xMin, xMax, step });
+  } else {
+    throw new Error("Invalid generic exponential formula string: " + formulaStr);
+  }
+};
+
+// Parse logarithmic formula string in the format "log:a,base,xMin,xMax,step" or "ln:a,base,xMin,xMax,step"
+const parseLogarithmic = (formulaStr) => {
+  const parts = formulaStr.split(":");
+  if (parts.length < 2) throw new Error("Invalid logarithmic formula string: " + formulaStr);
+  const params = parts[1].split(",").map(Number);
+  const [a, base, xMin, xMax, step] = params;
+  return plotLogarithmicParam({
+    a: isNaN(a) ? 1 : a,
+    base: isNaN(base) ? Math.E : base,
+    xMin: isNaN(xMin) ? 1 : xMin,
+    xMax: isNaN(xMax) ? 10 : xMax,
+    step: isNaN(step) ? 1 : step
+  });
+};
+
+// Extract quadratic coefficients from an expression of form ax^2+bx+c
+const extractQuadraticCoefficients = (expr) => {
+  let cleanedExpr = expr.replace(/\s+/g, "").replace(/\+\-/g, "-");
+  let a = 0, b = 0, c = 0;
+  const aMatch = cleanedExpr.match(/([+-]?\d*\.?\d*)x\^2/);
+  if (aMatch) {
+    const coeff = aMatch[1];
+    a = (coeff === "" || coeff === "+") ? 1 : (coeff === "-") ? -1 : parseFloat(coeff);
+    cleanedExpr = cleanedExpr.replace(aMatch[0], "");
+  }
+  const bMatch = cleanedExpr.match(/([+-]?\d*\.?\d+)x(?!\^)/);
+  if (bMatch) {
+    const coeff = bMatch[1];
+    b = (coeff === "" || coeff === "+") ? 1 : (coeff === "-") ? -1 : parseFloat(coeff);
+    cleanedExpr = cleanedExpr.replace(bMatch[0], "");
+  }
+  const constantMatches = cleanedExpr.match(/([+-]?\d*\.?\d+)/g);
+  if (constantMatches) {
+    c = constantMatches.reduce((sum, numStr) => sum + parseFloat(numStr), 0);
+  }
+  return { a, b, c };
+};
+
+// Helper function to invert an algebraic expression consisting of additions and subtractions
+const invertExpression = (expr) => {
+  const tokens = expr.match(/[+-]?[^+-]+/g) || [];
+  const inverted = tokens
+    .map((token) => {
+      token = token.trim();
+      return token.startsWith("-") ? "+" + token.slice(1) : "-" + token;
+    })
+    .join("");
+  return inverted[0] === "+" ? inverted.slice(1) : inverted;
+};
+
+// Delegate plotting based on formula string content
+const plotFromString = (formulaStr) => {
+  const lowerStr = formulaStr.toLowerCase();
+  if (lowerStr.startsWith("log:") || lowerStr.startsWith("ln:")) return parseLogarithmic(formulaStr);
+  if (formulaStr.includes(":")) {
+    if (lowerStr.startsWith("quadratic:") || lowerStr.startsWith("quad:")) return parseQuadratic(formulaStr);
+    if (lowerStr.startsWith("sine:")) return parseSine(formulaStr);
+    if (lowerStr.startsWith("cosine:") || lowerStr.startsWith("cos:")) return parseCosine(formulaStr);
+    if (lowerStr.startsWith("polar:")) return parsePolar(formulaStr);
+    if (lowerStr.startsWith("linear:")) return parseLinear(formulaStr);
+    if (lowerStr.startsWith("exponential:") || lowerStr.startsWith("exp:")) return parseExponential(formulaStr);
+    console.error("Unknown prefixed formula type for formula: " + formulaStr);
+    return [];
+  } else if (formulaStr.includes("=")) {
+    if (lowerStr.startsWith("y=")) {
+      if (formulaStr.toLowerCase().includes("e^")) {
+        try {
+          return parseGenericExponential(formulaStr);
+        } catch (e) {
+          console.error("Error parsing exponential formula: " + e.message);
+          return [];
+        }
+      } else if (formulaStr.toLowerCase().includes("log(")) {
+        try {
+          return parseLogarithmic(formulaStr);
+        } catch (e) {
+          console.error("Error parsing logarithmic formula: " + e.message);
+          return [];
+        }
+      } else if (!formulaStr.includes("x^2")) {
+        try {
+          return parseGenericLinear(formulaStr);
+        } catch (e) {
+          console.error("Error parsing linear formula: " + e.message);
+          return [];
+        }
+      } else {
+        try {
+          return parseGenericQuadratic(formulaStr);
+        } catch (e) {
+          console.error("Error parsing generic quadratic formula: " + e.message);
+          return [];
+        }
+      }
+    } else {
+      try {
+        return parseGenericQuadratic(formulaStr);
+      } catch (e) {
+        console.error("Error parsing generic quadratic formula: " + e.message);
+        return [];
+      }
+    }
+  } else {
+    console.error("Formula string is not in a recognized format: " + formulaStr);
+    return [];
+  }
+};
+
+// Helper function to parse formulas and return plots grouped by type
+const getPlotsFromFormulas = (formulas = []) => {
+  const quadratic = [];
+  const sine = [];
+  const cosine = [];
+  const polar = [];
+  const linear = [];
+  const exponential = [];
+  const logarithmic = [];
+  formulas.forEach((formula) => {
+    const lower = formula.toLowerCase();
+    try {
+      if (lower.startsWith("quad:") || lower.startsWith("quadratic:") || (formula.includes("x^2") && formula.includes("="))) {
+        quadratic.push(plotFromString(formula));
+      } else if (lower.startsWith("sine:")) {
+        sine.push(plotFromString(formula));
+      } else if (lower.startsWith("cosine:") || lower.startsWith("cos:")) {
+        cosine.push(parseCosine(formula));
+      } else if (lower.startsWith("polar:")) {
+        polar.push(plotFromString(formula));
+      } else if (lower.startsWith("linear:") || (lower.startsWith("y=") && !formula.includes("x^2") && !formula.toLowerCase().includes("e^") && !formula.toLowerCase().includes("log("))) {
+        linear.push(plotFromString(formula));
+      } else if (lower.startsWith("exponential:") || lower.startsWith("exp:") || (lower.startsWith("y=") && formula.toLowerCase().includes("e^"))) {
+        exponential.push(plotFromString(formula));
+      } else if (lower.startsWith("log:") || lower.startsWith("ln:") || (lower.startsWith("y=") && formula.toLowerCase().includes("log("))) {
+        logarithmic.push(plotFromString(formula));
+      } else {
+        console.error("Unrecognized formula: " + formula);
+      }
+    } catch (e) {
+      console.error("Error parsing formula: " + formula + ". " + e.message);
+    }
+  });
+  // Use defaults if no formulas were provided
+  if (quadratic.length === 0) quadratic.push(plotQuadratic());
+  if (linear.length === 0) linear.push(plotLinear());
+  if (sine.length === 0) sine.push(plotSine());
+  if (cosine.length === 0) cosine.push(plotCosine());
+  if (polar.length === 0) polar.push(plotPolar());
+  if (exponential.length === 0) exponential.push(plotExponential());
+  if (logarithmic.length === 0) logarithmic.push(plotLogarithmic());
+  return { quadratic, linear, sine, cosine, polar, exponential, logarithmic };
+};
+
+// Display Functions
+const displayPlot = (plotName, points) => {
+  console.log(`Plot for ${plotName}:`);
+  console.log(points.map((p) => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" "));
+};
+
+// SVG Generation Function
+const generateSvg = (quadraticPlots, linearPlots, sinePlots, cosinePlots, polarPlots, exponentialPlots, logarithmicPlots, gridEnabled = false, dealersChoice = false) => {
+  const width = 800;
+  const height = 1700;
+  let svg = `<?xml version="1.0" encoding="UTF-8"?>\n`;
+  svg += `<svg width="${width}" height="${height}" viewBox="0 0 ${width} ${height}" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">\n`;
+  svg += `  <rect width="100%" height="100%" fill="white" />\n`;
+
+  const randomColor = () => '#' + Math.floor(Math.random() * 16777216).toString(16).padStart(6, '0');
+  const generateUniqueColors = (n) => {
+    const colors = new Set();
+    while (colors.size < n) {
+      colors.add(randomColor());
+    }
+    return Array.from(colors);
+  };
+
+  let quadraticColors, linearColors, sineColors, cosineColors, polarColors, exponentialColors, logarithmicColors;
+  if (dealersChoice) {
+    quadraticColors = generateUniqueColors(quadraticPlots.length);
+    linearColors = generateUniqueColors(linearPlots.length);
+    sineColors = generateUniqueColors(sinePlots.length);
+    cosineColors = generateUniqueColors(cosinePlots.length);
+    polarColors = generateUniqueColors(polarPlots.length);
+    exponentialColors = generateUniqueColors(exponentialPlots.length);
+    logarithmicColors = generateUniqueColors(logarithmicPlots.length);
+  } else {
+    quadraticColors = ["blue", "darkblue", "purple", "royalblue", "deepskyblue"];
+    linearColors = ["orange", "darkorange", "gold", "chocolate", "peru"];
+    sineColors = ["red", "darkred", "crimson", "firebrick", "tomato"];
+    cosineColors = ["teal", "darkcyan", "cadetblue", "lightseagreen", "mediumturquoise"];
+    polarColors = ["green", "darkgreen", "limegreen", "seagreen", "forestgreen"];
+    exponentialColors = ["magenta", "darkmagenta", "violet", "indigo", "purple"];
+    logarithmicColors = ["brown", "saddlebrown", "peru", "chocolate", "tan"];
+  }
+
+  const drawRectGrid = (x, y, w, h, vCount, hCount) => {
+    let grid = "";
+    _.range(0, vCount + 1).forEach(i => {
+      const gx = x + i * (w / vCount);
+      grid += `  <line x1="${formatNumber(gx)}" y1="${formatNumber(y)}" x2="${formatNumber(gx)}" y2="${formatNumber(y + h)}" stroke="#eee" stroke-width="1" />\n`;
+    });
+    _.range(0, hCount + 1).forEach(i => {
+      const gy = y + i * (h / hCount);
+      grid += `  <line x1="${formatNumber(x)}" y1="${formatNumber(gy)}" x2="${formatNumber(x + w)}" y2="${formatNumber(gy)}" stroke="#eee" stroke-width="1" />\n`;
+    });
+    return grid;
+  };
+
+  const drawRectAxes = (x, y, w, h, minX, maxX, minY, maxY) => {
+    let axes = "";
+    if (0 >= minY && 0 <= maxY) {
+      const zeroY = y + h - ((0 - minY) / (maxY - minY)) * h;
+      axes += `  <line x1="${formatNumber(x)}" y1="${formatNumber(zeroY)}" x2="${formatNumber(x + w)}" y2="${formatNumber(zeroY)}" stroke="black" stroke-width="1" />\n`;
+    }
+    if (0 >= minX && 0 <= maxX) {
+      const zeroX = x + ((0 - minX) / (maxX - minX)) * w;
+      axes += `  <line x1="${formatNumber(zeroX)}" y1="${formatNumber(y)}" x2="${formatNumber(zeroX)}" y2="${formatNumber(y + h)}" stroke="black" stroke-width="1" />\n`;
+    }
+    return axes;
+  };
+
+  // Quadratic Plot
+  svg += `  <text x="${width / 2}" y="30" font-size="16" text-anchor="middle">Quadratic Plot: y = ax² + bx + c</text>\n`;
+  if (gridEnabled) {
+    svg += drawRectGrid(50, 50, 700, 180, 10, 5);
+    svg += drawRectAxes(50, 50, 700, 180, Math.min(...quadraticPlots.flat().map(p => p.x)), Math.max(...quadraticPlots.flat().map(p => p.x)), Math.min(...quadraticPlots.flat().map(p => p.y)), Math.max(...quadraticPlots.flat().map(p => p.y)));
+  }
+  const qAllPoints = quadraticPlots.flat();
+  const qValues = qAllPoints.map(p => p.y);
+  let qMinY = Math.min(...qValues);
+  let qMaxY = Math.max(...qValues);
+  if (qMinY === qMaxY) { qMinY -= 10; qMaxY += 10; }
+  const qAllX = qAllPoints.map(p => p.x);
+  let qMinX = Math.min(...qAllX);
+  let qMaxX = Math.max(...qAllX);
+  if (qMinX === qMaxX) { qMinX -= 10; qMaxX += 10; }
+  quadraticPlots.forEach((points, idx) => {
+    const color = quadraticColors[idx % quadraticColors.length];
+    const pts = points.map(p => {
+      const px = 50 + ((p.x - qMinX) / (qMaxX - qMinX)) * 700;
+      const py = 230 - ((p.y - qMinY) / (qMaxY - qMinY)) * 180;
+      return `${formatNumber(px)},${formatNumber(py)}`;
+    }).join(" ");
+    svg += `  <polyline points="${pts}" fill="none" stroke="${color}" stroke-width="2" />\n`;
+  });
+  svg += "\n";
+
+  // Linear Plot
+  svg += `  <text x="${width / 2}" y="250" font-size="16" text-anchor="middle">Linear Plot: y = m*x + b</text>\n`;
+  if (gridEnabled) {
+    svg += drawRectGrid(50, 270, 700, 180, 10, 5);
+    svg += drawRectAxes(50, 270, 700, 180, Math.min(...linearPlots.flat().map(p => p.x)), Math.max(...linearPlots.flat().map(p => p.x)), Math.min(...linearPlots.flat().map(p => p.y)), Math.max(...linearPlots.flat().map(p => p.y)));
+  }
+  const lAllPoints = linearPlots.flat();
+  const lValues = lAllPoints.map(p => p.y);
+  let lMinY = Math.min(...lValues);
+  let lMaxY = Math.max(...lValues);
+  if (lMinY === lMaxY) { lMinY -= 10; lMaxY += 10; }
+  const lAllX = lAllPoints.map(p => p.x);
+  let lMinX = Math.min(...lAllX);
+  let lMaxX = Math.max(...lAllX);
+  if (lMinX === lMaxX) { lMinX -= 10; lMaxX += 10; }
+  linearPlots.forEach((points, idx) => {
+    const color = linearColors[idx % linearColors.length];
+    const pts = points.map(p => {
+      const px = 50 + ((p.x - lMinX) / (lMaxX - lMinX)) * 700;
+      const py = 450 - ((p.y - lMinY) / (lMaxY - lMinY)) * 180;
+      return `${formatNumber(px)},${formatNumber(py)}`;
+    }).join(" ");
+    svg += `  <polyline points="${pts}" fill="none" stroke="${color}" stroke-width="2" />\n`;
+  });
+  svg += "\n";
+
+  // Sine Plot
+  svg += `  <text x="${width / 2}" y="470" font-size="16" text-anchor="middle">Sine Plot: y = A*sin(B*x + C)</text>\n`;
+  if (gridEnabled) {
+    svg += drawRectGrid(50, 490, 700, 180, 10, 5);
+    svg += drawRectAxes(50, 490, 700, 180, Math.min(...sinePlots.flat().map(p => p.x)), Math.max(...sinePlots.flat().map(p => p.x)), Math.min(...sinePlots.flat().map(p => p.y)), Math.max(...sinePlots.flat().map(p => p.y)));
+  }
+  const sAllPoints = sinePlots.flat();
+  const sValues = sAllPoints.map(p => p.y);
+  let sMinY = Math.min(...sValues);
+  let sMaxY = Math.max(...sValues);
+  if (sMinY === sMaxY) { sMinY -= 1; sMaxY += 1; }
+  const sAllX = sinePlots.flat().map(p => p.x);
+  let sMinX = Math.min(...sAllX);
+  let sMaxX = Math.max(...sAllX);
+  if (sMinX === sMaxX) { sMinX -= 10; sMaxX += 10; }
+  sinePlots.forEach((points, idx) => {
+    const color = sineColors[idx % sineColors.length];
+    const pts = points.map(p => {
+      const px = 50 + ((p.x - sMinX) / (sMaxX - sMinX)) * 700;
+      const py = 670 - ((p.y - sMinY) / (sMaxY - sMinY)) * 180;
+      return `${formatNumber(px)},${formatNumber(py)}`;
+    }).join(" ");
+    svg += `  <polyline points="${pts}" fill="none" stroke="${color}" stroke-width="2" />\n`;
+  });
+  svg += "\n";
+
+  // Cosine Plot
+  svg += `  <text x="${width / 2}" y="690" font-size="16" text-anchor="middle">Cosine Plot: y = A*cos(B*x + C)</text>\n`;
+  if (gridEnabled) {
+    svg += drawRectGrid(50, 710, 700, 180, 10, 5);
+    svg += drawRectAxes(50, 710, 700, 180, Math.min(...cosinePlots.flat().map(p => p.x)), Math.max(...cosinePlots.flat().map(p => p.x)), Math.min(...cosinePlots.flat().map(p => p.y)), Math.max(...cosinePlots.flat().map(p => p.y)));
+  }
+  const cAllPoints = cosinePlots.flat();
+  const cValues = cAllPoints.map(p => p.y);
+  let cMinY = Math.min(...cValues);
+  let cMaxY = Math.max(...cValues);
+  if (cMinY === cMaxY) { cMinY -= 1; cMaxY += 1; }
+  const cAllX = cosinePlots.flat().map(p => p.x);
+  let cMinX = Math.min(...cAllX);
+  let cMaxX = Math.max(...cAllX);
+  if (cMinX === cMaxX) { cMinX -= 10; cMaxX += 10; }
+  cosinePlots.forEach((points, idx) => {
+    const color = cosineColors[idx % cosineColors.length];
+    const pts = points.map(p => {
+      const px = 50 + ((p.x - cMinX) / (cMaxX - cMinX)) * 700;
+      const py = 890 - ((p.y - cMinY) / (cMaxY - cMinY)) * 180;
+      return `${formatNumber(px)},${formatNumber(py)}`;
+    }).join(" ");
+    svg += `  <polyline points="${pts}" fill="none" stroke="${color}" stroke-width="2" />\n`;
+  });
+  svg += "\n";
+
+  // Polar Plot
+  svg += `  <text x="${width / 2}" y="910" font-size="16" text-anchor="middle">Polar Plot: r = scale * |sin(multiplier * θ)|</text>\n`;
+  const centerX = width / 2;
+  const centerY = 970;
+  if (gridEnabled) {
+    [50, 100, 150].forEach(r => {
+      svg += `  <circle cx="${formatNumber(centerX)}" cy="${formatNumber(centerY)}" r="${r}" stroke="#eee" stroke-width="1" fill="none" />\n`;
+    });
+    svg += `  <line x1="${formatNumber(centerX - 150)}" y1="${formatNumber(centerY)}" x2="${formatNumber(centerX + 150)}" y2="${formatNumber(centerY)}" stroke="black" stroke-width="1" />\n`;
+    svg += `  <line x1="${formatNumber(centerX)}" y1="${formatNumber(centerY - 150)}" x2="${formatNumber(centerX)}" y2="${formatNumber(centerY + 150)}" stroke="black" stroke-width="1" />\n`;
+  }
+  polarPlots.forEach((points, idx) => {
+    const color = polarColors[idx % polarColors.length];
+    const pts = points.map(p => {
+      const px = centerX + p.x;
+      const py = centerY - p.y;
+      return `${formatNumber(px)},${formatNumber(py)}`;
+    }).join(" ");
+    svg += `  <polyline points="${pts}" fill="none" stroke="${color}" stroke-width="2" />\n`;
+  });
+  svg += "\n";
+
+  // Exponential Plot
+  svg += `  <text x="${width / 2}" y="1150" font-size="16" text-anchor="middle">Exponential Plot: y = a * e^(b*x)</text>\n`;
+  if (gridEnabled) {
+    svg += drawRectGrid(50, 1170, 700, 180, 10, 5);
+    svg += drawRectAxes(50, 1170, 700, 180, Math.min(...exponentialPlots.flat().map(p => p.x)), Math.max(...exponentialPlots.flat().map(p => p.x)), Math.min(...exponentialPlots.flat().map(p => p.y)), Math.max(...exponentialPlots.flat().map(p => p.y)));
+  }
+  const expAllPoints = exponentialPlots.flat();
+  const expValues = expAllPoints.map(p => p.y);
+  let expMinY = Math.min(...expValues);
+  let expMaxY = Math.max(...expValues);
+  if (expMinY === expMaxY) { expMinY -= 10; expMaxY += 10; }
+  const expAllX = exponentialPlots.flat().map(p => p.x);
+  let expMinX = Math.min(...expAllX);
+  let expMaxX = Math.max(...expAllX);
+  if (expMinX === expMaxX) { expMinX -= 10; expMaxX += 10; }
+  exponentialPlots.forEach((points, idx) => {
+    const color = exponentialColors[idx % exponentialColors.length];
+    const pts = points.map(p => {
+      const px = 50 + ((p.x - expMinX) / (expMaxX - expMinX)) * 700;
+      const py = 1350 - ((p.y - expMinY) / (expMaxY - expMinY)) * 180;
+      return `${formatNumber(px)},${formatNumber(py)}`;
+    }).join(" ");
+    svg += `  <polyline points="${pts}" fill="none" stroke="${color}" stroke-width="2" />\n`;
+  });
+  svg += "\n";
+
+  // Logarithmic Plot
+  svg += `  <text x="${width / 2}" y="1370" font-size="16" text-anchor="middle">Logarithmic Plot: y = a * log_b(x)</text>\n`;
+  if (gridEnabled) {
+    svg += drawRectGrid(50, 1390, 700, 180, 10, 5);
+    svg += drawRectAxes(50, 1390, 700, 180, Math.min(...logarithmicPlots.flat().map(p => p.x)), Math.max(...logarithmicPlots.flat().map(p => p.x)), Math.min(...logarithmicPlots.flat().map(p => p.y)), Math.max(...logarithmicPlots.flat().map(p => p.y)));
+  }
+  const logAllPoints = logarithmicPlots.flat();
+  const logValues = logAllPoints.map(p => p.y);
+  let logMinY = Math.min(...logValues);
+  let logMaxY = Math.max(...logValues);
+  if (logMinY === logMaxY) { logMinY -= 10; logMaxY += 10; }
+  const logAllX = logarithmicPlots.flat().map(p => p.x);
+  let logMinX = Math.min(...logAllX);
+  let logMaxX = Math.max(...logAllX);
+  if (logMinX === logMaxX) { logMinX -= 10; logMaxX += 10; }
+  logarithmicPlots.forEach((points, idx) => {
+    const color = logarithmicColors[idx % logarithmicColors.length];
+    const pts = points.map(p => {
+      const px = 50 + ((p.x - logMinX) / (logMaxX - logMinX)) * 700;
+      const py = 1570 - ((p.y - logMinY) / (logMaxY - logMinY)) * 180;
+      return `${formatNumber(px)},${formatNumber(py)}`;
+    }).join(" ");
+    svg += `  <polyline points="${pts}" fill="none" stroke="${color}" stroke-width="2" />\n`;
+  });
+
+  svg += "</svg>";
+  return svg;
+};
+
+// HTML Generation Function
+const plotToHtml = ({ formulas = [], grid = false, dealersChoice = false } = {}) => {
+  const svgContent = plotToSvg({ formulas, grid, dealersChoice });
+  return `<!DOCTYPE html>
+<html lang="en">
+<head>
+  <meta charset="UTF-8">
+  <title>Equation Plot</title>
+  <style>
+    body { margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #f8f8f8; }
+  </style>
+</head>
+<body>
+${svgContent}
+</body>
+</html>`;
+};
+
+// Markdown Generation Function (Extended Feature)
+const plotToMarkdown = ({ formulas = [] } = {}) => {
+  const { quadratic, linear, sine, cosine, polar, exponential, logarithmic } = getPlotsFromFormulas(formulas);
+  let md = "# Plot Data\n\n";
+  md += "## Quadratic Plot:\n";
+  quadratic.forEach((points, i) => {
+    md += `**Formula ${i + 1}:** ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ") + "\n\n";
+  });
+  md += "## Linear Plot:\n";
+  linear.forEach((points, i) => {
+    md += `**Formula ${i + 1}:** ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ") + "\n\n";
+  });
+  md += "## Sine Plot:\n";
+  sine.forEach((points, i) => {
+    md += `**Formula ${i + 1}:** ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ") + "\n\n";
+  });
+  md += "## Cosine Plot:\n";
+  cosine.forEach((points, i) => {
+    md += `**Formula ${i + 1}:** ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ") + "\n\n";
+  });
+  md += "## Polar Plot:\n";
+  polar.forEach((points, i) => {
+    md += `**Formula ${i + 1}:** ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ") + "\n\n";
+  });
+  md += "## Exponential Plot:\n";
+  exponential.forEach((points, i) => {
+    md += `**Formula ${i + 1}:** ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ") + "\n\n";
+  });
+  md += "## Logarithmic Plot:\n";
+  logarithmic.forEach((points, i) => {
+    md += `**Formula ${i + 1}:** ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ") + "\n\n";
+  });
+  return md;
+};
+
+// Exported API Functions
+const plotToSvg = ({ formulas = [], grid = false, dealersChoice = false } = {}) => {
+  const { quadratic, linear, sine, cosine, polar, exponential, logarithmic } = getPlotsFromFormulas(formulas);
+  return generateSvg(quadratic, linear, sine, cosine, polar, exponential, logarithmic, grid, dealersChoice);
+};
+
+const plotToAscii = ({ formulas = [] } = {}) => {
+  const { sine } = getPlotsFromFormulas(formulas);
+  let result = "";
+  sine.forEach((points, idx) => {
+    const header = `ASCII Art of Sine Wave - Formula ${idx + 1}:\n`;
+    const rows = 21;
+    const cols = points.length;
+    const grid = Array.from({ length: rows }, () => new Array(cols).fill(" "));
+
+    for (let col = 0; col < cols; col++) {
+      const { y } = points[col];
+      const row = Math.round((1 - (y + 1) / 2) * (rows - 1));
+      grid[row][col] = "*";
+    }
+
+    const xAxisRow = Math.round(0.5 * (rows - 1));
+    for (let col = 0; col < cols; col++) {
+      if (grid[xAxisRow][col] === " ") grid[xAxisRow][col] = "-";
+    }
+    result += header + grid.map(row => row.join(" ")).join("\n") + "\n\n";
+  });
+  return result;
+};
+
+const plotToText = ({ formulas = [] } = {}) => {
+  const { quadratic, linear, sine, cosine, polar, exponential, logarithmic } = getPlotsFromFormulas(formulas);
+  let output = "";
+  output += "Quadratic Plot:\n" +
+    quadratic.map((points, i) => `Formula ${i + 1}: ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")).join("\n") +
+    "\n\n";
+  output += "Linear Plot:\n" +
+    linear.map((points, i) => `Formula ${i + 1}: ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")).join("\n") +
+    "\n\n";
+  output += "Sine Plot:\n" +
+    sine.map((points, i) => `Formula ${i + 1}: ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")).join("\n") +
+    "\n\n";
+  output += "Cosine Plot:\n" +
+    cosine.map((points, i) => `Formula ${i + 1}: ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")).join("\n") +
+    "\n\n";
+  output += "Polar Plot:\n" +
+    polar.map((points, i) => `Formula ${i + 1}: ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")).join("\n") +
+    "\n\n";
+  output += "Exponential Plot:\n" +
+    exponential.map((points, i) => `Formula ${i + 1}: ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")).join("\n") +
+    "\n\n";
+  output += "Logarithmic Plot:\n" +
+    logarithmic.map((points, i) => `Formula ${i + 1}: ` + points.map(p => `(${formatNumber(p.x)}, ${formatNumber(p.y)})`).join(" ")).join("\n") +
+    "\n";
+  return output;
+};
+
+const plotToJson = ({ formulas = [] } = {}) => {
+  const { quadratic, linear, sine, cosine, polar, exponential, logarithmic } = getPlotsFromFormulas(formulas);
+  return {
+    quadratic,
+    linear,
+    sine,
+    cosine,
+    polar,
+    exponential,
+    logarithmic
+  };
+};
+
+const plotToCsv = ({ formulas = [] } = {}) => {
+  const { quadratic, linear, sine, cosine, polar, exponential, logarithmic } = getPlotsFromFormulas(formulas);
+  const lines = [];
+  lines.push("Plot, Formula, x, y");
+  lines.push("--Quadratic Plot--");
+  quadratic.forEach((points, i) => {
+    points.forEach(p => {
+      lines.push(`Quadratic,Formula ${i + 1},${formatNumber(p.x)},${formatNumber(p.y)}`);
+    });
+  });
+  lines.push("");
+  lines.push("--Linear Plot--");
+  linear.forEach((points, i) => {
+    points.forEach(p => {
+      lines.push(`Linear,Formula ${i + 1},${formatNumber(p.x)},${formatNumber(p.y)}`);
+    });
+  });
+  lines.push("");
+  lines.push("--Sine Plot--");
+  sine.forEach((points, i) => {
+    points.forEach(p => {
+      lines.push(`Sine,Formula ${i + 1},${formatNumber(p.x)},${formatNumber(p.y)}`);
+    });
+  });
+  lines.push("");
+  lines.push("--Cosine Plot--");
+  cosine.forEach((points, i) => {
+    points.forEach(p => {
+      lines.push(`Cosine,Formula ${i + 1},${formatNumber(p.x)},${formatNumber(p.y)}`);
+    });
+  });
+  lines.push("");
+  lines.push("--Polar Plot--");
+  polar.forEach((points, i) => {
+    points.forEach(p => {
+      lines.push(`Polar,Formula ${i + 1},${formatNumber(p.x)},${formatNumber(p.y)}`);
+    });
+  });
+  lines.push("");
+  lines.push("--Exponential Plot--");
+  exponential.forEach((points, i) => {
+    points.forEach(p => {
+      lines.push(`Exponential,Formula ${i + 1},${formatNumber(p.x)},${formatNumber(p.y)}`);
+    });
+  });
+  lines.push("");
+  lines.push("--Logarithmic Plot--");
+  logarithmic.forEach((points, i) => {
+    points.forEach(p => {
+      lines.push(`Logarithmic,Formula ${i + 1},${formatNumber(p.x)},${formatNumber(p.y)}`);
+    });
+  });
+  return lines.join("\n");
+};
+
+const plotToFile = ({ formulas = [], outputFileName = "output.svg", type = "svg" } = {}) => {
+  let content = "";
+  if (type === "svg") {
+    content = plotToSvg({ formulas });
+  } else if (type === "ascii") {
+    content = plotToAscii({ formulas });
+  } else if (type === "text") {
+    content = plotToText({ formulas });
+  } else if (type === "json") {
+    content = JSON.stringify(plotToJson({ formulas }), null, 2);
+  } else if (type === "csv") {
+    content = plotToCsv({ formulas });
+  } else if (type === "html") {
+    content = plotToHtml({ formulas });
+  } else if (type === "md") {
+    content = plotToMarkdown({ formulas });
+  } else {
+    throw new Error("Unsupported type provided for plotToFile");
+  }
+  try {
+    fs.writeFileSync(outputFileName, content, "utf8");
+  } catch (e) {
+    console.error("Error writing file:", e);
+    throw e;
+  }
+  return outputFileName;
+};
+
+// Demo Test Function
+const demoTest = () => {
+  console.log("=== Demo Test Output ===");
+
+  // Original sine plot demo
+  const demoPlotJson = plotToJson({ formulas: ["sine:1,1,0,0,360,30"] });
+  console.log("Plot JSON output for formula 'sine:1,1,0,0,360,30':");
+  console.log(JSON.stringify(demoPlotJson, null, 2));
+
+  // Additional demo: Markdown output for a linear formula
+  const demoMarkdown = plotToMarkdown({ formulas: ["y=2x+3:-10,10,1"] });
+  console.log("\nPlot Markdown output for formula 'y=2x+3:-10,10,1':");
+  console.log(demoMarkdown);
+
+  // Additional demo: Text output for a quadratic formula
+  const demoText = plotToText({ formulas: ["quad:1,0,0,-10,10,1"] });
+  console.log("\nPlot Text output for formula 'quad:1,0,0,-10,10,1':");
+  console.log(demoText);
+
+  // New demo: ASCII art output for sine formula
+  const demoAscii = plotToAscii({ formulas: ["sine:1,1,0,0,360,30"] });
+  console.log("\nPlot ASCII art output for formula 'sine:1,1,0,0,360,30':");
+  console.log(demoAscii);
+
+  // New demo: CSV output for quadratic formula
+  const demoCsv = plotToCsv({ formulas: ["quad:1,0,0,-10,10,1"] });
+  console.log("\nPlot CSV output for formula 'quad:1,0,0,-10,10,1':");
+  console.log(demoCsv);
+
+  // New demo: HTML output for linear formula with grid
+  const demoHtml = plotToHtml({ formulas: ["y=2x+3:-10,10,1"], grid: true });
+  console.log("\nPlot HTML output for formula 'y=2x+3:-10,10,1':");
+  console.log(demoHtml);
+
+  console.log("=== End Demo Test Output ===");
+};
+
+// Main Execution
+const main = () => {
+  const args = process.argv.slice(2);
+
+  if (args.includes("--version")) {
+    console.log("Equation Plotter Library version 0.1.1-74");
+    process.exit(0);
+  }
+
+  if (args.includes("--help") || args.includes("-h")) {
+    console.log(`Usage: node src/lib/main.js [outputFileName] [formulaStrings...]
+
+Options:
+  --help, -h       Show this help message
+  --json           Generate output as JSON instead of SVG
+  --csv            Generate output as CSV instead of SVG
+  --ascii          Generate output as ASCII art instead of SVG
+  --grid           Overlay grid lines on SVG plots
+  --debug          Output internal parsed plot data for debugging
+  --dealers-choice Use randomized color palette for SVG plots
+  --demo           Run demo test output
+  --version        Show version information
+  (output file extension .html will generate HTML output)
+
+Formula String Formats:
+  Quadratic: "quad:y=x^2+2*x+1" or "quadratic:y=x^2+2*x+1" or "x^2+y-1=0" (or with range e.g., "y=x^2+2*x+1:-10,10,1")
+  Linear:    "linear:m,b[,xMin,xMax,step]" or algebraic form like "y=2x+3" (or "y=2x+3:-10,10,1")
+  Sine:      "sine:amplitude,frequency,phase[,xMin,xMax,step]"
+  Cosine:    "cosine:amplitude,frequency,phase[,xMin,xMax,step]" or "cos:..."
+  Polar:     "polar:scale,multiplier,step[,degMin,degMax]"
+  Exponential: "exponential:a,b,xMin,xMax,step" or "exp:a,b,xMin,xMax,step" or in algebraic form like "y=2*e^(0.5x)" (optionally with range e.g., "y=2*e^(0.5x):-10,10,1")
+  Logarithmic: "log:a,base,xMin,xMax,step" or "ln:a,base,xMin,xMax,step"
+`);
+    process.exit(0);
+  }
+
+  // If --demo flag is provided, run the demo test and exit
+  if (args.includes("--demo")) {
+    demoTest();
+    process.exit(0);
+  }
+
+  let outputFileName = "output.svg";
+  let isJson = args.includes("--json");
+  let isCsv = args.includes("--csv");
+  let isHtml = false;
+  let isAscii = args.includes("--ascii");
+  const isDebug = args.includes("--debug");
+  const gridEnabled = args.includes("--grid");
+  const isDealersChoice = args.includes("--dealers-choice");
+
+  const nonFormulaArgs = args.filter(arg =>
+    !arg.includes(":") &&
+    !arg.includes("=") &&
+    !["--json", "--csv", "--version", "--ascii", "--debug", "--grid", "--dealers-choice"].includes(arg)
+  );
+  if (nonFormulaArgs.length > 0) {
+    outputFileName = nonFormulaArgs[0];
+  }
+  if (outputFileName.toLowerCase().endsWith(".json")) {
+    isJson = true;
+  } else if (outputFileName.toLowerCase().endsWith(".csv")) {
+    isCsv = true;
+  } else if (outputFileName.toLowerCase().endsWith(".html")) {
+    isHtml = true;
+  } else if (outputFileName.toLowerCase().endsWith(".txt") || outputFileName.toLowerCase().endsWith(".ascii")) {
+    isAscii = true;
+  }
+
+  const formulasList = args.filter(arg => arg.includes(":") || arg.includes("="));
+
+  if (formulasList.length === 0) {
+    console.log("No formulas provided. Using default plot functions for quadratic, linear, sine, cosine, polar, exponential, and logarithmic plots.");
+  }
+
+  if (isDebug) {
+    console.log("\nDebug: Internal parsed plot data:");
+    console.log(JSON.stringify(getPlotsFromFormulas(formulasList), null, 2));
+  }
+
+  let fileContent = "";
+  if (isJson) {
+    fileContent = JSON.stringify(plotToJson({ formulas: formulasList }), null, 2);
+  } else if (isCsv) {
+    fileContent = plotToCsv({ formulas: formulasList });
+  } else if (isHtml) {
+    fileContent = plotToHtml({ formulas: formulasList, grid: gridEnabled, dealersChoice: isDealersChoice });
+  } else if (isAscii) {
+    fileContent = plotToAscii({ formulas: formulasList });
+  } else {
+    fileContent = plotToSvg({ formulas: formulasList, grid: gridEnabled, dealersChoice: isDealersChoice });
+  }
+
+  try {
+    fs.writeFileSync(outputFileName, fileContent, "utf8");
+    console.log(`\n${isJson ? "JSON" : isCsv ? "CSV" : isHtml ? "HTML" : isAscii ? "ASCII" : "SVG"} file generated: ${outputFileName}`);
+  } catch (err) {
+    console.error(`Error writing file:`, err.message);
+    process.exit(1);
+  }
+
+  console.log("\nText Representation of Plots:");
+  console.log(plotToText({ formulas: formulasList }));
+};
+
+if (process.argv[1] === fileURLToPath(import.meta.url)) {
+  main();
+}
+
+export {
+  plotToSvg,
+  plotToAscii,
+  plotToText,
+  plotToJson,
+  plotToCsv,
+  plotToHtml,
+  plotToMarkdown,
+  plotToFile,
+  plotFromString,
+  plotQuadratic,
+  plotSine,
+  plotCosine,
+  plotPolar,
+  plotLinear,
+  plotExponential,
+  plotLogarithmic,
+  parseGenericQuadratic,
+  parseGenericExponential,
+  parseCosine
+};
